<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Javae on</title><link>https://quartz.jzhao.xyz/java/</link><description>Recent content in Javae on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://quartz.jzhao.xyz/java/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://quartz.jzhao.xyz/Java/IO/AIO/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/IO/AIO/</guid><description/></item><item><title/><link>https://quartz.jzhao.xyz/Java/IO/BIO/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/IO/BIO/</guid><description>字节流 InputStream（字节输入流） InputStream用于从源头（通常是文件）读取数据（字节信息）到内存中，java.io.InputStream抽象类是所有字节输入流的父类。
InputStream 常用方法 ：
read() ：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 -1 ，表示文件结束。
read(byte b[ ]) : 从输入流中读取一些字节存储到数组 b 中。如果数组 b 的长度为零，则不读取。如果没有可用字节读取，返回 -1。如果有可用字节读取，则最多读取的字节数最多等于 b.</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/IO/IO%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/IO/IO%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</guid><description>何为 I/O? I/O（Input/Outpu） 即输入／输出 。
我们先从计算机结构的角度来解读一下 I/O。
根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。
从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。
我们再先从应用程序的角度来解读一下 I/O。
为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 用户空间（User space） 和 内核空间（Kernel space ） 。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/IO/Java-IO-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/IO/Java-IO-overview/</guid><description>Java 中的 IO 流分为几种？ 流按照不同的特点，有很多种划分方式
按照流的流向分，可以分为 输入流 和 输出流 ；
按照操作单元划分，可以划分为 字节流 和 字符流 ；
按照流的角色划分为 节点流 和 处理流</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/IO/NIO/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/IO/NIO/</guid><description>NIO 与 IO 主要区别 ![[Pasted image 20230727001911.png]]
- 面向流与面向缓冲 io Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方 它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区 nio NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动 - 阻塞与非阻塞IO nio 使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel） io 当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了 - 选择器 NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道 这种选择机制，使得一个单独的线程很容易来管理多个通道。 - NIO和IO如何影响应用程序的设计 对NIO或IO类的API调用 使用NIO的API调用时看起来与使用IO时有所不同，但这并不意外，因为并不是仅从一个InputStream逐字节读取，而是数据必须先读入缓冲区再处理 数据处理 用来处理数据的线程数 NIO可让您只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂 如果你有少量的连接使用非常高的带宽，一次发送大量的数据，也许典型的IO服务器实现可能非常契合 NIO Path java.</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/JVM/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/JVM/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</guid><description>运行时数据区域 Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK 1.8 和之前的版本略有不同，下面会介绍到。
JDK 1.8 之前 ：
JDK 1.8 之后 ：
线程私有的：
程序计数器</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/JVM/JVM-%E8%B0%83%E4%BC%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/JVM/JVM-%E8%B0%83%E4%BC%98/</guid><description>有哪些常用的命令行性能监控和故障处理工具？ 操作系统工具
top：显示系统整体资源使用情况
vmstat：监控内存和CPU
iostat：监控IO使用
netstat：监控网络使用JDK性能监控工具
JDK性能监控工具</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid><description>堆空间的基本结构 Java 自动内存管理最核心的功能是 堆 内存中对象的分配与回收。
Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。
在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：
新生代内存(Young Generation)</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</guid><description>回顾下类加载过程 加载
连接
验证
准备
解析
初始化</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</guid><description>类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：
加载（Loading）
连接
验证（Verification）
准备（Preparation）
解析（Resolution）
初始化（Initialization）</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/JVM/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/JVM/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</guid><description>回顾一下字节码 在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），只面向虚拟机
Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，
同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，
下图展示了不同的语言被不同的编译器编译成.class文件最终运行在 Java 虚拟机之上。.</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/overview/</guid><description/></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-overview/</guid><description>什么是 Java Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里 难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。 Java语言作为静态面向对象编程语言的优秀代表，极好地实现了面向对象理论，允许 程序员以优雅的思维方式进行复杂的编程 Java 语言有哪些特点?
简单易学； 面向对象（封装，继承，多态）； 平台无关性（ Java 虚拟机实现平台无关性）； 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）； 可靠性； 安全性； 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）； 编译与解释并存； 🐛 修正（参见： issue#544open in new window） ：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用std::thread和std::async来创建线程。参考链接：http://www.</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-SPI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-SPI/</guid><description>何谓 SPI? SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。
SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。
很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。
SPI 和 API 有什么区别？ 那 SPI 和 API 有啥区别？</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E5%8F%8D%E5%B0%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E5%8F%8D%E5%B0%84/</guid><description>关于反射的详细解读，请看这篇文章 Java 反射机制详解。
何谓反射？ 主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。
反射的优缺点？ 优点：反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。
缺点：反射让我们在运行时有了分析操作类的能力的同时，也增加了安全题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。
相关阅读： Java Reflection: Why is it so slow?open in new window 。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid><description>注释有哪几种形式？ Java 中的注释有三种：
单行注释 ：通常用于解释方法内某单行代码的作用。
多行注释 ：通常用于解释一段代码的作用。
文档注释 ：通常用于生成 Java 开发文档。
用的比较多的还是单行注释和文档注释，多行注释在实际开发中使用的相对较少。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E5%B8%B8%E7%94%A8%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E5%B8%B8%E7%94%A8%E7%B1%BB/</guid><description>Object Object 类的常见方法有哪些？ Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。 */public final native Class&amp;lt;?</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</guid><description>什么是序列化?什么是反序列化? 如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。
简单来说：
序列化： 将数据结构或对象转换成二进制字节流的过程
反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程
对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E5%BC%82%E5%B8%B8/</guid><description>Java 异常类层次结构图概览 ：
Exception 和 Error 有什么区别？ 在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类:
Exception :程序本身可以处理的异常，可以通过 catch 来进行捕获。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E6%B3%9B%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E6%B3%9B%E5%9E%8B/</guid><description>什么是泛型？有什么作用？ Java 泛型（Generics） 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。
编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 ArrayList&amp;lt;Person&amp;gt; persons = new ArrayList&amp;lt;Person&amp;gt;() 这行代码就指明了该 ArrayList 对象只能传入 Person 对象，如果传入其他类型的对象就会报错。
1 ArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt; 并且，原生 List 返回类型是 Object ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E6%B3%A8%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E6%B3%A8%E8%A7%A3/</guid><description>注解 何谓注解？ Annotation （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。
注解本质是一个继承了Annotation 的特殊接口：
1 2 3 4 5 6 7 8 9 @Target(ElementType.METHOD) @Retention(RetentionPolicy.</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>Java 的数据类型 定义：Java 语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。 Java 语言数据类型分为两种：基本数据类型和引用数据类型 ![[Pasted image 20230726230002.png]]
基本数据类型 Ava 中有 8 种基本数据类型，分别为：
6 种数字类型： 4 种整数型：byte、short、int、long 2 种浮点型：float、double 1 种字符类型：char 1 种布尔型：boolean 这 8 种基本数据类型的默认值以及所占空间的大小如下： 基本类型 位数 字节 默认值 取值范围 byte 8 1 0 -128 ~ 127 short 16 2 0 -32768 ~ 32767 int 32 4 0 -2147483648 ~ 2147483647 long 64 8 0 L -9223372036854775808 ~ 9223372036854775807 char 16 2 &amp;lsquo;u 0000&amp;rsquo; 0 ~ 65535 float 32 4 0 f 1.</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid><description>面向对象和面向过程的区别 两者的主要区别在于解决问题的方式不同：
面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。
面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。
另外，面向对象开发的程序一般更易维护、易复用、易扩展。
相关 issue : 面向过程 ：面向过程性能比面向对象高？？open in new window
创建一个对象用什么运算符?对象实体与对象引用有何不同? new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>![[Java面试题、面经.pdf]]
![[Java 面试知识点总结.pdf]]
![[Java 面试知识点总结(1).pdf]]
![[Java面试题、面经(1).pdf]]
![[阿里大佬总结的Java面试资料.pdf]]</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid><description>要想理解透彻 JMM（Java 内存模型），我们先要从 CPU 缓存模型和指令重排序 说起！
从 CPU 缓存模型说起 CPU Cache CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。
为了更好地理解，我画了一个简单的 CPU Cache 示意图如下所示。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98/</guid><description>Java 内存模型 导致可见性的原因是缓存，导致有序性的原因是编译优化，那解决可见性、有序性最直接的办法就是禁用缓存和编译优化，但是这样性能堪忧，应该按需禁用缓存以及编译优化。
如何做到“按需禁用”呢？对于并发程序，何时禁用缓存以及编译优化只有程序员知道，那所谓“按需禁用”其实就是指按照程序员的要求来禁用。
本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 volatile、synchronized 和 final 三个关键字，以及六项 Happens-Before 规则。
volatile volatile 关键字并不是 Java 语言的特产，古老的 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B/</guid><description>Java 线程的生命周期 对于有生命周期的事物，要学好它，思路非常简单，只要能搞懂生命周期中各个节点的状态转换机制就可以了
通用的生命周期 &amp;mdash; &amp;mdash; 初始状态 初始状态，指的是线程已经被创建，但是还不允许分配 CPU 执行。这个状态属于编程语言特有的，不过这里所谓的被创建，仅仅是在编程语言层面被创建，而在操作系统层面，真正的线程还没有创建。 可运行状态 可运行状态，指的是线程可以分配 CPU 执行。在这种状态下，真正的操作系统线程已经被成功创建了，所以可以分配 CPU 执行。 运行状态 当有空闲的 CPU 时，操作系统会将其分配给一个处于可运行状态的线程，被分配到 CPU 的线程的状态就转换成了运行状态。 休眠状态 运行状态的线程如果调用一个阻塞的 API（例如以阻塞方式读文件）或者等待某个事件（例如条件变量），那么线程的状态就会转换到休眠状态，同时释放 CPU 使用权，休眠状态的线程永远没有机会获得 CPU 使用权。当等待的事件出现了，线程就会从休眠状态转换到可运行状态。 终止状态 线程执行完或者出现异常就会进入终止状态，终止状态的线程不会切换到其他任何状态，进入终止状态也就意味着线程的生命周期结束了。 java 中的生命周期 NEW（初始化状态）</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/ThreadLocal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/ThreadLocal/</guid><description>ThreadLocal 有什么用？ **ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal**类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。
如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。
如何使用 ThreadLocal？ 相信看了上面的解释，大家已经搞懂 ThreadLocal 类是个什么东西了。下面简单演示一下如何在项目中实际使用 ThreadLocal 。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import java.</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BA%92%E6%96%A5%E9%94%81%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BA%92%E6%96%A5%E9%94%81%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98/</guid><description>一个或者多个操作在 CPU 执行的过程中不被中断的特性，称为“原子性”。
如何解决原子性问题 原子性问题的源头是线程切换，如果能够禁用线程切换那不就能解决这个问题了吗？而操作系统做线程切换是依赖 CPU 中断的，所以禁止 CPU 发生中断就能够禁止线程切换。&amp;mdash;&amp;mdash;早期单核可行，现在不可行
在单核 CPU 场景下，同一时刻只有一个线程执行，禁止 CPU 中断，意味着操作系统不会重新调度线程，也就是禁止了线程切换，获得 CPU 使用权的线程就可以不间断地执行，所以两次写操作一定是：要么都被执行，要么都没有被执行，具有原子性
在多核场景下，同一时刻，有可能有两个线程同时在执行，一个线程执行在 CPU-1 上，一个线程执行在 CPU-2 上，此时禁止 CPU 中断，只能保证 CPU 上的线程连续执行，并不能保证同一时刻只有一个线程执行</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8BBug%E7%9A%84%E6%BA%90%E5%A4%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8BBug%E7%9A%84%E6%BA%90%E5%A4%B4/</guid><description>我们的 CPU、内存、I/O 设备都在不断迭代，不断朝着更快的方向努力。但是，在这个快速发展的过程中，有一个核心矛盾一直存在，就是这三者的速度差异
为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为：
cpu增加缓存，以均衡与内存的速度差异
操作系统增加了进程、线程，以分时复用CPU,进而均衡 CPU 与 I/O 设备的速度差异
编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。
这些优化导致了一些问题。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</guid><description>并行、并发的区别 从操作系统的角度来看，线程是CPU分配的最小单位
并发：两个及两个以上的作业在同一 时间段 内执行。
并行：两个及两个以上的作业在同一 时刻 执行。
同步和异步的区别 同步 ： 发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%AE%89%E5%85%A8%E6%80%A7%E6%B4%BB%E8%B7%83%E6%80%A7%E4%BB%A5%E5%8F%8A%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%AE%89%E5%85%A8%E6%80%A7%E6%B4%BB%E8%B7%83%E6%80%A7%E4%BB%A5%E5%8F%8A%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/</guid><description>存在共享数据并且该数据会发生变化，通俗地讲就是有多个线程会同时读写同一数据,需要分析安全性、活跃性以及性能问题。
那如果能够做到不共享数据或者数据状态不发生变化，不就能够保证线程的安全性了嘛。有不少技术方案都是基于这个理论的，例如线程本地存储（Thread Local Storage，TLS）、不变模式等等，后面我会详细介绍相关的技术方案是如何在 Java 语言中实现的。
安全性问题 当多个线程同时访问同一数据，并且至少有一个线程会写这个数据的时候，如果我们不采取防护措施，那么就会导致并发 Bug，对此还有一个专业的术语，叫做数据竞争（Data Race）
程序的执行结果依赖线程执行的顺序，叫做竟态条件（Race Condition）
那面对数据竞争和竞态条件问题，又该如何保证线程的安全性呢？其实这两类问题，都可以用互斥这个技术方案，而实现互斥的方案有很多，CPU 提供了相关的互斥指令，操作系统、编程语言也会提供相关的 API。从逻辑上来看，我们可以统一归为：锁。
活跃性问题 指的是某个操作无法执行下去。我们常见的**“死锁”**就是一种典型的活跃性问题，当然除了死锁外，还有两种情况，分别是“活锁”和“饥饿
活跃性问题</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/CompletableFuture%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/CompletableFuture%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid><description>前面我们不止一次提到，用多线程优化性能，其实不过就是将串行操作变成并行操作
异步化，是并行方案得以实施的基础，更深入地讲其实就是**：利用多线程优化性能这个核心方案得以实施的基础**
CompletableFuture 的核心优势 这里我们用 CompletableFuture 重新实现前面曾提及的烧水泡茶程序
我们分了 3 个任务：
任务 1 负责洗水壶、烧开水，
任务 2 负责洗茶壶、洗茶杯和拿茶叶，</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/CompletionService%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/CompletionService%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/</guid><description>有一个询价应用，这个应用需要从三个电商询价，然后保存在自己的数据库里。核心示例代码如下所示，由于是串行的，所以性能很慢，你来试着优化一下吧
1 2 3 4 5 6 7 8 9 10 // 向电商S1询价，并保存 r1 = getPriceByS1(); save(r1); // 向电商S2询价，并保存 r2 = getPriceByS2(); save(r2); // 向电商S3询价，并保存 r3 = getPriceByS3(); save(r3); 使用“ThreadPoolExecutor+Future”的方案，化结果很可能是下面示例代码这样：用三个线程异步执行询价，通过三次调用 Future 的 get() 方法获取询价结果，之后将询价结果保存在数据库中</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/CountDownLatch%E5%92%8CCyclicBarrier%E8%AE%A9%E7%BA%BF%E7%A8%8B%E6%AD%A5%E8%B0%83%E4%B8%80%E8%87%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/CountDownLatch%E5%92%8CCyclicBarrier%E8%AE%A9%E7%BA%BF%E7%A8%8B%E6%AD%A5%E8%B0%83%E4%B8%80%E8%87%B4/</guid><description>目前对账系统的处理逻辑是首先查询订单，然后查询派送单，之后对比订单和派送单，将差异写入差异库。
对账系统的代码抽象之后，也很简单，核心代码如下，就是在一个单线程里面循环查询订单、派送单，然后执行对账，最后将写入差异库。
1 2 3 4 5 6 7 8 9 10 11 while(存在未对账订单){ // 查询未对账订单 pos = getPOrders(); // 查询派送单 dos = getDOrders(); // 执行对账操作 diff = check(pos, dos); // 差异写入差异库 save(diff); } 利用并行优化对账系统 目前对账系统是单线程执行的，图形化后是下图这个样子。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/Executor-%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/Executor-%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid><description>线程是一个重量级的对象，应该避免频繁创建和销毁，可以使用线程池
一般意义上的池化资源，都是下面这样，当你需要资源的时候就调用 acquire() 方法来申请资源，用完之后就调用 release() 释放资源。
1 2 3 4 5 6 7 8 9 class XXXPool{ // 获取池化资源 XXX acquire() { } // 释放池化资源 void release(XXX x){ } } 若你带着这个固有模型来看并发包里线程池相关的工具类时，会很遗憾地发现它们完全匹配不上，Java 提供的线程池里面压根就没有申请线程和释放线程的方法.</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/Fork-Join%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84MapReduce/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/Fork-Join%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84MapReduce/</guid><description>对于简单的并行任务，你可以通过“线程池 +Future”的方案来解决；如果任务之间有聚合关系，无论是 AND 聚合还是 OR 聚合，都可以通过 CompletableFuture 来解决；而批量的并行任务，则可以通过 CompletionService 来解决。
我们一直讲，并发编程可以分为三个层面的问题，分别是分工、协作和互斥当你关注于任务的时候，你会发现你的视角已经从并发编程的细节中跳出来了，你应用的更多的是现实世界的思维模式，类比的往往是现实世界里的分工，所以我把线程池、Future、CompletableFuture 和 CompletionService 都列到了分工里面
上面提到的简单并行、聚合、批量并行这三种任务模型，基本上能够覆盖日常工作中的并发场景了，但还是不够全面，因为还有一种“分治”的任务模型没有覆盖到.
分治，顾名思义，即分而治之，是一种解决复杂问题的思维方法和模式；具体来讲，指的是把一个复杂的问题分解成多个相似的子问题，然后再把子问题分解成更小的子问题，直到子问题简单到可以直接求解。
分治任务模型 分治任务模型可分为两个阶段：
一个阶段是任务分解，也就是将任务迭代地分解为子任务，直至子任务可以直接计算出结果；</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/Future/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/Future/</guid><description>使用 ThreadPoolExecutor 的时候，如何获取任务执行结果
如何获取任务执行结果 Java 通过 ThreadPoolExecutor 提供的 3 个 submit() 方法和 1 个 FutureTask 工具类来支持获得任务执行结果的需求
submit() 1 2 3 4 5 6 7 // 提交Runnable任务 Future&amp;lt;?</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/Lock%E5%92%8CCondition/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/Lock%E5%92%8CCondition/</guid><description>ava SDK 并发包通过 Lock 和 Condition 两个接口来实现管程，其中 Lock 用于解决互斥问题，Condition 用于解决同步问题。
Java 语言本身提供的 synchronized 也是管程的一种实现，既然 Java 从语言层面已经实现了管程了，那为什么还要在 SDK 里提供另外一种实现呢？
再造管程的理由 例如在 Java 的 1.</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore/</guid><description>信号量模型 号量模型还是很简单的，可以简单概括为：一个计数器，一个等待队列，三个方法，
信号量模型里，计数器和等待队列对外是透明的，所以只能通过信号量模型提供的三个方法来访问它们，这三个方法分别是：init()、down() 和 up()。你可以结合下图来形象化地理解。
init()：设置计数器的初始值。
down()：计数器的值减 1；如果此时计数器的值小于 0，则当前线程将被阻塞，否则当前线程可以继续执行。
up()：计数器的值加 1；如果此时计数器的值小于或者等于 0，则唤醒等待队列中的一个线程，并将其从等待队列中移除。
对应的代码解释</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/%E5%8D%B0%E7%AB%A0%E9%94%81StampedLock%E6%AF%94%E8%AF%BB%E5%86%99%E9%94%81%E6%9B%B4%E5%BF%AB%E7%9A%84%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/%E5%8D%B0%E7%AB%A0%E9%94%81StampedLock%E6%AF%94%E8%AF%BB%E5%86%99%E9%94%81%E6%9B%B4%E5%BF%AB%E7%9A%84%E9%94%81/</guid><description>StampedLock 支持的三种锁模式 ReadWriteLock 支持两种模式：一种是读锁，一种是写锁。
StampedLock 支持三种模式，分别是：写锁、悲观读锁和乐观读。
其中，写锁、悲观读锁的语义和 ReadWriteLock 的写锁、读锁的语义非常类似，允许多个线程同时获取悲观读锁，但是只允许一个线程获取写锁，写锁和悲观读锁是互斥的。
StampedLock 里的写锁和悲观读锁加锁成功之后，都会返回一个 stamp；然后解锁的时候，需要传入这个 stamp
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 final StampedLock sl = new StampedLock(); // 获取/释放悲观读锁示意代码 long stamp = sl.</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%97%A0%E9%94%81%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E5%85%B8%E8%8C%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%97%A0%E9%94%81%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E5%85%B8%E8%8C%83/</guid><description>1 2 3 4 5 6 7 8 9 10 11 public class Test { AtomicLong count = new AtomicLong(0); void add10K() { int idx = 0; while(idx++ &amp;lt; 10000) { count.</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</guid><description>同步容器及其注意事项 都是基于 synchronized 这个同步关键字实现的，所以也被称为同步容器。
Java 中的容器主要可以分为四个大类，分别是 List、Map、Set 和 Queue，但并不是所有的 Java 容器都是线程安全的。
如何将非线程安全的容器变成线程安全的容器？
只要把非线程安全的容器封装在对象内部，然后控制好访问路径就可以了
以 ArrayList 为例，看看如何将它变成线程安全的在下面的代码中，SafeArrayList 内部持有一个 ArrayList 的实例 c，所有访问 c 的方法我们都增加了 synchronized 关键字，需要注意的是我们还增加了一个 addIfNotExist() 方法，这个方法也是用 synchronized 来保证原子性的。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/%E8%AF%BB%E5%86%99%E9%94%81ReadWriteLock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/%E8%AF%BB%E5%86%99%E9%94%81ReadWriteLock/</guid><description>一种非常普遍的并发场景：读多写少场景。实际工作中，为了优化性能，我们经常会使用缓存，例如缓存元数据、缓存基础数据等，这就是一种典型的读多写少应用场景。缓存之所以能提升性能，一个重要的条件就是缓存的数据一定是读多写少的，例如元数据和基础数据基本上不会发生变化（写少），但是使用它们的地方却很多（读多）。针对读多写少这种并发场景，Java SDK 并发包提供了读写锁——ReadWriteLock，非常容易使用，并且性能很好。
什么是读写锁 而是一个广为使用的通用技术，所有的读写锁都遵守以下三条基本原则： 1允许多个线程同时读共享变量； 2只允许一个线程写共享变量； 3如果一个写线程正在执行写操作，此时禁止读线程读共享变量。读写锁与互斥锁的一个重要区别就是读写锁允许多个线程同时读共享变量，而互斥锁是不允许的，这是读写锁在读多写少场景下性能优于互斥锁的关键。但读写锁的写操作是互斥的
实现一个缓存 在下面的代码中，我们声明了一个 Cache 类，其中类型参数 K 代表缓存里 key 的类型，V 代表缓存里 value 的类型，缓存的数据保存在 Cache 类内部的 HashMap 里面，HashMap 不是线程安全的，这里我们使用读写锁 ReadWriteLock 来保证其线程安全。ReadWriteLock 是一个接口，它的实现类是 ReentrantReadWriteLock，通过名字你应该就能判断出来，它是支持可重入的。下面我们通过 rwl 创建了一把读锁和一把写锁</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%AD%BB%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%AD%BB%E9%94%81/</guid><description>在上一篇文章中，我们用 Account.class 作为互斥锁，来解决银行业务里面的转账问题，虽然这个方案不存在并发问题，但是所有账户的转账操作都是串行的。
账户 A 转账户 B、账户 C 转账户 D 这两个转账操作现实世界里是可以并行的；
具体操作为：
文件架上恰好有转出账本和转入账本，那就同时拿走；
如果文件架上只有转出账本和转入账本之一，那这个柜员就先把文件架上有的账本拿到手，同时等着其他柜员把另外一个账本送回来；
转出账本和转入账本都没有，那这个柜员就等着两个账本都被送回来。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E4%BC%98%E5%8C%96%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E4%BC%98%E5%8C%96%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85/</guid><description>等待通知机制优化循环等待
在破坏占用且等待条件的时候，如果转出账本和转入账本不满足同时在文件架上这个条件，就用死循环的方式来循环等待
1 2 3 4 // 一次性申请转出账户和转入账户，直到成功 while(!actr.apply(this, target)) ； 如果 apply() 操作耗时长，或者并发冲突量大的时候，循环等待这种方案就不适用了，因为在这种场景下，可能要循环上万次才能获取到锁，太消耗 CPU 了。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%AE%A1%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%AE%A1%E7%A8%8B/</guid><description>什么是管程 Java 采用的是管程技术，synchronized 关键字及 wait()、notify()、notifyAll() 这三个方法都是管程的组成部分。而管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程
所谓管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发
MESA 模型 管程的发展历史上有三种管程模型
管程模型
Hasen 模型
Hoare 模型</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid><description>线程池
什么是线程池? 顾名思义，线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。
为什么要用线程池？ 池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。
线程池提供了一种限制和管理资源（包括执行一个任务）的方式。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。
这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：
降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
如何创建线程池？ 方式一：通过**ThreadPoolExecutor**构造函数来创建（推荐）。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Copy-on-Write/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Copy-on-Write/</guid><description>每次 RPC 调用都需要通过负载均衡器来计算目标服务的 IP 和端口号，而负载均衡器需要通过路由表获取接口的所有路由信息，也就是说，每次 RPC 调用都需要访问路由表，所以访问路由表这个操作的性能要求是很高的**。不过路由表对数据的一致性要求并不高，一个服务提供方从上线到反馈到客户端的路由表里，即便有 5 秒钟，很多时候也都是能接受的**（5 秒钟，对于以纳秒作为时钟周期的 CPU 来说，那何止是一万年，所以路由表对一致性的要求并不高）。
对读的性能要求很高，读多写少，弱一致性。它们综合在一起，你会想到什么呢？CopyOnWriteArrayList 和 CopyOnWriteArraySet 天生就适用这种场景啊。
RouteTable 这个类内部我们通过ConcurrentHashMap&amp;gt;这个数据结构来描述路由表，ConcurrentHashMap 的 Key 是接口名，Value 是路由集合，这个路由集合我们用是 CopyOnWriteArraySet</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Immutability%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E4%B8%8D%E5%8F%98%E6%80%A7%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Immutability%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E4%B8%8D%E5%8F%98%E6%80%A7%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</guid><description>Immutability 模式：如何利用不变性解决并发问题
解决并发问题，其实最简单的办法就是让共享变量只有读操作，而没有写操作
不变性（Immutability）模式。所谓不变性，简单来讲，就是对象一旦被创建之后，状态就不再发生变化
快速实现具备不可变性的类 将一个类所有的属性都设置成 final 的，并且只允许存在只读方法，那么这个类基本上就具备不可变性了，更严格的做法是这个类本身也是 final 的，也就是不允许继承。
Java SDK 里很多类都具备不可变性，如经常用到的 String 和 Long、Integer、Double 等基础类型的包装类都具备不可变性，
如果你仔细翻看这些类的声明、属性和方法，你会发现它们都严格遵守不可变类的三点要求：类和属性都是 final 的，所有方法均是只读的。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F-ThreadLocal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F-ThreadLocal/</guid><description>已经知道通过局部变量可以做到避免共享，那还有没有其他方法可以做到呢？
有的，Java 语言提供的**线程本地存储（ThreadLocal）**就能够做到
ThreadLocal 的使用方法 下面这个静态类 ThreadId 会为每个线程分配一个唯一的线程 Id，如果一个线程前后两次调用 ThreadId 的 get() 方法，两次 get() 方法的返回值是相同的。但如果是两个线程分别调用 ThreadId 的 get() 方法，那么两个线程看到的 get() 方法的返回值是不同的。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81/</guid><description>乐观锁和悲观锁 悲观锁：悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放
共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程
Java 中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现
悲观锁通常多用于写多比较多的情况下（多写场景），避免频繁失败和重试影响性能
乐观锁：总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid><description>Semaphore Semaphore的作用 synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，而Semaphore(信号量)可以用来控制同时访问特定资源的线程数量。
Semaphore 有两种模式：。
公平模式： 调用 acquire() 方法的顺序就是获取许可证的顺序，遵循 FIFO；
非公平模式： 抢占式的。
1 2 3 4 5 6 7 public Semaphore(int permits) { sync = new NonfairSync(permits); } public Semaphore(int permits, boolean fair) { sync = fair ?</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E9%9B%86%E5%90%88/Java-%E9%9B%86%E5%90%88-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E9%9B%86%E5%90%88/Java-%E9%9B%86%E5%90%88-overview/</guid><description>常见的集合 Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 Collection接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。对于Collection 接口，下面又有三个主要的子接口：List、Set 和 Queue。
Java 集合框架如下图所示
其中 Collection 是集合 List 、 Set 、Queue的父接口，它主要有两个子接口：</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E9%9B%86%E5%90%88/List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E9%9B%86%E5%90%88/List/</guid><description>ArrayList 和 Vector 的区别 ArrayList 是 List 的主要实现类，底层使用 Object[]存储，适用于频繁的查找工作，线程不安全 ；
Vector 是 List 的古老实现类，底层使用Object[] 存储，线程安全的。
ArrayList和LinkedList有什么区别？ 是否线程安全</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E9%9B%86%E5%90%88/Map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E9%9B%86%E5%90%88/Map/</guid><description>HashMap 和 HashTable 的区别 线程是否安全： HashMap 是非线程安全的，****Hashtable 是线程安全的,因为 Hashtable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；
效率： 因为线程安全的问题，HashMap 要比 Hashtable 效率高一点。另外，Hashtable 基本被淘汰，不要在代码中使用它；</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E9%9B%86%E5%90%88/Queue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E9%9B%86%E5%90%88/Queue/</guid><description>Queue 与 Deque 的区别 Queue
Queue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO） 规
Queue 扩展了 Collection 的接口，根据 因为容量问题而导致操作失败后处理方式的不同 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E9%9B%86%E5%90%88/Set/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E9%9B%86%E5%90%88/Set/</guid><description>comparable 和 Comparator 的区别 comparable 接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序
comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序
一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo()方法和使用自制的Comparator方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 Collections.</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>![[Java集合框架常见面试题.pdf]]
![[集合框架.pdf]]</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>![[《面渣逆袭手册》V1.1.pdf]]</description></item></channel></rss>