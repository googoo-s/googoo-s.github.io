<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="性能和可靠性 副本与存储结构 Pulsar通过BookKeeper实现了数据的高可靠。在BookKeeper中Ledger是基本的持久化存储单元。Pulsar的每个主题的数据都会在逻辑上映射为多个Ledger。每个Ledger在服务端会存储多个副本。为了灵活地控制存储时的一致性，BookKeeper在存储时提供了3个关键的参数—数据存储的副本数（Ensemble Size，直译为集合数量）、最大写入副本数（Write Quorum Size，直译为法定写入数量）、最小写入副本数（Ack Quorum Size，直译为法定确认数量） 集群的高可用一般通过多副本机制来保障。Pulsar、Kafka、RabbitMQ 与 RocketMQ 都依赖副本或备份来保障高可用。
 Kafka 以分区维度进行高可用保障，每个分区的数据会保存多个副本。在多个副本中会有一个被选为主副本并负责数据的读取与写入。与此同时，主副本还负责将数据同步至其他副本。在集群视角下，各个主副本会分布在不同的节点上，从全局来看，每个服务端的负载是相对均衡的 RocketMQ 依赖主从复制机制来实现数据的多副本，从而保证服务的可靠性。不同于 Kafka 采用物理分区方式（每个分区对应一个真实的日志文件），RocketMQ 采用逻辑分区的方式。RocketMQ 消息的存储由逻辑队列和物理日志一同实现，其中物理日志负责将消息存储在物理存储介质中，而消息的逻辑队列里存储对应消息的物理存储地址。在物理存储部分，RabbitMQ 也采用类似的主从复制机制来保障高可用。 Pulsar 通过 BookKeeper 实现了数据的高可靠。在 BookKeeper 中 Ledger 是基本的持久化存储单元。Pulsar 的每个主题的数据都会在逻辑上映射为多个 Ledger。每个 Ledger 在服务端会存储多个副本。为了灵活地控制存储时的一致性，BookKeeper 在存储时提供了 3 个关键的参数—数据存储的副本数（Ensemble Size，直译为集合数量）、最大写入副本数（Write Quorum Size，直译为法定写入数量）、最小写入副本数（Ack Quorum Size，直译为法定确认数量）  语义支持与一致性级别 根据 CAP 定理，在一个分布式系统中，一致性 (Consistency)、可用性 (Availability)、分区容错性 (Partition tolerance)三者不能同时满足。"><meta property="og:title" content><meta property="og:description" content="性能和可靠性 副本与存储结构 Pulsar通过BookKeeper实现了数据的高可靠。在BookKeeper中Ledger是基本的持久化存储单元。Pulsar的每个主题的数据都会在逻辑上映射为多个Ledger。每个Ledger在服务端会存储多个副本。为了灵活地控制存储时的一致性，BookKeeper在存储时提供了3个关键的参数—数据存储的副本数（Ensemble Size，直译为集合数量）、最大写入副本数（Write Quorum Size，直译为法定写入数量）、最小写入副本数（Ack Quorum Size，直译为法定确认数量） 集群的高可用一般通过多副本机制来保障。Pulsar、Kafka、RabbitMQ 与 RocketMQ 都依赖副本或备份来保障高可用。
 Kafka 以分区维度进行高可用保障，每个分区的数据会保存多个副本。在多个副本中会有一个被选为主副本并负责数据的读取与写入。与此同时，主副本还负责将数据同步至其他副本。在集群视角下，各个主副本会分布在不同的节点上，从全局来看，每个服务端的负载是相对均衡的 RocketMQ 依赖主从复制机制来实现数据的多副本，从而保证服务的可靠性。不同于 Kafka 采用物理分区方式（每个分区对应一个真实的日志文件），RocketMQ 采用逻辑分区的方式。RocketMQ 消息的存储由逻辑队列和物理日志一同实现，其中物理日志负责将消息存储在物理存储介质中，而消息的逻辑队列里存储对应消息的物理存储地址。在物理存储部分，RabbitMQ 也采用类似的主从复制机制来保障高可用。 Pulsar 通过 BookKeeper 实现了数据的高可靠。在 BookKeeper 中 Ledger 是基本的持久化存储单元。Pulsar 的每个主题的数据都会在逻辑上映射为多个 Ledger。每个 Ledger 在服务端会存储多个副本。为了灵活地控制存储时的一致性，BookKeeper 在存储时提供了 3 个关键的参数—数据存储的副本数（Ensemble Size，直译为集合数量）、最大写入副本数（Write Quorum Size，直译为法定写入数量）、最小写入副本数（Ack Quorum Size，直译为法定确认数量）  语义支持与一致性级别 根据 CAP 定理，在一个分布式系统中，一致性 (Consistency)、可用性 (Availability)、分区容错性 (Partition tolerance)三者不能同时满足。"><meta property="og:type" content="website"><meta property="og:image" content="https://googoo-s.github.io/icon.png"><meta property="og:url" content="https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AF%B9%E6%AF%94/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="性能和可靠性 副本与存储结构 Pulsar通过BookKeeper实现了数据的高可靠。在BookKeeper中Ledger是基本的持久化存储单元。Pulsar的每个主题的数据都会在逻辑上映射为多个Ledger。每个Ledger在服务端会存储多个副本。为了灵活地控制存储时的一致性，BookKeeper在存储时提供了3个关键的参数—数据存储的副本数（Ensemble Size，直译为集合数量）、最大写入副本数（Write Quorum Size，直译为法定写入数量）、最小写入副本数（Ack Quorum Size，直译为法定确认数量） 集群的高可用一般通过多副本机制来保障。Pulsar、Kafka、RabbitMQ 与 RocketMQ 都依赖副本或备份来保障高可用。
 Kafka 以分区维度进行高可用保障，每个分区的数据会保存多个副本。在多个副本中会有一个被选为主副本并负责数据的读取与写入。与此同时，主副本还负责将数据同步至其他副本。在集群视角下，各个主副本会分布在不同的节点上，从全局来看，每个服务端的负载是相对均衡的 RocketMQ 依赖主从复制机制来实现数据的多副本，从而保证服务的可靠性。不同于 Kafka 采用物理分区方式（每个分区对应一个真实的日志文件），RocketMQ 采用逻辑分区的方式。RocketMQ 消息的存储由逻辑队列和物理日志一同实现，其中物理日志负责将消息存储在物理存储介质中，而消息的逻辑队列里存储对应消息的物理存储地址。在物理存储部分，RabbitMQ 也采用类似的主从复制机制来保障高可用。 Pulsar 通过 BookKeeper 实现了数据的高可靠。在 BookKeeper 中 Ledger 是基本的持久化存储单元。Pulsar 的每个主题的数据都会在逻辑上映射为多个 Ledger。每个 Ledger 在服务端会存储多个副本。为了灵活地控制存储时的一致性，BookKeeper 在存储时提供了 3 个关键的参数—数据存储的副本数（Ensemble Size，直译为集合数量）、最大写入副本数（Write Quorum Size，直译为法定写入数量）、最小写入副本数（Ack Quorum Size，直译为法定确认数量）  语义支持与一致性级别 根据 CAP 定理，在一个分布式系统中，一致性 (Consistency)、可用性 (Availability)、分区容错性 (Partition tolerance)三者不能同时满足。"><meta name=twitter:image content="https://googoo-s.github.io/icon.png"><title>googoo-s 😄😸😎</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://googoo-s.github.io//icon.png><link href=https://googoo-s.github.io/styles.19109a40042e9f0e72e952fda4442a34.min.css rel=stylesheet><link href=https://googoo-s.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://googoo-s.github.io/js/darkmode.953af745b0f9342644d632fc167f3727.min.js></script>
<script src=https://googoo-s.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://googoo-s.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://googoo-s.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://googoo-s.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://googoo-s.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://googoo-s.github.io/",fetchData=Promise.all([fetch("https://googoo-s.github.io/indices/linkIndex.3bfb24158f5e9d4aff66ae07a3a8bd0d.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://googoo-s.github.io/indices/contentIndex.7e7b176f3dc5e31fceeff574620ae38a.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://googoo-s.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://googoo-s.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/googoo-s.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=googoo-s.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://googoo-s.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://googoo-s.github.io/>googoo-s 😄😸😎</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Unknown</p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#性能和可靠性>性能和可靠性</a><ol><li><a href=#副本与存储结构>副本与存储结构</a></li><li><a href=#语义支持与一致性级别>语义支持与一致性级别</a></li><li><a href=#扩展能力>扩展能力</a></li></ol></li><li><a href=#功能特性>功能特性</a><ol><li><a href=#消息模式>消息模式</a></li><li><a href=#多租户>多租户</a></li><li><a href=#优先级队列>优先级队列</a></li><li><a href=#延迟队列>延迟队列</a></li><li><a href=#重试队列和死信队列>重试队列和死信队列</a></li></ol></li></ol></nav></details></aside><a href=#性能和可靠性><h1 id=性能和可靠性><span class=hanchor arialabel=Anchor># </span>性能和可靠性</h1></a><a href=#副本与存储结构><h2 id=副本与存储结构><span class=hanchor arialabel=Anchor># </span>副本与存储结构</h2></a><p>Pulsar通过BookKeeper实现了数据的高可靠。在BookKeeper中Ledger是基本的持久化存储单元。Pulsar的每个主题的数据都会在逻辑上映射为多个Ledger。每个Ledger在服务端会存储多个副本。为了灵活地控制存储时的一致性，BookKeeper在存储时提供了3个关键的参数—数据存储的副本数（Ensemble Size，直译为集合数量）、最大写入副本数（Write Quorum Size，直译为法定写入数量）、最小写入副本数（Ack Quorum Size，直译为法定确认数量）
集群的高可用一般通过多副本机制来保障。Pulsar、Kafka、RabbitMQ 与 RocketMQ 都依赖副本或备份来保障高可用。</p><ul><li>Kafka 以分区维度进行高可用保障，每个分区的数据会保存多个副本。在多个副本中会有一个被选为主副本并负责数据的读取与写入。与此同时，主副本还负责将数据同步至其他副本。在集群视角下，各个主副本会分布在不同的节点上，从全局来看，每个服务端的负载是相对均衡的</li><li>RocketMQ 依赖主从复制机制来实现数据的多副本，从而保证服务的可靠性。不同于 Kafka 采用物理分区方式（每个分区对应一个真实的日志文件），RocketMQ 采用逻辑分区的方式。RocketMQ 消息的存储由逻辑队列和物理日志一同实现，其中物理日志负责将消息存储在物理存储介质中，而消息的逻辑队列里存储对应消息的物理存储地址。在物理存储部分，RabbitMQ 也采用类似的主从复制机制来保障高可用。</li><li>Pulsar 通过 BookKeeper 实现了数据的高可靠。在 BookKeeper 中 Ledger 是基本的持久化存储单元。Pulsar 的每个主题的数据都会在逻辑上映射为多个 Ledger。每个 Ledger 在服务端会存储多个副本。为了灵活地控制存储时的一致性，BookKeeper 在存储时提供了 3 个关键的参数—数据存储的副本数（Ensemble Size，直译为集合数量）、最大写入副本数（Write Quorum Size，直译为法定写入数量）、最小写入副本数（Ack Quorum Size，直译为法定确认数量）</li></ul><a href=#语义支持与一致性级别><h2 id=语义支持与一致性级别><span class=hanchor arialabel=Anchor># </span>语义支持与一致性级别</h2></a><p>根据 CAP 定理，在一个分布式系统中，一致性 (Consistency)、可用性 (Availability)、分区容错性 (Partition tolerance)三者不能同时满足。</p><p>消息在生产者和消费者之间进行传输的方式有 3 种—<strong>至多一次 (At most once)</strong>、<strong>至少一次 (At least once)</strong>、<strong>精确一次（Exactly once，又称精准一次）</strong></p><ul><li>Kafka，其具有幂等性和事务功能。Kafka 的幂等性是指单个生产者对于单分区单会话的幂等，而事务可以保证消息原子性地写入多个分区，即消息写入多个分区要么全部成功，要么全部回滚。<strong>Kafka 具备精确一次语义的能力</strong></li><li>Pulsar 可以通过幂等生产者在单个分区上写入数据，并保证其可靠性。通过客户端的自增序列 ID、重试机制与服务端的去重机制，幂等生产者可以保证发送到单个分区的每条消息只会被持久化一次，且不会丢失数据<ul><li>Pulsar 事务中的所有生产或消费操作都作为一个单元提交。一个事务中的所有操作要么全部提交，要么全部失败。，Kafka 与 Pulsar 的事务功能都是为了支持精确一次语义的</li></ul></li><li>RocketMQ 的事务流程被分为正常事务消息的发送和提交以及事务消息的补偿两个阶段。<ul><li>在消息发送过程中，生产者将消息发送到服务端后，若服务端未收到生产者对该消息的二次确认，则该消息会被标记成不可用状态。处于不可用状态的消息称为半事务消息，此时消费者无法正常消费这条消息。</li><li>另外，若发生网络闪断、生产者应用重启等情况，导致某条消息的二次确认丢失，那么 RocketMQ 服务端需要主动向消息生产者询问该消息的最终状态（Commit 或 Rollback），该询问过程即消息回查</li></ul></li></ul><a href=#扩展能力><h2 id=扩展能力><span class=hanchor arialabel=Anchor># </span>扩展能力</h2></a><p>消息队列集群到达瓶颈的时候，需要对集群进行扩容。扩容一般分为水平扩容和垂直扩容两种方式：</p><ul><li>水平扩容指的是往集群中增加节点，</li><li>垂直扩容指的是把集群中部分节点的配置调高以增加其处理能力</li></ul><p>在分布式系统中，大家更加期待能够发挥分布式集群的水平扩容能力。</p><ul><li>Kafka 是一个存储与计算混合的消息队列。由于 Kafka 集群采用主题物理分区设计，数据会存储在服务端节点上，而<strong>新加入集群的节点并没有存储分区，所以无法马上对外提供服务</strong>。因此需要把一些主题的分区分配到新加入的节点，此时需要运维人员介入。</li><li>由于采用了主备设计，RocketMQ 的服务端扩展能力比较强，只要将主备设备新增到集群中即可。但是需要在扩容完毕后，在新增的服务端节点创建对应的主题和订阅组信息。</li><li>RocketMQ 服务端具备读、写权限控制能力，可以针对单个主题的单个队列进行读写控制，这非常便于进行运维操作。</li></ul><a href=#功能特性><h1 id=功能特性><span class=hanchor arialabel=Anchor># </span>功能特性</h1></a><a href=#消息模式><h2 id=消息模式><span class=hanchor arialabel=Anchor># </span>消息模式</h2></a><ul><li><p>消息队列一般有两种消息读取模式—点对点 (Point to Point, P 2 P)模式和发布订阅模式</p><ul><li>RabbitMQ 采用的是点对点模式，而 Kafka、Pulsar 与 RocketMQ 采用的是发布订阅模式。不过在 RabbitMQ 中可以通过设置交换器类型实现发布订阅模式以达到广播消费的效果，在发布订阅模式中也能以点对点的形式进行消息消费。</li></ul></li><li><p>消息的可回溯性也是消息队列的重要特性。一般消息在消费完成之后就被处理了，之后再也不能消费该条消息。通过消息回溯可在消息被消费完成之后，再次消费该消息</p><ul><li>Kafka、Pulsar、RocketMQ 都支持消息回溯，可以根据时间戳或指定消费位置，重置消费组的偏移量使对应消息可以被重复消费。RabbitMQ 不支持回溯，消息一旦被标记确认就会被删除</li></ul></li><li><p>对于业务场景中对消息队列的使用需求，我们称为传统的消息队列应用场景。消息队列的主要应用场景包括<strong>低延迟订阅服务、流量削峰、异步请求处理</strong>等</p></li><li><p>在大数据系统中，消息队列是<strong>流数据的存储介质</strong>，是连接实时计算的基础组件，为大数据系统提供缓存与部分存储能力</p><ul><li>高吞吐量是最先被考虑的指标。例如，目前大数据的流处理系统事实标准 Kafka 就用了诸多设计来保障高吞吐量。首先，Kafka 使用了物理分区的设计（每个分区对应独立的存储文件），这使我们可以利用磁盘的顺序写入特性来增加吞吐量；其次，Kafka 使用了页缓存与零拷贝的底层技术，这也增加了消息队列的吞吐量</li></ul></li></ul><a href=#多租户><h2 id=多租户><span class=hanchor arialabel=Anchor># </span>多租户</h2></a><p>多租户是一种软件架构技术，主要用来实现多用户的环境下共用相同的系统或程序组件，并确保各用户的数据具有一定的隔离性。</p><ul><li>RabbitMQ 支持多租户技术，每一个租户为一个虚拟主机 (vhost)，本质上是一个独立的小型 RabbitMQ 服务器，具有自己独立的队列、交换器、绑定关系及权限等*</li><li>官方原生的 Kafka 没有完善的体系化多租户功能，但是包含一些配额管理与用户管理功能。基于 Kafka 协议的部分商业版消息队列支持多租户功能。例如 CKafka (Cloud Kafka)是一个具有分布式、高吞吐量、高可扩展等特性的消息系统，完全兼容开源 Kafka API 0.9.0 至 2.8.0版本</li><li>Pulsar 是天生支持多租户的消息队列。Pulsar 租户可以分布在多个集群中，并且每个租户都可以应用自己的身份验证和授权方案。命名空间是租户内的独立管理单元。在命名空间上设置的配置策略适用于在该命名空间中创建的所有主题</li></ul><a href=#优先级队列><h2 id=优先级队列><span class=hanchor arialabel=Anchor># </span>优先级队列</h2></a><p>优先级队列不同于先进先出队列，优先级高的消息具备优先被消费的特权，这样可以为下游提供不同消息级别。</p><p>优先级队列在消费速度小于生产速度时才有意义，因为只有这样才可以保证高优先级消息总是被消费</p><ul><li><strong>RabbitMQ 支持优先级队列</strong>，使用客户端提供的可选参数即可为任何队列设定优先级。</li><li>Kafka、RocketMQ、Pulsar 皆<strong>不支持原生的优先级队列</strong>，若想在这 3 类消息队列中使用优先级队列功能，需要<strong>用户通过不同主题或分区在业务层进行优先级划分</strong>。</li></ul><a href=#延迟队列><h2 id=延迟队列><span class=hanchor arialabel=Anchor># </span>延迟队列</h2></a><p>在一般的消息队列中，消息一旦入队就会被马上消费，而进入延迟队列的消息会被延迟消费。延迟队列存储的是延迟消息。所谓延迟消息是指消息被发送以后，并不想让消费者立刻拿到，而是等到特定时间消费者才能拿到的消息</p><ul><li>RabbitMQ：在 3.6 版本后，RabbitMQ <strong>官方提供了延迟队列的插件</strong>。RabbitMQ 需要在服务端插件目录中安装 rabbitmq_delayed_message_exchange 插件才能使用延迟队列功能</li><li>Kafka：Kafka 基于时间轮 (TimingWheel)自定义了一个用于实现延迟功能的定时器。但是该定时器无法被用户使用，仅用于实现内部的延时操作，比如延时请求和延时删除等。<strong>因此 Kafka 不支持用户使用延迟队列</strong></li><li>RocketMQ 开源版：RocketMQ 将延迟消息临时存储在一个内部主题中，<strong>不支持任意时间精度，支持特定的延迟级别</strong>，如 5 s、10 s、1 min 等。RocketMQ 发送延迟消息时，会在写入存储数据前将消息按照设置的延迟时间发送到指定的定时队列中。<strong>每个定时队列对应一个定时器</strong>。RocketMQ 通过定时器对定时队列进行轮询，并查看消息是否到期。若消息到期，RocketMQ 会将这条消息写入存储</li><li>Pulsar：支持秒级的延迟消息，所有延迟投递的消息都会被内部组件跟踪，消费组在消费消息时，会先去延迟消息追踪器中检查，以明确是否有到期需要投递的消息</li></ul><a href=#重试队列和死信队列><h2 id=重试队列和死信队列><span class=hanchor arialabel=Anchor># </span>重试队列和死信队列</h2></a><p>在提供消息不丢失保障功能的消息队列中，这条消息就可能会被不断处理，从而导致消息队列陷入死循环。为了解决这个问题，消息队列系统可以为需要重试的消息提供一个<strong>重试队列</strong>，由重试队列进行消息重试</p><p>在消息队列中，当由于某些原因导致消息多次重试，仍无法被正确投递时，为了确保消息不被无故丢弃，一般将其置于一个特殊角色的队列，这个队列一般称为<strong>死信队列</strong> (Dead-Letter Queue)。</p><ul><li>RabbitMQ 支持消息重试，可以对最大重试次数、重试间隔时间等进行设置。RabbitMQ 也支持死信队列。当队列中的消息超出重试次数或生存时间时，如果 RabbitMQ 配置了死信队列，那么这些应该被丢弃的消息会被放入死信队列中。</li><li>RocketMQ 中每个消费组都有一个重试队列，并且消息重试超过一定次数后就会被放入死信队列中</li><li>Kafka 暂不支持死信队列。</li><li>Pulsar 也支持死信队列。在 Pulsar 中某些消息可能会被多次重新传递，甚至可能永远都在重试中。通过使用死信队列，可让消息具有最大重新传递次数。当实际传递次数超过最大重新传递次数时，对应的消息会被发送到死信主题并自动确认。</li></ul></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://googoo-s.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by googoo-s using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2024</p><ul><li><a href=https://googoo-s.github.io/>Home</a></li><li><a href=https://github.com/googoo-s>GitHub</a></li></ul></footer></div></div></body></html>