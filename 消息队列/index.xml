<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>消息队列s on</title><link>https://quartz.jzhao.xyz/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link><description>Recent content in 消息队列s on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://quartz.jzhao.xyz/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://quartz.jzhao.xyz/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/kafka-%E6%9C%AF%E8%AF%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/kafka-%E6%9C%AF%E8%AF%AD/</guid><description>消息：Record。Kafka 是消息引擎嘛，这里的消息就是指 Kafka 处理的主要对象。
主题：Topic。主题是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。
分区：Partition。一个有序不变的消息序列。每个主题下可以有多个分区。
消息位移：Offset。表示分区中每条消息的位置信息，是一个单调递增且不变的值。
副本：Replica。Kafka 中同一条消息能够被拷贝到多个地方以提供数据冗余，这些地方就是所谓的副本。副本还分为领导者副本和追随者副本，各自有不同的角色划分。副本是在分区层级下的，即每个分区可配置多个副本实现高可用。
生产者：Producer。向主题发布新消息的应用程序。</description></item><item><title/><link>https://quartz.jzhao.xyz/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E5%AE%A2%E6%88%B7%E7%AB%AF-kafka%E6%8B%A6%E6%88%AA%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E5%AE%A2%E6%88%B7%E7%AB%AF-kafka%E6%8B%A6%E6%88%AA%E5%99%A8/</guid><description>其基本思想就是允许应用程序在不修改逻辑的情况下，动态地实现一组可插拔的事件处理逻辑链。它能够在主业务操作的前后多个时间点上插入对应的“拦截”逻辑。springmvcde 拦截器的工作原理
Kafka 拦截器借鉴了这样的设计思路。你可以在消息处理的前后多个时点动态植入不同的处理逻辑，比如在消息发送前或者在消息被消费后。
Kafka 拦截器 fka 拦截器分为生产者拦截器和消费者拦截器。生产者拦截器允许你在发送消息前以及消息提交成功后植入你的拦截器逻辑；而消费者拦截器支持在消费消息前以及提交位移后编写特定逻辑。值得一提的是，这两种拦截器都支持链的方式，即你可以将一组拦截器串连成一个大的拦截器，Kafka 会按照添加顺序依次执行拦截器逻辑。
当前 Kafka 拦截器的设置方法是通过参数配置完成的。生产者和消费者两端有一个相同的参数，名字叫 interceptor.classes
1 2 3 4 5 6 7 Properties props = new Properties(); List&amp;lt;String&amp;gt; interceptors = new ArrayList&amp;lt;&amp;gt;(); interceptors.</description></item><item><title/><link>https://quartz.jzhao.xyz/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE/</guid><description>一句话概括，Kafka 只对**“已提交”的消息（committed message）做有限度的持久化保证。**
生产者
要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。记住，一定要使用带有回调通知的 send 方法。 Broker
设置 acks = all。acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义。**如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。**这是最高等级的“已提交”定义</description></item><item><title/><link>https://quartz.jzhao.xyz/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E5%AE%A2%E6%88%B7%E7%AB%AF-%E7%94%9F%E4%BA%A7%E8%80%85%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E5%AE%A2%E6%88%B7%E7%AB%AF-%E7%94%9F%E4%BA%A7%E8%80%85%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/</guid><description>具体来说就是用 CPU 时间去换磁盘空间或网络 I/O 传输量，希望以较小的 CPU 开销带来更少的磁盘占用或更少的网络 I/O 传输。
怎么压缩 kafka 的消息层次都分为两层：
消息集合（message set）
消息（message）。一个消息集合中包含若干条日志项（record item）,而日志项才是真正封装消息的地方</description></item><item><title/><link>https://quartz.jzhao.xyz/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E5%AE%A2%E6%88%B7%E7%AB%AF-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E6%81%AF%E5%88%86%E5%8C%BA%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E5%AE%A2%E6%88%B7%E7%AB%AF-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E6%81%AF%E5%88%86%E5%8C%BA%E6%9C%BA%E5%88%B6/</guid><description>切记分区是实现负载均衡以及高吞吐量的关键
为什么分区 Kafka 有主题（Topic）的概念，它是承载真实数据的逻辑容器，而在主题之下还分为若干个分区，也就是说 Kafka 的消息组织方式实际上是三级结构：**主题 - 分区 - 消息。**主题下的每条消息只会保存在某一个分区中，而不会在多个分区中被保存多份
为啥要使用多个分区而不是直接使用多个主题？ 其实分区的作用就是提供负载均衡的能力
为了实现系统的高伸缩性（Scalability）。不同的分区能够被放置到不同节点的机器上，而数据的读写操作也都是针对分区这个粒度而进行的，这样每个节点的机器都能独立地执行各自分区的读写请求处理。并且，我们还可以通过添加新的节点机器来增加整体系统的吞吐量。
都有哪些分区策略 所谓分区策略是决定生产者将消息发送到哪个分区的算法。</description></item><item><title/><link>https://quartz.jzhao.xyz/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BE%85%E7%BB%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BE%85%E7%BB%AD/</guid><description/></item><item><title/><link>https://quartz.jzhao.xyz/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E6%B6%88%E6%81%AF%E5%BC%95%E6%93%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E6%B6%88%E6%81%AF%E5%BC%95%E6%93%8E/</guid><description>Apache Kafka 是一款开源的消息引擎系统。
最基础的消息引擎就做两个重要的事实：
消息引擎传输的对象是消息；
如何传输消息属于消息引擎设计机制的一部分。
消息的格式 那么现在我告诉你 Kafka 的选择：它使用的是纯二进制的字节序列。
传输方法 消息引擎系统还要设定具体的传输协议，即我用什么方法把消息传输出去。常见的有两种方法：
点对点模型：也叫消息队列模型。如果拿上面那个“民间版”的定义来说，那么系统 A 发送的消息只能被系统 B 接收，其他任何系统都不能读取 A 发送的消息。日常生活的例子比如电话客服就属于这种模型：同一个客户呼入电话只能被一位客服人员处理，第二个客服人员不能为该客户服务。</description></item><item><title/><link>https://quartz.jzhao.xyz/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E7%AE%A1%E7%90%86%E7%9B%91%E6%8E%A7%E5%BE%85%E7%BB%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E7%AE%A1%E7%90%86%E7%9B%91%E6%8E%A7%E5%BE%85%E7%BB%AD/</guid><description/></item><item><title/><link>https://quartz.jzhao.xyz/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RockerMQ/RockerMQ%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RockerMQ/RockerMQ%E4%BB%8B%E7%BB%8D/</guid><description>RocketMQ 的优缺点 RocketMQ优点：
单机吞吐量：十万级
可用性：非常高，分布式架构
消息可靠性：经过参数优化配置，消息可以做到0丢失
功能支持：MQ功能较为完善，还是分布式的，扩展性好
支持10亿级别的消息堆积，不会因为堆积导致性能下降</description></item><item><title/><link>https://quartz.jzhao.xyz/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80/</guid><description>为什么要使用消息队列呢？ 消息队列主要有三大用途，我们拿一个电商系统的下单举例：
解耦：引入消息队列之前，下单完成之后，需要订单服务去调用库存服务减库存，调用营销服务加营销数据……引入消息队列之后，可以把订单完成的消息丢进队列里，下游服务自己去调用就行了，这样就完成了订单服务和其它服务的解耦合。
异步：订单支付之后，我们要扣减库存、增加积分、发送消息等等**，这样一来这个链路就长了，链路一长，响应时间就变长了。引入消息队列，除了 更新订单状态 ，其它的都可以异步去做，这样一来就来，就能降低响应时间。**
削峰：消息队列合一用来削峰，例如秒杀系统，平时流量很低，但是要做秒杀 活动，秒杀的时候流量疯狂怼进来，我们的服务器，Redis，MySQL各自的承受能力都不一样，直接全部流量照单全收肯定有问题啊，严重点可能直接打挂了。我们可以把请求扔到队列里面，只放出我们服务能处理的流量，这样就能抗住短时间的大流量了
主流消息队列的对比 总结下：
选择中间件的可以从这些维度来考虑：可靠性，性能，功能，可运维行，可拓展性，社区活跃度。目前常用的几个中间件，ActiveMQ作为“老古董”，市面上用的已经不多，其它几种：
RabbitMQ：
优点：轻量，迅捷，容易部署和使用，拥有灵活的路由配置</description></item></channel></rss>