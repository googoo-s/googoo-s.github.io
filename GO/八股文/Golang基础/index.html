<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="init 和 main 函数相关特点 init 函数 （没有输入参数、返回值）的主要作用：  初始化不能采用初始化表达式初始化的变量。 程序运行前的注册。 实现sync.Once功能。 其他  init 顺序  在同一个 package 中，可以多个文件中定义 init 方法 在同一个 go 文件中，可以重复定义 init 方法 在同一个 package 中，不同文件中的 init 方法的执行按照文件名先后执行各个文件中的 init 方法 在同一个文件中的多个 init 方法，按照在代码中编写的顺序依次执行不同的 init 方法 对于不同的 package，如果不相互依赖的话，按照 main 包中 import 的顺序调用其包中的 init() 函数 如果 package 存在依赖，调用顺序为最后被依赖的最先被初始化，例如：导入顺序 main –> A –> B –> C，则初始化顺序为 C –> B –> A –> main，一次执行对应的 init 方法。  所有 init 函数都在同⼀个 goroutine 内执行。 所有 init 函数结束后才会执行 main."><meta property="og:title" content="Golang基础"><meta property="og:description" content="init 和 main 函数相关特点 init 函数 （没有输入参数、返回值）的主要作用：  初始化不能采用初始化表达式初始化的变量。 程序运行前的注册。 实现sync.Once功能。 其他  init 顺序  在同一个 package 中，可以多个文件中定义 init 方法 在同一个 go 文件中，可以重复定义 init 方法 在同一个 package 中，不同文件中的 init 方法的执行按照文件名先后执行各个文件中的 init 方法 在同一个文件中的多个 init 方法，按照在代码中编写的顺序依次执行不同的 init 方法 对于不同的 package，如果不相互依赖的话，按照 main 包中 import 的顺序调用其包中的 init() 函数 如果 package 存在依赖，调用顺序为最后被依赖的最先被初始化，例如：导入顺序 main –> A –> B –> C，则初始化顺序为 C –> B –> A –> main，一次执行对应的 init 方法。  所有 init 函数都在同⼀个 goroutine 内执行。 所有 init 函数结束后才会执行 main."><meta property="og:type" content="website"><meta property="og:image" content="https://googoo-s.github.io/icon.png"><meta property="og:url" content="https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/Golang%E5%9F%BA%E7%A1%80/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content="Golang基础"><meta name=twitter:description content="init 和 main 函数相关特点 init 函数 （没有输入参数、返回值）的主要作用：  初始化不能采用初始化表达式初始化的变量。 程序运行前的注册。 实现sync.Once功能。 其他  init 顺序  在同一个 package 中，可以多个文件中定义 init 方法 在同一个 go 文件中，可以重复定义 init 方法 在同一个 package 中，不同文件中的 init 方法的执行按照文件名先后执行各个文件中的 init 方法 在同一个文件中的多个 init 方法，按照在代码中编写的顺序依次执行不同的 init 方法 对于不同的 package，如果不相互依赖的话，按照 main 包中 import 的顺序调用其包中的 init() 函数 如果 package 存在依赖，调用顺序为最后被依赖的最先被初始化，例如：导入顺序 main –> A –> B –> C，则初始化顺序为 C –> B –> A –> main，一次执行对应的 init 方法。  所有 init 函数都在同⼀个 goroutine 内执行。 所有 init 函数结束后才会执行 main."><meta name=twitter:image content="https://googoo-s.github.io/icon.png"><title>Golang基础</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://googoo-s.github.io//icon.png><link href=https://googoo-s.github.io/styles.19109a40042e9f0e72e952fda4442a34.min.css rel=stylesheet><link href=https://googoo-s.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://googoo-s.github.io/js/darkmode.953af745b0f9342644d632fc167f3727.min.js></script>
<script src=https://googoo-s.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://googoo-s.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://googoo-s.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://googoo-s.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://googoo-s.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://googoo-s.github.io/",fetchData=Promise.all([fetch("https://googoo-s.github.io/indices/linkIndex.3bfb24158f5e9d4aff66ae07a3a8bd0d.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://googoo-s.github.io/indices/contentIndex.7e7b176f3dc5e31fceeff574620ae38a.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://googoo-s.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://googoo-s.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/googoo-s.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=googoo-s.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://googoo-s.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://googoo-s.github.io/>googoo-s 😄😸😎</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Golang基础</h1><p class=meta>Last updated
Feb 25, 2024</p><ul class=tags><li><a href=https://googoo-s.github.io/tags/GO/%E5%85%AB%E8%82%A1%E6%96%87/>Go 八股文</a></li></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#init-和-main-函数相关特点>init 和 main 函数相关特点</a><ol><li><a href=#init-函数-没有输入参数返回值的主要作用>init 函数 （没有输入参数、返回值）的主要作用：</a></li><li><a href=#init-顺序>init 顺序</a></li></ol></li><li><a href=#go-的数据结构的零值是什么>Go 的数据结构的零值是什么?</a></li><li><a href=#byte和rune有什么区别>byte和rune有什么区别</a></li><li><a href=#go-struct-能不能比较>Go struct 能不能比较</a></li><li><a href=#go-语言如何初始化变量>Go 语言如何初始化变量</a></li><li><a href=#go-import-的三种方式>Go import 的三种方式</a></li><li><a href=#与其他语言相比使用-go-有什么好处>与其他语言相比，使用 Go 有什么好处？</a></li><li><a href=#听说-go-有什么什么的缺陷你怎么看>听说 go 有什么什么的缺陷，你怎么看</a></li><li><a href=#golang的常量取地址>Golang的常量取地址</a></li><li><a href=#golang-的字符串拼接>Golang 的字符串拼接</a></li><li><a href=#string-和-byte-如何取舍>string 和 []byte 如何取舍</a></li><li><a href=#字符串转成-byte-数组会发生内存拷贝吗>字符串转成 byte 数组，会发生内存拷贝吗</a></li><li><a href=#翻转含有中文数字英文字母的字符串>翻转含有中文、数字、英文字母的字符串</a></li><li><a href=#json-包变量不加-tag-会怎么样>json 包变量不加 tag 会怎么样？</a></li><li><a href=#reflect反射包如何获取字段-tag为什么-json-包不能导出私有变量的-tag>reflect（反射包）如何获取字段 tag？为什么 json 包不能导出私有变量的 tag？</a></li><li><a href=#昨天那个在-for-循环里-append-元素的同事今天还在么>昨天那个在 for 循环里 append 元素的同事，今天还在么？</a></li><li><a href=#golang-语言的自增自减操作>Golang 语言的自增，自减操作</a></li><li><a href=#printfsprintffprintf函数的区别用法是什么>Printf()、Sprintf()、Fprintf()函数的区别用法是什么</a></li><li><a href=#go-语言中-cap-函数可以作用于哪些内容>Go 语言中 cap 函数可以作用于哪些内容？</a></li><li><a href=#golang-语言的引用类型有什么>Golang 语言的引用类型有什么?</a></li><li><a href=#通过指针变量-p访问其成员变量-name有哪几种方式>通过指针变量  <strong>p</strong> 访问其成员变量 name，有哪几种方式？</a></li><li><a href=#for-select-时如果通道已经关闭会怎么样如果只有个-case-呢>for select 时，如果通道已经关闭会怎么样？如果只有⼀个 case 呢？</a></li><li><a href=#golang-的-bool-类型的赋值>Golang 的 bool 类型的赋值</a></li><li><a href=#go-关键字-fallthrough-有什么作用>Go 关键字 fallthrough 有什么作用</a></li><li><a href=#空结构体占不占内存空间-为什么使用空结构体>空结构体占不占内存空间？ 为什么使用空结构体？</a></li><li><a href=#httpsyouandgentlenesscn20230921golange585abe882a1e69687e6b187e680bbgo-e79a84e99da2e59091e5afb9e8b1a1e789b9e680a7-go-的面向对象特性go-的面向对象特性><a href=https://youandgentleness.cn/2023/09/21/Golang%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/#Go-%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7 title="Go 的面向对象特性"></a>Go 的面向对象特性</a></li><li><a href=#go-语言中-下面哪个关于指针的说法是错误的>Go 语言中 ,下面哪个关于指针的说法是错误的?</a></li><li><a href=#go-语言的接口类型是如何实现的>Go 语言的接口类型是如何实现的？</a></li><li><a href=#关于-switch-语句下说法正确的有>关于 switch 语句，下⾯说法正确的有?</a></li><li><a href=#go-编程语言中-switch-语句的语法>Go 编程语言中 switch 语句的语法</a></li><li><a href=#copy-是操作符还是内置函数>copy 是操作符还是内置函数</a></li><li><a href=#go-两个接口之间可以存在什么关系>Go 两个接口之间可以存在什么关系？</a></li><li><a href=#如何在运行时检查变量类型>如何在运行时检查变量类型？</a></li><li><a href=#golang-的返回值命名>Golang 的返回值命名</a></li><li><a href=#golang-的-iota-如何使用>Golang 的 iota 如何使用？</a></li><li><a href=#数组之间如何进行比较>数组之间如何进行比较？</a></li><li><a href=#for-range-的注意点和坑>for range 的注意点和坑</a></li><li><a href=#golang-的断言>Golang 的断言</a></li><li><a href=#精通-golang-项目依赖-go-modules>精通 Golang 项目依赖 Go modules</a></li><li><a href=#go-string-的底层实现>Go string 的底层实现</a></li><li><a href=#go-语言的-panic-如何恢复>Go 语言的 panic 如何恢复</a></li><li><a href=#go-如何避免-panic>Go 如何避免 panic</a></li><li><a href=#空结构体的使用场景>空结构体的使用场景</a></li><li><a href=#defer-的几个坑>defer 的几个坑</a></li><li><a href=#使用过哪些-golang-的-string-类库>使用过哪些 Golang 的 String 类库</a></li><li><a href=#go-结构体内嵌后的命名冲突>Go 结构体内嵌后的命名冲突</a></li><li><a href=#go程序中的包是什么><strong>Go</strong>程序中的包是什么？</a></li><li><a href=#go-实现不重启热部署>Go 实现不重启热部署</a></li><li><a href=#go-中的指针强转>Go 中的指针强转</a></li><li><a href=#go-支持什么形式的类型转换将整数转换为浮点数>Go 支持什么形式的类型转换？将整数转换为浮点数。</a></li><li><a href=#golang-语言中的使用>Golang 语言中==的使用</a></li><li><a href=#make-函数底层实现>make 函数底层实现</a></li><li><a href=#go-语言实现小根堆>Go 语言实现小根堆</a></li><li><a href=#go-怎么实现-func-的自定义参数>Go 怎么实现 func 的自定义参数</a></li><li><a href=#为什么-go-的变量申请类型是为了什么>为什么 go 的变量申请类型是为了什么？</a></li><li><a href=#go-的闭包语法>Go 的闭包语法</a></li><li><a href=#go-语言中-int-占几个字节>Go 语言中 int 占几个字节</a></li><li><a href=#golang-程序启动过程>Golang 程序启动过程</a></li><li><a href=#golang-开发新手常犯的50个错误>Golang 开发新手常犯的50个错误</a></li><li><a href=#go基础语法50问>go基础语法50问</a></li><li><a href=#go-程序的基本结构>Go 程序的基本结构？</a></li><li><a href=#go-有哪些关键字>Go 有哪些关键字？</a></li><li><a href=#go-有哪些数据类型>Go 有哪些数据类型？</a></li><li><a href=#go-方法与函数的区别>Go 方法与函数的区别？</a></li><li><a href=#go-方法值接收者和指针接收者的区别>Go 方法值接收者和指针接收者的区别?</a></li><li><a href=#go-函数返回局部变量的指针是否安全>Go 函数返回局部变量的指针是否安全?</a></li><li><a href=#go-函数参数传递到底是值传递还是引用传递>Go 函数参数传递到底是值传递还是引用传递？</a></li><li><a href=#go-defer-关键字的实现原理>Go defer 关键字的实现原理？</a></li><li><a href=#go-内置函数-make-和-new-的区别>Go 内置函数 make 和 new 的区别？</a></li></ol></nav></details></aside><a href=#init-和-main-函数相关特点><h1 id=init-和-main-函数相关特点><span class=hanchor arialabel=Anchor># </span>init 和 main 函数相关特点</h1></a><a href=#init-函数-没有输入参数返回值的主要作用><h2 id=init-函数-没有输入参数返回值的主要作用><span class=hanchor arialabel=Anchor># </span>init 函数 （没有输入参数、返回值）的主要作用：</h2></a><ul><li>初始化不能采用初始化表达式初始化的变量。</li><li>程序运行前的注册。</li><li>实现sync.Once功能。</li><li>其他</li></ul><a href=#init-顺序><h2 id=init-顺序><span class=hanchor arialabel=Anchor># </span>init 顺序</h2></a><ol><li>在同一个 package 中，可以多个文件中定义 init 方法</li><li>在同一个 go 文件中，可以重复定义 init 方法</li><li>在同一个 package 中，不同文件中的 init 方法的执行按照文件名先后执行各个文件中的 init 方法</li><li>在同一个文件中的多个 init 方法，按照在代码中编写的顺序依次执行不同的 init 方法</li><li>对于不同的 package，如果不相互依赖的话，按照 main 包中 import 的顺序调用其包中的 init() 函数</li><li>如果 package 存在依赖，调用顺序为最后被依赖的最先被初始化，例如：导入顺序 main –> A –> B –> C，则初始化顺序为 C –> B –> A –> main，一次执行对应的 init 方法。</li></ol><p>所有 init 函数都在同⼀个 goroutine 内执行。
所有 init 函数结束后才会执行 main.main 函数</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statisticimage.png width=auto alt=image.png></p><a href=#go-的数据结构的零值是什么><h1 id=go-的数据结构的零值是什么><span class=hanchor arialabel=Anchor># </span>Go 的数据结构的零值是什么?</h1></a><ul><li><p>所有整型类型：0</p></li><li><p>浮点类型：0.0</p></li><li><p>布尔类型：false</p></li><li><p>字符串类型：””</p></li><li><p>指针、interface、切片（slice）、channel、map、function ：nil</p></li></ul><p>Go的零值初始是递归的，即数组、结构体等类型的零值初始化就是对其组成元素逐一进行零值初始化。</p><a href=#byte和rune有什么区别><h1 id=byte和rune有什么区别><span class=hanchor arialabel=Anchor># </span>byte和rune有什么区别</h1></a><p>rune和byte在go语言中都是字符类型，且都是别名类型</p><p>byte型本质上是uint8类型的别名，代表了ASCII 码的一个字符</p><p>rune型本质上是int32型的别名，代表一个 UTF-8 字符</p><a href=#go-struct-能不能比较><h1 id=go-struct-能不能比较><span class=hanchor arialabel=Anchor># </span>Go struct 能不能比较</h1></a><p>需要具体情况具体分析，如果struct中含有不能被比较的字段类型，就不能被比较。</p><p>如果struct中所有的字段类型都支持比较，那么就可以被比较。</p><ul><li>不可被比较的类型：<ul><li>slice，因为slice是引用类型，除非是和nil比较</li><li>map，和slice同理，如果要比较两个map只能通过循环遍历实现</li><li>函数类型</li></ul></li></ul><p>其他的类型都可以比较。</p><p>还有两点值得注意：</p><ul><li>结构体之间只能比较它们是否相等，而不能比较它们的大小</li><li>只有所有属性都相等而且属性顺序都一致的结构体才能进行比较</li></ul><a href=#go-语言如何初始化变量><h1 id=go-语言如何初始化变量><span class=hanchor arialabel=Anchor># </span>Go 语言如何初始化变量</h1></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>var a int=10  
</span></span><span class=line><span class=cl>var a=10  
</span></span><span class=line><span class=cl>a:=10
</span></span></code></pre></td></tr></table></div></div><a href=#go-import-的三种方式><h1 id=go-import-的三种方式><span class=hanchor arialabel=Anchor># </span>Go import 的三种方式</h1></a><p><strong>一、加下划线：</strong></p><p>import 下划线（如：_ “github.com/go-sql-driver/mysql”）</p><p>作用：当导入一个包时，该包下的文件里所有init()函数 都会被执行。然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行init()函数而已。这个时候就可以使用 import _ 引用该包。即：<strong>使用[import _ 包路径]只是引用该包，仅仅是为了调用init()函数，所以无法通过包名来调用包中的其他函数</strong>。</p><p><strong>二、加点(.)：</strong></p><p>import和引用的包名之间加点（.）操作的含义就是这个包导入之后在调用这个包的函数时，可以省略前缀的包名。</p><p><strong>三、别名：</strong></p><p>别名操作顾名思义可以把包命名成另一个用起来容易记忆的名字。</p><a href=#与其他语言相比使用-go-有什么好处><h1 id=与其他语言相比使用-go-有什么好处><span class=hanchor arialabel=Anchor># </span>与其他语言相比，使用 Go 有什么好处？</h1></a><ul><li>与其他作为学术实验开始的语⾔不同，Go 代码的设计是务实的。每个功能和语法决策都旨在让程序员的⽣活更轻松。</li><li>Golang 针对并发进行了优化，并且在规模上运行良好。</li><li>由于单⼀的标准代码格式，Golang 通常被认为比其他语⾔更具可读性。</li><li>⾃动垃圾收集明显比Java 或 Python 更有效，因为它与程序同时执行。</li></ul><a href=#听说-go-有什么什么的缺陷你怎么看><h1 id=听说-go-有什么什么的缺陷你怎么看><span class=hanchor arialabel=Anchor># </span>听说 go 有什么什么的缺陷，你怎么看</h1></a><ul><li>缺少框架；</li><li>go 语言通过函数和预期的调用代码简单地返回错误，容易丢失错误发生的范围；</li><li>go语言的软件包管理没有办法制定特定版本的依赖库。</li></ul><a href=#golang的常量取地址><h1 id=golang的常量取地址><span class=hanchor arialabel=Anchor># </span>Golang的常量取地址</h1></a><p>Go 语⾔中，常量⽆法寻址, 是不能进⾏取指针操作的</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>const i = 100  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>var j = 123  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>func main() {  
</span></span><span class=line><span class=cl>	fmt.Println(&amp;j, j)   
</span></span><span class=line><span class=cl>	fmt.Println(&amp;i, i)  //panic  
</span></span><span class=line><span class=cl>} //Go语⾔中，常量⽆法寻址, 是不能进⾏取指针操作的
</span></span></code></pre></td></tr></table></div></div><a href=#golang-的字符串拼接><h1 id=golang-的字符串拼接><span class=hanchor arialabel=Anchor># </span>Golang 的字符串拼接</h1></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>A. str := &#39;abc&#39; + &#39;123&#39;  
</span></span><span class=line><span class=cl>B. str := &#34;abc&#34; + &#34;123&#34;  
</span></span><span class=line><span class=cl>C. str ：= &#39;123&#39; + &#34;abc&#34;  
</span></span><span class=line><span class=cl>D. fmt.Sprintf(&#34;abc%d&#34;, 123)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>答案：B、D
</span></span></code></pre></td></tr></table></div></div><a href=#string-和-byte-如何取舍><h1 id=string-和-byte-如何取舍><span class=hanchor arialabel=Anchor># </span>string 和 []byte 如何取舍</h1></a><p>string 擅长的场景：</p><ul><li>需要字符串比较的场景；</li><li>不需要nil字符串的场景；</li></ul><p>[]byte擅长的场景：</p><ul><li>修改字符串的场景，尤其是修改粒度为1个字节；</li><li>函数返回值，需要用nil表示含义的场景；</li><li>需要切片操作的场景；</li></ul><a href=#字符串转成-byte-数组会发生内存拷贝吗><h1 id=字符串转成-byte-数组会发生内存拷贝吗><span class=hanchor arialabel=Anchor># </span>字符串转成 byte 数组，会发生内存拷贝吗</h1></a><p><a href="https://mp.weixin.qq.com/s?__biz=MzkxNTU5MjE0MQ==&mid=2247492748&idx=1&sn=1b836dbf9ce2e660080d28878f57476c&source=41#wechat_redirect" rel=noopener>https://mp.weixin.qq.com/s?__biz=MzkxNTU5MjE0MQ==&mid=2247492748&idx=1&sn=1b836dbf9ce2e660080d28878f57476c&source=41#wechat_redirect</a></p><a href=#翻转含有中文数字英文字母的字符串><h1 id=翻转含有中文数字英文字母的字符串><span class=hanchor arialabel=Anchor># </span>翻转含有中文、数字、英文字母的字符串</h1></a><p><a href="https://mp.weixin.qq.com/s?__biz=MzkxNTU5MjE0MQ==&mid=2247492747&idx=1&sn=2c2e3331053fe3baf9e842ddbd795f20&source=41#wechat_redirect" rel=noopener>https://mp.weixin.qq.com/s?__biz=MzkxNTU5MjE0MQ==&mid=2247492747&idx=1&sn=2c2e3331053fe3baf9e842ddbd795f20&source=41#wechat_redirect</a></p><a href=#json-包变量不加-tag-会怎么样><h1 id=json-包变量不加-tag-会怎么样><span class=hanchor arialabel=Anchor># </span>json 包变量不加 tag 会怎么样？</h1></a><p><a href="https://mp.weixin.qq.com/s?__biz=MzkxNTU5MjE0MQ==&mid=2247492753&idx=1&sn=50f47249103f79fd404c180cb9e2c926&source=41#wechat_redirect" rel=noopener>https://mp.weixin.qq.com/s?__biz=MzkxNTU5MjE0MQ==&mid=2247492753&idx=1&sn=50f47249103f79fd404c180cb9e2c926&source=41#wechat_redirect</a></p><a href=#reflect反射包如何获取字段-tag为什么-json-包不能导出私有变量的-tag><h1 id=reflect反射包如何获取字段-tag为什么-json-包不能导出私有变量的-tag><span class=hanchor arialabel=Anchor># </span>reflect（反射包）如何获取字段 tag？为什么 json 包不能导出私有变量的 tag？</h1></a><p><a href="https://mp.weixin.qq.com/s?__biz=MzkxNTU5MjE0MQ==&mid=2247492754&idx=1&sn=9fb4360da097c81fe733ba48d3aca8a7&source=41#wechat_redirect" rel=noopener>https://mp.weixin.qq.com/s?__biz=MzkxNTU5MjE0MQ==&mid=2247492754&idx=1&sn=9fb4360da097c81fe733ba48d3aca8a7&source=41#wechat_redirect</a></p><a href=#昨天那个在-for-循环里-append-元素的同事今天还在么><h1 id=昨天那个在-for-循环里-append-元素的同事今天还在么><span class=hanchor arialabel=Anchor># </span>昨天那个在 for 循环里 append 元素的同事，今天还在么？</h1></a><p><a href="https://mp.weixin.qq.com/s?__biz=MzkxNTU5MjE0MQ==&mid=2247492759&idx=1&sn=d91070aef6e10d92a7a094d1e99f45ee&source=41#wechat_redirect" rel=noopener>https://mp.weixin.qq.com/s?__biz=MzkxNTU5MjE0MQ==&mid=2247492759&idx=1&sn=d91070aef6e10d92a7a094d1e99f45ee&source=41#wechat_redirect</a></p><a href=#golang-语言的自增自减操作><h1 id=golang-语言的自增自减操作><span class=hanchor arialabel=Anchor># </span>Golang 语言的自增，自减操作</h1></a><p>Golang 语言没++i、–i，只有 i++、i–-。</p><a href=#printfsprintffprintf函数的区别用法是什么><h1 id=printfsprintffprintf函数的区别用法是什么><span class=hanchor arialabel=Anchor># </span>Printf()、Sprintf()、Fprintf()函数的区别用法是什么</h1></a><p>都是把格式好的字符串输出，只是输出的目标不一样。</p><ul><li>Printf()，是把格式字符串输出到标准输出（一般是屏幕，可以重定向）。Printf() 是和标准输出文件 (stdout) 关联的，Fprintf 则没有这个限制。</li><li>Sprintf()，是把格式字符串输出到指定字符串中，所以参数比 printf 多一个 char*。那就是目标字符串地址。</li><li>Fprintf()，是把格式字符串输出到指定文件设备中，所以参数比 printf 多一个文件指针 FILE*。主要用于文件操作。Fprintf() 是格式化输出到一个 stream，通常是到文件。</li></ul><a href=#go-语言中-cap-函数可以作用于哪些内容><h1 id=go-语言中-cap-函数可以作用于哪些内容><span class=hanchor arialabel=Anchor># </span>Go 语言中 cap 函数可以作用于哪些内容？</h1></a><ul><li><p>array 返回数组的元素个数；</p></li><li><p>slice 返回 slice 的最⼤容量；</p></li><li><p>channel 返回 channel 的容量；</p></li></ul><a href=#golang-语言的引用类型有什么><h1 id=golang-语言的引用类型有什么><span class=hanchor arialabel=Anchor># </span>Golang 语言的引用类型有什么?</h1></a><p>Go语言中的引用类型有</p><ul><li><p>func（函数类型）</p></li><li><p>interface（接口类型）</p></li><li><p>slice（切片类型）</p></li><li><p>map（字典类型）</p></li><li><p>channel（管道类型）</p></li><li><p>指针类型</p></li></ul><a href=#通过指针变量-p访问其成员变量-name有哪几种方式><h1 id=通过指针变量-p访问其成员变量-name有哪几种方式><span class=hanchor arialabel=Anchor># </span>通过指针变量  <strong>p</strong> 访问其成员变量 name，有哪几种方式？</h1></a><p>A. p.name</p><p>B. (&p).name</p><p>C. (*p).name</p><p>D. p->name</p><p><strong>答案：A、C</strong></p><a href=#for-select-时如果通道已经关闭会怎么样如果只有个-case-呢><h1 id=for-select-时如果通道已经关闭会怎么样如果只有个-case-呢><span class=hanchor arialabel=Anchor># </span>for select 时，如果通道已经关闭会怎么样？如果只有⼀个 case 呢？</h1></a><p><a href="https://mp.weixin.qq.com/s?__biz=MzkxNTU5MjE0MQ==&mid=2247492758&idx=1&sn=fb81bf91986b7c42f1ac2b8fb75f74a6&source=41#wechat_redirect" rel=noopener>https://mp.weixin.qq.com/s?__biz=MzkxNTU5MjE0MQ==&mid=2247492758&idx=1&sn=fb81bf91986b7c42f1ac2b8fb75f74a6&source=41#wechat_redirect</a></p><a href=#golang-的-bool-类型的赋值><h1 id=golang-的-bool-类型的赋值><span class=hanchor arialabel=Anchor># </span>Golang 的 bool 类型的赋值</h1></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>A. b = true  
</span></span><span class=line><span class=cl>B. b = 1  
</span></span><span class=line><span class=cl>C. b = bool(1)  
</span></span><span class=line><span class=cl>D. b = (1 == 2)  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>赋值正确的是A,D。   
</span></span><span class=line><span class=cl>首先B选项，int类型不能由bool类型来表示。  
</span></span><span class=line><span class=cl>其次C选项，bool()不能转化int类型。int和float可以相互转化
</span></span></code></pre></td></tr></table></div></div><a href=#go-关键字-fallthrough-有什么作用><h1 id=go-关键字-fallthrough-有什么作用><span class=hanchor arialabel=Anchor># </span>Go 关键字 fallthrough 有什么作用</h1></a><p>fallthrough关键字只能用在switch中。且只能在每个case分支中最后一行出现，<strong>作用是如果这个case分支被执行，将会继续执行下一个case分支，而且不会去判断下一个分支的case条件是否成立。</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>	<span class=k>switch</span> <span class=s>&#34;a&#34;</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=s>&#34;a&#34;</span><span class=p>:</span>  
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;匹配a&#34;</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>		<span class=k>fallthrough</span>  
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=s>&#34;b&#34;</span><span class=p>:</span>  
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;a成功了，也执行b分支&#34;</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=s>&#34;c&#34;</span><span class=p>:</span>  
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;a成功了，c分支会执行吗？&#34;</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>	<span class=k>default</span><span class=p>:</span>  
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;默认执行&#34;</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>	<span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=cm>/*  
</span></span></span><span class=line><span class=cl><span class=cm>	匹配a  
</span></span></span><span class=line><span class=cl><span class=cm>    a成功了，也执行b分支  
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></td></tr></table></div></div><a href=#空结构体占不占内存空间-为什么使用空结构体><h1 id=空结构体占不占内存空间-为什么使用空结构体><span class=hanchor arialabel=Anchor># </span>空结构体占不占内存空间？ 为什么使用空结构体？</h1></a><p>空结构体是没有内存大小的结构体。<br>通过 unsafe.Sizeof() 可以查看空结构体的宽度，代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>var s struct{}
</span></span><span class=line><span class=cl>fmt.Println(unsafe.Sizeof(s)) // prints 0
</span></span></code></pre></td></tr></table></div></div><p>准确的来说，空结构体有一个特殊起点： <code>zerobase</code> 变量。<code>zerobase</code>是一个占用 8 个字节的<code>uintptr</code>全局变量。每次定义 <code>struct {}</code> 类型的变量，编译器只是把<code>zerobase</code>变量的地址给出去。也就是说空结构体的变量的内存地址都是一样的。<br>空结构体的使用场景主要有三种：</p><ul><li>实现方法接收者：在业务场景下，我们需要将方法组合起来，代表其是一个 ”分组“ 的，便于后续拓展和维护。</li><li>实现集合类型：在 Go 语言的标准库中并没有提供集合（Set）的相关实现，因此一般在代码中我们图方便，会直接用 map 来替代：<code>type Set map[string]struct{}</code>。</li><li>实现空通道：在 Go channel 的使用场景中，常常会遇到通知型 channel，其不需要发送任何数据，只是用于协调 Goroutine 的运行，用于流转各类状态或是控制并发情况。</li></ul><h1 id=httpsyouandgentlenesscn20230921golange585abe882a1e69687e6b187e680bbgo-e79a84e99da2e59091e5afb9e8b1a1e789b9e680a7-go-的面向对象特性go-的面向对象特性><a href=https://youandgentleness.cn/2023/09/21/Golang%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/#Go-%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7 rel=noopener></a>Go 的面向对象特性</h1><p><strong>接口</strong></p><p>接口使用 interface 关键字声明，任何实现接口定义方法的类都可以实例化该接口，接口和实现类之间没有任何依赖，你可以实现一个新的类当做 Sayer 来使用，而不需要依赖 Sayer 接口，也可以为已有的类创建一个新的接口，而不需要修改任何已有的代码，和其他静态语言相比，这可以算是 golang 的特色了吧</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type Sayer interface {
</span></span><span class=line><span class=cl> Say(message string)
</span></span><span class=line><span class=cl> SayHi()
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><strong>继承</strong></p><p>继承使用组合的方式实现</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type Animal struct {
</span></span><span class=line><span class=cl> Name string
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func (a *Animal) Say(message string) {
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;Animal[%v] say: %v
</span></span><span class=line><span class=cl>&#34;, a.Name, message)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>type Dog struct {
</span></span><span class=line><span class=cl> Animal
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Dog 将继承 Animal 的 Say 方法，以及其成员 Name</p><p><strong>覆盖</strong></p><p>子类可以重新实现父类的方法</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// override Animal.Say
</span></span><span class=line><span class=cl>func (d *Dog) Say(message string) {
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;Dog[%v] say: %v
</span></span><span class=line><span class=cl>&#34;, d.Name, message)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Dog.Say 将覆盖 Animal.Say</p><p><strong>多态</strong></p><p>接口可以用任何实现该接口的指针来实例化</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>var sayer Sayer
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>sayer = &amp;Dog{Animal{Name: &#34;Yoda&#34;}}
</span></span><span class=line><span class=cl>sayer.Say(&#34;hello world&#34;)
</span></span></code></pre></td></tr></table></div></div><p>但是不支持父类指针指向子类，下面这种写法是不允许的</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>var animal *Animal
</span></span><span class=line><span class=cl>animal = &amp;Dog{Animal{Name: &#34;Yoda&#34;}}
</span></span></code></pre></td></tr></table></div></div><p>同样子类继承的父类的方法引用的父类的其他方法也没有多态特性</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (a *Animal) Say(message string) {
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;Animal[%v] say: %v
</span></span><span class=line><span class=cl>&#34;, a.Name, message)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func (a *Animal) SayHi() {
</span></span><span class=line><span class=cl>    a.Say(&#34;Hi&#34;)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func (d *Dog) Say(message string) {
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;Dog[%v] say: %v
</span></span><span class=line><span class=cl>&#34;, d.Name, message)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func main() {
</span></span><span class=line><span class=cl> var sayer Sayer
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    sayer = &amp;Dog{Animal{Name: &#34;Yoda&#34;}}
</span></span><span class=line><span class=cl>    sayer.Say(&#34;hello world&#34;) // Dog[Yoda] say: hello world
</span></span><span class=line><span class=cl>    sayer.SayHi() // Animal[Yoda] say: Hi
</span></span></code></pre></td></tr></table></div></div><p>上面这段代码中，子类 Dog 没有实现 SayHi 方法，调用的是从父类 Animal.SayHi，而 Animal.SayHi 调用的是 Animal.Say 而不是Dog.Say，这一点和其他面向对象语言有所区别，需要特别注意，但是可以用下面的方式来实现类似的功能，以提高代码的复用性</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func SayHi(s Sayer) {
</span></span><span class=line><span class=cl>    s.Say(&#34;Hi&#34;)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>type Cat struct {
</span></span><span class=line><span class=cl> Animal
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func (c *Cat) Say(message string) {
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;Cat[%v] say: %v
</span></span><span class=line><span class=cl>&#34;, c.Name, message)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func (c *Cat) SayHi() {
</span></span><span class=line><span class=cl> SayHi(c)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func main() {
</span></span><span class=line><span class=cl> var sayer Sayer
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    sayer = &amp;Cat{Animal{Name: &#34;Jerry&#34;}}
</span></span><span class=line><span class=cl>    sayer.Say(&#34;hello world&#34;) // Cat[Jerry] say: hello world
</span></span><span class=line><span class=cl>    sayer.SayHi() // Cat[Jerry] say: Hi
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#go-语言中-下面哪个关于指针的说法是错误的><h1 id=go-语言中-下面哪个关于指针的说法是错误的><span class=hanchor arialabel=Anchor># </span>Go 语言中 ,下面哪个关于指针的说法是错误的?</h1></a><ul><li>指针不能进行算术运算</li><li>指针可以比较</li><li>指针可以是nil</li><li>指针可以指向任何类型</li></ul><p>针在Go语言中只能指向相同类型的结构体或者基本类型。例如，一个int类型的变量，只能指向int类型的指针。如果尝试将一个不同类型的指针赋给一个变量，将会导致编译错误。</p><a href=#go-语言的接口类型是如何实现的><h1 id=go-语言的接口类型是如何实现的><span class=hanchor arialabel=Anchor># </span>Go 语言的接口类型是如何实现的？</h1></a><p>在Go语言中，接口类型是通过类型嵌入（embedding的方式实现的。每个实现了接口的类型的结构体中都有一个隐含的成员，该成员是指向接口类型的指针。通过这种方式，接口实现了对类型的约束和定义。</p><p>具体来说，当一个类型实现了某个接口的所有方法后，该类型就被认为是实现了该接口。在结构体中，可以通过嵌入接口类型的方式来实现接口方法。在实现接口方法时，方法的签名需要与接口定义中的方法签名保持一致。</p><a href=#关于-switch-语句下说法正确的有><h1 id=关于-switch-语句下说法正确的有><span class=hanchor arialabel=Anchor># </span>关于 switch 语句，下⾯说法正确的有?</h1></a><p>A. 条件表达式必须为常量或者整数；</p><p>B. 单个case中，可以出现多个结果选项；</p><p>C. 需要⽤break来明确退出⼀个case；</p><p>D. 只有在case中明确添加fallthrough关键字，才会继续执⾏紧跟的下⼀个case；</p><p><strong>答案B、D</strong></p><a href=#go-编程语言中-switch-语句的语法><h1 id=go-编程语言中-switch-语句的语法><span class=hanchor arialabel=Anchor># </span>Go 编程语言中 switch 语句的语法</h1></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>switch var1 {
</span></span><span class=line><span class=cl>    case val1:
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>    case val2:
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>    default:
</span></span><span class=line><span class=cl>        .
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>switch{
</span></span><span class=line><span class=cl>    case 1,2,3,4:
</span></span><span class=line><span class=cl>    default:
</span></span><span class=line><span class=cl>} //case可以有多个数据
</span></span></code></pre></td></tr></table></div></div><p>变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。</p><a href=#copy-是操作符还是内置函数><h1 id=copy-是操作符还是内置函数><span class=hanchor arialabel=Anchor># </span>copy 是操作符还是内置函数</h1></a><p>Golang中copy是内置函数。</p><a href=#go-两个接口之间可以存在什么关系><h1 id=go-两个接口之间可以存在什么关系><span class=hanchor arialabel=Anchor># </span>Go 两个接口之间可以存在什么关系？</h1></a><p>如果两个接口有相同的方法列表，那么他们就是等价的，可以相互赋值。如果接口 A的方法列表是接口B的方法列表的自己，那么接口B可以赋值给接口A。接口查询是否成功，要在运行期才能够确定。</p><a href=#如何在运行时检查变量类型><h1 id=如何在运行时检查变量类型><span class=hanchor arialabel=Anchor># </span>如何在运行时检查变量类型？</h1></a><p>类型开关是在运行时检查变量类型的最佳方式。类型开关按类型而不是值来评估变量。每个 Switch ⾄少包含⼀个case，⽤作条件语句，和⼀个 default，如果没有⼀个 case 为真，则执行。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func classifier(items ...interface{}) {
</span></span><span class=line><span class=cl>    for i, x := range items {
</span></span><span class=line><span class=cl>        switch x.(type) {
</span></span><span class=line><span class=cl>        case bool:
</span></span><span class=line><span class=cl>            fmt.Printf(&#34;Param #%d is a bool\n&#34;, i)
</span></span><span class=line><span class=cl>        case float64:
</span></span><span class=line><span class=cl>            fmt.Printf(&#34;Param #%d is a float64\n&#34;, i)
</span></span><span class=line><span class=cl>        case int, int64:
</span></span><span class=line><span class=cl>            fmt.Printf(&#34;Param #%d is a int\n&#34;, i)
</span></span><span class=line><span class=cl>        case nil:
</span></span><span class=line><span class=cl>            fmt.Printf(&#34;Param #%d is a nil\n&#34;, i)
</span></span><span class=line><span class=cl>        case string:
</span></span><span class=line><span class=cl>            fmt.Printf(&#34;Param #%d is a string\n&#34;, i)
</span></span><span class=line><span class=cl>        default:
</span></span><span class=line><span class=cl>            fmt.Printf(&#34;Param #%d is unknown\n&#34;, i)
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#golang-的返回值命名><h1 id=golang-的返回值命名><span class=hanchor arialabel=Anchor># </span>Golang 的返回值命名</h1></a><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statisticimage-20230724165455977.png width=auto alt=image-20230724165455977></p><a href=#golang-的-iota-如何使用><h1 id=golang-的-iota-如何使用><span class=hanchor arialabel=Anchor># </span>Golang 的 iota 如何使用？</h1></a><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statisticimage-20230724165708801.png width=auto alt=image-20230724165708801></p><ol><li>iota在const关键字出现时被重置为0</li><li>const声明块中每新增一行iota值自增1</li><li>第一个常量必须指定一个表达式，后续的常量如果没有表达式，则继承上面的表达式</li></ol><a href=#数组之间如何进行比较><h1 id=数组之间如何进行比较><span class=hanchor arialabel=Anchor># </span>数组之间如何进行比较？</h1></a><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statisticimage-20230724170030544.png width=auto alt=image-20230724170030544></p><a href=#for-range-的注意点和坑><h1 id=for-range-的注意点和坑><span class=hanchor arialabel=Anchor># </span>for range 的注意点和坑</h1></a><p><strong>第一个说法</strong></p><p>1.迭代变量。Python中for in 可以直接的到value，但Go的for range 迭代变量有两个，第一个是元素在迭代集合中的序号值key（从0开始），第二个值才是元素值value。</p><p>2.针对字符串。在Go中对字符串运用for range操作，每次返回的是一个码点，而不是一个字节。Go编译器不会为[]byte进行额外的内存分配，而是直接使用string的底层数据。</p><p>3.对map类型内元素的迭代顺序是随机的。要想有序迭代map内的元素，我们需要额外的数据结构支持，比如使用一个切片来有序保存map内元素的key值。</p><p>4.针对切片类型复制之后，如果原切片扩容增加新元素。迭代复制后的切片并不会输出扩容新增元素。这是因为range表达式中的切片实际上是原切片的副本。</p><p>5.迭代变量是重用的。类似PHP语言中的i=0；如果其他循环中使用相同的迭代变量，需要重新初始化i。</p><p>6.for range使用时，k,v值已经赋值好了，不会因为for循环的改变而改变</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>x</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;a&#34;</span><span class=p>,</span> <span class=s>&#34;b&#34;</span><span class=p>,</span> <span class=s>&#34;c&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>x</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>//输出 0 1 2
</span></span></span></code></pre></td></tr></table></div></div><p><strong>第二个说法</strong></p><p>应该是一个for循环中作用域的问题</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>src := []int{1, 2, 3, 4, 5}
</span></span><span class=line><span class=cl>var dst2 []*inv
</span></span><span class=line><span class=cl>for _, v := range src {
</span></span><span class=line><span class=cl>    dst2 = append(dst2, &amp;v)
</span></span><span class=line><span class=cl>    // fmt.println(&amp;v)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>for _, p := range dst2 {
</span></span><span class=line><span class=cl>    fmt.Print(*p)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>// 输出
</span></span><span class=line><span class=cl>// 5555
</span></span></code></pre></td></tr></table></div></div><p>为什么呢, 因为 for-range 中 循环变量的作用域的规则限制<br>假如取消append()后一行的注释，可以发现循环中v的变量内存地址是一样的，也可以解释为for range相当于</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>var i int
</span></span><span class=line><span class=cl>for j := 0; j &lt; len(src); j++ {
</span></span><span class=line><span class=cl>    i = src[j]
</span></span><span class=line><span class=cl>    dst2 = append(dst2, &amp;i)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>而不是我们想象中的</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>for j := 0; j &lt; len(src); j++ {
</span></span><span class=line><span class=cl>    dst2 = append(dst2, &amp;src[j])
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>如果要在for range中实现，我们可以改写为</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>src := []int{1, 2, 3, 4, 5}
</span></span><span class=line><span class=cl>var dst2 []*int
</span></span><span class=line><span class=cl>for _, v := range src {
</span></span><span class=line><span class=cl>    new_v := v
</span></span><span class=line><span class=cl>    dst2 = append(dst2, &amp;new_v)
</span></span><span class=line><span class=cl>    // fmt.println(&amp;new_v)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>for _, p := range dst2 {
</span></span><span class=line><span class=cl>    fmt.Print(*p)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#golang-的断言><h1 id=golang-的断言><span class=hanchor arialabel=Anchor># </span>Golang 的断言</h1></a><p>Go中的所有程序都实现了<code>interface{}</code>的接口，这意味着，所有的类型如<code>string</code>,<code>int</code>,<code>int64</code>甚至是自定义的<code>struct</code>类型都就此拥有了<code>interface{}</code>的接口.那么在一个数据通过<code>func funcName(interface{})</code>的方式传进来的时候，也就意味着这个参数被自动的转为interface{}的类型。</p><p>如以下的代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func funcName(a interface{}) string {     return string(a)}
</span></span></code></pre></td></tr></table></div></div><p>编译器将会返回：<code>cannot convert a (type interface{}) to type string: need type assertion</code></p><p>此时，意味着整个转化的过程需要类型断言。类型断言有以下几种形式：</p><p>直接断言使用</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>var a interface{}fmt.Println(&#34;Where are you,Jonny?&#34;, a.(string))
</span></span></code></pre></td></tr></table></div></div><p>但是如果断言失败一般会导致panic的发生。所以为了防止panic的发生，我们需要在断言前进行一定的判断</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>value, ok := a.(string)
</span></span></code></pre></td></tr></table></div></div><p>如果断言失败，那么ok的值将会是false,但是如果断言成功ok的值将会是true,同时value将会得到所期待的正确的值。示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>value, ok := a.(string)
</span></span><span class=line><span class=cl>if !ok {
</span></span><span class=line><span class=cl>    fmt.Println(&#34;It&#39;s not ok for type string&#34;)
</span></span><span class=line><span class=cl>    return
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>fmt.Println(&#34;The value is &#34;, value)
</span></span></code></pre></td></tr></table></div></div><p>另外也可以配合switch语句进行判断：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>var t interface{}
</span></span><span class=line><span class=cl>t = functionOfSomeType()
</span></span><span class=line><span class=cl>switch t := t.(type) {
</span></span><span class=line><span class=cl>default:
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;unexpected type %T&#34;, t)       // %T prints whatever type t has    break
</span></span><span class=line><span class=cl>case bool:
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;boolean %t\n&#34;, t)             // t has type bool    break
</span></span><span class=line><span class=cl>case int:
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;integer %d\n&#34;, t)             // t has type int    break
</span></span><span class=line><span class=cl>case *bool:
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;pointer to boolean %t\n&#34;, *t) // t has type *bool    break
</span></span><span class=line><span class=cl>case *int:
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;pointer to integer %d\n&#34;, *t) // t has type *int    break
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#精通-golang-项目依赖-go-modules><h1 id=精通-golang-项目依赖-go-modules><span class=hanchor arialabel=Anchor># </span>精通 Golang 项目依赖 Go modules</h1></a><p><a href=https://www.topgoer.cn/docs/golangxiuyang/golangxiuyang-1cmee13oek1e8 rel=noopener>https://www.topgoer.cn/docs/golangxiuyang/golangxiuyang-1cmee13oek1e8</a></p><a href=#go-string-的底层实现><h1 id=go-string-的底层实现><span class=hanchor arialabel=Anchor># </span>Go string 的底层实现</h1></a><p>源码包src/runTime/string.go.stringStruct定义了string的数据结构</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Type stringStruct struct{
</span></span><span class=line><span class=cl>	str unsafe.Pointer // 字符串的首地址
</span></span><span class=line><span class=cl> 	len int // 字符串的长度
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>声明：</p><p>如下代码所示，可以声明一个string变量赋予初值</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>var str string
</span></span><span class=line><span class=cl>str = &#34;Hello world&#34;
</span></span></code></pre></td></tr></table></div></div><p>字符串构建过程是根据字符串构建stringStruct，再转化成string。转换的源码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func gostringnocopy(str *byte) string{       //根据字符串地址构建string
</span></span><span class=line><span class=cl>       ss := stringStruct{str:unsafe.Pointer(str),len:findnull(str)}  // 先构造 stringStruct
</span></span><span class=line><span class=cl>       s := *(*string)(unsafe.Pointer(&amp;ss))   //再将stringStruct 转换成string
</span></span><span class=line><span class=cl>       return s
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#go-语言的-panic-如何恢复><h1 id=go-语言的-panic-如何恢复><span class=hanchor arialabel=Anchor># </span>Go 语言的 panic 如何恢复</h1></a><p>recover 可以中止 panic 造成的程序崩溃，或者说平息运行时恐慌，recover 函数不需要任何参数，并且会返回一个空接口类型的值。需要注意的是 recover 只能在 defer 中发挥作用，在其他作用域中调用不会发挥作用。编译器会将 recover 转换成 runtime.gorecover，该函数的实现逻辑是如果当前 goroutine 没有调用 panic，那么该函数会直接返回 nil，当前 goroutine 调用 panic 后，会先调用 runtime.gopaic 函数 runtime.gopaic 会从 runtime. _defer 结构体中取出程序计数器 pc 和栈指针 sp，再调用 runtime.recovery 函数来恢复程序，runtime.recovery 会根据传入的 pc 和 sp 跳转回 runtime.deferproc，编译器自动生成的代码会发现 runtime.deferproc 的返回值不为 0，这时会调回 runtime.deferreturn 并恢复到正常的执行流程。总的来说恢复流程就是通过程序计数器来回跳转。</p><a href=#go-如何避免-panic><h1 id=go-如何避免-panic><span class=hanchor arialabel=Anchor># </span>Go 如何避免 panic</h1></a><p>首先明确panic定义：go把真正的异常叫做 panic，是指出现重大错误，比如数组越界之类的编程BUG或者是那些需要人工介入才能修复的问题，比如程序启动时加载资源出错等等。<br>几个容易出现panic的点:</p><ul><li>函数返回值或参数为指针类型，nil, 未初始化结构体，此时调用容易出现panic，可加 != nil 进行判断</li><li>数组切片越界</li><li>如果我们关闭未初始化的通道，重复关闭通道，向已经关闭的通道中发送数据，这三种情况也会引发 panic，导致程序崩溃</li><li>如果我们直接操作未初始化的映射（map），也会引发 panic，导致程序崩溃</li><li>另外，操作映射可能会遇到的更为严重的一个问题是，同时对同一个映射并发读写，它会触发 runtime.throw，不像 panic 可以使用 recover 捕获。所以，我们在对同一个映射并发读写时，一定要使用锁。</li><li>如果类型断言使用不当，比如我们不接收布尔值的话，类型断言失败也会引发 panic，导致程序崩溃。</li><li>如果很多时候不可避免地出现了panic, 记得使用 defer/recover</li></ul><a href=#空结构体的使用场景><h1 id=空结构体的使用场景><span class=hanchor arialabel=Anchor># </span>空结构体的使用场景</h1></a><p>空结构体（empty struct）是在 Go 语言中一个特殊的概念，它没有任何字段。在 Go 中，它通常被称为匿名结构体或零宽度结构体。尽管它没有字段，但它在某些情况下仍然有其用途，以下是一些常见的空结构体的使用场景：</p><ol><li><strong>占位符</strong>：空结构体可以用作占位符，用于表示某个数据结构或数据集合的存在而不实际存储任何数据。这在某些数据结构的实现中非常有用，特别是在要实现某种数据结构的集合或映射时，但并不需要存储实际的值。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>goCopy code// 表示集合中是否包含某个元素的映射
</span></span><span class=line><span class=cl>set := make(map[string]struct{})
</span></span><span class=line><span class=cl>set[&#34;apple&#34;] = struct{}{}
</span></span></code></pre></td></tr></table></div></div><ol start=2><li><strong>信号量</strong>：空结构体可以用作信号量，用于控制并发操作。通过向通道发送或接收空结构体，可以实现信号的传递和同步。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>goCopy code// 用通道作为信号量
</span></span><span class=line><span class=cl>semaphore := make(chan struct{}, 5) // 控制并发数为5
</span></span><span class=line><span class=cl>go func() {
</span></span><span class=line><span class=cl>    semaphore &lt;- struct{}{} // 获取信号量
</span></span><span class=line><span class=cl>    defer func() { &lt;-semaphore }() // 释放信号量
</span></span><span class=line><span class=cl>    // 执行并发操作
</span></span><span class=line><span class=cl>}()
</span></span></code></pre></td></tr></table></div></div><ol><li><strong>强调结构</strong>：有时，空结构体可用于强调某个结构的重要性或存在。它可以用作结构体的标签，表示关注该结构的存在而不是其内容。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>goCopy code// 表示一篇文章的元信息，不包含实际内容
</span></span><span class=line><span class=cl>type Article struct {
</span></span><span class=line><span class=cl>    Title       string
</span></span><span class=line><span class=cl>    Author      string
</span></span><span class=line><span class=cl>    PublishedAt time.Time
</span></span><span class=line><span class=cl>    Metadata    struct{} // 空结构体强调元信息的存在
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><ol><li><strong>JSON 序列化</strong>：在处理 JSON 数据时，有时需要表示一个空对象。可以使用空结构体来表示 JSON 中的空对象（<code>{}</code>）。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>goCopy code// 表示一个空的JSON对象
</span></span><span class=line><span class=cl>emptyJSON := struct{}{}
</span></span><span class=line><span class=cl>jsonBytes, _ := json.Marshal(emptyJSON)
</span></span><span class=line><span class=cl>fmt.Println(string(jsonBytes)) // 输出: {}
</span></span></code></pre></td></tr></table></div></div><p>尽管空结构体没有字段，但它在上述情况下提供了一种轻量级的方式来实现特定的需求，而无需分配额外的内存或定义具体的数据结构。这使得它成为 Go 中的一种有用工具，可以在编写清晰、高效和易于理解的代码时派上用场。</p><p><strong>struct的特点</strong></p><ul><li>用来自定义复杂数据结构</li><li>struct里面可以包含多个字段（属性）</li><li>struct类型可以定义方法，注意和函数的区分</li><li>struct类型是值类型</li><li>struct类型可以嵌套</li><li>GO语言没有class类型，只有struct类型</li></ul><p><strong>特殊之处</strong></p><ul><li>结构体是用户单独定义的类型，不能和其他类型进行强制转换</li><li>golang中的struct没有构造函数，一般可以使用工厂模式来解决这个问题</li><li>我们可以为struct中的每个字段，写上一个tag。这个tag可以通过反射的机制获取到，最常用的场景就是json序列化和反序列化。</li><li>结构体中字段可以没有名字，即匿名字段</li></ul><a href=#defer-的几个坑><h1 id=defer-的几个坑><span class=hanchor arialabel=Anchor># </span>defer 的几个坑</h1></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func main() {
</span></span><span class=line><span class=cl>    fmt.Println(test())
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func test() error {
</span></span><span class=line><span class=cl>    var err error
</span></span><span class=line><span class=cl>    defer func() {
</span></span><span class=line><span class=cl>       if r := recover(); r != nil {
</span></span><span class=line><span class=cl>          err = errors.New(fmt.Sprintf(&#34;%s&#34;, r))
</span></span><span class=line><span class=cl>       }
</span></span><span class=line><span class=cl>    }()
</span></span><span class=line><span class=cl>    raisePanic()
</span></span><span class=line><span class=cl>    return err
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func raisePanic() {
</span></span><span class=line><span class=cl>    panic(&#34;发生了错误&#34;)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>为什么输出****?</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>       <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nb>recover</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span><span class=p>{</span>
</span></span><span class=line><span class=cl>           <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=p>}</span><span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>           <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;fatal&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=s>&#34;defer panic&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>panic</span><span class=p>(</span><span class=s>&#34;panic&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>结果</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>defer panic
</span></span></code></pre></td></tr></table></div></div><p><strong>分析</strong></p><p><strong>panic仅有最后一个可以被revover捕获</strong>。</p><p>触发<code>panic("panic")</code>后defer顺序出栈执行，第一个被执行的defer中 会有<code>panic("defer panic")</code>异常语句，这个异常将会覆盖掉main中的异常<code>panic("panic")</code>，最后这个异常被第二个执行的defer捕获到。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>function</span><span class=p>(</span><span class=nx>index</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>value</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>index</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nf>function</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nf>function</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nf>function</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=nf>function</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这里，有4个函数，他们的index序号分别为1，2，3，4。</p><p>那么这4个函数的先后执行顺序是什么呢？这里面有两个defer， 所以defer一共会压栈两次，先进栈1，后进栈2。 那么在压栈function1的时候，需要连同函数地址、函数形参一同进栈，那么为了得到function1的第二个参数的结果，所以就需要先执行function3将第二个参数算出，那么function3就被第一个执行。同理压栈function2，就需要执行function4算出function2第二个参数的值。然后函数结束，先出栈fuction2、再出栈function1.</p><p>所以顺序如下：</p><ul><li>defer压栈function1，压栈函数地址、形参1、形参2(调用function3) –> 打印3</li><li>defer压栈function2，压栈函数地址、形参1、形参2(调用function4) –> 打印4</li><li>defer出栈function2, 调用function2 –> 打印2</li><li>defer 出栈 function1, 调用 function1–> 打印1</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>3
</span></span><span class=line><span class=cl>4
</span></span><span class=line><span class=cl>2
</span></span></code></pre></td></tr></table></div></div><a href=#使用过哪些-golang-的-string-类库><h1 id=使用过哪些-golang-的-string-类库><span class=hanchor arialabel=Anchor># </span>使用过哪些 Golang 的 String 类库</h1></a><p><strong>string.builder</strong></p><p><code>Go</code> 语言提供了一个专门操作字符串的库 <code>strings</code>，可以用于字符串查找、替换、比较等。</p><p>使用 <code>strings.Builder</code> 可以进行字符串拼接，提供了 <code>writeString</code> 方法拼接字符串，使用方式如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>var builder strings.Builder
</span></span><span class=line><span class=cl>builder.WriteString(&#34;asong&#34;)
</span></span><span class=line><span class=cl>builder.String()
</span></span></code></pre></td></tr></table></div></div><p><code>strings.builder</code> 的实现原理很简单，结构如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type Builder struct {
</span></span><span class=line><span class=cl>    addr *Builder // of receiver, to detect copies by value
</span></span><span class=line><span class=cl>    buf  []byte // 1
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><code>addr</code> 字段主要是做 <code>copycheck</code>，<code>buf</code> 字段是一个 <code>byte</code> 类型的切片，这个就是用来存放字符串内容的，提供的 <code>writeString()</code> 方法就是向切片 <code>buf</code> 中追加数据：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (b *Builder) WriteString(s string) (int, error) {
</span></span><span class=line><span class=cl> b.copyCheck()
</span></span><span class=line><span class=cl> b.buf = append(b.buf, s...)
</span></span><span class=line><span class=cl> return len(s), nil
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>提供的 <code>String</code> 方法就是将 <code>[]byte</code> 转换为 <code>string</code> 类型，这里为了避免内存拷贝的问题，使用了强制转换来避免内存拷贝：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (b *Builder) String() string {
</span></span><span class=line><span class=cl> return *(*string)(unsafe.Pointer(&amp;b.buf))
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><strong>bytes.Buffer</strong></p><p>因为 <code>string</code> 类型底层就是一个 <code>byte</code> 数组，所以我们就可以 <code>Go</code> 语言的 <code>bytes.Buffer</code> 进行字符串拼接。<code>bytes.Buffer</code> 是一个一个缓冲 <code>byte</code> 类型的缓冲器，这个缓冲器里存放着都是 <code>byte</code>。使用方式如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>buf := new(bytes.Buffer)
</span></span><span class=line><span class=cl>buf.WriteString(&#34;asong&#34;)
</span></span><span class=line><span class=cl>buf.String()
</span></span></code></pre></td></tr></table></div></div><p><code>bytes.buffer</code> 底层也是一个 <code>[]byte</code> 切片，结构体如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type Buffer struct {
</span></span><span class=line><span class=cl> buf      []byte // contents are the bytes buf[off : len(buf)]
</span></span><span class=line><span class=cl> off      int    // read at &amp;buf[off], write at &amp;buf[len(buf)]
</span></span><span class=line><span class=cl> lastRead readOp // last read operation, so that Unread* can work correctly.
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>因为 <code>bytes.Buffer</code> 可以持续向 <code>Buffer</code> 尾部写入数据，从 <code>Buffer</code> 头部读取数据，所以 <code>off</code> 字段用来记录读取位置，再利用切片的 <code>cap</code> 特性来知道写入位置，这个不是本次的重点，重点看一下 <code>WriteString</code> 方法是如何拼接字符串的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (b *Buffer) WriteString(s string) (n int, err error) {
</span></span><span class=line><span class=cl> b.lastRead = opInvalid
</span></span><span class=line><span class=cl> m, ok := b.tryGrowByReslice(len(s))
</span></span><span class=line><span class=cl> if !ok {
</span></span><span class=line><span class=cl>  m = b.grow(len(s))
</span></span><span class=line><span class=cl> }
</span></span><span class=line><span class=cl> return copy(b.buf[m:], s), nil
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>切片在创建时并不会申请内存块，只有在往里写数据时才会申请，首次申请的大小即为写入数据的大小。如果写入的数据小于64字节，则按64字节申请。采用 <code>动态扩展slice</code> 的机制，字符串追加采用 <code>copy</code> 的方式将追加的部分拷贝到尾部，copy是内置的拷贝函数，可以减少内存分配。</p><p>但是在将 <code>[]byte</code> 转换为 <code>string</code> 类型依旧使用了标准类型，所以会发生内存分配：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (b *Buffer) String() string {
</span></span><span class=line><span class=cl> if b == nil {
</span></span><span class=line><span class=cl>  // Special case, useful in debugging.
</span></span><span class=line><span class=cl>  return &#34;&lt;nil&gt;&#34;
</span></span><span class=line><span class=cl> }
</span></span><span class=line><span class=cl> return string(b.buf[b.off:])
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#go-结构体内嵌后的命名冲突><h1 id=go-结构体内嵌后的命名冲突><span class=hanchor arialabel=Anchor># </span>Go 结构体内嵌后的命名冲突</h1></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>A</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>a</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>B</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>a</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>C</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>A</span>
</span></span><span class=line><span class=cl>	<span class=nx>B</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>C</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>A</span><span class=p>.</span><span class=nx>a</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 输出 &amp;{{1} {0}}
</span></span></span></code></pre></td></tr></table></div></div><p>第7行和第11行分别定义了两个拥有a int字段的结构体。
第15行的结构体嵌入了A和B的结构体。
第21行实例化C结构体。
第22行按常规的方法，访问嵌入结构体A中的a字段，并赋值1。
第23行可以正常输出实例化C结构体。
接着，将第22行修改为如下代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func main(){
</span></span><span class=line><span class=cl>	c:=&amp;C{}
</span></span><span class=line><span class=cl>    c.a=1
</span></span><span class=line><span class=cl>    fmt.Println(c)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statisticimg.png width=auto alt=img></p><p>此时再编译运行，编译器报错：</p><p>.main.go:22:3:ambiguousselectorc.a</p><p>编译器告知C的选择器a引起歧义，也就是说，编译器无法决定将1赋给C中的A还是B里的字段a。使用c.a引发二义性的问题一般应该由程序员逐级完整写出避免错误。</p><p>在使用内嵌结构体时，Go语言的编译器会非常智能地提醒我们可能发生的歧义和错误。</p><p><strong>解决：可以通过：c.A.a或者c.B.a 都可以正确得到对应的值</strong></p><a href=#go程序中的包是什么><h1 id=go程序中的包是什么><span class=hanchor arialabel=Anchor># </span><strong>Go</strong>程序中的包是什么？</h1></a><p>包(pkg)是 Go 工作区中包含 Go 源⽂件或其他包的目录。源文件中的每个函数、变量和类型都存储在链接包中。每个 Go 源文件都属于⼀个包，该包在文件顶部使⽤以下命令声明：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=p>&lt;</span><span class=nx>packagename</span><span class=p>&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>您可以使⽤以下⽅法导⼊和导出包以重⽤导出的函数或类型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>import &lt;packagename&gt;
</span></span></code></pre></td></tr></table></div></div><p>Golang 的标准包是 fmt，其中包含格式化和打印功能，如 Println().</p><a href=#go-实现不重启热部署><h1 id=go-实现不重启热部署><span class=hanchor arialabel=Anchor># </span>Go 实现不重启热部署</h1></a><p>根据系统的 SIGHUP 信号量，以此信号量触发进程重启，达到热更新的效果。</p><p>热部署我们需要考虑几个能力：</p><ul><li>新进程启动成功，老进程不会有资源残留</li><li>新进程初始化的过程中，服务不会中断</li><li>新进程初始化失败，老进程仍然继续工作</li><li>同一时间，只能有一个更新动作执行</li></ul><p>监听信号量的方法的环境是在 类 UNIX 系统中，在现在的 UNIX 内核中，允许多个进程同时监听一个端口。在收到 SIGHUP 信号量时，先 fork 出一个新的进程监听端口，同时等待旧进程处理完已经进来的连接，最后杀掉旧进程。</p><p>我基于这个思路，实现了一段示例代码，仓库地址：
<a href=https://github.com/guowei-gong/tablefilp-example%EF%BC%8C rel=noopener>https://github.com/guowei-gong/tablefilp-example，</a>  如果你希望动手来加深印象可以打开看看。</p><a href=#go-中的指针强转><h1 id=go-中的指针强转><span class=hanchor arialabel=Anchor># </span>Go 中的指针强转</h1></a><p>在 Golang 中无法使用指针类型对指针进行强制转换</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statisticimage-20220501142757244.png width=auto alt=image-20220501142757244></p><p>但可以借助 <code>unsafe</code> 包中的 <code>unsafe.Pointer</code> 转换</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statisticimage-20220501142724715.png width=auto alt=image-20220501142724715></p><p>在 <code>src/unsafe.go</code> 中可以看到指针类型说明</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// ArbitraryType 与 IntegerType 在此只用于文档描述，实际并不 unsafe 包中的一部分
</span></span><span class=line><span class=cl>// 表示任意 go 的表达式
</span></span><span class=line><span class=cl>type ArbitraryType int
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 表示任意 integer 类型
</span></span><span class=line><span class=cl>type IntegerType int
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>type Pointer *ArbitraryType
</span></span></code></pre></td></tr></table></div></div><p>对于指针类型 <code>Pointer</code> 强调以下四种操作</p><ul><li>指向任意类型的指针都可以被转化成 Pointer</li><li>Pointer 可以转化成指向任意类型的指针</li><li>uintptr 可以转化成 Pointer</li><li>Pointer 可以转化成 uintptr</li></ul><blockquote><p>uintptr 在 <code>src/builtin/builtin.go</code> 中定义</p></blockquote><p>其后描述了六种指针转换的情形</p><p>其一：*<em>Conversion of a <em>T1 to Pointer to *T2</em></em></p><p>转换条件：</p><ul><li>T2 的数据类型不大于 T1</li><li>T1、T2 的内存模型相同</li></ul><p>因此对于 <code>*int</code> 不能强制转换 <code>*float64</code> 可以变化为 <code>*int</code> -> <code>unsafe.Pointer</code> -> <code>*float64</code> 的过程</p><a href=#go-支持什么形式的类型转换将整数转换为浮点数><h1 id=go-支持什么形式的类型转换将整数转换为浮点数><span class=hanchor arialabel=Anchor># </span>Go 支持什么形式的类型转换？将整数转换为浮点数。</h1></a><p>Go 支持显式类型转换以满足其严格的类型要求。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>i := 55 //int
</span></span><span class=line><span class=cl>j := 67.8 //float64
</span></span><span class=line><span class=cl>sum := i + int(j)//j is converted to int
</span></span></code></pre></td></tr></table></div></div><a href=#golang-语言中的使用><h1 id=golang-语言中的使用><span class=hanchor arialabel=Anchor># </span>Golang 语言中==的使用</h1></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>x</span> <span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>y</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>x</span> <span class=o>==</span> <span class=nx>x</span> <span class=c1>//输出true
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>x</span> <span class=o>==</span> <span class=nx>y</span> <span class=c1>//interface{}比较的是动态类型和动态值，输出false
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>y</span> <span class=o>==</span> <span class=nx>y</span> <span class=c1>//panic,切片不可比较
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#make-函数底层实现><h1 id=make-函数底层实现><span class=hanchor arialabel=Anchor># </span>make 函数底层实现</h1></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func makeslice(et *_type, len, cap int) unsafe.Pointer {
</span></span><span class=line><span class=cl>	mem, overflow := math.MulUintptr(et.size, uintptr(cap))
</span></span><span class=line><span class=cl>	if overflow || mem &gt; maxAlloc || len &lt; 0 || len &gt; cap {
</span></span><span class=line><span class=cl>		// NOTE: Produce a &#39;len out of range&#39; error instead of a
</span></span><span class=line><span class=cl>		// &#39;cap out of range&#39; error when someone does make([]T, bignumber).
</span></span><span class=line><span class=cl>		// &#39;cap out of range&#39; is true too, but since the cap is only being
</span></span><span class=line><span class=cl>		// supplied implicitly, saying len is clearer.
</span></span><span class=line><span class=cl>		// See golang.org/issue/4085.
</span></span><span class=line><span class=cl>		mem, overflow := math.MulUintptr(et.size, uintptr(len))
</span></span><span class=line><span class=cl>		if overflow || mem &gt; maxAlloc || len &lt; 0 {
</span></span><span class=line><span class=cl>			panicmakeslicelen()
</span></span><span class=line><span class=cl>		}
</span></span><span class=line><span class=cl>		panicmakeslicecap()
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	return mallocgc(mem, et, true)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>函数功能：</p><ul><li>检查切片占用的内存空间是否溢出。</li><li>调用<code>mallocgc</code>在堆上申请一片连续的内存。</li></ul><p>检查内存空间这里是根据切片容量进行计算的，根据当前切片元素的大小与切片容量的乘积得出当前内存空间的大小，检查溢出的条件：</p><ul><li>内存空间大小溢出了</li><li>申请的内存空间大于最大可分配的内存</li><li>传入的<code>len</code>小于<code>0</code>，<code>cap</code>的大小只小于`len</li></ul><a href=#go-语言实现小根堆><h1 id=go-语言实现小根堆><span class=hanchor arialabel=Anchor># </span>Go 语言实现小根堆</h1></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;container/heap&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MinHeap</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>h</span> <span class=nx>MinHeap</span><span class=p>)</span> <span class=nf>Len</span><span class=p>()</span> <span class=kt>int</span>           <span class=p>{</span> <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=nx>h</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>h</span> <span class=nx>MinHeap</span><span class=p>)</span> <span class=nf>Less</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span> <span class=k>return</span> <span class=nx>h</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>&lt;</span> <span class=nx>h</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>h</span> <span class=nx>MinHeap</span><span class=p>)</span> <span class=nf>Swap</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=kt>int</span><span class=p>)</span>      <span class=p>{</span> <span class=nx>h</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>h</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=nx>h</span><span class=p>[</span><span class=nx>j</span><span class=p>],</span> <span class=nx>h</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>h</span> <span class=o>*</span><span class=nx>MinHeap</span><span class=p>)</span> <span class=nf>Push</span><span class=p>(</span><span class=nx>x</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=o>*</span><span class=nx>h</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=o>*</span><span class=nx>h</span><span class=p>,</span> <span class=nx>x</span><span class=p>.(</span><span class=kt>int</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>h</span> <span class=o>*</span><span class=nx>MinHeap</span><span class=p>)</span> <span class=nf>Pop</span><span class=p>()</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>old</span> <span class=o>:=</span> <span class=o>*</span><span class=nx>h</span>
</span></span><span class=line><span class=cl>	<span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>old</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>x</span> <span class=o>:=</span> <span class=nx>old</span><span class=p>[</span><span class=nx>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=o>*</span><span class=nx>h</span> <span class=p>=</span> <span class=nx>old</span><span class=p>[:</span><span class=nx>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>x</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>h</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>MinHeap</span><span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>heap</span><span class=p>.</span><span class=nf>Init</span><span class=p>(</span><span class=nx>h</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;堆中最小的元素是：&#34;</span><span class=p>,</span> <span class=p>(</span><span class=o>*</span><span class=nx>h</span><span class=p>)[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>		<span class=nx>heap</span><span class=p>.</span><span class=nf>Push</span><span class=p>(</span><span class=nx>h</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;插入后最小的元素是：&#34;</span><span class=p>,</span> <span class=p>(</span><span class=o>*</span><span class=nx>h</span><span class=p>)[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>		<span class=nx>min</span> <span class=o>:=</span> <span class=nx>heap</span><span class=p>.</span><span class=nf>Pop</span><span class=p>(</span><span class=nx>h</span><span class=p>).(</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;弹出最小的元素是：&#34;</span><span class=p>,</span> <span class=nx>min</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#go-怎么实现-func-的自定义参数><h1 id=go-怎么实现-func-的自定义参数><span class=hanchor arialabel=Anchor># </span>Go 怎么实现 func 的自定义参数</h1></a><p>在 golang中，type 可以定义任何自定义的类型</p><p>func 也是可以作为类型自定义的，type myFunc func(int) int，意思是自定义了一个叫 myFunc 的函数类型，这个函数的签名必须符合输入为 int，输出为 int。</p><p>golang通过type定义函数类型<br>通过 type 可以定义函数类型，格式如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type typeName func(arguments) retType
</span></span></code></pre></td></tr></table></div></div><p>函数类型也是一种类型，故可以将其定义为函数入参，在 go 语言中函数名可以看做是函数类型的常量，所以我们可以直接将函数名作为参数传入的函数中。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>add</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//sub作为函数名可以看成是 op 类型的常量
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>sub</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>a</span> <span class=o>-</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//定义函数类型 op
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>op</span> <span class=kd>func</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//形参指定传入参数为函数类型op
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Oper</span><span class=p>(</span><span class=nx>fu</span> <span class=nx>op</span><span class=p>,</span> <span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>fu</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>//在go语言中函数名可以看做是函数类型的常量，所以我们可以直接将函数名作为参数传入的函数中。
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>aa</span> <span class=o>:=</span> <span class=nf>Oper</span><span class=p>(</span><span class=nx>add</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>aa</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>bb</span> <span class=o>:=</span> <span class=nf>Oper</span><span class=p>(</span><span class=nx>sub</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>bb</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#为什么-go-的变量申请类型是为了什么><h1 id=为什么-go-的变量申请类型是为了什么><span class=hanchor arialabel=Anchor># </span>为什么 go 的变量申请类型是为了什么？</h1></a><p>在 Go 编程语言中，数据类型用于声明函数和变量。<br>数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。</p><a href=#go-的闭包语法><h1 id=go-的闭包语法><span class=hanchor arialabel=Anchor># </span>Go 的闭包语法</h1></a><p>go语言的闭包可以理解为一个引用外部变量的匿名函数，Go语言中闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量，因此，简单的说：<br><code>函数 + 引用环境 = 闭包</code><br>同一个函数与不同引用环境组合，可以形成不同的实例，如下图：<br><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statisticimg.jpg width=auto alt=img><br>一个函数类型就像结构体一样，可以被实例化，函数本身不存储任何信息，只有与引用环境结合后形成的闭包才具有“记忆性”，函数是编译期静态的概念，而闭包是运行期动态的概念。</p><a href=#go-语言中-int-占几个字节><h1 id=go-语言中-int-占几个字节><span class=hanchor arialabel=Anchor># </span>Go 语言中 int 占几个字节</h1></a><p>Go语言中的int的大小是和操作系统位数相关的，如果是32位操作系统，int类型的大小就是4字节; 如果是64位操作系统，int类型的大小就是8个字节</p><a href=#golang-程序启动过程><h1 id=golang-程序启动过程><span class=hanchor arialabel=Anchor># </span>Golang 程序启动过程</h1></a><p><a href=https://juejin.cn/post/6942509882281033764 rel=noopener>Go程序启动过程</a> </p><p><a href=https://juejin.cn/post/7035633561805783070 rel=noopener>Golang 程序启动过程</a> </p><a href=#golang-开发新手常犯的50个错误><h1 id=golang-开发新手常犯的50个错误><span class=hanchor arialabel=Anchor># </span>Golang 开发新手常犯的50个错误</h1></a><p><a href=https://blog.csdn.net/gezhonglei2007/article/details/52237582 rel=noopener>https://blog.csdn.net/gezhonglei2007/article/details/52237582</a> </p><a href=#go基础语法50问><h1 id=go基础语法50问><span class=hanchor arialabel=Anchor># </span>go基础语法50问</h1></a><p><a href=https://juejin.cn/post/7160639446612705316 rel=noopener>https://juejin.cn/post/7160639446612705316</a></p><a href=#go-程序的基本结构><h1 id=go-程序的基本结构><span class=hanchor arialabel=Anchor># </span>Go 程序的基本结构？</h1></a><p><img src=https://blog-1314857283.cos.ap-shanghai.myqcloud.com/images/202308281927218.png width=auto alt=img></p><a href=#go-有哪些关键字><h1 id=go-有哪些关键字><span class=hanchor arialabel=Anchor># </span>Go 有哪些关键字？</h1></a><p><img src=https://blog-1314857283.cos.ap-shanghai.myqcloud.com/images/202308281929906.png width=auto alt=img></p><a href=#go-有哪些数据类型><h1 id=go-有哪些数据类型><span class=hanchor arialabel=Anchor># </span>Go 有哪些数据类型？</h1></a><p><img src=https://blog-1314857283.cos.ap-shanghai.myqcloud.com/images/202308281929278.png width=auto alt=img></p><a href=#go-方法与函数的区别><h1 id=go-方法与函数的区别><span class=hanchor arialabel=Anchor># </span>Go 方法与函数的区别？</h1></a><p><img src=https://blog-1314857283.cos.ap-shanghai.myqcloud.com/images/202308281929899.png width=auto alt=image-20230828192956848></p><a href=#go-方法值接收者和指针接收者的区别><h1 id=go-方法值接收者和指针接收者的区别><span class=hanchor arialabel=Anchor># </span>Go 方法值接收者和指针接收者的区别?</h1></a><p>如果方法的接收者是指针类型，无论调用者是对象还是对象指针，修改的都是对象本身，会影响调用者；</p><p>如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Person</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>age</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 如果实现了接收者是指针类型的方法，会隐含地也实现了接收者是值类型的IncrAge1方法。
</span></span></span><span class=line><span class=cl><span class=c1>// 会修改age的值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>Person</span><span class=p>)</span> <span class=nf>IncrAge1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span><span class=p>.</span><span class=nx>age</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的IncrAge2方法。
</span></span></span><span class=line><span class=cl><span class=c1>// 不会修改age的值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=nx>Person</span><span class=p>)</span> <span class=nf>IncrAge2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span><span class=p>.</span><span class=nx>age</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的GetAge方法。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=nx>Person</span><span class=p>)</span> <span class=nf>GetAge</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>age</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// p1 是值类型
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>p</span> <span class=o>:=</span> <span class=nx>Person</span><span class=p>{</span><span class=nx>age</span><span class=p>:</span> <span class=mi>10</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 值类型 调用接收者是指针类型的方法
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>p</span><span class=p>.</span><span class=nf>IncrAge1</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nf>GetAge</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 值类型 调用接收者是值类型的方法
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>p</span><span class=p>.</span><span class=nf>IncrAge2</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nf>GetAge</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// ----------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// p2 是指针类型
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>p2</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Person</span><span class=p>{</span><span class=nx>age</span><span class=p>:</span> <span class=mi>20</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 指针类型 调用接收者是指针类型的方法
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>p2</span><span class=p>.</span><span class=nf>IncrAge1</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>p2</span><span class=p>.</span><span class=nf>GetAge</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 指针类型 调用接收者是值类型的方法
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>p2</span><span class=p>.</span><span class=nf>IncrAge2</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>p2</span><span class=p>.</span><span class=nf>GetAge</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>11
</span></span></span><span class=line><span class=cl><span class=cm>11
</span></span></span><span class=line><span class=cl><span class=cm>21
</span></span></span><span class=line><span class=cl><span class=cm>21
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></td></tr></table></div></div><p>上述代码中：</p><p>实现了接收者是指针类型的 IncrAge 1 函数，不管调用者是值类型还是指针类型，都可以调用 IncrAge 1 方法，并且它的 age 值都改变了。</p><p>实现了接收者是指针类型的 IncrAge 2 函数，不管调用者是值类型还是指针类型，都可以调用 IncrAge 2 方法，并且它的 age 值都没有被改变。</p><p>通常我们使用<strong>指针类型作为方法的接收者的理由</strong>：</p><ul><li>使用指针类型能够修改调用者的值。</li><li>使用指针类型可以避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。</li></ul><a href=#go-函数返回局部变量的指针是否安全><h1 id=go-函数返回局部变量的指针是否安全><span class=hanchor arialabel=Anchor># </span>Go 函数返回局部变量的指针是否安全?</h1></a><p>一般来说，局部变量会在函数返回后被销毁，因此被返回的引用就成为了”无所指”的引用，程序会进入未知状态。</p><p>但这在 Go 中是安全的，Go 编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上，因为他们不在栈区，即使释放函数，其内容也不会受影响。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>add</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span> <span class=kt>int</span><span class=p>)</span> <span class=o>*</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>res</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=nx>res</span> <span class=p>=</span> <span class=nx>x</span> <span class=o>+</span> <span class=nx>y</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这个例子中，函数 <code>add</code> 局部变量 <code>res</code> 发生了逃逸。Res 作为返回值，在 main 函数中继续使用，因此 res 指向的内存不能够分配在栈上，随着函数结束而回收，只能分配在堆上。</p><p>编译时可以借助选项 <code>-gcflags=-m</code>，查看变量逃逸的情况</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>./main.go:6:2: res escapes to heap:
</span></span><span class=line><span class=cl>./main.go:6:2:   flow: ~r2 = &amp;res:
</span></span><span class=line><span class=cl>./main.go:6:2:     from &amp;res (address-of) at ./main.go:8:9
</span></span><span class=line><span class=cl>./main.go:6:2:     from return &amp;res (return) at ./main.go:8:2
</span></span><span class=line><span class=cl>./main.go:6:2: moved to heap: res
</span></span><span class=line><span class=cl>./main.go:12:13: ... argument does not escape
</span></span><span class=line><span class=cl>0xc0000ae008
</span></span></code></pre></td></tr></table></div></div><p><code>res escapes to heap</code> 即表示 <code>res</code> 逃逸到堆上了。</p><a href=#go-函数参数传递到底是值传递还是引用传递><h1 id=go-函数参数传递到底是值传递还是引用传递><span class=hanchor arialabel=Anchor># </span>Go 函数参数传递到底是值传递还是引用传递？</h1></a><p>先说下结论：</p><p><strong>Go 语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。</strong></p><p><strong>参数如果是非引用类型（int、string、struct 等这些），这样就在函数中就无法修改原内容数据；如果是引用类型（指针、map、slice、chan 等这些），这样就可以修改原内容数据。</strong></p><p><strong>是否可以修改原内容数据，和传值、传引用没有必然的关系。在 C++中，传引用肯定是可以修改原内容数据的，在 Go 语言里，虽然只有传值，但是我们也可以修改原内容数据，因为参数是引用类型</strong></p><p><strong>引用类型和引用传递是 2 个概念，切记</strong>！！！</p><p><strong>什么是值传递？</strong></p><p>将实参的值传递给形参，形参是实参的一份拷贝，实参和形参的内存地址不同。函数内对形参值内容的修改，是否会影响实参的值内容，取决于参数是否是引用类型</p><p><strong>什么是引用传递？</strong></p><p>将实参的地址传递给形参，函数内对形参值内容的修改，将会影响实参的值内容。Go 语言是没有引用传递的，在 C++中，函数参数的传递方式有引用传递。</p><p><strong>例子：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span><span class=p>[</span><span class=s>&#34;age&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=mi>8</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;原始map的内存地址是：%p\n&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>modifyMap</span><span class=p>(</span><span class=nx>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;改动后的值是: %v\n&#34;</span><span class=p>,</span> <span class=nx>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>modifyMap</span><span class=p>(</span><span class=nx>m</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;函数里接收到map的内存地址是：%p\n&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span><span class=p>[</span><span class=s>&#34;age&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=mi>9</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>原始map的内存地址是：0xc00000e028
</span></span></span><span class=line><span class=cl><span class=cm>函数里接收到map的内存地址是：0xc00000e038
</span></span></span><span class=line><span class=cl><span class=cm>改动后的值是: map[age:9]
</span></span></span><span class=line><span class=cl><span class=cm>通过make函数创建的map变量本质是一个hmap类型的指针*hmap，所以函数内对形参的修改，会修改原内容数据(channel也如此)
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></td></tr></table></div></div><a href=#go-defer-关键字的实现原理><h1 id=go-defer-关键字的实现原理><span class=hanchor arialabel=Anchor># </span>Go defer 关键字的实现原理？</h1></a><p><strong>定义</strong>：</p><p>Defer 能够让我们推迟执行某些函数调用，推迟到当前函数<strong>返回前</strong>才实际执行。Defer 与 panic 和 recover 结合，形成了 Go 语言风格的异常与捕获机制。</p><p><strong>使用场景</strong>：</p><p>Defer 语句经常被用于处理成对的操作，如文件句柄关闭、连接关闭、释放锁</p><p><strong>优点：</strong></p><p>方便开发者使用</p><p><strong>缺点：</strong></p><p>有性能损耗</p><p><strong>实现原理</strong>：</p><p>Go 1.14 中编译器会将 defer 函数直接插入到函数的尾部，无需链表和栈上参数拷贝，性能大幅提升。把 defer 函数在当前函数内展开并直接调用，这种方式被称为 open coded defer</p><p>源代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func A(i int) {
</span></span><span class=line><span class=cl>    defer A1(i, 2*i)
</span></span><span class=line><span class=cl>    if(i &gt; 1) {
</span></span><span class=line><span class=cl>        defer A2(&#34;Hello&#34;, &#34;eggo&#34;)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    // code to do something
</span></span><span class=line><span class=cl>    return
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>func A1(a,b int) {
</span></span><span class=line><span class=cl>    //......
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>func A2(m,n string) {
</span></span><span class=line><span class=cl>    //......
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>编译后（伪代码）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func A(i int) {
</span></span><span class=line><span class=cl>        // code to do something
</span></span><span class=line><span class=cl>    if(i &gt; 1){
</span></span><span class=line><span class=cl>       A2(&#34;Hello&#34;, &#34;eggo&#34;)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    A1(i, 2*i)
</span></span><span class=line><span class=cl>    return
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><strong>代码示例</strong>：</p><p>1、函数退出前，按照先进后出的顺序，执行 defer 函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// defer：延迟函数执行，先进后出
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;defer1&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;defer2&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;defer3&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;defer4&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;11111&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 11111
</span></span></span><span class=line><span class=cl><span class=c1>// defer4
</span></span></span><span class=line><span class=cl><span class=c1>// defer3
</span></span></span><span class=line><span class=cl><span class=c1>// defer2
</span></span></span><span class=line><span class=cl><span class=c1>// defer1
</span></span></span></code></pre></td></tr></table></div></div><p>2、panic 后的 defer 函数不会被执行（遇到 panic，如果没有捕获错误，函数会立刻终止）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// panic后的defer函数不会被执行
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;panic before&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>panic</span><span class=p>(</span><span class=s>&#34;发生panic&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;panic after&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// panic before
</span></span></span><span class=line><span class=cl><span class=c1>// panic: 发生panic
</span></span></span></code></pre></td></tr></table></div></div><p>3、panic 没有被 recover 时，抛出的 panic 到当前 goroutine 最上层函数时，最上层程序直接异常终止</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>F</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;b&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>    <span class=nb>panic</span><span class=p>(</span><span class=s>&#34;a&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 子函数抛出的panic没有recover时，上层函数时，程序直接异常终止
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;c&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>    <span class=nf>F</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;继续执行&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// b
</span></span></span><span class=line><span class=cl><span class=c1>// c
</span></span></span><span class=line><span class=cl><span class=c1>// panic: a
</span></span></span></code></pre></td></tr></table></div></div><p>4、panic 有被 recover 时，当前 goroutine 最上层函数正常执行</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>F</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nb>recover</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;捕获异常:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;b&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>    <span class=nb>panic</span><span class=p>(</span><span class=s>&#34;a&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;c&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>    <span class=nf>F</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;继续执行&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 捕获异常: a
</span></span></span><span class=line><span class=cl><span class=c1>// b
</span></span></span><span class=line><span class=cl><span class=c1>// 继续执行
</span></span></span><span class=line><span class=cl><span class=c1>// c
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>v</span> <span class=o>:=</span> <span class=nb>recover</span><span class=p>();</span><span class=nx>v</span> <span class=o>==</span> <span class=mi>11</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;v:&#34;</span><span class=p>,</span><span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;defer1...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;defer2...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>array</span> <span class=o>:=</span> <span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;array: &#34;</span><span class=p>,</span><span class=nx>array</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>	<span class=nb>panic</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>//array:  2
</span></span></span><span class=line><span class=cl><span class=c1>//defer2...
</span></span></span><span class=line><span class=cl><span class=c1>//v:  11   
</span></span></span><span class=line><span class=cl><span class=c1>//defer1...
</span></span></span></code></pre></td></tr></table></div></div><ol start=5><li>执行过程是: 保存返回值 (若有)–>执行 defer（若有）–>执行 ret 跳转</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func foo() (ret int) {
</span></span><span class=line><span class=cl>    defer func() {
</span></span><span class=line><span class=cl>        ret++
</span></span><span class=line><span class=cl>    }()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return 0
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><ol start=6><li>延迟函数的参数在 defer 语句出现时就已经确定下来了</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func a() {
</span></span><span class=line><span class=cl>    i := 0
</span></span><span class=line><span class=cl>    defer fmt.Println(i)
</span></span><span class=line><span class=cl>    i++
</span></span><span class=line><span class=cl>    return
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><strong>注意：</strong></p><p>执行顺序应该为 panic、defer、recover</p><ul><li>发生 panic 的函数并不会立刻返回，而是先层层函数执行 defer，再返回。如果有办法将 panic 捕获到 panic，就正常处理（若是外部函数捕获到，则外部函数只执行 defer），如果没有没有捕获，程序直接异常终止。</li><li>Go 语言提供了 recover 内置函数。前面提到，一旦 panic 逻辑就会走到 defer（defer 必须在 panic 的前面！)。调用 recover 函数将会捕获到当前的 panic，被捕获到的 panic 就不会向上传递了</li><li>在 panic 发生时，在前面的 defer 中通过 recover 捕获这个 panic，转化为错误通过返回值告诉方法调用者。</li></ul><a href=#go-内置函数-make-和-new-的区别><h1 id=go-内置函数-make-和-new-的区别><span class=hanchor arialabel=Anchor># </span>Go 内置函数 make 和 new 的区别？</h1></a><p>首先纠正下 make 和 new 是内置函数，不是关键字</p><p>变量初始化，一般包括 2 步，变量声明 + 变量内存分配，var 关键字就是用来声明变量的，new 和 make 函数主要是用来分配内存的</p><p>Var 声明<strong>值类型</strong>的变量时，系统会<strong>默认为他分配内存空间</strong>，并赋该类型的<strong>零值</strong></p><p>比如布尔、数字、字符串、结构体</p><p>如果<strong>指针类型</strong>或者<strong>引用类型</strong>的变量，系统<strong>不会为它分配内存</strong>，默认就是 <code>nil</code>。此时如果你想 <code>直接使用，那么系统会抛异常</code>，必须进行内存分配后，才能使用。</p><p>New 和 make 两个内置函数，主要用来分配内存空间，有了内存，变量就能使用了，主要有以下 2 点区别：</p><p><strong>使用场景区别：</strong></p><p>Make 只能用来分配及初始化类型为 slice、map、chan 的数据。</p><p>New 可以分配任意类型的数据，并且置零。</p><p><strong>返回值区别：</strong></p><p>Make 函数原型如下，返回的是 slice、map、chan 类型本身</p><p>这 3 种类型是引用类型，就没有必要返回他们的指针</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func make(t Type, size ...IntegerType) Type
</span></span></code></pre></td></tr></table></div></div><p>New 函数原型如下，返回一个指向该类型内存地址的指针</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type slice struct {
</span></span><span class=line><span class=cl>    array unsafe.Pointer
</span></span><span class=line><span class=cl>    len   int
</span></span><span class=line><span class=cl>    cap   int
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://googoo-s.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by googoo-s using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2024</p><ul><li><a href=https://googoo-s.github.io/>Home</a></li><li><a href=https://github.com/googoo-s>GitHub</a></li></ul></footer></div></div></body></html>