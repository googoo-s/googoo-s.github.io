<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="内存管理  Golang 的内存模型，为什么小对象多了会造成 gc 压力。 通常小对象过多会导致 GC 三色法消耗过多的 GPU。优化思路是，减少对象分配。
 Go 语言什么时候垃圾回收，写代码的时候如何减少对象分配 当 goroutine 申请新的内存管理单元时触发垃圾回收。写代码的时候如何减少对象分配，这是一个关于性能的问题，例如如果需要把数字转换成字符串，使用 strconv.Itoa () 比 fmt.Sprintf () 要快一倍左右。如果需要把数字转换成字符串，使用 strconv."><meta property="og:title" content><meta property="og:description" content="内存管理  Golang 的内存模型，为什么小对象多了会造成 gc 压力。 通常小对象过多会导致 GC 三色法消耗过多的 GPU。优化思路是，减少对象分配。
 Go 语言什么时候垃圾回收，写代码的时候如何减少对象分配 当 goroutine 申请新的内存管理单元时触发垃圾回收。写代码的时候如何减少对象分配，这是一个关于性能的问题，例如如果需要把数字转换成字符串，使用 strconv.Itoa () 比 fmt.Sprintf () 要快一倍左右。如果需要把数字转换成字符串，使用 strconv."><meta property="og:type" content="website"><meta property="og:image" content="https://googoo-s.github.io/icon.png"><meta property="og:url" content="https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="内存管理  Golang 的内存模型，为什么小对象多了会造成 gc 压力。 通常小对象过多会导致 GC 三色法消耗过多的 GPU。优化思路是，减少对象分配。
 Go 语言什么时候垃圾回收，写代码的时候如何减少对象分配 当 goroutine 申请新的内存管理单元时触发垃圾回收。写代码的时候如何减少对象分配，这是一个关于性能的问题，例如如果需要把数字转换成字符串，使用 strconv.Itoa () 比 fmt.Sprintf () 要快一倍左右。如果需要把数字转换成字符串，使用 strconv."><meta name=twitter:image content="https://googoo-s.github.io/icon.png"><title>googoo-s 😄😸😎</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://googoo-s.github.io//icon.png><link href=https://googoo-s.github.io/styles.19109a40042e9f0e72e952fda4442a34.min.css rel=stylesheet><link href=https://googoo-s.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://googoo-s.github.io/js/darkmode.953af745b0f9342644d632fc167f3727.min.js></script>
<script src=https://googoo-s.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://googoo-s.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://googoo-s.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://googoo-s.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://googoo-s.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://googoo-s.github.io/",fetchData=Promise.all([fetch("https://googoo-s.github.io/indices/linkIndex.3bfb24158f5e9d4aff66ae07a3a8bd0d.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://googoo-s.github.io/indices/contentIndex.8972f3e1fb9ffb8fdb949f104473fa8d.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://googoo-s.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://googoo-s.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/googoo-s.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=googoo-s.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://googoo-s.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://googoo-s.github.io/>googoo-s 😄😸😎</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Unknown</p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><ol><li><a href=#-httpsyouandgentlenesscn20230921golange585abe882a1e69687e6b187e680bbe58685e5ad98e7aea1e79086-内存管理内存管理><a href=https://youandgentleness.cn/2023/09/21/Golang%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86 title=内存管理></a>内存管理</a><ol><li><a href=#-httpsyouandgentlenesscn20230921golange585abe882a1e69687e6b187e680bbgolange79a84e58685e5ad98e6a8a1e59e8befbc8ce4b8bae4bb80e4b988e5b08fe5afb9e8b1a1e5a49ae4ba86e4bc9ae980a0e68890gce58e8be58a9be38082-golang-的内存模型为什么小对象多了会造成-gc-压力-golang-的内存模型为什么小对象多了会造成-gc-压力><a href=https://youandgentleness.cn/2023/09/21/Golang%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/#Golang%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%8F%E5%AF%B9%E8%B1%A1%E5%A4%9A%E4%BA%86%E4%BC%9A%E9%80%A0%E6%88%90gc%E5%8E%8B%E5%8A%9B%E3%80%82 title="Golang 的内存模型，为什么小对象多了会造成 gc 压力。"></a> Golang 的内存模型，为什么小对象多了会造成 gc 压力。</a></li><li><a href=#-httpsyouandgentlenesscn20230921golange585abe882a1e69687e6b187e680bbgoe8afade8a880e4bb80e4b988e697b6e58099e59e83e59cbee59b9ee694b6efbc8ce58699e4bba3e7a081e79a84e697b6e58099e5a682e4bd95e5878fe5b091e5afb9e8b1a1e58886e9858d-go-语言什么时候垃圾回收写代码的时候如何减少对象分配-go-语言什么时候垃圾回收写代码的时候如何减少对象分配><a href=https://youandgentleness.cn/2023/09/21/Golang%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/#Go%E8%AF%AD%E8%A8%80%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%8C%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%97%B6%E5%80%99%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D title="Go 语言什么时候垃圾回收，写代码的时候如何减少对象分配"></a> Go 语言什么时候垃圾回收，写代码的时候如何减少对象分配</a></li><li><a href=#-httpsyouandgentlenesscn20230921golange585abe882a1e69687e6b187e680bbe6808ee4b988e981bfe5858de58685e5ad98e98083e980b8efbc9f-怎么避免内存逃逸怎么避免内存逃逸><a href=https://youandgentleness.cn/2023/09/21/Golang%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/#%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%EF%BC%9F title=怎么避免内存逃逸？></a>怎么避免内存逃逸？</a></li><li><a href=#-httpsyouandgentlenesscn20230921golange585abe882a1e69687e6b187e680bbe7ae80e58d95e8818ae8818ae58685e5ad98e98083e980b8efbc9f-简单聊聊内存逃逸简单聊聊内存逃逸><a href=https://youandgentleness.cn/2023/09/21/Golang%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/#%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%EF%BC%9F title=简单聊聊内存逃逸？></a>简单聊聊内存逃逸？</a></li><li><a href=#-httpsyouandgentlenesscn20230921golange585abe882a1e69687e6b187e680bbe7bb99e5a4a7e5aeb6e4b8a2e884b8e4ba86efbc8ce794a8e4ba86e4b889e5b9b4golangefbc8ce68891e8bf98e698afe6b2a1e7ad94e5afb9e8bf99e98193e58685e5ad98e6b384e6bc8fe9a298-给大家丢脸了用了三年-golang我还是没答对这道内存泄漏题给大家丢脸了用了三年-golang我还是没答对这道内存泄漏题><a href=https://youandgentleness.cn/2023/09/21/Golang%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/#%E7%BB%99%E5%A4%A7%E5%AE%B6%E4%B8%A2%E8%84%B8%E4%BA%86%EF%BC%8C%E7%94%A8%E4%BA%86%E4%B8%89%E5%B9%B4Golang%EF%BC%8C%E6%88%91%E8%BF%98%E6%98%AF%E6%B2%A1%E7%AD%94%E5%AF%B9%E8%BF%99%E9%81%93%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%A2%98 title="给大家丢脸了，用了三年 Golang，我还是没答对这道内存泄漏题"></a>给大家丢脸了，用了三年 Golang，我还是没答对这道内存泄漏题</a></li><li><a href=#-httpsyouandgentlenesscn20230921golange585abe882a1e69687e6b187e680bbgoe58685e5ad98e6b384e6bc8fefbc9fe4b88de698afe982a3e4b988e7ae80e58d95-go-内存泄漏不是那么简单-go-内存泄漏不是那么简单><a href=https://youandgentleness.cn/2023/09/21/Golang%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/#Go%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F%E4%B8%8D%E6%98%AF%E9%82%A3%E4%B9%88%E7%AE%80%E5%8D%95 title="Go 内存泄漏？不是那么简单"></a> Go 内存泄漏？不是那么简单</a></li><li><a href=#-httpsyouandgentlenesscn20230921golange585abe882a1e69687e6b187e680bbgoe58685e5ad98e58886e9858defbc8ce5928c-tcmalloc-e79a84e58cbae588ab-go-内存分配和-tcmalloc-的区别-go-内存分配和-tcmalloc-的区别><a href=https://youandgentleness.cn/2023/09/21/Golang%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/#Go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%8C%E5%92%8C-tcmalloc-%E7%9A%84%E5%8C%BA%E5%88%AB title="Go 内存分配，和 tcmalloc 的区别?"></a> Go 内存分配，和 tcmalloc 的区别?</a></li><li><a href=#-httpsyouandgentlenesscn20230921golange585abe882a1e69687e6b187e680bbgolang-e9878ce6808ee4b988e981bfe5858de58685e5ad98e98083e980b8efbc9f-golang-里怎么避免内存逃逸-golang-里怎么避免内存逃逸><a href=https://youandgentleness.cn/2023/09/21/Golang%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/#Golang-%E9%87%8C%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%EF%BC%9F title="Golang 里怎么避免内存逃逸？"></a> Golang 里怎么避免内存逃逸？</a></li><li><a href=#-httpsyouandgentlenesscn20230921golange585abe882a1e69687e6b187e680bbgoe8afade8a880e4b8ade79a84e5a086e5928ce6a088-go-语言中的堆和栈-go-语言中的堆和栈><a href=https://youandgentleness.cn/2023/09/21/Golang%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/#Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88 title="Go 语言中的堆和栈"></a> Go 语言中的堆和栈</a></li></ol></li></ol></li><li><a href=#go-内存分配机制>Go 内存分配机制？</a><ol><li><a href=#设计思想>设计思想</a></li><li><a href=#分配组件>分配组件</a></li><li><a href=#内存管理单元mspan>内存管理单元：mspan</a></li><li><a href=#线程缓存mcache>线程缓存：mcache</a></li><li><a href=#中心缓存mcentral>中心缓存：mcentral</a></li><li><a href=#页堆mheap>页堆：mheap</a><ol><li><a href=#分配对象>分配对象</a></li><li><a href=#分配流程>分配流程</a></li></ol></li></ol></li><li><a href=#go-内存逃逸机制>Go 内存逃逸机制？</a><ol><li><a href=#概念>概念</a></li><li><a href=#逃逸机制>逃逸机制</a><ol><li><a href=#指针逃逸>指针逃逸</a></li><li><a href=#栈空间不足>栈空间不足</a></li><li><a href=#变量大小不确定>变量大小不确定</a></li><li><a href=#动态类型>动态类型</a></li></ol></li><li><a href=#总结>总结</a></li></ol></li><li><a href=#go-内存对齐机制>Go 内存对齐机制？</a><ol><li><a href=#什么是内存对齐>什么是内存对齐</a></li><li><a href=#对齐系数>对齐系数</a></li><li><a href=#优点>优点</a></li><li><a href=#缺点>缺点</a></li><li><a href=#结构体对齐>结构体对齐</a></li></ol></li><li><a href=#go-gc-实现原理>Go GC 实现原理？</a><ol><li><a href=#什么是-gc>什么是 GC？</a></li><li><a href=#主流-gc-算法>主流 GC 算法</a></li><li><a href=#三色标记法><strong>三色标记法</strong></a><ol><li><a href=#root-对象><strong>root 对象</strong></a></li><li><a href=#插入写屏障><strong>插入写屏障</strong></a></li><li><a href=#删除写屏障><strong>删除写屏障</strong></a></li><li><a href=#混合写屏障><strong>混合写屏障</strong></a></li></ol></li><li><a href=#gc-流程>GC 流程</a></li><li><a href=#gc-触发时机>GC 触发时机</a></li><li><a href=#gc-算法演进>GC 算法演进</a></li><li><a href=#go-gc-如何调优>Go GC 如何调优？</a></li><li><a href=#go-如何查看-gc-信息>Go 如何查看 GC 信息？</a><ol><li><a href=#1-godebuggctrace1>1. GODEBUG=’gctrace=1’</a></li><li><a href=#2-go-tool-trace>2. Go tool trace</a></li><li><a href=#3-debug-readgcstats>3. Debug. ReadGCStats</a></li><li><a href=#4-runtime-readmemstats>4. Runtime. ReadMemStats</a></li></ol></li></ol></li></ol></nav></details></aside><h2 id=-httpsyouandgentlenesscn20230921golange585abe882a1e69687e6b187e680bbe58685e5ad98e7aea1e79086-内存管理内存管理><a href=https://youandgentleness.cn/2023/09/21/Golang%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86 rel=noopener></a>内存管理</h2><h3 id=-httpsyouandgentlenesscn20230921golange585abe882a1e69687e6b187e680bbgolange79a84e58685e5ad98e6a8a1e59e8befbc8ce4b8bae4bb80e4b988e5b08fe5afb9e8b1a1e5a49ae4ba86e4bc9ae980a0e68890gce58e8be58a9be38082-golang-的内存模型为什么小对象多了会造成-gc-压力-golang-的内存模型为什么小对象多了会造成-gc-压力><a href=https://youandgentleness.cn/2023/09/21/Golang%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/#Golang%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%8F%E5%AF%B9%E8%B1%A1%E5%A4%9A%E4%BA%86%E4%BC%9A%E9%80%A0%E6%88%90gc%E5%8E%8B%E5%8A%9B%E3%80%82 rel=noopener></a> Golang 的内存模型，为什么小对象多了会造成 gc 压力。</h3><p>通常小对象过多会导致 GC 三色法消耗过多的 GPU。优化思路是，减少对象分配。</p><h3 id=-httpsyouandgentlenesscn20230921golange585abe882a1e69687e6b187e680bbgoe8afade8a880e4bb80e4b988e697b6e58099e59e83e59cbee59b9ee694b6efbc8ce58699e4bba3e7a081e79a84e697b6e58099e5a682e4bd95e5878fe5b091e5afb9e8b1a1e58886e9858d-go-语言什么时候垃圾回收写代码的时候如何减少对象分配-go-语言什么时候垃圾回收写代码的时候如何减少对象分配><a href=https://youandgentleness.cn/2023/09/21/Golang%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/#Go%E8%AF%AD%E8%A8%80%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%8C%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%97%B6%E5%80%99%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D rel=noopener></a> Go 语言什么时候垃圾回收，写代码的时候如何减少对象分配</h3><p>当 goroutine 申请新的内存管理单元时触发垃圾回收。写代码的时候如何减少对象分配，这是一个关于性能的问题，例如如果需要把数字转换成字符串，使用 strconv.Itoa () 比 fmt.Sprintf () 要快一倍左右。如果需要把数字转换成字符串，使用 strconv.Itoa () 比 fmt.Sprintf () 要快一倍左右。这里就不一一展开了。</p><h3 id=-httpsyouandgentlenesscn20230921golange585abe882a1e69687e6b187e680bbe6808ee4b988e981bfe5858de58685e5ad98e98083e980b8efbc9f-怎么避免内存逃逸怎么避免内存逃逸><a href=https://youandgentleness.cn/2023/09/21/Golang%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/#%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%EF%BC%9F rel=noopener></a>怎么避免内存逃逸？</h3><p><a href=https://mp.weixin.qq.com/s/VzRTHz1JaDUvNRVB_yJa1A rel=noopener>https://mp.weixin.qq.com/s/VzRTHz1JaDUvNRVB_yJa1A</a> </p><h3 id=-httpsyouandgentlenesscn20230921golange585abe882a1e69687e6b187e680bbe7ae80e58d95e8818ae8818ae58685e5ad98e98083e980b8efbc9f-简单聊聊内存逃逸简单聊聊内存逃逸><a href=https://youandgentleness.cn/2023/09/21/Golang%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/#%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%EF%BC%9F rel=noopener></a>简单聊聊内存逃逸？</h3><p><a href=https://mp.weixin.qq.com/s/wJmztRMB1ZAAIItyMcS0tw rel=noopener>https://mp.weixin.qq.com/s/wJmztRMB1ZAAIItyMcS0tw</a> </p><h3 id=-httpsyouandgentlenesscn20230921golange585abe882a1e69687e6b187e680bbe7bb99e5a4a7e5aeb6e4b8a2e884b8e4ba86efbc8ce794a8e4ba86e4b889e5b9b4golangefbc8ce68891e8bf98e698afe6b2a1e7ad94e5afb9e8bf99e98193e58685e5ad98e6b384e6bc8fe9a298-给大家丢脸了用了三年-golang我还是没答对这道内存泄漏题给大家丢脸了用了三年-golang我还是没答对这道内存泄漏题><a href=https://youandgentleness.cn/2023/09/21/Golang%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/#%E7%BB%99%E5%A4%A7%E5%AE%B6%E4%B8%A2%E8%84%B8%E4%BA%86%EF%BC%8C%E7%94%A8%E4%BA%86%E4%B8%89%E5%B9%B4Golang%EF%BC%8C%E6%88%91%E8%BF%98%E6%98%AF%E6%B2%A1%E7%AD%94%E5%AF%B9%E8%BF%99%E9%81%93%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%A2%98 rel=noopener></a>给大家丢脸了，用了三年 Golang，我还是没答对这道内存泄漏题</h3><p><a href=https://mp.weixin.qq.com/s/-agtdhlW7Yj7S88a0z7KHg rel=noopener>https://mp.weixin.qq.com/s/-agtdhlW7Yj7S88a0z7KHg</a> </p><h3 id=-httpsyouandgentlenesscn20230921golange585abe882a1e69687e6b187e680bbgoe58685e5ad98e6b384e6bc8fefbc9fe4b88de698afe982a3e4b988e7ae80e58d95-go-内存泄漏不是那么简单-go-内存泄漏不是那么简单><a href=https://youandgentleness.cn/2023/09/21/Golang%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/#Go%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F%E4%B8%8D%E6%98%AF%E9%82%A3%E4%B9%88%E7%AE%80%E5%8D%95 rel=noopener></a> Go 内存泄漏？不是那么简单</h3><p><a href=https://colobu.com/2019/08/28/go-memory-leak-i-dont-think-so/ rel=noopener>https://colobu.com/2019/08/28/go-memory-leak-i-dont-think-so/</a> </p><h3 id=-httpsyouandgentlenesscn20230921golange585abe882a1e69687e6b187e680bbgoe58685e5ad98e58886e9858defbc8ce5928c-tcmalloc-e79a84e58cbae588ab-go-内存分配和-tcmalloc-的区别-go-内存分配和-tcmalloc-的区别><a href=https://youandgentleness.cn/2023/09/21/Golang%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/#Go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%8C%E5%92%8C-tcmalloc-%E7%9A%84%E5%8C%BA%E5%88%AB rel=noopener></a> Go 内存分配，和 tcmalloc 的区别?</h3><p>Go 内存分配核心思想就是把内存分为多级管理，从而降低锁的粒度。它将可用的堆内存采用二级分配的方式进行管理：每个线程都会自行维护一个独立的内存池，进行内存分配时优先从该内存池中分配，当内存池不足时才会向全局内存池申请，以避免不同线程对全局内存池的频繁竞争。</p><ul><li>Go 在程序启动时，会向操作系统申请一大块内存，之后自行管理。</li><li>Go 内存管理的基本单元是 mspan，它由若干个页组成，每种 mspan 可以分配特定大小的 object。</li><li>Mcache, mcentral, mheap 是 Go 内存管理的三大组件，层层递进。Mcache 管理线程在本地缓存的 mspan；mcentral 管理全局的 mspan 供所有线程使用；mheap 管理 Go 的所有动态分配内存。</li><li>极小的对象 (&lt;=16B)会分配在一个object中，以节省资源，使用tiny分配器分配内存；一般对象(16B-32KB)通过mspan分配内存；大对象(>32 KB)则直接由 mheap 分配内存。</li></ul><p><strong>tcmalloc</strong><br>Tcmalloc 是 google 开发的内存分配算法库，最开始它是作为 google 的一个性能工具库 perftools 的一部分。TCMalloc 是用来替代传统的 malloc 内存分配函数。它有减少内存碎片，适用于多核，更好的并行性支持等特性。<br>TC 就是 Thread Cache 两英文的简写。它提供了很多优化，如：</p><ol><li>TCMalloc 用固定大小的 page (页)来执行内存获取、分配等操作。这个特性跟 Linux 物理内存页的划分是不是有同样的道理。</li><li>TCMalloc 用固定大小的对象，比如 8 KB，16 KB 等用于特定大小对象的内存分配，这对于内存获取或释放等操作都带来了简化的作用。</li><li>TCMalloc 还利用缓存常用对象来提高获取内存的速度。</li><li>TCMalloc 还可以基于每个线程或者每个 CPU 来设置缓存大小，这是默认设置。</li><li>TCMalloc 基于每个线程独立设置缓存分配策略，减少了多线程之间锁的竞争。</li></ol><p>Go 中的内存分类并不像 TCMalloc 那样分成小、中、大对象，但是它的小对象里又细分了一个 Tiny 对象，Tiny 对象指大小在 1 Byte 到 16 Byte 之间并且不包含指针的对象。小对象和大对象只用大小划定，无其他区分。<br>Go 内存管理与 tcmalloc 最大的不同在于，它提供了逃逸分析和垃圾回收机制。</p><h3 id=-httpsyouandgentlenesscn20230921golange585abe882a1e69687e6b187e680bbgolang-e9878ce6808ee4b988e981bfe5858de58685e5ad98e98083e980b8efbc9f-golang-里怎么避免内存逃逸-golang-里怎么避免内存逃逸><a href=https://youandgentleness.cn/2023/09/21/Golang%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/#Golang-%E9%87%8C%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%EF%BC%9F rel=noopener></a> Golang 里怎么避免内存逃逸？</h3><ol><li>不要盲目使用变量指针作为参数，虽然减少了复制，但变量逃逸的开销更大。</li><li>预先设定好 slice 长度，避免频繁超出容量，重新分配。</li><li>一个经验是，指针指向的数据大部分在堆上分配的，请注意。</li></ol><p>出现内存逃逸的情况有：</p><ol><li><p>发送指针或带有指针的值到 channel，因为编译时候无法知道那个 goroutine 会在 channel 接受数据，编译器无法知道什么时候释放。</p></li><li><p>在一个切片上存储指针或带指针的值。比如[]*string，导致切片内容逃逸，其引用值一直在堆上。</p></li><li><p>切片的 append 导致超出容量，切片重新分配地址，切片背后的存储基于运行时的数据进行扩充，就会在堆上分配。</p></li><li><p>调用接口类型时，接口类型的方法调用是动态调度，实际使用的具体实现只能在运行时确定，如一个接口类型为 io. Reader 的变量 r，对r.Read (b)的调用将导致 r 的值和字节片 b 的后续转义并因此分配到堆上。</p></li><li><p>在方法内把局部变量指针返回，被外部引用，其生命周期大于栈，导致内存溢出。</p></li></ol><h3 id=-httpsyouandgentlenesscn20230921golange585abe882a1e69687e6b187e680bbgoe8afade8a880e4b8ade79a84e5a086e5928ce6a088-go-语言中的堆和栈-go-语言中的堆和栈><a href=https://youandgentleness.cn/2023/09/21/Golang%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/#Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88 rel=noopener></a> Go 语言中的堆和栈</h3><p>栈主要用来存储值类型的数据，如<strong>整数、浮点数、布尔值</strong>等。因为值类型的数据大小是固定的，所以可以直接分配在栈上，访问速度非常快。</p><p>堆主要用来存储引用类型的数据，如字<strong>符串、切片、字典</strong>等。因为引用类型的数据大小是不固定的，所以需要动态分配内存，通常在堆上进行。同时，由于引用类型的数据通常需要共享和修改，因此使用指针来进行引用和操作，从而避免了复制大量的数据。</p><p>可以看出，栈的性能会更好——<strong>不需要额外的垃圾回收机制</strong>（离开该作用域，它们的内存就会被自动回收），<strong>CPU 可以连续缓存</strong>（内存空间是连续的）。堆是通过<strong>GC 回收内存</strong>的。</p><a href=#go-内存分配机制><h1 id=go-内存分配机制><span class=hanchor arialabel=Anchor># </span>Go 内存分配机制？</h1></a><p>Go 语言内置运行时（就是 runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。</p><a href=#设计思想><h2 id=设计思想><span class=hanchor arialabel=Anchor># </span>设计思想</h2></a><ul><li>内存分配算法采用 Google 的 <code>TCMalloc算法</code>，每个线程都会自行维护一个独立的内存池，进行内存分配时优先从该内存池中分配，当内存池不足时才会向加锁向全局内存池申请，减少系统调用并且避免不同线程对全局内存池的锁竞争</li><li>把内存切分的非常的细小，分为多级管理，以降低锁的粒度</li><li>回收对象内存时，并没有将其真正释放掉，只是放回预先分配的大块内存中，以便复用。只有内存闲置过多的时候，才会尝试归还部分内存给操作系统，降低整体开销</li></ul><a href=#分配组件><h2 id=分配组件><span class=hanchor arialabel=Anchor># </span>分配组件</h2></a><p>Go 的内存管理组件主要有：<code>mspan</code>、<code>mcache</code>、<code>mcentral</code> 和 <code>mheap</code>
<img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226003340.png width=auto alt=image.png></p><a href=#内存管理单元mspan><h2 id=内存管理单元mspan><span class=hanchor arialabel=Anchor># </span>内存管理单元：mspan</h2></a><p><code>mspan</code> 是内存管理的基本单元，该结构体中包含 <code>next</code> 和 <code>prev</code> 两个字段，它们分别指向了前一个和后一个 mspan，每个 <code>mspan</code> 都管理 <code>npages</code> 个大小为 8 KB 的页，一个 span 是由多个 page 组成的，这里的页不是操作系统中的内存页，它们是操作系统内存页的整数倍。</p><p><code>page</code> 是内存存储的基本单元，“对象”放到 <code>page</code> 中</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type mspan struct {
</span></span><span class=line><span class=cl>    next *mspan // 后指针
</span></span><span class=line><span class=cl>    prev *mspan // 前指针
</span></span><span class=line><span class=cl>    startAddr uintptr // 管理页的起始地址，指向page
</span></span><span class=line><span class=cl>    npages    uintptr // 页数
</span></span><span class=line><span class=cl>    spanclass   spanClass // 规格
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>type spanClass uint8
</span></span></code></pre></td></tr></table></div></div><p>Go 有 68 种不同大小的 spanClass，用于小对象的分配</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>const _NumSizeClasses = 68
</span></span><span class=line><span class=cl>var class_to_size = [_NumSizeClasses]uint16{0, 8, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536,1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768}
</span></span></code></pre></td></tr></table></div></div><p>如果按照序号为 1 的 spanClass（对象规格为 8 B）分配，每个 span 占用堆的字节数：8 k，mspan 可以保存 1024个对象</p><p>如果按照序号为 2 的 spanClass（对象规格为 16 B）分配，每个 span 占用堆的字节数：8 k，mspan 可以保存 512个对象</p><p>…</p><p>如果按照序号为 67 的 spanClass（对象规格为 32 K）分配，每个 span 占用堆的字节数：32 k，mspan 可以保存1个对象</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226003424.png width=auto alt=image.png></p><p>字段含义：</p><ul><li>Class： class ID，每个 span 结构中都有一个 class ID, 表示该 span 可处理的对象类型</li><li>Bytes/obj：该 class 代表对象的字节数</li><li>Bytes/span：每个 span 占用堆的字节数，也即页数*页大小</li><li>Objects: 每个 span 可分配的对象个数，也即（bytes/spans）/（bytes/obj）</li><li>Waste bytes: 每个 span 产生的内存碎片，也即（bytes/spans）%（bytes/obj）</li></ul><p>大于 32 k 的对象出现时，会直接从 heap 分配一个特殊的 span，这个特殊的 span 的类型 (class)是 0, 只包含了一个大对象</p><a href=#线程缓存mcache><h2 id=线程缓存mcache><span class=hanchor arialabel=Anchor># </span>线程缓存：mcache</h2></a><p>mcache 管理线程在本地缓存的 mspan，每个 goroutine 绑定的 P 都有一个 <code>mcache</code> 字段</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type mcache struct {
</span></span><span class=line><span class=cl>    alloc [numSpanClasses]*mspan
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>_NumSizeClasses = 68
</span></span><span class=line><span class=cl>numSpanClasses = _NumSizeClasses &lt;&lt; 1
</span></span></code></pre></td></tr></table></div></div><p><code>mcache</code> 用 <code>Span Classes</code> 作为索引管理多个用于分配的 <code>mspan</code>，它包含所有规格的 <code>mspan</code>。它是 <code>_NumSizeClasses</code> 的 2 倍，也就是 <code>68*2=136</code>，其中* 2 是将 spanClass 分成了有指针和没有指针两种, 方便与垃圾回收。对于每种规格，有 2 个 mspan，一个 mspan 不包含指针，另一个 mspan 则包含指针。对于无指针对象的 <code>mspan</code> 在进行垃圾回收的时候无需进一步扫描它是否引用了其他活跃的对象。</p><p><code>mcache</code> 在初始化的时候是没有任何 <code>mspan</code> 资源的，在使用过程中会动态地从 <code>mcentral</code> 申请，之后会缓存下来。当对象小于等于 32 KB 大小时，使用 <code>mcache</code> 的相应规格的 <code>mspan</code> 进行分配。</p><a href=#中心缓存mcentral><h2 id=中心缓存mcentral><span class=hanchor arialabel=Anchor># </span>中心缓存：mcentral</h2></a><p>Mcentral 管理全局的 mspan 供所有线程使用，全局 mheap 变量包含 central 字段，每个 mcentral 结构都维护在<strong>mheap</strong>结构内</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type mcentral struct {
</span></span><span class=line><span class=cl>    spanclass spanClass // 指当前规格大小
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    partial [2]spanSet // 有空闲object的mspan列表
</span></span><span class=line><span class=cl>    full    [2]spanSet // 没有空闲object的mspan列表
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>每个 mcentral 管理一种 spanClass 的 mspan，并将有空闲空间和没有空闲空间的 mspan 分开管理。Partial 和 full <code>的数据类型为</code> spanSet，表示 <code>mspans</code> 集，可以通过 pop、push 来获得 mspans</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type spanSet struct {
</span></span><span class=line><span class=cl>    spineLock mutex
</span></span><span class=line><span class=cl>    spine     unsafe.Pointer // 指向[]span的指针
</span></span><span class=line><span class=cl>    spineLen  uintptr        // Spine array length, accessed atomically
</span></span><span class=line><span class=cl>    spineCap  uintptr        // Spine array cap, accessed under lock
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    index headTailIndex  // 前32位是头指针，后32位是尾指针
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>简单说下 <code>mcache</code> 从 <code>mcentral</code> 获取和归还 <code>mspan</code> 的流程：</p><ul><li>获取；加锁，从 <code>partial</code> 链表找到一个可用的 <code>mspan</code>；并将其从 <code>partial</code> 链表删除；将取出的 <code>mspan</code> 加入到 <code>full</code> 链表；将 <code>mspan</code> 返回给工作线程，解锁。</li><li>归还；加锁，将 <code>mspan</code> 从 <code>full</code> 链表删除；将 <code>mspan</code> 加入到 <code>partial</code> 链表，解锁。</li></ul><a href=#页堆mheap><h2 id=页堆mheap><span class=hanchor arialabel=Anchor># </span>页堆：mheap</h2></a><p>Mheap 管理 Go 的所有动态分配内存，可以认为是 Go 程序持有的整个堆空间，全局唯一</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>var mheap_ mheap
</span></span><span class=line><span class=cl>type mheap struct {
</span></span><span class=line><span class=cl>    lock      mutex    // 全局锁
</span></span><span class=line><span class=cl>    pages     pageAlloc // 页面分配的数据结构
</span></span><span class=line><span class=cl>    allspans []*mspan // 所有通过 mheap_ 申请的mspans
</span></span><span class=line><span class=cl>        // 堆
</span></span><span class=line><span class=cl>    arenas [1 &lt;&lt; arenaL1Bits]*[1 &lt;&lt; arenaL2Bits]*heapArena
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>        // 所有中心缓存mcentral
</span></span><span class=line><span class=cl>    central [numSpanClasses]struct {
</span></span><span class=line><span class=cl>        mcentral mcentral
</span></span><span class=line><span class=cl>        pad      [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral{})%cpu.CacheLinePadSize]byte
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>所有 <code>mcentral</code> 的集合则是存放于 <code>mheap</code> 中的。<code>mheap</code> 里的 <code>arena</code> 区域是堆内存的抽象，运行时会将 <code>8KB</code> 看做一页，这些内存页中存储了所有在堆上初始化的对象。运行时使用二维的 runtime. HeapArena 数组管理所有的内存，每个 runtime. HeapArena 都会管理 64 MB 的内存。</p><p>当申请内存时，依次经过 <code>mcache</code> 和 <code>mcentral</code> 都没有可用合适规格的大小内存，这时候会向 <code>mheap</code> 申请一块内存。然后按指定规格划分为一些列表，并将其添加到相同规格大小的 <code>mcentral</code> 的 <code>非空闲列表</code> 后面</p><a href=#分配对象><h3 id=分配对象><span class=hanchor arialabel=Anchor># </span>分配对象</h3></a><ul><li>微对象 (0, 16 B)：先使用线程缓存上的微型分配器，再依次尝试线程缓存、中心缓存、堆分配内存；</li><li>小对象 [16 B, 32 KB]：依次尝试线程缓存、中心缓存、堆分配内存；</li><li>大对象 (32 KB, +∞)：直接尝试堆分配内存；</li></ul><a href=#分配流程><h3 id=分配流程><span class=hanchor arialabel=Anchor># </span>分配流程</h3></a><ul><li>首先通过计算使用的大小规格</li><li>然后使用 <code>mcache</code> 中对应大小规格的块分配。</li><li>如果 <code>mcentral</code> 中没有可用的块，则向 <code>mheap</code> 申请，并根据算法找到最合适的 <code>mspan</code>。</li><li>如果申请到的 <code>mspan</code> 超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的 mspan 放回 mheap 的空闲列表。</li><li>如果 mheap 中没有可用 span，则向操作系统申请一系列新的页（最小 1 MB）
<img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226003626.png width=auto alt=image.png></li></ul><a href=#go-内存逃逸机制><h1 id=go-内存逃逸机制><span class=hanchor arialabel=Anchor># </span>Go 内存逃逸机制？</h1></a><a href=#概念><h2 id=概念><span class=hanchor arialabel=Anchor># </span>概念</h2></a><p>在一段程序中，每一个函数都会有自己的内存区域存放自己的局部变量、返回地址等，这些内存会由编译器在栈中进行分配，每一个函数都会分配一个栈桢，在函数运行结束后进行销毁，但是有些变量我们想在函数运行结束后仍然使用它，那么就需要把这个变量在堆上分配，这种从”栈”上逃逸到”堆”上的现象就成为内存逃逸。</p><p>在栈上分配的地址，一般由系统申请和释放，不会有额外性能的开销，比如函数的入参、局部变量、返回值等。在堆上分配的内存，如果要回收掉，需要进行 GC，那么 GC 一定会带来额外的性能开销。编程语言不断优化 GC 算法，主要目的都是为了减少 GC 带来的额外性能开销，变量一旦逃逸会导致性能开销变大。</p><a href=#逃逸机制><h2 id=逃逸机制><span class=hanchor arialabel=Anchor># </span>逃逸机制</h2></a><p>编译器会根据变量是否被外部引用来决定是否逃逸：</p><ol><li>如果函数外部没有引用，则优先放到栈中；</li><li>如果函数外部存在引用，则必定放到堆中;</li><li>如果栈上放不下，则必定放到堆上;</li></ol><p>逃逸分析也就是由编译器决定哪些变量放在栈，哪些放在堆中，通过编译参数 <code>-gcflag=-m</code> 可以查看编译过程中的逃逸分析，发生逃逸的几种场景如下：</p><a href=#指针逃逸><h3 id=指针逃逸><span class=hanchor arialabel=Anchor># </span>指针逃逸</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>escape1</span><span class=p>()</span> <span class=o>*</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>a</span> <span class=kt>int</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&amp;</span><span class=nx>a</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>escape1</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>通过 <code>go build -gcflags=-m main.go</code> 查看逃逸情况：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>./main.go:4:6: moved to heap: a
</span></span></code></pre></td></tr></table></div></div><p>函数返回值为局部变量的指针，函数虽然退出了，但是因为指针的存在，指向的内存不能随着函数结束而回收，因此只能分配在堆上。</p><a href=#栈空间不足><h3 id=栈空间不足><span class=hanchor arialabel=Anchor># </span>栈空间不足</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>escape2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>s</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>10000</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>index</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>s</span><span class=p>[</span><span class=nx>index</span><span class=p>]</span> <span class=p>=</span> <span class=nx>index</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>escape2</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>通过 <code>go build -gcflags=-m main.go</code> 查看逃逸情况：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>./main.go:4:11: make([]int, 10000, 10000) escapes to heap
</span></span></code></pre></td></tr></table></div></div><p>当栈空间足够时，不会发生逃逸，但是当变量过大时，已经完全超过栈空间的大小时，将会发生逃逸到堆上分配内存。局部变量 s 占用内存过大，编译器会将其分配到堆上</p><a href=#变量大小不确定><h3 id=变量大小不确定><span class=hanchor arialabel=Anchor># </span>变量大小不确定</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>escape3</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>number</span> <span class=o>:=</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl>    <span class=nx>s</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>number</span><span class=p>)</span> <span class=c1>// 编译期间无法确定slice的长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>escape3</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>编译期间无法确定 slice 的长度，这种情况为了保证内存的安全，编译器也会触发逃逸，在堆上进行分配内存。直接 <code>s := make([]int, 10)</code> 不会发生逃逸</p><a href=#动态类型><h3 id=动态类型><span class=hanchor arialabel=Anchor># </span>动态类型</h3></a><p>动态类型就是编译期间不确定参数的类型、参数的长度也不确定的情况下就会发生逃逸</p><p>空接口 interface{} 可以表示任意的类型，如果函数参数为 interface{}，编译期间很难确定其参数的具体类型，也会发生逃逸。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>escape4</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=mi>1111</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>escape4</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>通过 <code>go build -gcflags=-m main.go</code> 查看逃逸情况：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>./main.go:4:6: moved to heap: i
</span></span></code></pre></td></tr></table></div></div><p>Fmt.Println (a …interface{})函数参数为 interface，编译器不确定参数的类型，会将变量分配到堆上</p><h5 id=-httpsyouandgentlenesscn20230828goe8afade8a880e99da2e8af95e9a298e7b2bee8aeb2e997ade58c85e5bc95e794a8e5afb9e8b1a1-闭包引用对象闭包引用对象><a href=https://youandgentleness.cn/2023/08/28/Go%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E8%AE%B2/#%E9%97%AD%E5%8C%85%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1 rel=noopener></a>闭包引用对象</h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>escape5</span><span class=p>()</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>i</span> <span class=kt>int</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>i</span><span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>escape5</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>通过 <code>go build -gcflags=-m main.go</code> 查看逃逸情况：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>./main.go:4:6: moved to heap: i
</span></span></code></pre></td></tr></table></div></div><p>闭包函数中局部变量 i 在后续函数是继续使用的，编译器将其分配到堆上</p><a href=#总结><h2 id=总结><span class=hanchor arialabel=Anchor># </span>总结</h2></a><ol><li>栈上分配内存比在堆中分配内存效率更高</li><li>栈上分配的内存不需要 GC 处理，而堆需要</li><li>逃逸分析目的是决定内分配地址是栈还是堆</li><li>逃逸分析在编译阶段完成</li></ol><p>因为无论变量的大小，只要是指针变量都会在堆上分配，所以对于小变量我们还是使用传值效率（而不是传指针）更高一点。</p><a href=#go-内存对齐机制><h1 id=go-内存对齐机制><span class=hanchor arialabel=Anchor># </span>Go 内存对齐机制？</h1></a><a href=#什么是内存对齐><h2 id=什么是内存对齐><span class=hanchor arialabel=Anchor># </span>什么是内存对齐</h2></a><p>为了能让 CPU 可以更快的存取到各个字段，Go 编译器会帮你把 struct 结构体做数据的对齐。<strong>所谓的数据对齐，是指内存地址是所存储数据大小（按字节为单位）的整数倍，以便 CPU 可以一次将该数据从内存中读取出来。</strong> 编译器通过在结构体的各个字段之间填充一些空白已达到对齐的目的。</p><a href=#对齐系数><h2 id=对齐系数><span class=hanchor arialabel=Anchor># </span>对齐系数</h2></a><p>不同硬件平台占用的大小和对齐值都可能是不一样的，每个特定平台上的编译器都有自己的默认”对齐系数”，32 位系统对齐系数是 4，64 位系统对齐系数是 8</p><p>不同类型的对齐系数也可能不一样，使用 <code>Go</code> 语言中的 <code>unsafe.Alignof</code> 函数可以返回相应类型的对齐系数，对齐系数都符合 <code>2^n</code> 这个规律，最大也不会超过8</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;unsafe&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;bool alignof is %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=nb>bool</span><span class=p>(</span><span class=kc>true</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;string alignof is %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=s>&#34;a&#34;</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;int alignof is %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=mi>0</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;float alignof is %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=nb>float64</span><span class=p>(</span><span class=mi>0</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;int32 alignof is %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=nb>int32</span><span class=p>(</span><span class=mi>0</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;float32 alignof is %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=nb>float32</span><span class=p>(</span><span class=mi>0</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>可以查看到各种类型在 Mac 64 位上的对齐系数如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>bool alignof is 1
</span></span><span class=line><span class=cl>string alignof is 8
</span></span><span class=line><span class=cl>int alignof is 8
</span></span><span class=line><span class=cl>int32 alignof is 4
</span></span><span class=line><span class=cl>float32 alignof is 4
</span></span><span class=line><span class=cl>float alignof is 8
</span></span></code></pre></td></tr></table></div></div><a href=#优点><h2 id=优点><span class=hanchor arialabel=Anchor># </span>优点</h2></a><ol><li>提高可移植性，有些 <code>CPU</code> 可以访问任意地址上的任意数据，而有些 <code>CPU</code> 只能在特定地址访问数据，因此不同硬件平台具有差异性，这样的代码就不具有移植性，如果在编译时，将分配的内存进行对齐，这就具有平台可以移植性了</li><li>提高内存的访问效率，32 位 CPU 下一次可以从内存中读取 32 位（4 个字节）的数据，64 位 CPU 下一次可以从内存中读取 64 位（8 个字节）的数据，这个长度也称为 CPU 的字长。CPU 一次可以读取 1 个字长的数据到内存中，如果所需要读取的数据正好跨了 1 个字长，那就得花两个 CPU 周期的时间去读取了。因此在内存中存放数据时进行对齐，可以提高内存访问效率。</li></ol><a href=#缺点><h2 id=缺点><span class=hanchor arialabel=Anchor># </span>缺点</h2></a><ol><li>存在内存空间的浪费，实际上是空间换时间</li></ol><a href=#结构体对齐><h2 id=结构体对齐><span class=hanchor arialabel=Anchor># </span>结构体对齐</h2></a><p>对齐原则：</p><ol><li><strong>结构体变量中成员的偏移量必须是成员大小的整数倍</strong></li><li><strong>整个结构体的地址必须是最大字节的整数倍</strong>（结构体的内存占用是 1/4/8/16 byte…)</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;runtime&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;unsafe&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>T1</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>i16</span>  <span class=kt>int16</span> <span class=c1>// 2 byte
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=kt>bool</span>  <span class=c1>// 1 byte
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>T2</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>i8</span>  <span class=kt>int8</span>  <span class=c1>// 1 byte
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>i64</span> <span class=kt>int64</span> <span class=c1>// 8 byte
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>i32</span> <span class=kt>int32</span> <span class=c1>// 4 byte
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>T3</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>i8</span>  <span class=kt>int8</span>  <span class=c1>// 1 byte
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>i32</span> <span class=kt>int32</span> <span class=c1>// 4 byte
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>i64</span> <span class=kt>int64</span> <span class=c1>// 8 byte
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>runtime</span><span class=p>.</span><span class=nx>GOARCH</span><span class=p>)</span> <span class=c1>// amd64
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nx>t1</span> <span class=o>:=</span> <span class=nx>T1</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nx>t1</span><span class=p>))</span> <span class=c1>// 4 bytes
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nx>t2</span> <span class=o>:=</span> <span class=nx>T2</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nx>t2</span><span class=p>))</span> <span class=c1>// 24 bytes
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nx>t3</span> <span class=o>:=</span> <span class=nx>T3</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nx>t3</span><span class=p>))</span> <span class=c1>// 16 bytes
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>以 T 1 结构体为例，实际存储数据的只有 3 字节，但实际用了 4 字节，浪费了 1 个字节：</p><p>I 16 并没有直接放在 bool 的后面，而是在 bool 中填充了一个空白后，放到了偏移量为 2 的位置上。如果 i 16 从偏移量为 1 的位置开始占用 2 个字节，根据对齐原则 2：构体变量中成员的偏移量必须是成员大小的整数倍，套用公式 1 % 2 = 1，就不满足对齐的要求，所以 i 16 从偏移量为2的位置开始
<img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226004114.png width=auto alt=image.png></p><p>以 T 2 结构体为例，实际存储数据的只有 13 字节，但实际用了 24 字节，浪费了 11 个字节：
<img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226004122.png width=auto alt=image.png></p><p>以 T 3 结构体为例，实际存储数据的只有 13 字节，但实际用了 16 字节，浪费了 3 个字节：</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226004134.png width=auto alt=image.png></p><a href=#go-gc-实现原理><h1 id=go-gc-实现原理><span class=hanchor arialabel=Anchor># </span>Go GC 实现原理？</h1></a><a href=#什么是-gc><h2 id=什么是-gc><span class=hanchor arialabel=Anchor># </span>什么是 GC？</h2></a><p>垃圾回收也称为 GC（Garbage Collection），是一种自动内存管理机制</p><p>现代高级编程语言管理内存的方式分为两种：自动和手动，像 C、C++ 等编程语言使用手动管理内存的方式，工程师编写代码过程中需要主动申请或者释放内存；而 PHP、Java 和 Go 等语言使用自动的内存管理系统，有内存分配器和垃圾收集器来代为分配和回收内存，其中垃圾收集器就是我们常说的 GC。</p><p>在应用程序中会使用到两种内存，分别为堆（Heap）和栈（Stack），GC 负责回收堆内存，而不负责回收栈中的内存：</p><p>栈是线程的专用内存，专门为了函数执行而准备的，存储着函数中的局部变量以及调用栈，函数执行完后，编译器可以将栈上分配的内存可以直接释放，不需要通过 GC 来回收。</p><p>堆是程序共享的内存，需要 GC 进行回收在堆上分配的内存。</p><p>垃圾回收器的执行过程被划分为两个半独立的组件：</p><ul><li>赋值器（Mutator）：这一名称本质上是在指代用户态的代码。因为对垃圾回收器而言，用户态的代码仅仅只是在修改对象之间的引用关系，也就是在对象图（对象之间引用关系的一个有向图）上进行操作。</li><li>回收器（Collector）：负责执行垃圾回收的代码。</li></ul><a href=#主流-gc-算法><h2 id=主流-gc-算法><span class=hanchor arialabel=Anchor># </span>主流 GC 算法</h2></a><p>目前比较常见的垃圾回收算法有三种：</p><ol><li>引用计数：为每个对象维护一个引用计数，当引用该对象的对象销毁时，引用计数 -1，当对象引用计数为 0 时回收该对象。<ul><li>代表语言：<strong>Python</strong>、<strong>PHP</strong>、<strong>Swift</strong></li><li>优点：对象回收快，不会出现内存耗尽或达到某个阈值时才回收。</li><li>缺点：不能很好的处理循环引用，而实时维护引用计数也是有损耗的。</li></ul></li><li>分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。<ul><li>代表语言：<strong>Java</strong></li><li>优点：回收性能好</li><li>缺点：算法复杂</li></ul></li><li>标记-清除：从根变量开始遍历所有引用的对象，标记引用的对象，没有被标记的进行回收。<ul><li>代表语言：<strong>Golang</strong>（三色标记法）</li><li>优点：解决了引用计数的缺点。</li><li>缺点：需要 STW，暂时停掉程序运行。
Go GC 算法
<img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226004206.png width=auto alt=image.png></li></ul></li></ol><a href=#三色标记法><h2 id=三色标记法><span class=hanchor arialabel=Anchor># </span><strong>三色标记法</strong></h2></a><p>此算法是在 Go 1.5 版本开始使用，Go 语言采用的是标记清除算法，并在此基础上使用了三色标记法和混合写屏障技术，GC 过程和其他用户 goroutine 可并发运行，但需要一定时间的 STW</p><p>三色标记法只是为了叙述方便而抽象出来的一种说法，实际上的对象是没有三色之分的。这里的三色，对应了垃圾回收过程中对象的三种状态：</p><ul><li><p>灰色：对象还在标记队列中等待</p></li><li><p>黑色：对象已被标记，<code>gcmarkBits</code> 对应位为 <code>1</code> （该对象不会在本次 GC 中被回收）</p></li><li><p>白色：对象未被标记，<code>gcmarkBits</code> 对应位为 <code>0</code> （该对象将会在本次 GC 中被清理）</p></li><li><p>Step 1: 创建：白、灰、黑三个集合</p></li><li><p>Step 2: 将所有对象放入白色集合中</p></li><li><p>Step 3: 遍历所有<strong>root 对象</strong>，把遍历到的对象从白色集合放入灰色集合 (这里放入灰色集合的都是根节点的对象)</p></li><li><p>Step 4: 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，自身标记为黑色</p></li><li><p>Step 5: 重复步骤 4，直到灰色中无任何对象，其中用到 2 个机制：</p><ul><li><strong>写屏障（Write Barrier）</strong>：上面说到的 STW 的目的是防止 GC 扫描时内存变化引起的混乱，而写屏障就是让 goroutine 与 GC 同时运行的手段，虽然不能完全消除 STW，但是可以大大减少 STW 的时间。写屏障在 GC 的特定时间开启，开启后<strong>指针传递时</strong>会把指针标记，即本轮不回收，下次 GC 时再确定。</li><li><strong>辅助 GC（Mutator Assist）</strong>：为了防止内存分配过快，在 GC 执行过程中，GC 过程中 mutator 线程会并发运行，而 mutator assist 机制会协助 GC 做一部分的工作。</li></ul></li></ul><p>Step 6: 收集所有白色对象（垃圾）</p><a href=#root-对象><h3 id=root-对象><span class=hanchor arialabel=Anchor># </span><strong>root 对象</strong></h3></a><p>根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：</p><p>全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上指向堆内存的指针。寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。</p><a href=#插入写屏障><h3 id=插入写屏障><span class=hanchor arialabel=Anchor># </span><strong>插入写屏障</strong></h3></a><p>对象被引用时触发的机制（只在堆内存中生效）：赋值器这一行为通知给并发执行的回收器，被引用的对象标记为灰色</p><p>缺点：结束时需要 STW 来重新扫描栈，标记栈上引用的白色对象的存活</p><a href=#删除写屏障><h3 id=删除写屏障><span class=hanchor arialabel=Anchor># </span><strong>删除写屏障</strong></h3></a><p>对象被删除时触发的机制（只在堆内存中生效）：赋值器将这一行为通知给并发执行的回收器，被删除的对象，如果自身为灰色或者白色，那么标记为灰色</p><p>缺点：一个对象的引用被删除后，即使没有其他存活的对象引用它，它仍然会活到下一轮，会产生很大冗余扫描成本，且降低了回收精度</p><a href=#混合写屏障><h3 id=混合写屏障><span class=hanchor arialabel=Anchor># </span><strong>混合写屏障</strong></h3></a><p>GC 没有混合写屏障前，一直是插入写屏障；混合写屏障是插入写屏障 + 删除写屏障，写屏障只应用在堆上应用，栈上不启用（栈上启用成本很高）</p><ul><li>GC 开始将栈上的对象全部扫描并标记为黑色。</li><li>GC 期间，任何在栈上创建的新对象，均为黑色。</li><li>被删除的对象标记为灰色。</li><li>被添加的对象标记为灰色。</li></ul><a href=#gc-流程><h2 id=gc-流程><span class=hanchor arialabel=Anchor># </span>GC 流程</h2></a><p>一次完整的垃圾回收会分为四个阶段，分别是标记准备、标记开始、标记终止、清理：</p><ol><li><strong>标记准备（Mark Setup）</strong>：打开写屏障（Write Barrier），需 STW（stop the world)</li><li><strong>标记开始（Marking）</strong>：使用三色标记法并发标记，与用户程序并发执行</li><li><strong>标记终止（Mark Termination</strong>）：对触发写屏障的对象进行重新扫描标记，关闭写屏障（Write Barrier），需 STW（stop the world)</li><li><strong>清理（Sweeping）</strong>：将需要回收的内存归还到堆中，将过多的内存归还给操作系统，与用户程序并发执行
<img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226004354.png width=auto alt=image.png></li></ol><a href=#gc-触发时机><h2 id=gc-触发时机><span class=hanchor arialabel=Anchor># </span>GC 触发时机</h2></a><p><strong>主动触发：</strong></p><ul><li>调用 runtime.GC () 方法，触发 GC</li></ul><p><strong>被动触发：</strong></p><ul><li>定时触发，该触发条件由 <code>runtime.forcegcperiod</code> 变量控制，默认为 2 分钟。当超过两分钟没有产生任何 GC 时，触发 GC</li><li>根据内存分配阈值触发，该触发条件由环境变量 GOGC 控制，默认值为 100（100%），当前堆内存占用是上次 GC 结束后占用内存的 2 倍时，触发 GC</li></ul><a href=#gc-算法演进><h2 id=gc-算法演进><span class=hanchor arialabel=Anchor># </span>GC 算法演进</h2></a><ul><li>Go 1：mark and sweep 操作都需要 STW</li><li><strong>Go 1.3</strong>：分离了 mark 和 sweep 操作，mark 过程需要 STW，mark 完成后让 sweep 任务和普通协程任务一样并行，停顿时间在约几百 ms</li><li><strong>Go 1.5</strong>：引入三色并发标记法、插入写屏障，不需要每次都扫描整个内存空间，可以减少 stop the world 的时间，停顿时间在 100 ms 以内</li><li>Go 1.6：使用 bitmap 来记录回收内存的位置，大幅优化垃圾回收器自身消耗的内存，停顿时间在 10 ms 以内</li><li>Go 1.7：停顿时间控制在 2 ms 以内</li><li><strong>Go 1.8</strong>：混合写屏障（插入写屏障和删除写屏障），停顿时间在 0.5 ms 左右</li><li>Go 1.9：彻底移除了栈的重扫描过程</li><li>Go 1.12：整合了两个阶段的 Mark Termination</li><li>Go 1.13：着手解决向操作系统归还内存的，提出了新的 Scavenger</li><li>Go 1.14：替代了仅存活了一个版本的 scavenger，全新的页分配器，优化分配内存过程的速率与现有的扩展性问题，并引入了异步抢占，解决了由于密集循环导致的 STW 时间过长的问题</li></ul><a href=#go-gc-如何调优><h2 id=go-gc-如何调优><span class=hanchor arialabel=Anchor># </span>Go GC 如何调优？</h2></a><ul><li>控制内存分配的速度，限制 Goroutine 的数量，提高赋值器 mutator 的 CPU 利用率（降低 GC 的 CPU 利用率）</li><li>少量使用 <code>+</code> 连接 string</li><li>Slice 提前分配足够的内存来降低扩容带来的拷贝</li><li>避免 map key 对象过多，导致扫描时间增加</li><li>变量复用，减少对象分配，例如使用 sync. Pool 来复用需要频繁创建临时对象、使用全局变量等</li><li>增大 GOGC 的值，降低 GC 的运行频率</li></ul><a href=#go-如何查看-gc-信息><h2 id=go-如何查看-gc-信息><span class=hanchor arialabel=Anchor># </span>Go 如何查看 GC 信息？</h2></a><a href=#1-godebuggctrace1><h3 id=1-godebuggctrace1><span class=hanchor arialabel=Anchor># </span>1. GODEBUG=’gctrace=1’</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>n</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>n</span> <span class=p>&lt;</span> <span class=mi>100000</span><span class=p>;</span> <span class=nx>n</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>_</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>20</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ GODEBUG=&#39;gctrace=1&#39; go run main.go
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>gc 1 @0.003s 4%: 0.013+1.7+0.008 ms clock, 0.10+0.67/1.2/0.018+0.064 ms cpu, 4-&gt;6-&gt;2 MB, 5 MB goal, 8 P
</span></span><span class=line><span class=cl>gc 2 @0.006s 2%: 0.006+4.5+0.058 ms clock, 0.048+0.070/0.027/3.6+0.47 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P
</span></span><span class=line><span class=cl>gc 3 @0.011s 3%: 0.021+1.3+0.009 ms clock, 0.17+0.041/0.41/0.046+0.072 ms cpu, 4-&gt;6-&gt;2 MB, 5 MB goal, 8 P
</span></span><span class=line><span class=cl>gc 4 @0.013s 5%: 0.025+0.38+0.26 ms clock, 0.20+0.054/0.15/0.009+2.1 ms cpu, 4-&gt;6-&gt;2 MB, 5 MB goal, 8 P
</span></span><span class=line><span class=cl>gc 5 @0.014s 5%: 0.021+0.16+0.002 ms clock, 0.17+0.098/0.028/0.001+0.016 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P
</span></span><span class=line><span class=cl>gc 6 @0.014s 7%: 0.025+1.6+0.003 ms clock, 0.20+0.061/2.9/1.5+0.025 ms cpu, 4-&gt;6-&gt;2 MB, 5 MB goal, 8 P
</span></span><span class=line><span class=cl>gc 7 @0.016s 7%: 0.019+1.0+0.002 ms clock, 0.15+0.053/1.0/0.018+0.017 ms cpu, 4-&gt;6-&gt;2 MB, 5 MB goal, 8 P
</span></span><span class=line><span class=cl>gc 8 @0.017s 7%: 0.029+0.17+0.002 ms clock, 0.23+0.037/0.10/0.063+0.022 ms cpu, 4-&gt;4-&gt;0 MB, 5 MB goal, 8 P
</span></span><span class=line><span class=cl>gc 9 @0.018s 7%: 0.019+0.23+0.002 ms clock, 0.15+0.040/0.16/0.023+0.018 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P
</span></span><span class=line><span class=cl>gc 10 @0.018s 7%: 0.022+0.23+0.003 ms clock, 0.17+0.061/0.13/0.006+0.024 ms cpu, 4-&gt;6-&gt;2 MB, 5 MB goal, 8 P
</span></span><span class=line><span class=cl>gc 11 @0.018s 7%: 0.019+0.11+0.001 ms clock, 0.15+0.033/0.051/0.013+0.015 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P
</span></span><span class=line><span class=cl>gc 12 @0.019s 7%: 0.018+0.19+0.001 ms clock, 0.14+0.035/0.10/0.018+0.014 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P
</span></span><span class=line><span class=cl>gc 13 @0.019s 7%: 0.018+0.35+0.002 ms clock, 0.15+0.21/0.054/0.013+0.016 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P
</span></span><span class=line><span class=cl>gc 14 @0.019s 8%: 0.024+0.27+0.002 ms clock, 0.19+0.022/0.13/0.014+0.017 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P
</span></span><span class=line><span class=cl>gc 15 @0.020s 8%: 0.019+0.42+0.038 ms clock, 0.15+0.060/0.28/0.007+0.31 ms cpu, 4-&gt;17-&gt;13 MB, 5 MB goal, 8 P
</span></span><span class=line><span class=cl>gc 16 @0.021s 8%: 0.018+0.53+0.060 ms clock, 0.14+0.045/0.39/0.005+0.48 ms cpu, 21-&gt;28-&gt;7 MB, 26 MB goal, 8 P
</span></span><span class=line><span class=cl>gc 17 @0.021s 10%: 0.020+0.91+0.64 ms clock, 0.16+0.050/0.36/0.027+5.1 ms cpu, 12-&gt;16-&gt;4 MB, 14 MB goal, 8 P
</span></span><span class=line><span class=cl>gc 18 @0.023s 10%: 0.020+0.55+0.002 ms clock, 0.16+0.053/0.50/0.081+0.023 ms cpu, 7-&gt;9-&gt;2 MB, 8 MB goal, 8 P
</span></span></code></pre></td></tr></table></div></div><p>字段含义由下表所示：</p><table><thead><tr><th style=text-align:left>字段</th><th style=text-align:left>含义</th></tr></thead><tbody><tr><td style=text-align:left>gc 2</td><td style=text-align:left>第二个 GC 周期</td></tr><tr><td style=text-align:left>0.006</td><td style=text-align:left>程序开始后的 0.006 秒</td></tr><tr><td style=text-align:left>2%</td><td style=text-align:left>该 GC 周期中 CPU 的使用率</td></tr><tr><td style=text-align:left>0.006</td><td style=text-align:left>标记开始时， STW 所花费的时间（wall clock）</td></tr><tr><td style=text-align:left>4.5</td><td style=text-align:left>标记过程中，并发标记所花费的时间（wall clock）</td></tr><tr><td style=text-align:left>0.058</td><td style=text-align:left>标记终止时， STW 所花费的时间（wall clock）</td></tr><tr><td style=text-align:left>0.048</td><td style=text-align:left>标记开始时， STW 所花费的时间（cpu time）</td></tr><tr><td style=text-align:left>0.070</td><td style=text-align:left>标记过程中，标记辅助所花费的时间（cpu time）</td></tr><tr><td style=text-align:left>0.027</td><td style=text-align:left>标记过程中，并发标记所花费的时间（cpu time）</td></tr><tr><td style=text-align:left>3.6</td><td style=text-align:left>标记过程中，GC 空闲的时间（cpu time）</td></tr><tr><td style=text-align:left>0.47</td><td style=text-align:left>标记终止时， STW 所花费的时间（cpu time）</td></tr><tr><td style=text-align:left>4</td><td style=text-align:left>标记开始时，堆的大小的实际值</td></tr><tr><td style=text-align:left>5</td><td style=text-align:left>标记结束时，堆的大小的实际值</td></tr><tr><td style=text-align:left>1</td><td style=text-align:left>标记结束时，标记为存活的对象大小</td></tr><tr><td style=text-align:left>5</td><td style=text-align:left>标记结束时，堆的大小的预测值</td></tr><tr><td style=text-align:left>8</td><td style=text-align:left>P 的数量</td></tr></tbody></table><a href=#2-go-tool-trace><h3 id=2-go-tool-trace><span class=hanchor arialabel=Anchor># </span>2. Go tool trace</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;os&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;runtime/trace&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>f</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Create</span><span class=p>(</span><span class=s>&#34;trace.out&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>trace</span><span class=p>.</span><span class=nf>Start</span><span class=p>(</span><span class=nx>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>trace</span><span class=p>.</span><span class=nf>Stop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>n</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>n</span> <span class=p>&lt;</span> <span class=mi>100000</span><span class=p>;</span> <span class=nx>n</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>_</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>20</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ go run main.go
</span></span><span class=line><span class=cl>$ go tool trace trace.out
</span></span></code></pre></td></tr></table></div></div><p>打开浏览器后，可以看到如下统计：
<img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226004606.png width=auto alt=image.png></p><p>点击 View trace，可以查看当时的 trace 情况
<img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226004617.png width=auto alt=image.png></p><p>点击 Minimum mutator utilization，可以查看到赋值器 mutator （用户程序）对 CPU 的利用率 74.1%，接近 100%则代表没有针对 GC 的优化空间了
<img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226004625.png width=auto alt=image.png></p><a href=#3-debug-readgcstats><h3 id=3-debug-readgcstats><span class=hanchor arialabel=Anchor># </span>3. Debug. ReadGCStats</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;runtime/debug&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>printGCStats</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>NewTicker</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>s</span> <span class=o>:=</span> <span class=nx>debug</span><span class=p>.</span><span class=nx>GCStats</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>t</span><span class=p>.</span><span class=nx>C</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nx>debug</span><span class=p>.</span><span class=nf>ReadGCStats</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;gc %d last@%v, PauseTotal %v\n&#34;</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nx>NumGC</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nx>LastGC</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nx>PauseTotal</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>printGCStats</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>n</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>n</span> <span class=p>&lt;</span> <span class=mi>100000</span><span class=p>;</span> <span class=nx>n</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>_</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>20</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ go run main.go
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>gc 3392 last@2022-05-04 19:22:52.877293 +0800 CST, PauseTotal 117.524907ms
</span></span><span class=line><span class=cl>gc 6591 last@2022-05-04 19:22:53.876837 +0800 CST, PauseTotal 253.254996ms
</span></span><span class=line><span class=cl>gc 10028 last@2022-05-04 19:22:54.87674 +0800 CST, PauseTotal 376.981595ms
</span></span><span class=line><span class=cl>gc 13447 last@2022-05-04 19:22:55.87689 +0800 CST, PauseTotal 511.420111ms
</span></span><span class=line><span class=cl>gc 16938 last@2022-05-04 19:22:56.876955 +0800 CST, PauseTotal 649.293449ms
</span></span><span class=line><span class=cl>gc 20350 last@2022-05-04 19:22:57.876756 +0800 CST, PauseTotal 788.003014ms
</span></span></code></pre></td></tr></table></div></div><p>字段含义由下表所示：</p><table><thead><tr><th style=text-align:left>字段</th><th style=text-align:left>含义</th></tr></thead><tbody><tr><td style=text-align:left>NumGC</td><td style=text-align:left>GC 总次数</td></tr><tr><td style=text-align:left>LastGC</td><td style=text-align:left>上次 GC 时间</td></tr><tr><td style=text-align:left>PauseTotal</td><td style=text-align:left>STW 总耗时</td></tr></tbody></table><a href=#4-runtime-readmemstats><h3 id=4-runtime-readmemstats><span class=hanchor arialabel=Anchor># </span>4. Runtime. ReadMemStats</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;runtime&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>printMemStats</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>NewTicker</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>s</span> <span class=o>:=</span> <span class=nx>runtime</span><span class=p>.</span><span class=nx>MemStats</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>t</span><span class=p>.</span><span class=nx>C</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nx>runtime</span><span class=p>.</span><span class=nf>ReadMemStats</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;gc %d last@%v, heap_object_num: %v, heap_alloc: %vMB, next_heap_size: %vMB\n&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nx>s</span><span class=p>.</span><span class=nx>NumGC</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Unix</span><span class=p>(</span><span class=nb>int64</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Duration</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>LastGC</span><span class=p>).</span><span class=nf>Seconds</span><span class=p>()),</span> <span class=mi>0</span><span class=p>),</span> <span class=nx>s</span><span class=p>.</span><span class=nx>HeapObjects</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nx>HeapAlloc</span><span class=o>/</span><span class=p>(</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>20</span><span class=p>),</span> <span class=nx>s</span><span class=p>.</span><span class=nx>NextGC</span><span class=o>/</span><span class=p>(</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>20</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>printMemStats</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>20</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>n</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>n</span> <span class=p>&lt;</span> <span class=mi>100000</span><span class=p>;</span> <span class=nx>n</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>_</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>20</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ go run main.go
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>gc 2978 last@2022-05-04 19:38:04 +0800 CST, heap_object_num: 391, heap_alloc: 20MB, next_heap_size: 28MB
</span></span><span class=line><span class=cl>gc 5817 last@2022-05-04 19:38:05 +0800 CST, heap_object_num: 370, heap_alloc: 4MB, next_heap_size: 4MB
</span></span><span class=line><span class=cl>gc 9415 last@2022-05-04 19:38:06 +0800 CST, heap_object_num: 392, heap_alloc: 7MB, next_heap_size: 8MB
</span></span><span class=line><span class=cl>gc 11429 last@2022-05-04 19:38:07 +0800 CST, heap_object_num: 339, heap_alloc: 4MB, next_heap_size: 5MB
</span></span><span class=line><span class=cl>gc 14706 last@2022-05-04 19:38:08 +0800 CST, heap_object_num: 436, heap_alloc: 6MB, next_heap_size: 8MB
</span></span><span class=line><span class=cl>gc 18253 last@2022-05-04 19:38:09 +0800 CST, heap_object_num: 375, heap_alloc: 4MB, next_heap_size: 6M
</span></span></code></pre></td></tr></table></div></div><p>字段含义由下表所示：</p><table><thead><tr><th style=text-align:left>字段</th><th style=text-align:left>含义</th></tr></thead><tbody><tr><td style=text-align:left>NumGC</td><td style=text-align:left>GC 总次数</td></tr><tr><td style=text-align:left>LastGC</td><td style=text-align:left>上次 GC 时间</td></tr><tr><td style=text-align:left>HeapObjects</td><td style=text-align:left>堆中已经分配的对象总数，GC 内存回收后 HeapObjects 取值相应减小</td></tr><tr><td style=text-align:left>HeapAlloc</td><td style=text-align:left>堆中已经分配给对象的字节数，GC 内存回收后 HeapAlloc 取值相应减小</td></tr><tr><td style=text-align:left>NextGC</td><td style=text-align:left>下次 GC 目标堆的大小</td></tr></tbody></table></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://googoo-s.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by googoo-s using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2024</p><ul><li><a href=https://googoo-s.github.io/>Home</a></li><li><a href=https://github.com/googoo-s>GitHub</a></li></ul></footer></div></div></body></html>