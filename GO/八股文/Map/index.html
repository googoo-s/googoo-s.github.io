<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Go Map 的查询复杂度 空间复杂度: 先我们不考虑因删除大量元素导致的空间浪费情况（这种情况现在 go 是留给程序员自己解决），只考虑一个持续增长状态的 map 的一个空间使用率：
由于溢出桶数量超过 hash 桶数量时会触发缩容，所以最坏的情况是数据被集中在一条链上，hash 表基本是空的，这时空间浪费 O (n)。
最好的情况下，数据均匀散列在 hash 表上，没有元素溢出，这时最好的空间复杂度就是扩散因子决定了，当前 go 的扩散因子由全局变量决定，即 loadFactorNum/loadFactorDen = 6."><meta property="og:title" content><meta property="og:description" content="Go Map 的查询复杂度 空间复杂度: 先我们不考虑因删除大量元素导致的空间浪费情况（这种情况现在 go 是留给程序员自己解决），只考虑一个持续增长状态的 map 的一个空间使用率：
由于溢出桶数量超过 hash 桶数量时会触发缩容，所以最坏的情况是数据被集中在一条链上，hash 表基本是空的，这时空间浪费 O (n)。
最好的情况下，数据均匀散列在 hash 表上，没有元素溢出，这时最好的空间复杂度就是扩散因子决定了，当前 go 的扩散因子由全局变量决定，即 loadFactorNum/loadFactorDen = 6."><meta property="og:type" content="website"><meta property="og:image" content="https://googoo-s.github.io/icon.png"><meta property="og:url" content="https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/Map/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Go Map 的查询复杂度 空间复杂度: 先我们不考虑因删除大量元素导致的空间浪费情况（这种情况现在 go 是留给程序员自己解决），只考虑一个持续增长状态的 map 的一个空间使用率：
由于溢出桶数量超过 hash 桶数量时会触发缩容，所以最坏的情况是数据被集中在一条链上，hash 表基本是空的，这时空间浪费 O (n)。
最好的情况下，数据均匀散列在 hash 表上，没有元素溢出，这时最好的空间复杂度就是扩散因子决定了，当前 go 的扩散因子由全局变量决定，即 loadFactorNum/loadFactorDen = 6."><meta name=twitter:image content="https://googoo-s.github.io/icon.png"><title>googoo-s 😄😸😎</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://googoo-s.github.io//icon.png><link href=https://googoo-s.github.io/styles.19109a40042e9f0e72e952fda4442a34.min.css rel=stylesheet><link href=https://googoo-s.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://googoo-s.github.io/js/darkmode.953af745b0f9342644d632fc167f3727.min.js></script>
<script src=https://googoo-s.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://googoo-s.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://googoo-s.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://googoo-s.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://googoo-s.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://googoo-s.github.io/",fetchData=Promise.all([fetch("https://googoo-s.github.io/indices/linkIndex.3bfb24158f5e9d4aff66ae07a3a8bd0d.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://googoo-s.github.io/indices/contentIndex.8972f3e1fb9ffb8fdb949f104473fa8d.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://googoo-s.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://googoo-s.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/googoo-s.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=googoo-s.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://googoo-s.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://googoo-s.github.io/>googoo-s 😄😸😎</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Unknown</p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#go-map-的查询复杂度>Go Map 的查询复杂度</a></li><li><a href=#map-的-key-可以是哪些类型可以嵌套-map-吗>Map 的 key 可以是哪些类型？可以嵌套 map 吗？</a></li><li><a href=#map-怎么知道自己处于竞争状态是-go-编码实现的还是底层硬件实现的>Map 怎么知道自己处于竞争状态？是 Go 编码实现的还是底层硬件实现的？</a></li><li><a href=#map-的-panic-能被-recover-掉吗了解-panic-和-recover-的机制>Map 的 panic 能被 recover 掉吗？了解 panic 和 recover 的机制？</a></li><li><a href=#go-中两个-map-对象如何比较>Go 中两个 map 对象如何比较</a></li><li><a href=#map-的优缺点以及改进>Map 的优缺点以及改进?</a></li><li><a href=#sync-map-怎么使用>Sync. Map 怎么使用</a></li><li><a href=#如果一个-map-没申请空间去向里面取值会发生什么情况>如果一个 map 没申请空间，去向里面取值，会发生什么情况</a></li><li><a href=#sync-map-底层数据结构>Sync. Map 底层数据结构</a></li><li><a href=#go-map-的底层实现原理>Go map 的底层实现原理？</a></li><li><a href=#go-map-遍历为什么是无序的>Go map 遍历为什么是无序的？</a></li><li><a href=#go-map-为什么是非线程安全的>Go map 为什么是非线程安全的？</a></li><li><a href=#go-map-如何查找>Go map 如何查找？</a></li><li><a href=#go-map-冲突的解决方式>Go map 冲突的解决方式？</a></li><li><a href=#go-map-的负载因子为什么是-65>Go map 的负载因子为什么是 6.5？</a></li><li><a href=#go-map-如何扩容>Go map 如何扩容?</a></li><li><a href=#go-map-和-sync-map-谁的性能好为什么>Go map 和 sync. Map 谁的性能好，为什么？</a></li></ol></nav></details></aside><a href=#go-map-的查询复杂度><h1 id=go-map-的查询复杂度><span class=hanchor arialabel=Anchor># </span>Go Map 的查询复杂度</h1></a><p><strong>空间复杂度</strong>:
先我们不考虑因删除大量元素导致的空间浪费情况（这种情况现在 go 是留给程序员自己解决），只考虑一个持续增长状态的 map 的一个空间使用率：</p><p>由于溢出桶数量超过 hash 桶数量时会触发缩容，所以最坏的情况是数据被集中在一条链上，hash 表基本是空的，这时空间浪费 O (n)。<br>最好的情况下，数据均匀散列在 hash 表上，没有元素溢出，这时最好的空间复杂度就是扩散因子决定了，当前 go 的扩散因子由全局变量决定，即 loadFactorNum/loadFactorDen = 6.5。即平均每个 hash 桶被分配到 6.5 个元素以上时，开始扩容。所以最小的空间浪费是 (8-6.5)/8 = 0.1875，即 O (0.1875n)</p><p>结论：go map 的空间复杂度（指除去正常存储元素所需空间之外的空间浪费）是 O (0.1875 n) ~ O (n)之间。<br>​ 具体细节：
<a href=https://blog.csdn.net/dongjijiaoxiangqu/article/details/109643025 rel=noopener>https://blog.csdn.net/dongjijiaoxiangqu/article/details/109643025</a> </p><p><strong>时间复杂度</strong>：</p><p>Go 采用的 hash 算法应是很成熟的算法，极端情况暂不考虑。所以综合情况下 go map 的时间复杂度应为 O(1)</p><a href=#map-的-key-可以是哪些类型可以嵌套-map-吗><h1 id=map-的-key-可以是哪些类型可以嵌套-map-吗><span class=hanchor arialabel=Anchor># </span>Map 的 key 可以是哪些类型？可以嵌套 map 吗？</h1></a><p>Map key 必须是可比较的类型，语言规范中定义了可比较的类型：boolean, numeric, string, pointer, channel, interface, 以及仅包含这些类型的 struct 和 array 。**不能作为 map key 的类型有：slice，map, function。**可以嵌套 map。</p><a href=#map-怎么知道自己处于竞争状态是-go-编码实现的还是底层硬件实现的><h1 id=map-怎么知道自己处于竞争状态是-go-编码实现的还是底层硬件实现的><span class=hanchor arialabel=Anchor># </span>Map 怎么知道自己处于竞争状态？是 Go 编码实现的还是底层硬件实现的？</h1></a><p>代码实现的，在查找、赋值、遍历、删除的过程中都会检测写标志 flags，一旦发现写标志置位 (等于 1)，则直接 panic。赋值和删除函数载检测完标志是复位状态 (等于 0)之后，先将写标志位置位，才会进行之后的操作。</p><a href=#map-的-panic-能被-recover-掉吗了解-panic-和-recover-的机制><h1 id=map-的-panic-能被-recover-掉吗了解-panic-和-recover-的机制><span class=hanchor arialabel=Anchor># </span>Map 的 panic 能被 recover 掉吗？了解 panic 和 recover 的机制？</h1></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func main() {
</span></span><span class=line><span class=cl>    defer errorHandler()
</span></span><span class=line><span class=cl>    m := map[string]int{}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    go func() {
</span></span><span class=line><span class=cl>        for {
</span></span><span class=line><span class=cl>            m[&#34;x&#34;] = 1
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }()
</span></span><span class=line><span class=cl>    for {
</span></span><span class=line><span class=cl>        _ = m[&#34;x&#34;]
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func errorHandler() {
</span></span><span class=line><span class=cl>    if r := recover(); r != nil {
</span></span><span class=line><span class=cl>        fmt.Println(r)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}//不能
</span></span></code></pre></td></tr></table></div></div><p>Map 由于不是线程安全的，所以在遇到并发读写的时候会抛出 concurrent map read and map write 异常，从而使程序直接退出。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer {
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    if h.flags&amp;hashWriting != 0 {
</span></span><span class=line><span class=cl>        throw(&#34;concurrent map read and map write&#34;)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>｝
</span></span></code></pre></td></tr></table></div></div><p>这里的 throw 和上面一样，最终会调用到 exit 执行退出。</p><a href=#go-中两个-map-对象如何比较><h1 id=go-中两个-map-对象如何比较><span class=hanchor arialabel=Anchor># </span>Go 中两个 map 对象如何比较</h1></a><p>使用 reflect. DeepEqual 这个函数进行比较。使用 reflect. DeepEqual 有一点注意：由于使用了反射，所以有性能的损失。如果你多做一些测试，那么你会发现 reflect. DeepEqual 会比 == 慢 100 倍以上。</p><a href=#map-的优缺点以及改进><h1 id=map-的优缺点以及改进><span class=hanchor arialabel=Anchor># </span>Map 的优缺点以及改进?</h1></a><p><strong>优点</strong>：</p><ol><li><p>Map 类似其他语言中的哈希表或字典，以 key-value 形式存储数据</p></li><li><p>Key 必须是支持==或!=比较运算的类型，不可以是函数、map 或 slice</p></li><li><p>Map 通过 key 查找 value 比线性搜索快很多。</p></li><li><p>Map 使用 make ()创建，支持:=这种简写方式</p></li><li><p>超出容量时会自动扩容，</p></li><li><p>当键值对不存在时自动添加，使用 delete ()删除某键值对</p></li></ol><p><strong>缺点：</strong></p><p>并发中的 map 不是安全的</p><a href=#sync-map-怎么使用><h1 id=sync-map-怎么使用><span class=hanchor arialabel=Anchor># </span>Sync. Map 怎么使用</h1></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;sync&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>scene</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Map</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 将键值对保存到sync.Map
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>scene</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=s>&#34;1&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>scene</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=s>&#34;2&#34;</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>scene</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=s>&#34;3&#34;</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 从sync.Map中根据键取值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>scene</span><span class=p>.</span><span class=nf>Load</span><span class=p>(</span><span class=s>&#34;1&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 根据键删除对应的键值对
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>scene</span><span class=p>.</span><span class=nf>Delete</span><span class=p>(</span><span class=s>&#34;1&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 遍历所有sync.Map中的键值对
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>scene</span><span class=p>.</span><span class=nf>Range</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;iterate:&#34;</span><span class=p>,</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#如果一个-map-没申请空间去向里面取值会发生什么情况><h1 id=如果一个-map-没申请空间去向里面取值会发生什么情况><span class=hanchor arialabel=Anchor># </span>如果一个 map 没申请空间，去向里面取值，会发生什么情况</h1></a><p>在 map 查询操作中，最多可以给两个变量赋值，第一个为值，第二个为 bool 类型的变量，用于指示是否存在指定的键，如果键不存在，那么第一个值为相应类型的零值。如果只指定一个变量，那么该变量仅表示改键对应的值，如果键不存在，那么该值同样为相应类型的零值</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>myMap</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span> <span class=c1>// 未初始化的 map
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>value</span> <span class=o>:=</span> <span class=nx>myMap</span><span class=p>[</span><span class=s>&#34;some_key&#34;</span><span class=p>]</span> <span class=c1>// 尝试获取一个键的值
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>//panic: assignment to entry in nil map
</span></span></span></code></pre></td></tr></table></div></div><a href=#sync-map-底层数据结构><h1 id=sync-map-底层数据结构><span class=hanchor arialabel=Anchor># </span>Sync. Map 底层数据结构</h1></a><p><img src=https://blog-1314857283.cos.ap-shanghai.myqcloud.com/images/202309221401184.png width=auto alt=image-20230922140118984></p><p><img src=https://blog-1314857283.cos.ap-shanghai.myqcloud.com/images/202309221401220.png width=auto alt=image-20230922140130100></p><p><img src=https://blog-1314857283.cos.ap-shanghai.myqcloud.com/images/202309221401144.png width=auto alt=image-20230922140139039></p><p><img src=https://blog-1314857283.cos.ap-shanghai.myqcloud.com/images/202309221401990.png width=auto alt=image-20230922140145882></p><p><img src=https://blog-1314857283.cos.ap-shanghai.myqcloud.com/images/202309221401528.png width=auto alt=image-20230922140150436></p><p><img src=https://blog-1314857283.cos.ap-shanghai.myqcloud.com/images/202309221402243.png width=auto alt=image-20230922140201135></p><a href=#go-map-的底层实现原理><h1 id=go-map-的底层实现原理><span class=hanchor arialabel=Anchor># </span>Go map 的底层实现原理？</h1></a><p>Go 中的 map 是一个指针，占用 8 个字节，指向 hmap 结构体</p><p>源码包中 <code>src/runtime/map.go</code> 定义了 hmap 的数据结构：</p><p>Hmap 包含若干个结构为 bmap 的数组，每个 bmap 底层都采用链表结构，bmap 通常叫其 bucket</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240225233011.png width=auto alt=image.png></p><p><strong>hmap 结构体</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// A header for a Go map.
</span></span><span class=line><span class=cl>type hmap struct {
</span></span><span class=line><span class=cl>    count     int 
</span></span><span class=line><span class=cl>    // 代表哈希表中的元素个数，调用len(map)时，返回的就是该字段值。
</span></span><span class=line><span class=cl>    flags     uint8 
</span></span><span class=line><span class=cl>    // 状态标志（是否处于正在写入的状态等）
</span></span><span class=line><span class=cl>    B         uint8  
</span></span><span class=line><span class=cl>    // buckets（桶）的对数
</span></span><span class=line><span class=cl>    // 如果B=5，则buckets数组的长度 = 2^B=32，意味着有32个桶
</span></span><span class=line><span class=cl>    noverflow uint16 
</span></span><span class=line><span class=cl>    // 溢出桶的数量
</span></span><span class=line><span class=cl>    hash0     uint32 
</span></span><span class=line><span class=cl>    // 生成hash的随机数种子
</span></span><span class=line><span class=cl>    buckets    unsafe.Pointer 
</span></span><span class=line><span class=cl>    // 指向buckets数组的指针，数组大小为2^B，如果元素个数为0，它为nil。
</span></span><span class=line><span class=cl>    oldbuckets unsafe.Pointer 
</span></span><span class=line><span class=cl>    // 如果发生扩容，oldbuckets是指向老的buckets数组的指针，老的buckets数组大小是新的buckets的1/2;非扩容状态下，它为nil。
</span></span><span class=line><span class=cl>    nevacuate  uintptr        
</span></span><span class=line><span class=cl>    // 表示扩容进度，小于此地址的buckets代表已搬迁完成。
</span></span><span class=line><span class=cl>    extra *mapextra 
</span></span><span class=line><span class=cl>    // 存储溢出桶，这个字段是为了优化GC扫描而设计的，下面详细介绍
</span></span><span class=line><span class=cl> }
</span></span></code></pre></td></tr></table></div></div><p><strong>bmap 结构体</strong></p><p><code>bmap</code> 就是我们常说的“桶”，一个桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果的低 B 位是相同的，关于 key 的定位我们在 map 的查询中详细说明。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有8个位置)。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// A bucket for a Go map.
</span></span><span class=line><span class=cl>type bmap struct {
</span></span><span class=line><span class=cl>    tophash [bucketCnt]uint8        
</span></span><span class=line><span class=cl>    // len为8的数组
</span></span><span class=line><span class=cl>    // 用来快速定位key是否在这个bmap中
</span></span><span class=line><span class=cl>    // 一个桶最多8个槽位，如果key所在的tophash值在tophash中，则代表该key在这个桶中
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>上面 bmap 结构是静态结构，在编译过程中 <code>runtime.bmap</code> 会拓展成以下结构体：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type bmap struct{
</span></span><span class=line><span class=cl>    tophash [8]uint8
</span></span><span class=line><span class=cl>    keys [8]keytype 
</span></span><span class=line><span class=cl>    // keytype 由编译器编译时候确定
</span></span><span class=line><span class=cl>    values [8]elemtype 
</span></span><span class=line><span class=cl>    // elemtype 由编译器编译时候确定
</span></span><span class=line><span class=cl>    overflow uintptr 
</span></span><span class=line><span class=cl>    // overflow指向下一个bmap，overflow是uintptr而不是*bmap类型，保证bmap完全不含指针，是为了减少gc，溢出桶存储到extra字段中
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Tophash 就是用于实现快速定位 key 的位置，在实现过程中会使用 key 的 hash 值的高 8 位作为 tophash 值，存放在 bmap 的 tophash 字段中</p><p>Tophash 字段不仅存储 key 哈希值的高 8 位，还会存储一些状态值，用来表明当前桶单元状态，这些状态值都是小于 minTopHash 的</p><p>为了避免 key 哈希值的高 8 位值和这些状态值相等，产生混淆情况，所以当 key 哈希值高 8 位若小于 minTopHash 时候，自动将其值加上 minTopHash 作为该 key 的 tophash。桶单元的状态值如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>emptyRest      = 0 // 表明此桶单元为空，且更高索引的单元也是空
</span></span><span class=line><span class=cl>emptyOne       = 1 // 表明此桶单元为空
</span></span><span class=line><span class=cl>evacuatedX     = 2 // 用于表示扩容迁移到新桶前半段区间
</span></span><span class=line><span class=cl>evacuatedY     = 3 // 用于表示扩容迁移到新桶后半段区间
</span></span><span class=line><span class=cl>evacuatedEmpty = 4 // 用于表示此单元已迁移
</span></span><span class=line><span class=cl>minTopHash     = 5 // key的tophash值与桶状态值分割线值，小于此值的一定代表着桶单元的状态，大于此值的一定是key对应的tophash值
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func tophash(hash uintptr) uint8 {
</span></span><span class=line><span class=cl>    top := uint8(hash &gt;&gt; (goarch.PtrSize*8 - 8))
</span></span><span class=line><span class=cl>    if top &lt; minTopHash {
</span></span><span class=line><span class=cl>        top += minTopHash
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    return top
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><strong>mapextra 结构体</strong></p><p>当 map 的 key 和 value 都不是指针类型时候，bmap 将完全不包含指针，那么 gc 时候就不用扫描 bmap。Bmap 指向溢出桶的字段 overflow 是 uintptr 类型，为了防止这些 overflow 桶被 gc 掉，所以需要 mapextra. Overflow 将它保存起来。如果 bmap 的 overflow 是bmap 类型，那么 gc 扫描的是一个个拉链表，效率明显不如直接扫描一段内存(hmap.Mapextra.Overflow)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type mapextra struct {
</span></span><span class=line><span class=cl>    overflow    *[]*bmap
</span></span><span class=line><span class=cl>    // overflow 包含的是 hmap.buckets 的 overflow 的 buckets
</span></span><span class=line><span class=cl>    oldoverflow *[]*bma
</span></span><span class=line><span class=cl>   // oldoverflow 包含扩容时 hmap.oldbuckets 的 overflow 的 bucket
</span></span><span class=line><span class=cl>    nextOverflow *bmap 
</span></span><span class=line><span class=cl>     // 指向空闲的 overflow bucket 的指针
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><strong>总结</strong></p><p>Bmap（bucket）内存数据结构可视化如下:</p><p>注意到 key 和 value 是各自放在一起的，并不是 <code>key/value/key/value/...</code> 这样的形式，当 key 和 value 类型不一样的时候，key 和 value 占用字节大小不一样，使用 key/value 这种形式可能会因为内存对齐导致内存空间浪费，所以 Go 采用 key 和 value 分开存储的设计，更节省内存空间
<img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240225233151.png width=auto alt=image.png></p><a href=#go-map-遍历为什么是无序的><h1 id=go-map-遍历为什么是无序的><span class=hanchor arialabel=Anchor># </span>Go map 遍历为什么是无序的？</h1></a><p>使用 range 多次遍历 map 时输出的 key 和 value 的顺序可能不同。这是 Go 语言的设计者们<strong>有意为之</strong>，旨在提示开发者们，Go 底层实现并不保证 map 遍历顺序稳定，请大家不要依赖 range 遍历结果顺序</p><p>主要原因有 2 点：</p><ul><li>Map 在遍历时，并不是从固定的 0 号 bucket 开始遍历的，每次遍历，都会从一个<strong>随机值序号的 bucket</strong>，再从其中<strong>随机的 cell</strong>开始遍历</li><li>Map 遍历时，是按序遍历 bucket，同时按需遍历 bucket 中和其 overflow bucket 中的 cell。但是 map 在扩容后，会发生 key 的搬迁，这造成原来落在一个 bucket 中的 key，搬迁后，有可能会落到其他 bucket 中了，从这个角度看，遍历 map 的结果就不可能是按照原来的顺序了</li></ul><p>Map 本身是无序的，且遍历时顺序还会被随机化，如果想顺序遍历 map，需要对 map key 先排序，再按照 key 的顺序遍历 map。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func TestMapRange(t *testing.T) {
</span></span><span class=line><span class=cl>    m := map[int]string{1: &#34;a&#34;, 2: &#34;b&#34;, 3: &#34;c&#34;}
</span></span><span class=line><span class=cl>    t.Log(&#34;first range:&#34;)
</span></span><span class=line><span class=cl>    for i, v := range m {
</span></span><span class=line><span class=cl>        t.Logf(&#34;m[%v]=%v &#34;, i, v)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    t.Log(&#34;\nsecond range:&#34;)
</span></span><span class=line><span class=cl>    for i, v := range m {
</span></span><span class=line><span class=cl>        t.Logf(&#34;m[%v]=%v &#34;, i, v)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // 实现有序遍历
</span></span><span class=line><span class=cl>    var sl []int
</span></span><span class=line><span class=cl>    // 把 key 单独取出放到切片
</span></span><span class=line><span class=cl>    for k := range m {
</span></span><span class=line><span class=cl>        sl = append(sl, k)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    // 排序切片
</span></span><span class=line><span class=cl>    sort.Ints(sl)
</span></span><span class=line><span class=cl>    // 以切片中的 key 顺序遍历 map 就是有序的了
</span></span><span class=line><span class=cl>    for _, k := range sl {
</span></span><span class=line><span class=cl>        t.Log(k, m[k])
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#go-map-为什么是非线程安全的><h1 id=go-map-为什么是非线程安全的><span class=hanchor arialabel=Anchor># </span>Go map 为什么是非线程安全的？</h1></a><p>Map 默认是并发不安全的，同时对 map 进行并发读写时，程序会 panic，原因如下：</p><p>Go 官方在经过了长时间的讨论后，认为 Go map 更应适配典型使用场景（不需要从多个 goroutine 中进行安全访问），而不是为了小部分情况（并发访问），导致大部分程序付出加锁代价（性能），决定了不支持。</p><p>场景: 2 个协程同时读和写，以下程序会出现致命错误：fatal error: concurrent map writes</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>s</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>100</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>        <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>100</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;map第%d个元素值是%d\n&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>如果想实现 map 线程安全，有两种方式：</p><p>方式一：使用读写锁 <code>map</code> + <code>sync.RWMutex</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;sync&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>lock</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
</span></span><span class=line><span class=cl>    <span class=nx>s</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>100</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>            <span class=nx>lock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>100</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>lock</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;map第%d个元素值是%d\n&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=nx>lock</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>方式二：使用 Go 提供的 <code>sync.Map</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;sync&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>m</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Map</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>100</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>m</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>100</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>v</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nf>Load</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Load: %v, %v\n&#34;</span><span class=p>,</span> <span class=nx>v</span><span class=p>,</span> <span class=nx>ok</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#go-map-如何查找><h1 id=go-map-如何查找><span class=hanchor arialabel=Anchor># </span>Go map 如何查找？</h1></a><p>Go 语言中读取 map 有两种语法：带 comma 和不带 comma。当要查询的 key 不在 map 里，带 comma 的用法会返回一个 bool 型变量提示 key 是否在 map 中；而不带 comma 的语句则会返回一个 value 类型的零值。如果 value 是 int 型就会返回 0，如果 value 是 string 类型，就会返回空字符串。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// 不带 comma 用法
</span></span><span class=line><span class=cl>value := m[&#34;name&#34;]
</span></span><span class=line><span class=cl>fmt.Printf(&#34;value:%s&#34;, value)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 带 comma 用法
</span></span><span class=line><span class=cl>value, ok := m[&#34;name&#34;]
</span></span><span class=line><span class=cl>if ok {
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;value:%s&#34;, value)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Map 的查找通过生成汇编码可以知道，根据 key 的不同类型/返回参数，编译器会将查找函数用更具体的函数替换，以优化效率：</p><table><thead><tr><th style=text-align:left>key 类型</th><th style=text-align:left>查找</th></tr></thead><tbody><tr><td style=text-align:left>uint 32</td><td style=text-align:left>mapaccess 1_fast 32 (t <em>maptype, h</em> hmap, key uint 32) unsafe. Pointer</td></tr><tr><td style=text-align:left>uint 32</td><td style=text-align:left>mapaccess 2_fast 32 (t <em>maptype, h</em> hmap, key uint 32) (unsafe. Pointer, bool)</td></tr><tr><td style=text-align:left>uint 64</td><td style=text-align:left>mapaccess 1_fast 64 (t <em>maptype, h</em> hmap, key uint 64) unsafe. Pointer</td></tr><tr><td style=text-align:left>uint 64</td><td style=text-align:left>mapaccess 2_fast 64 (t <em>maptype, h</em> hmap, key uint 64) (unsafe. Pointer, bool)</td></tr><tr><td style=text-align:left>string</td><td style=text-align:left>mapaccess 1_faststr (t <em>maptype, h</em> hmap, ky string) unsafe. Pointer</td></tr><tr><td style=text-align:left>string</td><td style=text-align:left>mapaccess 2_faststr (t <em>maptype, h</em> hmap, ky string) (unsafe. Pointer, bool)</td></tr></tbody></table><p><strong>查找流程</strong>
<img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240225233311.png width=auto alt=image.png></p><p><strong>1. 写保护监测</strong></p><p>函数首先会检查 map 的标志位 flags。如果 flags 的写标志位此时被置 1 了，说明有其他协程在执行“写”操作，进而导致程序 panic，这也说明了 map 不是线程安全的</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>if h.flags&amp;hashWriting != 0 {
</span></span><span class=line><span class=cl>    throw(&#34;concurrent map read and map write&#34;)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><strong>2. 计算 hash 值</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>hash := t.hasher(key, uintptr(h.hash0))
</span></span></code></pre></td></tr></table></div></div><p>Key 经过哈希函数计算后，得到的哈希值如下（主流 64 位机下共 64 个 bit 位），不同类型的 key 会有不同的 hash 函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>10010111 | 000011110110110010001111001010100010010110010101010 │ 01010
</span></span></code></pre></td></tr></table></div></div><p><strong>3. 找到 hash 对应的 bucket</strong></p><p>Bucket 定位：<strong>哈希值的低 B 个 bit 位</strong>，用来定位 key 所存放的 bucket</p><p>如果当前正在扩容中，并且定位到的旧 bucket 数据还未完成迁移，则使用旧的 bucket（扩容前的 bucket）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>hash := t.hasher(key, uintptr(h.hash0))
</span></span><span class=line><span class=cl>// 桶的个数m-1，即 1&lt;&lt;B-1,B=5时，则有0~31号桶
</span></span><span class=line><span class=cl>m := bucketMask(h.B)
</span></span><span class=line><span class=cl>// 计算哈希值对应的bucket
</span></span><span class=line><span class=cl>// t.bucketsize为一个bmap的大小，通过对哈希值和桶个数取模得到桶编号，通过对桶编号和buckets起始地址进行运算，获取哈希值对应的bucket
</span></span><span class=line><span class=cl>b := (*bmap)(add(h.buckets, (hash&amp;m)*uintptr(t.bucketsize)))
</span></span><span class=line><span class=cl>// 是否在扩容
</span></span><span class=line><span class=cl>if c := h.oldbuckets; c != nil {
</span></span><span class=line><span class=cl>  // 桶个数已经发生增长一倍，则旧bucket的桶个数为当前桶个数的一半
</span></span><span class=line><span class=cl>    if !h.sameSizeGrow() {
</span></span><span class=line><span class=cl>        // There used to be half as many buckets; mask down one more power of two.
</span></span><span class=line><span class=cl>        m &gt;&gt;= 1
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    // 计算哈希值对应的旧bucket
</span></span><span class=line><span class=cl>    oldb := (*bmap)(add(c, (hash&amp;m)*uintptr(t.bucketsize)))
</span></span><span class=line><span class=cl>    // 如果旧bucket的数据没有完成迁移，则使用旧bucket查找
</span></span><span class=line><span class=cl>    if !evacuated(oldb) {
</span></span><span class=line><span class=cl>        b = oldb
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><strong>4. 遍历 bucket 查找</strong></p><p>Tophash 值定位：<strong>哈希值的高 8 个 bit 位</strong>，用来快速判断 key 是否已在当前 bucket 中（如果不在的话，需要去 bucket 的 overflow 中查找）</p><p>用步骤 2 中的 hash 值，得到高 8 个 bit 位，也就是 <code>10010111</code>，转化为十进制，也就是<strong>151</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>top := tophash(hash)
</span></span><span class=line><span class=cl>func tophash(hash uintptr) uint8 {
</span></span><span class=line><span class=cl>    top := uint8(hash &gt;&gt; (goarch.PtrSize*8 - 8))
</span></span><span class=line><span class=cl>    if top &lt; minTopHash {
</span></span><span class=line><span class=cl>        top += minTopHash
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    return top
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>上面函数中 hash 是 64 位的，sys. PtrSize 值是 8，所以 <code>top := uint8(hash >> (sys.PtrSize*8 - 8))</code> 等效 <code>top = uint8(hash >> 56)</code>，最后 top 取出来的值就是 hash 的高8位值</p><p>在 bucket 及 bucket 的 overflow 中寻找<strong>tophash 值（HOB hash）为 151* 的槽位</strong>，即为 key 所在位置，找到了空槽位或者 2 号槽位，这样整个查找过程就结束了，其中找到空槽位代表没找到。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>for ; b != nil; b = b.overflow(t) {
</span></span><span class=line><span class=cl>        for i := uintptr(0); i &lt; bucketCnt; i++ {
</span></span><span class=line><span class=cl>            if b.tophash[i] != top {
</span></span><span class=line><span class=cl>              // 未被使用的槽位，插入
</span></span><span class=line><span class=cl>                if b.tophash[i] == emptyRest {
</span></span><span class=line><span class=cl>                    break bucketloop
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                continue
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            // 找到tophash值对应的的key
</span></span><span class=line><span class=cl>            k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
</span></span><span class=line><span class=cl>            if t.key.equal(key, k) {
</span></span><span class=line><span class=cl>                e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
</span></span><span class=line><span class=cl>                return e
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span></code></pre></td></tr></table></div></div><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240225233436.png width=auto alt=image.png></p><p><strong>5. 返回 key 对应的指针</strong></p><p>如果通过上面的步骤找到了 key 对应的槽位下标 i，我们再详细分析下 key/value 值是如何获取的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// keys的偏移量
</span></span><span class=line><span class=cl>dataOffset = unsafe.Offsetof(struct{
</span></span><span class=line><span class=cl>  b bmap
</span></span><span class=line><span class=cl>  v int64
</span></span><span class=line><span class=cl>}{}.v)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 一个bucket的元素个数
</span></span><span class=line><span class=cl>bucketCnt = 8
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// key 定位公式
</span></span><span class=line><span class=cl>k :=add(unsafe.Pointer(b),dataOffset+i*uintptr(t.keysize))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// value 定位公式
</span></span><span class=line><span class=cl>v:= add(unsafe.Pointer(b),dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
</span></span></code></pre></td></tr></table></div></div><p>Bucket 里 keys 的起始地址就是 unsafe.Pointer (b)+dataOffset</p><p>第 i 个下标 key 的地址就要在此基础上跨过 i 个 key 的大小；</p><p>而我们又知道，value 的地址是在所有 key 之后，因此第 i 个下标 value 的地址还需要加上所有 key 的偏移。</p><a href=#go-map-冲突的解决方式><h1 id=go-map-冲突的解决方式><span class=hanchor arialabel=Anchor># </span>Go map 冲突的解决方式？</h1></a><p>比较常用的 Hash 冲突解决方案有链地址法和开放寻址法：</p><p><strong>链地址法</strong></p><p>当哈希冲突发生时，创建新<strong>单元</strong>，并将新单元添加到冲突单元所在链表的尾部。</p><p><strong>开放寻址法</strong></p><p>当哈希冲突发生时，从发生冲突的那个<strong>单元</strong>起，按照一定的次序，从哈希表中寻找一个空闲的单元，然后把发生冲突的元素存入到该单元。<strong>开放寻址法需要的表长度要大于等于所需要存放的元素数量</strong></p><p>开放寻址法有多种方式：线性探测法、平方探测法、随机探测法和双重哈希法。这里以线性探测法来帮助读者理解开放寻址法思想</p><p><strong>线性探测法</strong></p><p>设 <code>Hash(key)</code> 表示关键字 <code>key</code> 的哈希值，表示哈希表的槽位数（哈希表的大小）。</p><p>线性探测法则可以表示为：</p><p>如果 <code>Hash(x) % M</code> 已经有数据，则尝试 <code>(Hash(x) + 1) % M</code> ;</p><p>如果 <code>(Hash(x) + 1) % M</code> 也有数据了，则尝试 <code>(Hash(x) + 2) % M</code> ;</p><p>如果 <code>(Hash(x) + 2) % M</code> 也有数据了，则尝试 <code>(Hash(x) + 3) % M</code> ;</p><p><strong>两种解决方案比较</strong></p><p>对于链地址法，基于数组 + 链表进行存储，链表节点可以在需要时再创建，不必像开放寻址法那样事先申请好足够内存，因此链地址法对于内存的利用率会比开方寻址法高。链地址法对装载因子的容忍度会更高，并且适合存储大对象、大数据量的哈希表。而且相较于开放寻址法，它更加灵活，支持更多的优化策略，比如可采用红黑树代替链表。但是链地址法需要额外的空间来存储指针。</p><p>对于开放寻址法，它只有数组一种数据结构就可完成存储，继承了数组的优点，对 CPU 缓存友好，易于序列化操作。但是它对内存的利用率不如链地址法，且发生冲突时代价更高。<strong>当数据量明确、装载因子小，适合采用开放寻址法。</strong></p><p><strong>总结</strong></p><p>在发生哈希冲突时，Python 中 dict 采用的开放寻址法，Java 的 HashMap 采用的是链地址法，而 Go map 也采用链地址法解决冲突，具体就是<strong>插入 key 到 map 中时</strong>，当 key 定位的桶<strong>填满 8 个元素后</strong>（这里的单元就是桶，不是元素），将会创建一个溢出桶，并且将溢出桶插入当前桶所在链表尾部。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>if inserti == nil {
</span></span><span class=line><span class=cl>        // all current buckets are full, allocate a new one.
</span></span><span class=line><span class=cl>        newb := h.newoverflow(t, b)
</span></span><span class=line><span class=cl>        // 创建一个新的溢出桶
</span></span><span class=line><span class=cl>        inserti = &amp;newb.tophash[0]
</span></span><span class=line><span class=cl>        insertk = add(unsafe.Pointer(newb), dataOffset)
</span></span><span class=line><span class=cl>        elem = add(insertk, bucketCnt*uintptr(t.keysize))
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#go-map-的负载因子为什么是-65><h1 id=go-map-的负载因子为什么是-65><span class=hanchor arialabel=Anchor># </span>Go map 的负载因子为什么是 6.5？</h1></a><p><strong>什么是负载因子?</strong></p><p><strong>负载因子（load factor），用于衡量当前哈希表中空间占用率的核心指标</strong>，也就是每个 bucket 桶存储的平均元素个数。</p><table><thead><tr><th>负载因子 = 哈希表存储的元素个数/桶个</th></tr></thead></table><p>另外负载因子<strong>与扩容、迁移</strong>等重新散列（rehash）行为有直接关系：</p><ul><li>在程序运行时，会不断地进行插入、删除等，会导致 bucket 不均，内存利用率低，需要迁移。</li><li>在程序运行时，出现负载因子过大，需要做扩容，解决 bucket 过大的问题。</li></ul><p>负载因子是哈希表中的一个重要指标，在各种版本的哈希表实现中都有类似的东西，主要目的是<strong>为了平衡 buckets 的存储空间大小和查找元素时的性能高低</strong>。</p><p>在接触各种哈希表时都可以关注一下，做不同的对比，看看各家的考量。</p><p><strong>为什么是 6.5?</strong></p><p>为什么 Go 语言中哈希表的负载因子是 6.5，为什么不是 8 ，也不是 1。这里面有可靠的数据支撑吗？</p><p><strong>测试报告</strong></p><p>实际上这是 Go 官方的经过认真的测试得出的数字，一起来看看官方的这份测试报告。</p><p>报告中共包含 4 个关键指标，如下：</p><table><thead><tr><th style=text-align:left>loadFactor</th><th style=text-align:left>%overflow</th><th style=text-align:left>bytes/entry</th><th style=text-align:left>hitprobe</th><th style=text-align:left>missprobe</th></tr></thead><tbody><tr><td style=text-align:left>4.00</td><td style=text-align:left>2.13</td><td style=text-align:left>20.77</td><td style=text-align:left>3.00</td><td style=text-align:left>4.00</td></tr><tr><td style=text-align:left>4.50</td><td style=text-align:left>4.05</td><td style=text-align:left>17.30</td><td style=text-align:left>3.25</td><td style=text-align:left>4.50</td></tr><tr><td style=text-align:left>5.00</td><td style=text-align:left>6.85</td><td style=text-align:left>14.77</td><td style=text-align:left>3.50</td><td style=text-align:left>5.00</td></tr><tr><td style=text-align:left>5.50</td><td style=text-align:left>10.55</td><td style=text-align:left>12.94</td><td style=text-align:left>3.75</td><td style=text-align:left>5.50</td></tr><tr><td style=text-align:left>6.00</td><td style=text-align:left>15.27</td><td style=text-align:left>11.67</td><td style=text-align:left>4.00</td><td style=text-align:left>6.00</td></tr><tr><td style=text-align:left>6.50</td><td style=text-align:left>20.90</td><td style=text-align:left>10.79</td><td style=text-align:left>4.25</td><td style=text-align:left>6.50</td></tr><tr><td style=text-align:left>7.00</td><td style=text-align:left>27.14</td><td style=text-align:left>10.15</td><td style=text-align:left>4.50</td><td style=text-align:left>7.00</td></tr><tr><td style=text-align:left>7.50</td><td style=text-align:left>34.03</td><td style=text-align:left>9.73</td><td style=text-align:left>4.75</td><td style=text-align:left>7.50</td></tr><tr><td style=text-align:left>8.00</td><td style=text-align:left>41.10</td><td style=text-align:left>9.40</td><td style=text-align:left>5.00</td><td style=text-align:left>8.00</td></tr></tbody></table><ul><li>LoadFactor：负载因子，也有叫装载因子。</li><li>%overflow：溢出率，有溢出 bukcet 的百分比。</li><li>Bytes/entry：平均每对 key/value 的开销字节数.</li><li>Hitprobe：查找一个存在的 key 时，要查找的平均个数。</li><li>Missprobe：查找一个不存在的 key 时，要查找的平均个数。</li></ul><p><strong>选择数值</strong></p><p>Go 官方发现：<strong>装载因子越大，填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。反之，装载因子越小，填入的元素越少，冲突发生的几率减小，但空间浪费也会变得更多，而且还会提高扩容操作的次数</strong></p><p>根据这份测试结果和讨论，Go 官方取了一个相对适中的值，把 Go 中的 map 的负载因子硬编码为 6.5，这就是 6.5 的选择缘由。</p><p>这意味着在 Go 语言中，<strong>当 map 存储的元素个数大于或等于 6.5 * 桶个数时，就会触发扩容行为</strong>。</p><a href=#go-map-如何扩容><h1 id=go-map-如何扩容><span class=hanchor arialabel=Anchor># </span>Go map 如何扩容?</h1></a><p><strong>扩容时机：</strong></p><p>在<strong>向 map 插入新 key</strong> 的时候，会进行条件检测，符合下面这 2 个条件，就会触发扩容</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>if !h.growing() &amp;&amp; (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
</span></span><span class=line><span class=cl>  hashGrow(t, h)
</span></span><span class=line><span class=cl>  goto again // Growing the table invalidates everything, so try again
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 判断是否在扩容
</span></span><span class=line><span class=cl>func (h *hmap) growing() bool {
</span></span><span class=line><span class=cl>    return h.oldbuckets != nil
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><strong>扩容条件：</strong></p><p><strong>条件 1：超过负载</strong></p><p>Map 元素个数 > 6.5 * 桶个数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func overLoadFactor(count int, B uint8) bool {
</span></span><span class=line><span class=cl>   return count &gt; bucketCnt &amp;&amp; uintptr(count) &gt; loadFactor*bucketShift(B)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/*
</span></span><span class=line><span class=cl>其中 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>bucketCnt = 8，一个桶可以装的最大元素个数
</span></span><span class=line><span class=cl>loadFactor = 6.5，负载因子，平均每个桶的元素个数
</span></span><span class=line><span class=cl>bucketShift(B): 桶的个数
</span></span><span class=line><span class=cl>*/
</span></span></code></pre></td></tr></table></div></div><p><strong>条件 2：溢出桶太多</strong></p><p>当桶总数 &lt; 2 ^ 15 时，如果溢出桶总数 >= 桶总数，则认为溢出桶过多。</p><p>当桶总数 >= 2 ^ 15 时，直接与 2 ^ 15 比较，当溢出桶总数 >= 2 ^ 15 时，即认为溢出桶太多了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func tooManyOverflowBuckets(noverflow uint16, B uint8) bool {
</span></span><span class=line><span class=cl>    // If the threshold is too low, we do extraneous work.
</span></span><span class=line><span class=cl>    // If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory.
</span></span><span class=line><span class=cl>    // &#34;too many&#34; means (approximately) as many overflow buckets as regular buckets.
</span></span><span class=line><span class=cl>    // See incrnoverflow for more details.
</span></span><span class=line><span class=cl>    if B &gt; 15 {
</span></span><span class=line><span class=cl>        B = 15
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    // The compiler doesn&#39;t see here that B &lt; 16; mask B to generate shorter shift code.
</span></span><span class=line><span class=cl>    return noverflow &gt;= uint16(1)&lt;&lt;(B&amp;15)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>对于条件 2，其实算是对条件 1 的补充。因为在负载因子比较小的情况下，有可能 map 的查找和插入效率也很低，而第 1 点识别不出来这种情况。</p><p>表面现象就是负载因子比较小比较小，即 map 里元素总数少，但是桶数量多（真实分配的桶数量多，包括大量的溢出桶）。比如不断的增删，这样会造成 overflow 的 bucket 数量增多，但负载因子又不高，达不到第 1 点的临界值，就不能触发扩容来缓解这种情况。这样会造成桶的使用率不高，值存储得比较稀疏，查找插入效率会变得非常低，因此有了第 2 扩容条件。</p><p><strong>扩容机制：</strong></p><p><strong>双倍扩容</strong>：针对条件 1，新建一个 buckets 数组，新的 buckets 大小是原来的 2 倍，然后旧 buckets 数据搬迁到新的 buckets。该方法我们称之为<strong>双倍扩容</strong></p><p><strong>等量扩容：<strong>针对条件 2，并不扩大容量，buckets 数量维持不变，重新做一遍类似双倍扩容的搬迁动作，把松散的键值对重新排列一次，使得同一个 bucket 中的 key 排列地更紧密，节省空间，提高 bucket 利用率，进而保证更快的存取。该方法我们称之为</strong>等量扩容</strong>。</p><p><strong>扩容函数：</strong></p><p>上面说的 <code>hashGrow ()</code> 函数实际上并没有真正地“搬迁”，它只是分配好了新的 buckets，并将老的 buckets 挂到了 oldbuckets 字段上。真正搬迁 buckets 的动作在 <code>growWork ()</code> 函数中，而调用 <code>growWork ()</code> 函数的动作是在 mapassign 和 mapdelete 函数中。也就是<strong>插入或修改、删除 key 的时候，都会尝试进行搬迁 buckets 的工作</strong>。先检查 oldbuckets 是否搬迁完毕，具体来说就是检查 oldbuckets 是否为 nil</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func hashGrow(t *maptype, h *hmap) {
</span></span><span class=line><span class=cl>   // 如果达到条件 1，那么将B值加1，相当于是原来的2倍
</span></span><span class=line><span class=cl>   // 否则对应条件 2，进行等量扩容，所以 B 不变
</span></span><span class=line><span class=cl>     bigger := uint8(1)
</span></span><span class=line><span class=cl>     if !overLoadFactor(h.count+1, h.B) {
</span></span><span class=line><span class=cl>         bigger = 0
</span></span><span class=line><span class=cl>         h.flags |= sameSizeGrow
</span></span><span class=line><span class=cl>     }
</span></span><span class=line><span class=cl>   // 记录老的buckets
</span></span><span class=line><span class=cl>    oldbuckets := h.buckets
</span></span><span class=line><span class=cl>  // 申请新的buckets空间
</span></span><span class=line><span class=cl>    newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil)
</span></span><span class=line><span class=cl>  // 注意&amp;^ 运算符，这块代码的逻辑是转移标志位
</span></span><span class=line><span class=cl>    flags := h.flags &amp;^ (iterator | oldIterator)
</span></span><span class=line><span class=cl>    if h.flags&amp;iterator != 0 {
</span></span><span class=line><span class=cl>        flags |= oldIterator
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    // 提交grow (atomic wrt gc)
</span></span><span class=line><span class=cl>    h.B += bigger
</span></span><span class=line><span class=cl>    h.flags = flags
</span></span><span class=line><span class=cl>    h.oldbuckets = oldbuckets
</span></span><span class=line><span class=cl>    h.buckets = newbuckets
</span></span><span class=line><span class=cl>  // 搬迁进度为0
</span></span><span class=line><span class=cl>    h.nevacuate = 0
</span></span><span class=line><span class=cl>  // overflow buckets 数为0
</span></span><span class=line><span class=cl>    h.noverflow = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  // 如果发现hmap是通过extra字段 来存储 overflow buckets时
</span></span><span class=line><span class=cl>    if h.extra != nil &amp;&amp; h.extra.overflow != nil {
</span></span><span class=line><span class=cl>        if h.extra.oldoverflow != nil {
</span></span><span class=line><span class=cl>            throw(&#34;oldoverflow is not nil&#34;)
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        h.extra.oldoverflow = h.extra.overflow
</span></span><span class=line><span class=cl>        h.extra.overflow = nil
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    if nextOverflow != nil {
</span></span><span class=line><span class=cl>        if h.extra == nil {
</span></span><span class=line><span class=cl>            h.extra = new(mapextra)
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        h.extra.nextOverflow = nextOverflow
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>由于 map 扩容需要将原有的 key/value 重新搬迁到新的内存地址，如果 map 存储了数以亿计的 key-value，一次性搬迁将会造成比较大的延时，因此 Go map 的扩容采取了一种称为**“渐进式”**的方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func growWork(t *maptype, h *hmap, bucket uintptr) {
</span></span><span class=line><span class=cl>    // 为了确认搬迁的 bucket 是我们正在使用的 bucket
</span></span><span class=line><span class=cl>    // 即如果当前key映射到老的bucket1，那么就搬迁该bucket1。
</span></span><span class=line><span class=cl>    evacuate(t, h, bucket&amp;h.oldbucketmask())
</span></span><span class=line><span class=cl>    // 如果还未完成扩容工作，则再搬迁一个bucket。
</span></span><span class=line><span class=cl>    if h.growing() {
</span></span><span class=line><span class=cl>        evacuate(t, h, h.nevacuate)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#go-map-和-sync-map-谁的性能好为什么><h1 id=go-map-和-sync-map-谁的性能好为什么><span class=hanchor arialabel=Anchor># </span>Go map 和 sync. Map 谁的性能好，为什么？</h1></a><p>Go 语言的 <code>sync. Map</code> 支持并发读写，采取了 “空间换时间” 的机制，冗余了两个数据结构，分别是：read 和 dirty</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type Map struct {
</span></span><span class=line><span class=cl>   mu Mutex
</span></span><span class=line><span class=cl>   read atomic.Value // readOnly
</span></span><span class=line><span class=cl>   dirty map[interface{}]*entry
</span></span><span class=line><span class=cl>   misses int
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><strong>对比原始 map：</strong></p><p>和原始 map+RWLock 的实现并发的方式相比，减少了加锁对性能的影响。它做了一些优化：可以无锁访问 read map，而且会优先操作 read map，倘若只操作 read map 就可以满足要求，那就不用去操作 write map (dirty)，所以在某些特定场景中它发生锁竞争的频率会远远小于 map+RWLock 的实现方式</p><p><strong>优点：</strong></p><p>适合读多写少的场景</p><p><strong>缺点：</strong></p><p>写多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://googoo-s.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by googoo-s using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2024</p><ul><li><a href=https://googoo-s.github.io/>Home</a></li><li><a href=https://github.com/googoo-s>GitHub</a></li></ul></footer></div></div></body></html>