<!DOCTYPE html>
<html lang="en"><head><title>Map</title><meta charset="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Schibsted Grotesk:wght@400;700&amp;family=Source Sans Pro:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="Map"/><meta property="og:description" content="参考 Golang map 实现原理 Golang sync.Map 实现原理 Map 概述 map 又称字典，是一种常用的数据结构，核心特征包含下述三点： （1）存储基于 key-value 对映射的模式； （2）基于 key 维度实现存储数据的去重； （3）读、写、删操作控制，时间复杂度 O(1) ..."/><meta property="og:image" content="https://googoo-s.github.io/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../../static/icon.png"/><meta name="description" content="参考 Golang map 实现原理 Golang sync.Map 实现原理 Map 概述 map 又称字典，是一种常用的数据结构，核心特征包含下述三点： （1）存储基于 key-value 对映射的模式； （2）基于 key 维度实现存储数据的去重； （3）读、写、删操作控制，时间复杂度 O(1) ..."/><meta name="generator" content="Quartz"/><link href="../../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><script src="../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch("../../static/contentIndex.json").then(data => data.json())</script></head><body data-slug="GO/八股文/Map-和Sync.map"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title"><a href="../..">googoo-s</a></h1><div class="spacer mobile-only"></div><div class="search"><div id="search-icon"><p>Search</p><div></div><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="search-layout" data-preview="true"></div></div></div></div><div class="darkmode"><input class="toggle" id="darkmode-toggle" type="checkbox" tabindex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35" xml:space="preserve"><title>Dark mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100" xml:space="preserve"><title>Light mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div><div class="explorer desktop-only"><button type="button" id="explorer" data-behavior="collapse" data-collapsed="collapsed" data-savestate="true" data-tree="[{&quot;path&quot;:&quot;awesome&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;elastic&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;GO&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;GO/八股文&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;GO/并发编程&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;GO/并发编程/Channel&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;GO/并发编程/分布式并发原语&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;GO/并发编程/原子操作&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;GO/并发编程/基础并发原语&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;GO/并发编程/扩展并发原语&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Java&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Java/netty&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Java/Spring&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Java/Spring/Spring-cloud&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;journal&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;lua&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;lua/用Go实现Lua&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Obsidian&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;zookeeper&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;分布式高并发高性能高可用&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;分布式高并发高性能高可用/日志&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;分布式高并发高性能高可用/监控&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;工具和环境&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;工具和环境/emacs&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;工具和环境/git&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;工具和环境/msys2&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;消息队列&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;消息队列/Pulsar&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;系统设计&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;系统设计/场景题&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;资源&quot;,&quot;collapsed&quot;:true}]"><h1>Explorer</h1><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="explorer-content"><ul class="overflow" id="explorer-ul"><li><div class="folder-outer open"><ul style="padding-left:0;" class="content" data-folderul><li><div class="folder-outer "><ul style="padding-left:0;" class="content" data-folderul></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="awesome"><button class="folder-button"><span class="folder-title">awesome</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="awesome"><li><a href="../../awesome/JavaGuide-知识星球优质主题汇总" data-for="awesome/JavaGuide-知识星球优质主题汇总">JavaGuide 知识星球优质主题汇总</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="elastic"><button class="folder-button"><span class="folder-title">elastic</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="elastic"><li><a href="../../elastic/KQL" data-for="elastic/KQL">KQL</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="GO"><button class="folder-button"><span class="folder-title">GO</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="GO"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="GO/八股文"><button class="folder-button"><span class="folder-title">八股文</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="GO/八股文"><li><a href="../../GO/八股文/Context" data-for="GO/八股文/Context">Context</a></li><li><a href="../../GO/八股文/Golang基础" data-for="GO/八股文/Golang基础">Golang基础</a></li><li><a href="../../GO/八股文/Map-和Sync.map" data-for="GO/八股文/Map-和Sync.map">Map</a></li><li><a href="../../GO/八股文/Slice" data-for="GO/八股文/Slice">Slice</a></li><li><a href="../../GO/八股文/内存管理和GC" data-for="GO/八股文/内存管理和GC">内存管理</a></li><li><a href="../../GO/八股文/并发" data-for="GO/八股文/并发">并发</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="GO/并发编程"><button class="folder-button"><span class="folder-title">并发编程</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="GO/并发编程"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="GO/并发编程/Channel"><button class="folder-button"><span class="folder-title">Channel</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="GO/并发编程/Channel"><li><a href="../../GO/并发编程/Channel/channel" data-for="GO/并发编程/Channel/channel">channel</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="GO/并发编程/分布式并发原语"><button class="folder-button"><span class="folder-title">分布式并发原语</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="GO/并发编程/分布式并发原语"><li><a href="../../GO/并发编程/分布式并发原语/Leader选举互斥锁和读写锁" data-for="GO/并发编程/分布式并发原语/Leader选举互斥锁和读写锁">Leader选举互斥锁和读写锁</a></li><li><a href="../../GO/并发编程/分布式并发原语/队列、栅栏和STM" data-for="GO/并发编程/分布式并发原语/队列、栅栏和STM">队列、栅栏和STM</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="GO/并发编程/原子操作"><button class="folder-button"><span class="folder-title">原子操作</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="GO/并发编程/原子操作"><li><a href="../../GO/并发编程/原子操作/atomic" data-for="GO/并发编程/原子操作/atomic">atomic</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="GO/并发编程/基础并发原语"><button class="folder-button"><span class="folder-title">基础并发原语</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="GO/并发编程/基础并发原语"><li><a href="../../GO/并发编程/基础并发原语/Cond" data-for="GO/并发编程/基础并发原语/Cond">Cond</a></li><li><a href="../../GO/并发编程/基础并发原语/Context" data-for="GO/并发编程/基础并发原语/Context">Context</a></li><li><a href="../../GO/并发编程/基础并发原语/map" data-for="GO/并发编程/基础并发原语/map">map</a></li><li><a href="../../GO/并发编程/基础并发原语/Mutex" data-for="GO/并发编程/基础并发原语/Mutex">Mutex</a></li><li><a href="../../GO/并发编程/基础并发原语/Once" data-for="GO/并发编程/基础并发原语/Once">Once</a></li><li><a href="../../GO/并发编程/基础并发原语/Pool" data-for="GO/并发编程/基础并发原语/Pool">Pool</a></li><li><a href="../../GO/并发编程/基础并发原语/RWMutex" data-for="GO/并发编程/基础并发原语/RWMutex">RWMutex</a></li><li><a href="../../GO/并发编程/基础并发原语/WaitGroup" data-for="GO/并发编程/基础并发原语/WaitGroup">WaitGroup</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="GO/并发编程/扩展并发原语"><button class="folder-button"><span class="folder-title">扩展并发原语</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="GO/并发编程/扩展并发原语"><li><a href="../../GO/并发编程/扩展并发原语/Semaphore-信号量" data-for="GO/并发编程/扩展并发原语/Semaphore-信号量">Semaphore-信号量</a></li><li><a href="../../GO/并发编程/扩展并发原语/SingleFlight-和-CyclicBarrier-请求合并和循环栅栏" data-for="GO/并发编程/扩展并发原语/SingleFlight-和-CyclicBarrier-请求合并和循环栅栏">SingleFlight 和 CyclicBarrier-请求合并和循环栅栏</a></li><li><a href="../../GO/并发编程/扩展并发原语/分组操作" data-for="GO/并发编程/扩展并发原语/分组操作">分组操作</a></li></ul></div></li><li><a href="../../GO/并发编程/开篇词" data-for="GO/并发编程/开篇词">开篇词</a></li></ul></div></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="Java"><button class="folder-button"><span class="folder-title">Java</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="Java"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="Java/netty"><button class="folder-button"><span class="folder-title">netty</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="Java/netty"><li><a href="../../Java/netty/1.-概念和体系结构" data-for="Java/netty/1.-概念和体系结构">1. 概念和体系结构</a></li><li><a href="../../Java/netty/BootStrap" data-for="Java/netty/BootStrap">BootStrap</a></li><li><a href="../../Java/netty/ByteBuf" data-for="Java/netty/ByteBuf">ByteBuf</a></li><li><a href="../../Java/netty/ChannelHandler、ChannelPipeline、ChannelContext" data-for="Java/netty/ChannelHandler、ChannelPipeline、ChannelContext">ChannelHandler、ChannelPipeline、ChannelContext</a></li><li><a href="../../Java/netty/EventLoop-和线程模型" data-for="Java/netty/EventLoop-和线程模型">EventLoop 和线程模型</a></li><li><a href="../../Java/netty/传输和Channel" data-for="Java/netty/传输和Channel">传输和Channel</a></li><li><a href="../../Java/netty/编解码器" data-for="Java/netty/编解码器">编解码器</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="Java/Spring"><button class="folder-button"><span class="folder-title">Spring</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="Java/Spring"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="Java/Spring/Spring-cloud"><button class="folder-button"><span class="folder-title">Spring cloud</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="Java/Spring/Spring-cloud"><li><a href="../../Java/Spring/Spring-cloud/spring-cloud-alibaba" data-for="Java/Spring/Spring-cloud/spring-cloud-alibaba">spring cloud alibaba</a></li></ul></div></li></ul></div></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="journal"><button class="folder-button"><span class="folder-title">journal</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="journal"><li><a href="../../journal/2023-07-25" data-for="journal/2023-07-25">2023-07-25</a></li><li><a href="../../journal/2023-07-26" data-for="journal/2023-07-26">2023-07-26</a></li><li><a href="../../journal/2023-07-27" data-for="journal/2023-07-27">2023-07-27</a></li><li><a href="../../journal/2023-07-31" data-for="journal/2023-07-31">2023-07-31</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="lua"><button class="folder-button"><span class="folder-title">lua</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="lua"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="lua/用Go实现Lua"><button class="folder-button"><span class="folder-title">用Go实现Lua</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="lua/用Go实现Lua"><li><a href="../../lua/用Go实现Lua/1.二进制Chunk" data-for="lua/用Go实现Lua/1.二进制Chunk">1.二进制Chunk</a></li><li><a href="../../lua/用Go实现Lua/2.指令集" data-for="lua/用Go实现Lua/2.指令集">2.指令集</a></li><li><a href="../../lua/用Go实现Lua/3.lua-API" data-for="lua/用Go实现Lua/3.lua-API">3.lua API</a></li><li><a href="../../lua/用Go实现Lua/前言" data-for="lua/用Go实现Lua/前言">前言</a></li></ul></div></li><li><a href="../../lua/lua基础" data-for="lua/lua基础">lua基础</a></li><li><a href="../../lua/Lua高级" data-for="lua/Lua高级">Lua高级</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="Obsidian"><button class="folder-button"><span class="folder-title">Obsidian</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="Obsidian"><li><a href="../../Obsidian/dataview" data-for="Obsidian/dataview">dataview</a></li><li><a href="../../Obsidian/excalidraw" data-for="Obsidian/excalidraw">excalidraw</a></li><li><a href="../../Obsidian/Front-Matter" data-for="Obsidian/Front-Matter">Front Matter</a></li><li><a href="../../Obsidian/obsidian-overview" data-for="Obsidian/obsidian-overview">obsidian overview</a></li><li><a href="../../Obsidian/Obsidian-plugin" data-for="Obsidian/Obsidian-plugin">Obsidian-plugin</a></li><li><a href="../../Obsidian/publish" data-for="Obsidian/publish">publish</a></li><li><a href="../../Obsidian/template" data-for="Obsidian/template">template</a></li><li><a href="../../Obsidian/使用quartz发布obsidian--vault" data-for="Obsidian/使用quartz发布obsidian--vault">使用quartz发布obsidian  vault</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="zookeeper"><button class="folder-button"><span class="folder-title">zookeeper</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="zookeeper"><li><a href="../../zookeeper/Zookeeper-教程" data-for="zookeeper/Zookeeper-教程">Zookeeper 教程</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="分布式高并发高性能高可用"><button class="folder-button"><span class="folder-title">分布式高并发高性能高可用</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="分布式高并发高性能高可用"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="分布式高并发高性能高可用/日志"><button class="folder-button"><span class="folder-title">日志</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="分布式高并发高性能高可用/日志"><li><a href="../../分布式高并发高性能高可用/日志/服务治理：分布式下如何进行日志管理？" data-for="分布式高并发高性能高可用/日志/服务治理：分布式下如何进行日志管理？">服务治理：分布式下如何进行日志管理？</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="分布式高并发高性能高可用/监控"><button class="folder-button"><span class="folder-title">监控</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="分布式高并发高性能高可用/监控"><li><a href="../../分布式高并发高性能高可用/监控/服务治理：监控系统如何做？" data-for="分布式高并发高性能高可用/监控/服务治理：监控系统如何做？">服务治理：监控系统如何做？</a></li></ul></div></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="工具和环境"><button class="folder-button"><span class="folder-title">工具和环境</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="工具和环境"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="工具和环境/emacs"><button class="folder-button"><span class="folder-title">emacs</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="工具和环境/emacs"><li><a href="../../工具和环境/emacs/安装" data-for="工具和环境/emacs/安装">安装</a></li><li><a href="../../工具和环境/emacs/快捷键" data-for="工具和环境/emacs/快捷键">快捷键</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="工具和环境/git"><button class="folder-button"><span class="folder-title">git</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="工具和环境/git"><li><a href="../../工具和环境/git/git" data-for="工具和环境/git/git">git</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="工具和环境/msys2"><button class="folder-button"><span class="folder-title">msys2</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="工具和环境/msys2"><li><a href="../../工具和环境/msys2/pacman" data-for="工具和环境/msys2/pacman">pacman</a></li></ul></div></li><li><a href="../../工具和环境/工具" data-for="工具和环境/工具">工具</a></li><li><a href="../../工具和环境/环境搭建" data-for="工具和环境/环境搭建">环境搭建</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="消息队列"><button class="folder-button"><span class="folder-title">消息队列</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="消息队列"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="消息队列/Pulsar"><button class="folder-button"><span class="folder-title">Pulsar</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="消息队列/Pulsar"><li><a href="../../消息队列/Pulsar/1.Pulsar概述" data-for="消息队列/Pulsar/1.Pulsar概述">1.Pulsar概述</a></li><li><a href="../../消息队列/Pulsar/2.doccker-中启动-standalone-Pulsar" data-for="消息队列/Pulsar/2.doccker-中启动-standalone-Pulsar">2.doccker 中启动 standalone Pulsar</a></li></ul></div></li><li><a href="../../消息队列/消息队列对比" data-for="消息队列/消息队列对比">消息队列对比</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="系统设计"><button class="folder-button"><span class="folder-title">系统设计</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="系统设计"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="系统设计/场景题"><button class="folder-button"><span class="folder-title">场景题</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="系统设计/场景题"><li><a href="../../系统设计/场景题/如何" data-for="系统设计/场景题/如何">如何</a></li><li><a href="../../系统设计/场景题/如何设计一个排行榜？" data-for="系统设计/场景题/如何设计一个排行榜？">如何设计一个排行榜？</a></li></ul></div></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="资源"><button class="folder-button"><span class="folder-title">资源</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="资源"><li><a href="../../资源/资源汇总" data-for="资源/资源汇总">资源汇总</a></li></ul></div></li></ul></div></li><li id="explorer-end"></li></ul></div></div></div><div class="center"><div class="page-header"><div class="popover-hint"><nav class="breadcrumb-container" aria-label="breadcrumbs"><div class="breadcrumb-element"><a href="../../">Home</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../../GO/">GO</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../../GO/八股文/">八股文</a><p> ❯ </p></div><div class="breadcrumb-element"><a href>Map</a></div></nav><h1 class="article-title">Map</h1><p show-comma="true" class="content-meta"><span>Feb 26, 2024</span><span>71 min read</span></p><ul class="tags"><li><a href="../../tags/GO/八股文" class="internal tag-link">GO/八股文</a></li><li><a href="../../tags/" class="internal tag-link"></a></li></ul></div></div><article class="popover-hint"><h1 id="参考">参考<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#参考" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzkxMjQzMjA0OQ==&amp;mid=2247483868&amp;idx=1&amp;sn=6e954af8e5e98ec0a9d9fc5c8ceb9072&amp;chksm=c10c4f02f67bc614ff40a152a848508aa1631008eb5a600006c7552915d187179c08d4adf8d7&amp;scene=178&amp;cur_album_id=2709593649634033668#rd" class="external">Golang map 实现原理<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>
<a href="https://mp.weixin.qq.com/s?__biz=MzkxMjQzMjA0OQ==&amp;mid=2247483821&amp;idx=1&amp;sn=f45e9e2b4c4cb7edaa57d904e3bf7bd7&amp;chksm=c10c4f73f67bc6655e7e7c9f808a318b1c74e76782824df18843f4c31e39ce512819d6abe156&amp;scene=178&amp;cur_album_id=2709593649634033668#rd" class="external">Golang sync.Map 实现原理<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></p>
<h1 id="map-概述">Map 概述<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#map-概述" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>map 又称字典，是一种常用的数据结构，核心特征包含下述三点：</p>
<p>（1）存储基于 key-value 对映射的模式；</p>
<p>（2）基于 key 维度实现存储数据的去重；</p>
<p>（3）读、写、删操作控制，时间复杂度 O(1).</p>
<h1 id="map-初始化">Map 初始化<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#map-初始化" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>Golang 中，对 map 的初始化分为以下几种方式：</p>
<pre><code>

myMap1 := make(map[int]int,2)
//通过 make 关键字进行初始化，同时指定 map 预分配的容量.

myMap2 := make(map[int]int)
//通过 make 关键字进行初始化，不显式声明容量，因此默认容量 为 0.

myMap3 :=map[int]int{
  1:2,
  3:4,
}
</code></pre>
<h1 id="map-的-key-可以是哪些类型可以嵌套-map-吗">Map 的 key 可以是哪些类型？可以嵌套 map 吗？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#map-的-key-可以是哪些类型可以嵌套-map-吗" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<ul>
<li>
<p><strong>Map key 必须是可比较的类型</strong>，</p>
<ul>
<li>语言规范中定义了可比较的类型：boolean, numeric, string, pointer, channel, interface,以及仅包含这些类型的 struct 和 array 。</li>
<li>不能作为 map key 的类型有：slice，map, function。</li>
</ul>
</li>
<li>
<p>可以嵌套 map。</p>
</li>
</ul>
<h1 id="map-读">Map 读<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#map-读" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<ul>
<li>第一种方式是直接读，倘若 key 存在，则获取到对应的 val，倘若 key 不存在或者 map 未初始化，会返回 val 类型的零值作为兜底</li>
</ul>
<pre><code>v1 := myMap[10]
</code></pre>
<ul>
<li>第二种方式是读的同时添加一个 bool 类型的 flag 标识是否读取成功. 倘若 ok == false，<strong>说明读取失败， key 不存在，或者 map 未初始化.</strong></li>
</ul>
<pre><code>v2,ok := myMap[10]
</code></pre>
<ul>
<li>如果 map 没有初始化,取值得到零值</li>
</ul>
<pre><code>package main

import &quot;fmt&quot;

func main() {
    var myMap map[string]int // 未初始化的 map
    value := myMap[&quot;some_key&quot;] // 尝试获取一个键的值

    fmt.Println(value)
}
//panic: assignment to entry in nil map
</code></pre>
<h1 id="map-的查询复杂度">Map 的查询复杂度<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#map-的查询复杂度" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p><strong>空间复杂度</strong>:
由于溢出桶数量超过 hash 桶数量时会触发缩容，所以最坏的情况是数据被集中在一条链上，hash 表基本是空的，这时空间浪费 O (n)。<br/>
最好的情况下，数据均匀散列在 hash 表上，没有元素溢出，这时最好的空间复杂度就是扩散因子决定了，当前 go 的扩散因子由全局变量决定，即 loadFactorNum/loadFactorDen = 6.5。即平均每个 hash 桶被分配到 6.5 个元素以上时，开始扩容。所以最小的空间浪费是 (8-6.5)/8 = 0.1875，即 O (0.1875n)</p>
<p>结论：go map 的空间复杂度（指除去正常存储元素所需空间之外的空间浪费）是 O (0.1875 n) ~ O (n)之间。<br/>
​ 具体细节：<a href="https://blog.csdn.net/dongjijiaoxiangqu/article/details/109643025" class="external">https://blog.csdn.net/dongjijiaoxiangqu/article/details/109643025<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> </p>
<p><strong>时间复杂度</strong>：</p>
<p>Go 采用的 hash 算法应是很成熟的算法，极端情况暂不考虑。所以综合情况下 go map 的时间复杂度应为 O(1)</p>
<h1 id="map-写">Map 写<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#map-写" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<pre><code>myMap[5] = 6
</code></pre>
<p>倘若 map 未初始化，直接执行写操作会导致 panic：</p>
<pre><code>const plainError string
panic(plainError(&quot;assignment to entry in nil map&quot;))
</code></pre>
<h1 id="map-删除">Map 删除<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#map-删除" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<pre><code>delete(myMap,5)

</code></pre>
<p>执行 delete 方法时，倘若 key 存在，则会从 map 中将对应的 key-value 对删除；倘若 key 不存在或 map 未初始化，则方法直接结束，不会产生显式提示.</p>
<h1 id="map-遍历">Map 遍历<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#map-遍历" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>遍历分为下面两种方式：</p>
<pre><code>for k,v := range myMap{
// ...
}
</code></pre>
<p>基于 k,v 依次承接 map 中的 key-value 对；</p>
<pre><code>for k := range myMap{  
// ...
}
</code></pre>
<p>基于 k 依次承接 map 中的 key，不关注 val 的取值.</p>
<p>需要注意的是，在执行 map 遍历操作时，<strong>获取的 key-value 对并没有一个固定的顺序，因此前后两次遍历顺序可能存在差异</strong>.</p>
<h1 id="map-的底层实现原理">map 的底层实现原理？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#map-的底层实现原理" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>map 又称为 hash map，在算法上基于 hash 实现 key 的映射和寻址；在数据结构上基于桶数组实现 key-value 对的存储.</p>
<p>以一组 key-value 对写入 map 的流程为例进行简述：</p>
<p>（1）通过哈希方法取得 key 的 hash 值；</p>
<p>（2）hash 值对桶数组长度取模，确定其所属的桶；</p>
<p>（3）在桶中插入 key-value 对.</p>
<h2 id="hash">Hash<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#hash" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>hash 译作散列，是一种将任意长度的输入压缩到某一固定长度的输出摘要的过程</p>
<ul>
<li>（1）hash 的可重入性：相同的 key，必然产生相同的 hash 值；</li>
<li>（2）hash 的离散性：只要两个 key 不相同，不论其相似度的高低，产生的 hash 值会在整个输出域内均匀地离散化；</li>
<li>（3）hash 的单向性：企图通过 hash 值反向映射回 key 是无迹可寻的.</li>
<li>（4）hash 冲突：由于输入域（key）无穷大，输出域（hash 值）有限，因此必然存在不同 key 映射到相同 hash 值的情况，称之为 hash 冲突.</li>
</ul>
<h2 id="桶数组">桶数组<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#桶数组" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>map 中，会通过长度为 2 的整数次幂的桶数组进行 key-value 对的存储：</p>
<p>（1）每个桶固定可以存放 8 个 key-value 对；</p>
<p>（2）倘若超过 8 个 key-value 对打到桶数组的同一个索引当中，此时会通过创建桶链表的方式来化解这一问题.</p>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226212728.png" alt="image.png"/></p>
<h2 id="map-冲突的解决方式">map 冲突的解决方式？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#map-冲突的解决方式" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>比较常用的 Hash 冲突解决方案有链地址法和开放寻址法：</p>
<p><strong>链地址法</strong></p>
<p>当哈希冲突发生时，创建新<strong>单元</strong>，并将新单元添加到冲突单元所在链表的尾部. 在 Go 中将命中同一个桶的元素通过链表的形式进行链接，因此很便于动态扩展</p>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226213338.png" alt="image.png"/></p>
<p><strong>开放寻址法</strong></p>
<p>当哈希冲突发生时，从发生冲突的那个<strong>单元</strong>起，按照一定的次序，从哈希表中寻找一个空闲的单元，然后把发生冲突的元素存入到该单元。<strong>开放寻址法需要的表长度要大于等于所需要存放的元素数量</strong></p>
<p>开放寻址法有多种方式：<strong>线性探测法、平方探测法、随机探测法和双重哈希法</strong>。这里以线性探测法来帮助读者理解开放寻址法思想</p>
<p><strong>两种解决方案比较</strong></p>

















<div class="table-container"><table><thead><tr><th>方法</th><th>优点</th></tr></thead><tbody><tr><td>拉链法</td><td>简单常用；无需预先为元素分配内存.</td></tr><tr><td>开放寻址法</td><td>无需额外的指针用于链接元素；内存地址完全连续，可以基于局部性原理，充分利用 CPU 高速缓存.</td></tr></tbody></table></div>
<p><strong>总结</strong></p>
<p><strong>GO 中 实际上结合了拉链法和开放寻址法两种思路</strong>. 以 map 的插入写流程为例，进行思路阐述：</p>
<ul>
<li>
<p>（1）桶数组中的每个桶，严格意义上是一个单向桶链表，以桶为节点进行串联；</p>
</li>
<li>
<p>（2）每个桶固定可以存放 8 个 key-value 对；</p>
</li>
<li>
<p>（3）当 key 命中一个桶时，首先根据开放寻址法，在桶的 8 个位置中寻找空位进行插入；</p>
</li>
<li>
<p>（4）倘若桶的 8 个位置都已被占满，则基于桶的溢出桶指针，找到下一个桶，重复第（3）步；</p>
</li>
<li>
<p>（5）倘若遍历到链表尾部，仍未找到空位，则基于拉链法，在桶链表尾部续接新桶，并插入 key-value 对.</p>
</li>
</ul>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226213553.png" alt="image.png"/></p>
<h2 id="扩容">扩容<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#扩容" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>map 扩容机制的核心点包括：</p>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226221432.png" alt="image.png"/></p>
<ul>
<li>
<p>（1）扩容分为增量扩容和等量扩容；</p>
<ul>
<li><strong>双倍扩容</strong>：新建一个 buckets 数组，<strong>新的 buckets 大小是原来的 2 倍</strong>，然后旧 buckets 数据搬迁到新的 buckets。该方法我们称之为<strong>双倍扩容</strong></li>
<li>等量扩容：<strong>并不扩大容量</strong>，buckets 数量维持不变，<strong>重新做一遍类似双倍扩容的搬迁动作，把松散的键值对重新排列一次</strong>，使得同一个 bucket 中的 key 排列地更紧密，节省空间，提高 bucket 利用率，进而保证更快的存取。该方法我们称之为等量扩容。</li>
</ul>
</li>
<li>
<p>（2）当桶内 key-value 总数/桶数组长度 > 6.5 时发生增量扩容，桶数组长度增长为原值的两倍；</p>
</li>
<li>
<p>（3）当桶内溢出桶数量大于等于 2^B 时( B 为桶数组长度的指数，B 最大取 15)，发生等量扩容，桶的长度保持为原值；</p>
</li>
<li>
<p>（4）采用渐进扩容的方式，当桶被实际操作到时，由使用者负责完成数据迁移，避免因为一次性的全量数据迁移引发性能抖动.</p>
</li>
</ul>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226214126.png" alt="image.png"/></p>
<h2 id="hmap-结构体"><strong>hmap 结构体</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#hmap-结构体" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Go 中的 map 是一个应用，占用 8 个字节，指向 hmap 结构体</p>
<p>源码包中 <code>src/runtime/map.go</code> 定义了 hmap 的数据结构：</p>
<p>Hmap 包含若干个结构为 bmap 的数组，每个 bmap 底层都采用链表结构，bmap 通常叫其 bucket</p>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240225233011.png" alt="image.png"/></p>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226214237.png" alt="image.png"/></p>
<pre><code>// A header for a Go map.
type hmap struct {
    count     int 
    // 代表哈希表中的元素个数，调用len(map)时，返回的就是该字段值。
    flags     uint8 
    // 状态标志（是否处于正在写入的状态等）
    B         uint8  
    // buckets（桶）的对数
    // 如果B=5，则buckets数组的长度 = 2^B=32，意味着有32个桶
    noverflow uint16 
    // 溢出桶的数量
    hash0     uint32 
    // 生成hash的随机数种子
    buckets    unsafe.Pointer 
    // 指向buckets数组的指针，数组大小为2^B，如果元素个数为0，它为nil。
    oldbuckets unsafe.Pointer 
    // 如果发生扩容，oldbuckets是指向老的buckets数组的指针，老的buckets数组大小是新的buckets的1/2;非扩容状态下，它为nil。
    nevacuate  uintptr        
    // 表示扩容进度，小于此地址的buckets代表已搬迁完成。
    extra *mapextra 
    // 存储溢出桶，这个字段是为了优化GC扫描而设计的，下面详细介绍
 }
</code></pre>
<ul>
<li>
<p>（1）count：map 中的 key-value 总数；</p>
</li>
<li>
<p>（2）flags：map 状态标识，可以标识出 map 是否被 goroutine 并发读写；</p>
</li>
<li>
<p>（3）B：桶数组长度的指数，桶数组长度为 2^B；</p>
</li>
<li>
<p>（4）noverflow：map 中溢出桶的数量；</p>
</li>
<li>
<p>（5）hash0：hash 随机因子，生成 key 的 hash 值时会使用到；</p>
</li>
<li>
<p>（6）buckets：桶数组；</p>
</li>
<li>
<p>（7）oldbuckets：扩容过程中老的桶数组；</p>
</li>
<li>
<p>（8）nevacuate：扩容时的进度标识，index 小于 nevacuate 的桶都已经由老桶转移到新桶中；</p>
</li>
<li>
<p>（9）extra：预申请的溢出桶.</p>
</li>
</ul>
<h2 id="bmap-结构体"><strong>bmap 结构体</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#bmap-结构体" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226214340.png" alt="image.png"/></p>
<p><code>bmap</code> 就是我们常说的“桶”，一个桶里面会最多装 8 个 key，</p>
<ul>
<li>这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，<strong>哈希结果的低 B 位是相同的</strong>，</li>
<li>在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有 8 个位置)。</li>
</ul>
<pre><code>// A bucket for a Go map.
type bmap struct {
    tophash [bucketCnt]uint8        
    // len为8的数组
    // 用来快速定位key是否在这个bmap中
    // 一个桶最多8个槽位，如果key所在的tophash值在tophash中，则代表该key在这个桶中
}
</code></pre>
<p>上面 bmap 结构是静态结构，在编译过程中 <code>runtime.bmap</code> 会拓展成以下结构体：</p>
<pre><code>type bmap struct{
    tophash [8]uint8
    keys [8]keytype 
    // keytype 由编译器编译时候确定
    values [8]elemtype 
    // elemtype 由编译器编译时候确定
    overflow uintptr 
    // overflow指向下一个bmap，overflow是uintptr而不是*bmap类型，保证bmap完全不含指针，是为了减少gc，溢出桶存储到extra字段中
}
</code></pre>
<ul>
<li>
<p>Tophash 就是用于实现快速定位 key 的位置，在实现过程中<strong>会使用 key 的 hash 值的高 8 位作为 tophash 值</strong>，存放在 bmap 的 tophash 字段中</p>
</li>
<li>
<p>Tophash 字段不仅存储 key 哈希值的高 8 位，<strong>还会存储一些状态值，用来表明当前桶单元状态，这些状态值都是小于 minTopHash</strong> 的</p>
</li>
<li>
<p>为了避免 key 哈希值的高 8 位值和这些状态值相等，产生混淆情况，<strong>所以当 key 哈希值高 8 位若小于 minTopHash 时候，自动将其值加上 minTopHash 作为该 key 的 tophash</strong>。桶单元的状态值如下：</p>
</li>
</ul>
<pre><code>emptyRest      = 0 // 表明此桶单元为空，且更高索引的单元也是空
emptyOne       = 1 // 表明此桶单元为空
evacuatedX     = 2 // 用于表示扩容迁移到新桶前半段区间
evacuatedY     = 3 // 用于表示扩容迁移到新桶后半段区间
evacuatedEmpty = 4 // 用于表示此单元已迁移
minTopHash     = 5 // key的tophash值与桶状态值分割线值，小于此值的一定代表着桶单元的状态，大于此值的一定是key对应的tophash值

func tophash(hash uintptr) uint8 {
    top := uint8(hash >> (goarch.PtrSize*8 - 8))
    if top &lt; minTopHash {
        top += minTopHash
    }
    return top
}
</code></pre>
<p><strong>总结</strong></p>
<p>Bmap（bucket）内存数据结构可视化如下:</p>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240225233151.png" alt="image.png"/></p>
<h2 id="mapextra-结构体"><strong>mapextra 结构体</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#mapextra-结构体" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>当 map 的 key 和 value 都不是指针类型时候，bmap 将完全不包含指针，那么 gc 时候就不用扫描 bmap。Bmap 指向溢出桶的字段 overflow 是 uintptr 类型，为了防止这些 overflow 桶被 gc 掉，所以需要 mapextra. Overflow 将它保存起来。如果 bmap 的 overflow 是 bmap 类型，那么 gc 扫描的是一个个拉链表，效率明显不如直接扫描一段内存 (hmap. Mapextra. Overflow)</p>
<pre><code>type mapextra struct {
    overflow    *[]*bmap
    // overflow 包含的是 hmap.buckets 的 overflow 的 buckets
    oldoverflow *[]*bma
   // oldoverflow 包含扩容时 hmap.oldbuckets 的 overflow 的 bucket
    nextOverflow *bmap 
     // 指向空闲的 overflow bucket 的指针
}
</code></pre>
<p><strong>在 map 初始化时，倘若容量过大，会提前申请好一批溢出桶</strong>，以供后续使用，这部分溢出桶存放在 hmap.mapextra 当中：</p>
<p>（1）mapextra.overflow：供桶数组 buckets 使用的溢出桶；</p>
<p>（2）mapextra.oldoverFlow: 扩容流程中，供老桶数组 oldBuckets 使用的溢出桶；</p>
<p>（3）mapextra.nextOverflow：下一个可用的溢出桶.</p>
<h2 id="map-的负载因子为什么是-65">Map 的负载因子为什么是 6.5？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#map-的负载因子为什么是-65" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><strong>什么是负载因子?</strong></p>
<p><strong>负载因子（load factor），用于衡量当前哈希表中空间占用率的核心指标</strong>，也就是每个 bucket 桶存储的平均元素个数。</p>






<div class="table-container"><table><thead><tr><th>负载因子 = 哈希表存储的元素个数/桶个</th></tr></thead></table></div>
<p>另外负载因子<strong>与扩容、迁移</strong>等重新散列（rehash）行为有直接关系：</p>
<ul>
<li>在程序运行时，会不断地进行插入、删除等，会导致 bucket 不均，内存利用率低，需要迁移。</li>
<li>在程序运行时，出现负载因子过大，需要做扩容，解决 bucket 过大的问题。</li>
</ul>
<p>负载因子是哈希表中的一个重要指标，在各种版本的哈希表实现中都有类似的东西，主要目的是<strong>为了平衡 buckets 的存储空间大小和查找元素时的性能高低</strong>。</p>
<p>在接触各种哈希表时都可以关注一下，做不同的对比，看看各家的考量。</p>
<p><strong>为什么是 6.5?</strong></p>
<p>为什么 Go 语言中哈希表的负载因子是 6.5，为什么不是 8 ，也不是 1。这里面有可靠的数据支撑吗？</p>
<p><strong>测试报告</strong></p>
<p>实际上这是 Go 官方的经过认真的测试得出的数字，一起来看看官方的这份测试报告。</p>
<p>报告中共包含 4 个关键指标，如下：</p>











































































<div class="table-container"><table><thead><tr><th style="text-align:left;">loadFactor</th><th style="text-align:left;">%overflow</th><th style="text-align:left;">bytes/entry</th><th style="text-align:left;">hitprobe</th><th style="text-align:left;">missprobe</th></tr></thead><tbody><tr><td style="text-align:left;">4.00</td><td style="text-align:left;">2.13</td><td style="text-align:left;">20.77</td><td style="text-align:left;">3.00</td><td style="text-align:left;">4.00</td></tr><tr><td style="text-align:left;">4.50</td><td style="text-align:left;">4.05</td><td style="text-align:left;">17.30</td><td style="text-align:left;">3.25</td><td style="text-align:left;">4.50</td></tr><tr><td style="text-align:left;">5.00</td><td style="text-align:left;">6.85</td><td style="text-align:left;">14.77</td><td style="text-align:left;">3.50</td><td style="text-align:left;">5.00</td></tr><tr><td style="text-align:left;">5.50</td><td style="text-align:left;">10.55</td><td style="text-align:left;">12.94</td><td style="text-align:left;">3.75</td><td style="text-align:left;">5.50</td></tr><tr><td style="text-align:left;">6.00</td><td style="text-align:left;">15.27</td><td style="text-align:left;">11.67</td><td style="text-align:left;">4.00</td><td style="text-align:left;">6.00</td></tr><tr><td style="text-align:left;">6.50</td><td style="text-align:left;">20.90</td><td style="text-align:left;">10.79</td><td style="text-align:left;">4.25</td><td style="text-align:left;">6.50</td></tr><tr><td style="text-align:left;">7.00</td><td style="text-align:left;">27.14</td><td style="text-align:left;">10.15</td><td style="text-align:left;">4.50</td><td style="text-align:left;">7.00</td></tr><tr><td style="text-align:left;">7.50</td><td style="text-align:left;">34.03</td><td style="text-align:left;">9.73</td><td style="text-align:left;">4.75</td><td style="text-align:left;">7.50</td></tr><tr><td style="text-align:left;">8.00</td><td style="text-align:left;">41.10</td><td style="text-align:left;">9.40</td><td style="text-align:left;">5.00</td><td style="text-align:left;">8.00</td></tr></tbody></table></div>
<ul>
<li>LoadFactor：负载因子，也有叫装载因子。</li>
<li>%overflow：溢出率，有溢出 bukcet 的百分比。</li>
<li>Bytes/entry：平均每对 key/value 的开销字节数.</li>
<li>Hitprobe：查找一个存在的 key 时，要查找的平均个数。</li>
<li>Missprobe：查找一个不存在的 key 时，要查找的平均个数。</li>
</ul>
<p><strong>选择数值</strong></p>
<p>Go 官方发现：<strong>装载因子越大，填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。反之，装载因子越小，填入的元素越少，冲突发生的几率减小，但空间浪费也会变得更多，而且还会提高扩容操作的次数</strong></p>
<p>根据这份测试结果和讨论，Go 官方取了一个相对适中的值，把 Go 中的 map 的负载因子硬编码为 6.5，这就是 6.5 的选择缘由。</p>
<p>这意味着在 Go 语言中，<strong>当 map 存储的元素个数大于或等于 6.5 * 桶个数时，就会触发扩容行为</strong>。</p>
<h2 id="构造流程">构造流程<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#构造流程" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226215050.png" alt="image.png"/></p>
<p>创建 map 时，实际上会调用 runtime/map.go 文件中的 makemap 方法，下面对源码展开分析：</p>
<pre><code>func makemap(t *maptype, hint int, h *hmap) *hmap {
    mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size)
    if overflow || mem > maxAlloc {
        hint = 0
    }


    if h == nil {
        h = new(hmap)
    }
    h.hash0 = fastrand()


    B := uint8(0)
    for overLoadFactor(hint, B) {
        B++
    }
    h.B = B


    if h.B != 0 {
        var nextOverflow *bmap
        h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)
        if nextOverflow != nil {
            h.extra = new(mapextra)
            h.extra.nextOverflow = nextOverflow
        }
    }


    return 
</code></pre>
<ul>
<li>
<p>（1）hint 为 map 拟分配的容量；在分配前，会提前对拟分配的内存大小进行判断，倘若超限，会将 hint 置为零；</p>
</li>
<li>
<p>（2）通过 new 方法初始化 hmap；</p>
</li>
<li>
<p>（3）调用 fastrand，构造 hash 因子：hmap.hash0；</p>
</li>
<li>
<p>（4）大致上基于 log2(B) >= hint 的思路，计算桶数组的容量 B；</p>
<ul>
<li>overLoadFactor   中实现</li>
<li>倘若 map 预分配容量小于等于 8，B 取 0，桶的个数为 1；</li>
<li>保证 map 预分配容量小于等于桶数组长度 * 6.5.</li>
</ul>
</li>
<li>
<p>（5）调用 makeBucketArray 方法，初始化桶数组 hmap.buckets</p>
<ul>
<li>makeBucketArray 方法会进行桶数组的初始化，并根据桶的数量决定是否需要提前作溢出桶的初始化.</li>
</ul>
</li>
<li>
<p>（6）倘若 map 容量较大，会提前申请一批溢出桶 hmap.extra.</p>
</li>
</ul>
<h2 id="读流程">读流程<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#读流程" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226215347.png" alt="image.png"/></p>
<p>map 读流程主要分为以下几步：</p>
<p>（1）根据 key 取 hash 值；</p>
<p>（2）根据 hash 值对桶数组取模，确定所在的桶；</p>
<p>（3）沿着桶链表依次遍历各个桶内的 key-value 对；</p>
<p>（4）命中相同的 key，则返回 value；倘若 key 不存在，则返回零值.</p>
<p>map 读操作最终会走进 runtime/map.go 的 mapaccess 方法中，下面开始阅读源码</p>
<pre><code>func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
    if h == nil || h.count == 0 {
        return unsafe.Pointer(&amp;zeroVal[0])
    }
    if h.flags&amp;hashWriting != 0 {
        fatal(&quot;concurrent map read and map write&quot;)
    }
    hash := t.hasher(key, uintptr(h.hash0))
    m := bucketMask(h.B)
    b := (*bmap)(add(h.buckets, (hash&amp;m)*uintptr(t.bucketsize)))
    if c := h.oldbuckets; c != nil {
        if !h.sameSizeGrow() {
            m >>= 1
        }
        oldb := (*bmap)(add(c, (hash&amp;m)*uintptr(t.bucketsize)))
        if !evacuated(oldb) {
            b = oldb
        }
    }
    top := tophash(hash)
bucketloop:
    for ; b != nil; b = b.overflow(t) {
        for i := uintptr(0); i &lt; bucketCnt; i++ {
            if b.tophash[i] != top {
                if b.tophash[i] == emptyRest {
                    break bucketloop
                }
                continue
            }
            k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
            if t.indirectkey() {
                k = *((*unsafe.Pointer)(k))
            }
            if t.key.equal(key, k) {
                e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
                if t.indirectelem() {
                    e = *((*unsafe.Pointer)(e))
                }
                return e
            }
        }
    }
    return unsafe.Pointer(&amp;zeroVal[0])
}


func (h *hmap) sameSizeGrow() bool {
    return h.flags&amp;sameSizeGrow != 0
}


func evacuated(b *bmap) bool {
    h := b.tophash[0]
    return h > emptyOne &amp;&amp; h &lt; minTopHash
}
</code></pre>
<p>（1）倘若 map 未初始化，或此时存在 key-value 对数量为 0，直接返回零值；</p>
<p>（2）倘若发现存在其他 goroutine 在写 map，直接抛出并发读写的 fatal error；其中，并发写标记，位于 hmap.flags 的第 3 个 bit 位；</p>
<p>（3）通过 maptype.hasher() 方法计算得到 key 的 hash 值，并对桶数组长度取模，取得对应的桶. 关于 hash 方法的内部实现，golang 并未暴露.</p>
<ul>
<li>其中，bucketMast 方法会根据 B 求得桶数组长度 - 1 的值，用于后续的 &amp; 运算，实现取模的效果：</li>
</ul>
<p>（4）在取桶时，会关注当前 map 是否处于扩容的流程，倘若是的话，需要在老的桶数组 oldBuckets 中取桶，通过 evacuated 方法判断桶数据是已迁到新桶还是仍存留在老桶，倘若仍在老桶，需要取老桶进行遍历.</p>
<ul>
<li>在取老桶前，会先判断 map 的扩容流程是否是增量扩容，倘若是的话，说明老桶数组的长度是新桶数组的一半，需要将桶长度值 m 除以 2.</li>
</ul>
<p>（5）取 key hash 值的高 8 位值 top. 倘若该值 &lt; 5，会累加 5，以避开 0 ~ 4 的取值. 因为这几个值会用于枚举，具有一些特殊的含义.</p>
<p>（6）开启两层 for 循环进行遍历流程，外层基于桶链表，依次遍历首个桶和后续的每个溢出桶，内层依次遍历一个桶内的 key-value 对.</p>
<ul>
<li>
<p>内存遍历时，首先查询高 8 位的 tophash 值，看是否和 key 的 top 值匹配.</p>
</li>
<li>
<p>倘若不匹配且当前位置 tophash 值为 0，说明桶的后续位置都未放入过元素，当前 key 在 map 中不存在，可以直接打破循环，返回零值.</p>
</li>
<li>
<p>倘若找到了相等的 key，则通过地址偏移的方式取到 value 并返回.</p>
</li>
</ul>
<p>其中 dataOffset 为一个桶中 tophash 数组所占用的空间大小.</p>
<h2 id="写流程">写流程<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#写流程" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226215900.png" alt="image.png"/></p>
<p>map 写流程主要分为以下几步：</p>
<p>（1）根据 key 取 hash 值；</p>
<p>（2）根据 hash 值对桶数组取模，确定所在的桶；</p>
<p>（3）倘若 map 处于扩容，则迁移命中的桶，帮助推进渐进式扩容；</p>
<p>（4）沿着桶链表依次遍历各个桶内的 key-value 对；</p>
<p>（5）倘若命中相同的 key，则对 value 中进行更新；</p>
<p>（6）倘若 key 不存在，则插入 key-value 对；</p>
<p>（7）倘若发现 map 达成扩容条件，则会开启扩容模式，并重新返回第（2）步.</p>
<pre><code>func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
    if h == nil {
        panic(plainError(&quot;assignment to entry in nil map&quot;))
    }
    if h.flags&amp;hashWriting != 0 {
        fatal(&quot;concurrent map writes&quot;)
    }
    hash := t.hasher(key, uintptr(h.hash0))


    h.flags ^= hashWriting


    if h.buckets == nil {
        h.buckets = newobject(t.bucket) 
    }


again:
    bucket := hash &amp; bucketMask(h.B)
    if h.growing() {
        growWork(t, h, bucket)
    }
    b := (*bmap)(add(h.buckets, bucket*uintptr(t.bucketsize)))
    top := tophash(hash)


    var inserti *uint8
    var insertk unsafe.Pointer
    var elem unsafe.Pointer
bucketloop:
    for {
        for i := uintptr(0); i &lt; bucketCnt; i++ {
            if b.tophash[i] != top {
                if isEmpty(b.tophash[i]) &amp;&amp; inserti == nil {
                    inserti = &amp;b.tophash[i]
                    insertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
                    elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
                }
                if b.tophash[i] == emptyRest {
                    break bucketloop
                }
                continue
            }
            k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
            if t.indirectkey() {
                k = *((*unsafe.Pointer)(k))
            }
            if !t.key.equal(key, k) {
                continue
            }
            if t.needkeyupdate() {
                typedmemmove(t.key, k, key)
            }
            elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
            goto done
        }
        ovf := b.overflow(t)
        if ovf == nil {
            break
        }
        b = ovf
    }


    if !h.growing() &amp;&amp; (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
        hashGrow(t, h)
        goto again 
    }


    if inserti == nil {
        newb := h.newoverflow(t, b)
        inserti = &amp;newb.tophash[0]
        insertk = add(unsafe.Pointer(newb), dataOffset)
        elem = add(insertk, bucketCnt*uintptr(t.keysize))
    }


    if t.indirectkey() {
        kmem := newobject(t.key)
        *(*unsafe.Pointer)(insertk) = kmem
        insertk = kmem
    }
    if t.indirectelem() {
        vmem := newobject(t.elem)
        *(*unsafe.Pointer)(elem) = vmem
    }
    typedmemmove(t.key, insertk, key)
    *inserti = top
    h.count++




done:
    if h.flags&amp;hashWriting == 0 {
        fatal(&quot;concurrent map writes&quot;)
    }
    h.flags &amp;^= hashWriting
    if t.indirectelem() {
        elem = *((*unsafe.Pointer)(elem))
    }
    return 
}
</code></pre>
<p>（1）写操作时，倘若 map 未初始化，直接 panic；</p>
<p>（2）倘若其他 goroutine 在进行写或删操作，抛出并发写 fatal error；</p>
<p>（3）通过 maptype.hasher() 方法求得 key 对应的 hash 值；</p>
<p>（4）通过异或位运算，将 map.flags 的第 3 个 bit 位置为 1，添加写标记；</p>
<p>（5）倘若 map 的桶数组 buckets 未空，则对其进行初始化；</p>
<p>（6）找到当前 key 对应的桶索引 bucket；</p>
<p>（7）倘若发现当前 map 正处于扩容过程，则帮助其渐进扩容，具体内容在第 9 节中再作展开；</p>
<p>（8）从 map 的桶数组 buckets 出发，结合桶索引和桶容量大小，进行地址偏移，获得对应桶 b；</p>
<p>（9）取得 key 的高 8 位 tophash：</p>
<p>（10）提前声明好的三个指针，用于指向存放 key-value 的空槽:</p>
<pre><code>inserti：tophash 拟插入位置；

insertk：key 拟插入位置 ；

elem：val 拟插入位置；
</code></pre>
<p>（11）开启两层 for 循环，外层沿着桶链表依次遍历，内层依次遍历桶内的 key-value 对：</p>
<p>(12）倘若 key 的 tophash 和当前位置 tophash 不同，则会尝试将 inserti、insertk elem 调整指向首个空位，用于后续的插入操作.</p>
<ul>
<li>
<p>倘若发现当前位置 tophash 标识为 emtpyRest（0），则说明当前桶链表后续位置都未空，无需继续遍历，直接 break 遍历流程即可.</p>
</li>
<li>
<p>倘若桶中某个位置的 tophash 标识为 emptyOne（1），说明当前位置未放入元素，倘若为 emptyRest（0），说明包括当前位置在内，此后的位置都为空.</p>
</li>
</ul>
<p>（13）倘若找到了相等的 key，则执行更新操作，并且直接跳转到方法的 done 标志位处，进行收尾处理</p>
<p>（14）倘若没找到相等的 key，会在执行插入操作前，判断 map 是否需要开启扩容模式. 这部分内容在第 9 节中作展开.</p>
<p>倘若需要扩容，会在开启扩容模式后，跳转回 again 标志位，重新开始桶的定位以及遍历流程.</p>
<p>（15）倘若遍历完桶链表，都没有为当前待插入的 key-value 对找到空位，则会创建一个新的溢出桶，挂载在桶链表的尾部，并将 inserti、insertk、elem 指向溢出桶的首个空位：</p>
<p>创建溢出桶时：</p>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226220556.png" alt="image.png"/></p>
<ul>
<li>
<p>I 倘若 hmap.extra 中还有剩余可用的溢出桶，则直接获取 hmap.extra.nextOverflow，并将 nextOverflow 调整指向下一个空闲可用的溢出桶；</p>
</li>
<li>
<p>II 倘若 hmap 已经没有空闲溢出桶了，则创建一个新的溢出桶.</p>
</li>
<li>
<p>III hmap 的溢出桶数量 hmap.noverflow 累加 1；</p>
</li>
<li>
<p>IV 将新获得的溢出桶添加到原桶链表的尾部；</p>
</li>
<li>
<p>V 返回溢出桶.</p>
</li>
</ul>
<p>（16）将 tophash、key、value 插入到取得空位中，并且将 map 的 key-value 对计数器 count 值加 1；</p>
<p>（17）收尾环节，再次校验是否有其他协程并发写，倘若有，则抛 fatal error. 将 hmap.flags 中的写标记抹去，然后退出方法.</p>
<h2 id="删除流程">删除流程<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#删除流程" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226220742.png" alt="image.png"/></p>
<p>map 删楚 kv 对流程主要分为以下几步：</p>
<p>（1）根据 key 取 hash 值；</p>
<p>（2）根据 hash 值对桶数组取模，确定所在的桶；</p>
<p>（3）倘若 map 处于扩容，则迁移命中的桶，帮助推进渐进式扩容；</p>
<p>（4）沿着桶链表依次遍历各个桶内的 key-value 对；</p>
<p>（5）倘若命中相同的 key，删除对应的 key-value 对；并将当前位置的 tophash 置为 emptyOne，表示为空；</p>
<p>（6）倘若当前位置为末位，或者下一个位置的 tophash 为 emptyRest，则沿当前位置向前遍历，将毗邻的 emptyOne 统一更新为 emptyRest.</p>
<p>map 删操作最终会走进 runtime/map.go 的 mapdelete 方法中，下面开始阅读源码：</p>
<pre><code>func mapdelete(t *maptype, h *hmap, key unsafe.Pointer) {
    if h == nil || h.count == 0 {
        return
    }
    if h.flags&amp;hashWriting != 0 {
        fatal(&quot;concurrent map writes&quot;)
    }


    hash := t.hasher(key, uintptr(h.hash0))


    h.flags ^= hashWriting


    bucket := hash &amp; bucketMask(h.B)
    if h.growing() {
        growWork(t, h, bucket)
    }
    b := (*bmap)(add(h.buckets, bucket*uintptr(t.bucketsize)))
    bOrig := b
    top := tophash(hash)
search:
    for ; b != nil; b = b.overflow(t) {
        for i := uintptr(0); i &lt; bucketCnt; i++ {
            if b.tophash[i] != top {
                if b.tophash[i] == emptyRest {
                    break search
                }
                continue
            }
            k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
            k2 := k
            if t.indirectkey() {
                k2 = *((*unsafe.Pointer)(k2))
            }
            if !t.key.equal(key, k2) {
                continue
            }
            // Only clear key if there are pointers in it.
            if t.indirectkey() {
                *(*unsafe.Pointer)(k) = nil
            } else if t.key.ptrdata != 0 {
                memclrHasPointers(k, t.key.size)
            }
            e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
            if t.indirectelem() {
                *(*unsafe.Pointer)(e) = nil
            } else if t.elem.ptrdata != 0 {
                memclrHasPointers(e, t.elem.size)
            } else {
                memclrNoHeapPointers(e, t.elem.size)
            }
            b.tophash[i] = emptyOne
            if i == bucketCnt-1 {
                if b.overflow(t) != nil &amp;&amp; b.overflow(t).tophash[0] != emptyRest {
                    goto notLast
                }
            } else {
                if b.tophash[i+1] != emptyRest {
                    goto notLast
                }
            }
            for {
                b.tophash[i] = emptyRest
                if i == 0 {
                    if b == bOrig {
                        break
                    }
                    c := b
                    for b = bOrig; b.overflow(t) != c; b = b.overflow(t) {
                    }
                    i = bucketCnt - 1
                } else {
                    i--
                }
                if b.tophash[i] != emptyOne {
                    break
                }
            }
        notLast:
            h.count--
            if h.count == 0 {
                h.hash0 = fastrand()
            }
            break search
        }
    }


    if h.flags&amp;hashWriting == 0 {
        fatal(&quot;concurrent map writes&quot;)
    }
    h.flags &amp;^= hashWritin
</code></pre>
<p>（1）倘若 map 未初始化或者内部 key-value 对数量为 0，删除时不会报错，直接返回；</p>
<p>（2）倘若存在其他 goroutine 在进行写或删操作，抛出并发写的 fatal error；</p>
<p>（3）通过 maptype.hasher() 方法求得 key 对应的 hash 值；</p>
<p>（4）通过异或位运算，将 map.flags 的第 3 个 bit 位置为 1，添加写标记；</p>
<p>（5）找到当前 key 对应的桶索引 bucket；</p>
<p>（6）倘若发现当前 map 正处于扩容过程，则帮助其渐进扩容</p>
<p>（7）从 map 的桶数组 buckets 出发，结合桶索引和桶容量大小，进行地址偏移，获得对应桶 b，并赋值给 bOrg</p>
<p>（8）取得 key 的高 8 位 tophash：</p>
<p>（9）开启两层 for 循环，外层沿着桶链表依次遍历，内层依次遍历桶内的 key-value 对</p>
<p>（10）遍历时，倘若发现当前位置 tophash 值为 emptyRest，则直接结束遍历流程：</p>
<p>（11）倘若 key 不相等，则继续遍历：</p>
<p>（12）倘若 key 相等，则删除对应的 key-value 对，并且将当前位置的 tophash 置为 emptyOne：</p>
<p>（13）倘若当前位置不位于最后一个桶的最后一个位置，或者当前位置的后置位 tophash 不为 emptyRest，则无需向前遍历更新 tophash 标识，直接跳转到 notLast 位置即可；</p>
<p>（14）向前遍历，将沿途的空位（ tophash 为 emptyOne ）的 tophash 都更新为 emptySet.</p>
<p>（15）倘若成功从 map 中删除了一组 key-value 对，则将 hmap 的计数器 count 值减 1. 倘若 map 中的元素全都被删除完了，会为 map 更换一个新的随机因子 hash0.</p>
<p>（16）收尾环节，再次校验是否有其他协程并发写，倘若有，则抛 fatal error. 将 hmap.flags 中的写标记抹去，然后退出方法.</p>
<h2 id="遍历流程">遍历流程<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#遍历流程" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226221021.png" alt="image.png"/></p>
<p>Map 的遍历流程首先会走进 runtime/map.go 的 mapiterinit() 方法当中，初始化用于遍历的迭代器 hiter；接着会调用 runtime/map.go 的 mapiternext() 方法开启遍历流程.</p>
<p><strong>迭代器数据结构</strong></p>
<pre><code>type hiter struct {
    key         unsafe.Pointer 
    elem        unsafe.Pointer 
    t           *maptype
    h           *hmap
    buckets     unsafe.Pointer 
    bptr        *bmap         
    overflow    *[]*bmap      
    oldoverflow *[]*bmap      
    startBucket uintptr       
    offset      uint8         
    wrapped     bool         
    B           uint8
    i           uint8
    bucket      uintptr
    checkBucket uintptr
}
</code></pre>
<p>hiter 是遍历 map 时用于存放临时数据的迭代器：</p>
<p>（1）key：指向遍历得到 key 的指针；</p>
<p>（2）value：指向遍历得到 value 的指针；</p>
<p>（3）t：map 类型，包含了 key、value 类型大小等信息；</p>
<p>（4）h：map 的指针；</p>
<p>（5）buckets：map 的桶数组；</p>
<p>（6）bptr：当前遍历到的桶；</p>
<p>（7）overflow：新老桶数组对应的溢出桶；</p>
<p>（8）startBucket：遍历起始位置的桶索引；</p>
<p>（9）offset：遍历起始位置的 key-value 对索引；</p>
<p>（10）wrapped：遍历是否穿越桶数组尾端回到头部了；</p>
<p>（11）B：桶数组的长度指数；</p>
<p>（12）i：当前遍历到的 key-value 对在桶中的索引；</p>
<p>（13）bucket：当前遍历到的桶；</p>
<p>（14）checkBucket：因为扩容流程的存在，需要额外检查的桶.</p>
<p>map 遍历流程开始时，首先会走进 runtime/map.go 的 mapiterinit() 方法当中，此时会对创建 map 迭代器 hiter，并且通过取随机数的方式，决定遍历的起始桶号，以及起始 key-value 对索引号.</p>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226221137.png" alt="image.png"/></p>
<p>1）遍历时发现其他 goroutine 在并发写，直接抛出 fatal error：</p>
<p>（2）开启最外圈的循环，依次遍历桶数组中的每个桶链表，通过 next 和 goto next 关键字实现循环代码块；</p>
<p>（3）倘若已经遍历完所有的桶，重新回到起始桶为止，则直接结束方法；</p>
<p>（4）倘若 map 处于扩容流程，取桶时兼容新老桶数组的逻辑. 倘若桶处于旧桶数组且未完成迁移，需要将 checkBucket 置为当前的桶号；</p>
<p>5）遍历的桶号加 1，倘若来到桶数组末尾，则将桶号置为 0. 将 key-value 对的遍历索引 i 置为 0.</p>
<p>（6）依次遍历各个桶中每个 key-value 对：</p>
<p>（7）倘若遍历到的桶属于旧桶数组未迁移完成的桶，需要按照其在新桶中的顺序完成遍历. 比如，增量扩容流程中，旧桶中的 key-value 对最终应该被分散迁移到新桶数组的 x、y 两个区域，则此时遍历时，哪怕 key-value 对仍存留在旧桶中未完成迁移，遍历时也应该严格按照其在新桶数组中的顺序来执行.</p>
<p>（8）执行 mapaccessK 方法，基于读流程方法获取 key-value 对，通过迭代 hiter 的 key、value 指针进行接收，用于对用户的遍历操作进行响应：</p>
<h2 id="扩容流程">扩容流程<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#扩容流程" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226221610.png" alt="image.png"/></p>
<h3 id="扩容类型">扩容类型<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#扩容类型" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>（1）增量扩容</p>
<p>表现：扩容后，桶数组的长度增长为原长度的 2 倍；</p>
<p>目的：降低每个桶中 key-value 对的数量，优化 map 操作的时间复杂度.</p>
<p>（2）等量扩容</p>
<p>表现：扩容后，桶数组的长度和之前保持一致；但是溢出桶的数量会下降.</p>
<p>目的：提高桶主体结构的数据填充率，减少溢出桶数量，避免发生内存泄漏</p>
<h3 id="何时扩容">何时扩容<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#何时扩容" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>（1）只有 map 的写流程可能开启扩容模式；</p>
<p>（2）写 map 新插入 key-value 对之前，会发起是否需要扩容的逻辑判断：</p>
<p>（3）根据 hmap 的 oldbuckets 是否空，可以判断 map 此前是否已开启扩容模式：</p>
<p>（4）倘若此前未进入扩容模式，且 map 中 key-value 对的数量超过 8 个，且大于桶数组长度的 6.5 倍，则进入增量扩容：</p>
<p>（5）倘若溢出桶的数量大于 2^B 个（即桶数组的长度；B 大于 15 时取15），则进入等量扩容：</p>
<h3 id="如何开启扩容模式">如何开启扩容模式<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#如何开启扩容模式" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>开启扩容模式的方法位于 runtime/map.go 的 hashGrow 方法中：</p>
<pre><code>func hashGrow(t *maptype, h *hmap) {
    bigger := uint8(1)
    if !overLoadFactor(h.count+1, h.B) {
        bigger = 0
        h.flags |= sameSizeGrow
    }
    oldbuckets := h.buckets
    newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil)




    flags := h.flags &amp;^ (iterator | oldIterator)
    if h.flags&amp;iterator != 0 {
        flags |= oldIterator
    }
    // commit the grow (atomic wrt gc)
    h.B += bigger
    h.flags = flags
    h.oldbuckets = oldbuckets
    h.buckets = newbuckets
    h.nevacuate = 0
    h.noverflow = 0


    if h.extra != nil &amp;&amp; h.extra.overflow != nil {
        // Promote current overflow buckets to the old generation.
        if h.extra.oldoverflow != nil {
            throw(&quot;oldoverflow is not nil&quot;)
        }
        h.extra.oldoverflow = h.extra.overflow
        h.extra.overflow = nil
    }
    if nextOverflow != nil {
        if h.extra == nil {
            h.extra = new(mapextra)
        }
        h.extra.nextOverflow = nextOverflow
    }
</code></pre>
<p>（1）倘若是增量扩容，bigger 值取 1；倘若是等量扩容，bigger 值取 0，并将 hmap.flags 的第 4 个 bit 位置为 1，标识当前处于等量扩容流程
（2）将原桶数组赋值给 oldBuckets，并创建新的桶数组和一批新的溢出桶.</p>
<p>此处会通过变量 bigger，实现不同扩容模式下，新桶数组长度的区别处理.
（3）更新 hmap 的桶数组长度指数 B，flag 标识，并将新、老桶数组赋值给 hmap.oldBuckets 和 hmap.buckets；扩容迁移进度 hmap.nevacuate 标记为 0；新桶数组的溢出桶数量 hmap.noverflow 置为 0.</p>
<p>（4）将原本存量可用的溢出桶赋给 hmap.extra.oldoverflow；倘若存在下一个可用的溢出桶，赋给 hmap.extra.nextOverflow.</p>
<h3 id="扩容迁移规则">扩容迁移规则<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#扩容迁移规则" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226222118.png" alt="image.png"/></p>
<p>（1）在等量扩容中，<strong>新桶数组长度与原桶数组相同</strong>；</p>
<p>（2）key-value 对在新桶数组和老桶数组的中的索引号保持一致；</p>
<p>（3）在增量扩容中，<strong>新桶数组长度为原桶数组的两倍</strong>；</p>
<p>（4）把新桶数组中桶号对应于老桶数组的区域称为 x 区域，新扩展的区域称为 y 区域.</p>
<p>（5）实际上，一个 key 属于哪个桶，取决于其 hash 值对桶数组长度取模得到的结果，因此依赖于其低位的 hash 值结果.；</p>
<p>（6）在增量扩容流程中，新桶数组的长度会扩展一位，假定 key 原本从属的桶号为 i，则在新桶数组中从属的桶号只可能是 i （x 区域）或者 i + 老桶数组长度（y 区域）；</p>
<p>（7）当 key 低位 hash 值向左扩展一位的 bit 位为 0，则应该迁往 x 区域的 i 位置；倘若该 bit 位为 1，应该迁往 y 区域对应的 i + 老桶数组长度的位置.</p>
<h3 id="渐进式扩容">渐进式扩容<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#渐进式扩容" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>map 采用的是<strong>渐进扩容</strong>的方式，避免因为一次性的全量数据迁移引发性能抖动.</p>
<p>当每次触发写、删操作时，会为处于扩容流程中的 map 完成两组桶的数据迁移：</p>
<p><strong>（1）一组桶是当前写、删操作所命中的桶；</strong></p>
<p><strong>（2）另一组桶是，当前未迁移的桶中，索引最小的那个桶.</strong></p>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226222153.png" alt="image.png"/></p>
<p>数据迁移的逻辑位于 runtime/map.go 的 evacuate 方法当中：</p>
<pre><code>func evacuate(t *maptype, h *hmap, oldbucket uintptr) {
    // 入参中，oldbucket 为当前要迁移的桶在旧桶数组中的索引
    // 获取到待迁移桶的内存地址 b
    b := (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))
    // 获取到旧桶数组的容量 newbit
    newbit := h.noldbuckets()
    // evacuated 方法判断出桶 b 是否已经迁移过了，未迁移过，才进入此 if 分支进行迁移处理
    if !evacuated(b) {
        // 通过一个二元数组 xy 指向当前桶可能迁移到的目的桶
        // x = xy[0]，代表新桶数组中索引和旧桶数组一致的桶
        // y = xy[1]，代表新桶数组中，索引为原索引加上旧桶容量的桶，只在增量扩容中会使用到
        var xy [2]evacDst
        x := &amp;xy[0]
        x.b = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize)))
        x.k = add(unsafe.Pointer(x.b), dataOffset)
        x.e = add(x.k, bucketCnt*uintptr(t.keysize))


        // 只有进入增量扩容的分支，才需要对 y 进行初始化
        if !h.sameSizeGrow() {
            // Only calculate y pointers if we're growing bigger.
            // Otherwise GC can see bad pointers.
            y := &amp;xy[1]
            y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize)))
            y.k = add(unsafe.Pointer(y.b), dataOffset)
            y.e = add(y.k, bucketCnt*uintptr(t.keysize))
        }


        // 外层 for 循环，遍历桶 b 和对应的溢出桶
        for ; b != nil; b = b.overflow(t) {
            // k,e 分别记录遍历桶时，当前的 key 和 value 的指针
            k := add(unsafe.Pointer(b), dataOffset)
            e := add(k, bucketCnt*uintptr(t.keysize))
            // 遍历桶内的 key-value 对
            for i := 0; i &lt; bucketCnt; i, k, e = i+1, add(k, uintptr(t.keysize)), add(e, uintptr(t.elemsize)) {
                top := b.tophash[i]
                if isEmpty(top) {
                    b.tophash[i] = evacuatedEmpty
                    continue
                }
                if top &lt; minTopHash {
                    throw(&quot;bad map state&quot;)
                }
                k2 := k
                if t.indirectkey() {
                    k2 = *((*unsafe.Pointer)(k2))
                }
                var useY uint8
                if !h.sameSizeGrow() {
                    // Compute hash to make our evacuation decision (whether we need
                    // to send this key/elem to bucket x or bucket y).
                    hash := t.hasher(k2, uintptr(h.hash0))
                    if hash&amp;newbit != 0 {
                       useY = 1
                    }
                }
                b.tophash[i] = evacuatedX + useY // evacuatedX + 1 == evacuatedY
                dst := &amp;xy[useY]                 // evacuation destination
                if dst.i == bucketCnt {
                    dst.b = h.newoverflow(t, dst.b)
                    dst.i = 0
                    dst.k = add(unsafe.Pointer(dst.b), dataOffset)
                    dst.e = add(dst.k, bucketCnt*uintptr(t.keysize))
                }
                dst.b.tophash[dst.i&amp;(bucketCnt-1)] = top // mask dst.i as an optimization, to avoid a bounds check
                if t.indirectkey() {
                    *(*unsafe.Pointer)(dst.k) = k2 // copy pointer
                } else {
                    typedmemmove(t.key, dst.k, k) // copy elem
                }
                if t.indirectelem() {
                    *(*unsafe.Pointer)(dst.e) = *(*unsafe.Pointer)(e)
                } else {
                    typedmemmove(t.elem, dst.e, e)
                }
                dst.i++
                dst.k = add(dst.k, uintptr(t.keysize))
                dst.e = add(dst.e, uintptr(t.elemsize))
            }
        }
        // Unlink the overflow buckets &amp; clear key/elem to help GC.
        if h.flags&amp;oldIterator == 0 &amp;&amp; t.bucket.ptrdata != 0 {
            b := add(h.oldbuckets, oldbucket*uintptr(t.bucketsize))
            // Preserve b.tophash because the evacuation
            // state is maintained there.
            ptr := add(b, dataOffset)
            n := uintptr(t.bucketsize) - dataOffset
            memclrHasPointers(ptr, n)
        }
    }


    if oldbucket == h.nevacuate {
        advanceEvacuationMark(h, t, newbit)
    }
}


func (h *hmap) noldbuckets() uintptr {
    oldB := h.B
    if !h.sameSizeGrow() {
        oldB--
    }
    return bucketShift(oldB)
</code></pre>
<p>（1）从老桶数组中获取到待迁移的桶 b；</p>
<p>（2）获取到老桶数组的长度 newbit；</p>
<p>（3）倘若当前桶已经完成了迁移，则无需处理；</p>
<p>（4）创建一个二元数组 xy，分别承载 x 区域和 y 区域（含义定义见 9.4 小节）中的新桶位置，用于接受来自老桶数组的迁移数组；只有在增量扩容的流程中，才存在 y 区域，因此才需要对 xy 中的 y 进行定义；</p>
<p>（5）开启两层 for 循环，外层遍历桶链表，内层遍历每个桶中的 key-value 对：</p>
<p>（6）取每个位置的 tophash 值进行判断，倘若当前是个空位，则将当前位置 tophash 值置为 evacuatedEmpty，开始遍历下一个位置：</p>
<p>（7）基于 9.4 的规则，寻找到迁移的目的桶；</p>
<p>其中目的桶的类型定义如下：</p>
<pre><code>type evacDst struct {
    b *bmap          // current destination bucket
    i int            // key/elem index into b
    k unsafe.Pointer // pointer to current key storage
    e unsafe.Pointer // pointer to current elem storage
}
</code></pre>
<p>I evacDst.b：目的地的所在桶；</p>
<p>II evacDst.i：即将入桶的 key-value 对在桶中的索引；</p>
<p>III evacDst.k：入桶 key 的存储指针；</p>
<p>IV evacDst.e：入桶 value 的存储指针.</p>
<p>（8）将 key-value 对迁移到目的桶中，并且更新目的桶结构内几个指针的指向：</p>
<p>（9）倘若当前迁移的桶是旧桶数组未迁移的桶中索引最小的一个，则 hmap.nevacuate 累加 1.</p>
<p>倘若已经迁移完所有的旧桶，则会确保 hmap.flags 中，等量扩容的标识位被置为 0.</p>
<h1 id="map-遍历为什么是无序的">map 遍历为什么是无序的？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#map-遍历为什么是无序的" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>使用 range 多次遍历 map 时输出的 key 和 value 的顺序可能不同。这是 Go 语言的设计者们<strong>有意为之</strong>，旨在提示开发者们，Go 底层实现并不保证 map 遍历顺序稳定，请大家不要依赖 range 遍历结果顺序</p>
<p>主要原因有 2 点：</p>
<ul>
<li>Map 在遍历时，并不是从固定的 0 号 bucket 开始遍历的，每次遍历，都会从一个<strong>随机值序号的 bucket</strong>，再从其中<strong>随机的 cell</strong>开始遍历</li>
<li>Map 遍历时，是按序遍历 bucket，同时按需遍历 bucket 中和其 overflow bucket 中的 cell。但是 map 在扩容后，会发生 key 的搬迁，这造成原来落在一个 bucket 中的 key，搬迁后，有可能会落到其他 bucket 中了，从这个角度看，遍历 map 的结果就不可能是按照原来的顺序了</li>
</ul>
<p>Map 本身是无序的，且遍历时顺序还会被随机化，如果想顺序遍历 map，需要对 map key 先排序，再按照 key 的顺序遍历 map。</p>
<pre><code>func TestMapRange(t *testing.T) {
    m := map[int]string{1: &quot;a&quot;, 2: &quot;b&quot;, 3: &quot;c&quot;}
    t.Log(&quot;first range:&quot;)
    for i, v := range m {
        t.Logf(&quot;m[%v]=%v &quot;, i, v)
    }
    t.Log(&quot;\nsecond range:&quot;)
    for i, v := range m {
        t.Logf(&quot;m[%v]=%v &quot;, i, v)
    }

    // 实现有序遍历
    var sl []int
    // 把 key 单独取出放到切片
    for k := range m {
        sl = append(sl, k)
    }
    // 排序切片
    sort.Ints(sl)
    // 以切片中的 key 顺序遍历 map 就是有序的了
    for _, k := range sl {
        t.Log(k, m[k])
    }
}
</code></pre>
<h1 id="map-为什么是非线程安全的">map 为什么是非线程安全的？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#map-为什么是非线程安全的" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>Map 默认是并发不安全的，同时对 map 进行并发读写时，程序会 panic，原因如下：</p>
<p>Go 官方在经过了长时间的讨论后，认为 Go map 更应适配典型使用场景（不需要从多个 goroutine 中进行安全访问），而不是为了小部分情况（并发访问），导致大部分程序付出加锁代价（性能），决定了不支持。</p>
<p>场景: 2 个协程同时读和写，以下程序会出现致命错误：fatal error: concurrent map writes</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    s := make(map[int]int)
    for i := 0; i &lt; 100; i++ {
        go func(i int) {
            s[i] = i
        }(i)
    }
    for i := 0; i &lt; 100; i++ {
        go func(i int) {
            fmt.Printf(&quot;map第%d个元素值是%d\n&quot;, i, s[i])
        }(i)
    }
    time.Sleep(1 * time.Second)
}
</code></pre>
<p>如果想实现 map 线程安全，有两种方式：</p>
<p>方式一：使用读写锁 <code>map</code> + <code>sync.RWMutex</code></p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

func main() {
    var lock sync.RWMutex
    s := make(map[int]int)
    for i := 0; i &lt; 100; i++ {
        go func(i int) {
            lock.Lock()
            s[i] = i
            lock.Unlock()
        }(i)
    }
    for i := 0; i &lt; 100; i++ {
        go func(i int) {
            lock.RLock()
            fmt.Printf(&quot;map第%d个元素值是%d\n&quot;, i, s[i])
            lock.RUnlock()
        }(i)
    }
    time.Sleep(1 * time.Second)
}

</code></pre>
<p>方式二：使用 Go 提供的 <code>sync.Map</code></p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

func main() {
    var m sync.Map
    for i := 0; i &lt; 100; i++ {
        go func(i int) {
            m.Store(i, i)
        }(i)
    }
    for i := 0; i &lt; 100; i++ {
        go func(i int) {
            v, ok := m.Load(i)
            fmt.Printf(&quot;Load: %v, %v\n&quot;, v, ok)
        }(i)
    }
    time.Sleep(1 * time.Second)
}
</code></pre>
<h1 id="map-怎么知道自己处于竞争状态是-go-编码实现的还是底层硬件实现的">Map 怎么知道自己处于竞争状态？是 Go 编码实现的还是底层硬件实现的？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#map-怎么知道自己处于竞争状态是-go-编码实现的还是底层硬件实现的" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<ul>
<li>
<p>代码实现的，在查找、赋值、遍历、删除的过程中**都会检测写标志 flags，一旦发现写标志置位 (等于 1)，抛出 fatal error，无法使用 recover 进行恢复。</p>
</li>
<li>
<p>赋值和删除函数载检测完标志是复位状态 (等于 0)之后，先将写标志位置位，才会进行之后的操作。</p>
</li>
</ul>
<h1 id="map-的-panic-能被-recover-掉吗了解-panic-和-recover-的机制">Map 的 panic 能被 recover 掉吗？了解 panic 和 recover 的机制？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#map-的-panic-能被-recover-掉吗了解-panic-和-recover-的机制" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p><strong>抛出 fatal error，无法使用 recover 进行恢复</strong></p>
<pre><code>func main() {
    defer errorHandler()
    m := map[string]int{}

    go func() {
        for {
            m[&quot;x&quot;] = 1
        }
    }()
    for {
        _ = m[&quot;x&quot;]
    }
}

func errorHandler() {
    if r := recover(); r != nil {
        fmt.Println(r)
    }
}//不能
</code></pre>
<p>Map 由于不是线程安全的，所以在遇到并发读写的时候会抛出 concurrent map read and map write 异常，从而使程序直接退出。</p>
<pre><code>func mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer {
    ...
    if h.flags&amp;hashWriting != 0 {
        throw(&quot;concurrent map read and map write&quot;)
    }
    ...
｝
</code></pre>
<p>这里的 throw 和上面一样，最终会调用到 exit 执行退出。</p>
<h1 id="go-中两个-map-对象如何比较">Go 中两个 map 对象如何比较<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-中两个-map-对象如何比较" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>使用 reflect. DeepEqual 这个函数进行比较。使用 reflect. DeepEqual 有一点注意：由于使用了反射，所以有性能的损失。如果你多做一些测试，那么你会发现 reflect. DeepEqual 会比 == 慢 100 倍以上。</p>
<h1 id="map-的优缺点以及改进">Map 的优缺点以及改进?<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#map-的优缺点以及改进" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p><strong>优点</strong>：</p>
<ol>
<li>
<p>Map 类似其他语言中的哈希表或字典，以 key-value 形式存储数据</p>
</li>
<li>
<p>Key 必须是支持==或!=比较运算的类型，不可以是函数、map 或 slice</p>
</li>
<li>
<p>Map 通过 key 查找 value 比线性搜索快很多。</p>
</li>
<li>
<p>Map 使用 make ()创建，支持:=这种简写方式</p>
</li>
<li>
<p>超出容量时会自动扩容，</p>
</li>
<li>
<p>当键值对不存在时自动添加，使用 delete ()删除某键值对</p>
</li>
</ol>
<p><strong>缺点：</strong></p>
<p>并发中的 map 不是安全的</p>
<h1 id="sync-map-怎么使用">Sync. Map 怎么使用<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#sync-map-怎么使用" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

func main() {
    var scene sync.Map
    // 将键值对保存到sync.Map
    scene.Store(&quot;1&quot;, 1)
    scene.Store(&quot;2&quot;, 2)
    scene.Store(&quot;3&quot;, 3)
    // 从sync.Map中根据键取值
    fmt.Println(scene.Load(&quot;1&quot;))
    // 根据键删除对应的键值对
    scene.Delete(&quot;1&quot;)
    // 遍历所有sync.Map中的键值对
    scene.Range(func(k, v interface{}) bool {
        fmt.Println(&quot;iterate:&quot;, k, v)
        return true
    })
}
</code></pre>
<h1 id="sync-map-底层实现原理">Sync. Map 底层实现原理<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#sync-map-底层实现原理" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<h2 id="sync-map">Sync. Map<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#sync-map" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226223137.png" alt="image.png"/></p>
<pre><code>type Map struct {
    mu Mutex
    read atomic.Value 
    dirty map[any]*entry
    misses int
}
</code></pre>
<p>sync.Map 主类中包含以下核心字段：</p>
<ul>
<li>
<p>read：无锁化的只读 map，实际类型为 readOnly，2.3 小节会进一步介绍；</p>
</li>
<li>
<p>dirty：加锁处理的读写 map；</p>
</li>
<li>
<p>misses：记录访问 read 的失效次数，累计达到阈值时，会进行 read map/dirty map 的更新轮换；</p>
</li>
<li>
<p>mu：一把互斥锁，实现 dirty 和 misses 的并发管理.</p>
</li>
</ul>
<p>可见，sync.Map 的特点是冗余了两份 map：read map 和 dirty map，后续的所介绍的交互流程也和这两个 map 息息相关，基本可以归结为两条主线</p>
<ul>
<li>
<p>主线一：首先基于无锁操作访问 read map；倘若 read map 不存在该 key，则加锁并使用 dirty map 兜底；</p>
</li>
<li>
<p>主线二：read map 和 dirty map 之间会交替轮换更新</p>
</li>
</ul>
<h2 id="entry">Entry<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#entry" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<pre><code>type entry struct {
    p unsafe.Pointer 
}
</code></pre>
<p>kv 对中的 value，统一采用 unsafe.Pointer 的形式进行存储，通过 entry.p 的指针进行链接.</p>
<p>entry.p 的指向分为三种情况：</p>
<ul>
<li>
<p>I 存活态：正常指向元素；</p>
</li>
<li>
<p>II 软删除态：指向 nil；</p>
</li>
<li>
<p>III 硬删除态：指向固定的全局变量 expunged.</p>
</li>
</ul>
<pre><code>var expunged = unsafe.Pointer(new(any))
</code></pre>
<blockquote>
<ul>
<li>
<p>存活态很好理解，即 key-entry 对仍未删除；</p>
</li>
<li>
<p>nil 态表示软删除，read map 和 dirty map 底层的 map 结构仍存在 key-entry 对，但在逻辑上该 key-entry 对已经被删除，因此无法被用户查询到；<br/>
    * expunged 态表示硬删除，dirty map 中已不存在该 key-entry 对.</p>
</li>
</ul>
</blockquote>
<h2 id="readonly">readOnly<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#readonly" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<pre><code>type readOnly struct {
    m       map[any]*entry
    amended bool // true if the dirty map contains some key not in m.
}
</code></pre>
<p>sync.Map 中的只读 map：read 内部包含两个成员属性：</p>
<ul>
<li>
<p>m：真正意义上的 read map，实现从 key 到 entry 的映射；</p>
</li>
<li>
<p>amended：标识 read map 中的 key-entry 对是否存在缺失，需要通过 dirty map 兜底.</p>
</li>
</ul>
<h2 id="读流程-1">读流程<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#读流程-1" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226223946.png" alt="image.png"/></p>
<h3 id="syncmapload">sync.Map.Load()<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#syncmapload" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<pre><code>func (m *Map) Load(key any) (value any, ok bool) {
    read, _ := m.read.Load().(readOnly)
    e, ok := read.m[key]
    if !ok &amp;&amp; read.amended {
        m.mu.Lock()
        read, _ = m.read.Load().(readOnly)
        e, ok = read.m[key]
        if !ok &amp;&amp; read.amended {
            e, ok = m.dirty[key]
            m.missLocked()
        }
        m.mu.Unlock()
    }
    if !ok {
        return nil, false
    }
    return e.load()
}
</code></pre>
<ul>
<li>
<p>查看 read map 中是否存在 key-entry 对，若存在，则直接读取 entry 返回；</p>
</li>
<li>
<p>倘若第一轮 read map 查询 miss，且 read map 不全，则需要加锁 double check；</p>
</li>
<li>
<p>第二轮 read map 查询仍 miss（加锁后），且 read map 不全，则查询 dirty map 兜底；</p>
</li>
<li>
<p> 查询操作涉及到与 dirty map 的交互，misses 加一；</p>
</li>
<li>
<p> 解锁，返回查得的结果.</p>
</li>
</ul>
<h3 id="entryload">entry.load()<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#entryload" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<pre><code>func (e *entry) load() (value any, ok bool) {
    p := atomic.LoadPointer(&amp;e.p)
    if p == nil || p == expunged {
        return nil, false
    }
    return *(*any)(p), true
}
</code></pre>
<ul>
<li>
<p>sync.Map 中，kv 对的 value 是基于 entry 指针封装的形式；</p>
</li>
<li>
<p> 从 map 取得 entry 后，最终需要调用 entry.load 方法读取指针指向的内容；</p>
</li>
<li>
<p>倘若 entry 的指针状态为 nil 或者 expunged，说明 key-entry 对已被删除，则返回 nil；</p>
</li>
<li>
<p> 倘若 entry 未被删除，则读取指针内容，并且转为 any 的形式进行返回.</p>
</li>
</ul>
<h3 id="-syncmapmisslocked"><a href="../.././../tags/" class="tag-link internal alias" data-slug="tags/index"></a> sync.Map.missLocked()<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#-syncmapmisslocked" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<pre><code>func (m *Map) missLocked() {
    m.misses++
    if m.misses &lt; len(m.dirty) {
        return
    }
    m.read.Store(readOnly{m: m.dirty})
    m.dirty = nil
    m.misses = 0
}
</code></pre>
<ul>
<li>
<p> 在读流程中，倘若未命中 read map，且由于 read map 内容存在缺失需要和 dirty map 交互时，会走进 missLocked 流程；</p>
</li>
<li>
<p> 在 missLocked 流程中，首先 misses 计数器累加 1；</p>
</li>
<li>
<p> 倘若 miss 次数小于 dirty map 中存在的 key-entry 对数量，直接返回即可；</p>
</li>
<li>
<p> 倘若 miss 次数大于等于 dirty map 中存在的 key-entry 对数量，则使用 dirty map 覆盖 read map，并将 read map 的 amended flag 置为 false；</p>
</li>
<li>
<p> 新的 dirty map 置为 nil，misses 计数器清零.</p>
</li>
</ul>
<h2 id="写流程-1"> 写流程<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#写流程-1" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZsUuTG80xphH43Ht3WJG36CEl8AXCYgWOicSKtS6hNVcTzjJwoG6VrEqImiahxnV3aeImfEyNh9IsqQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"/></p>
<p>sync.Map 写流程</p>
<h3 id="syncmapstore">sync.Map.Store()<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#syncmapstore" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<pre><code>func (m *Map) Store(key, value any) {
    read, _ := m.read.Load().(readOnly)
    if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) {
        return
    }


    m.mu.Lock()
    read, _ = m.read.Load().(readOnly)
    if e, ok := read.m[key]; ok {
        if e.unexpungeLocked() {
            m.dirty[key] = e
        }
        e.storeLocked(&amp;value)
    } else if e, ok := m.dirty[key]; ok {
        e.storeLocked(&amp;value)
    } else {
        if !read.amended {
            m.dirtyLocked()
            m.read.Store(readOnly{m: read.m, amended: true})
        }
        m.dirty[key] = newEntry(value)
    }
    m.mu.Unlock()
}


func (e *entry) storeLocked(i *any) {
    atomic.StorePointer(&amp;e.p, unsafe.Pointe
}
</code></pre>
<p>（1）倘若 read map 存在拟写入的 key，且 entry 不为 expunged 状态，说明这次操作属于更新而非插入，直接基于 CAS 操作进行 entry 值的更新，并直接返回（存活态或者软删除，直接覆盖更新）；</p>
<p>（2）倘若未命中（1）的分支，则需要加锁 double check；</p>
<p>（3）倘若第二轮检查中发现 read map 或者 dirty map 中存在 key-entry 对，则直接将 entry 更新为新值即可（存活态或者软删除，直接覆盖更新）；</p>
<p>（4）在第（3）步中，如果发现 read map 中该 key-entry 为 expunged 态，需要在 dirty map 先补齐 key-entry 对，再更新 entry 值（从硬删除中恢复，然后覆盖更新）；</p>
<p>（5）倘若 read map 和 dirty map 均不存在，则在 dirty map 中插入新 key-entry 对，并且保证 read map 的 amended flag 为 true.（插入）</p>
<p>（6）第（5）步的分支中，倘若发现 dirty map 未初始化，需要前置执行 dirtyLocked 流程；</p>
<p>（7）解锁返回.  </p>
<p>下面补充介绍 Store() 方法中涉及到的几个子方法.</p>
<h3 id="entrytrystore">entry.tryStore()<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#entrytrystore" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<pre><code>func (m *Map) Store(key, value any) {
    read, _ := m.read.Load().(readOnly)
    if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) {
        return
    }


    m.mu.Lock()
   // ...
}


func (e *entry) tryStore(i *any) bool {
    for {
        p := atomic.LoadPointer(&amp;e.p)
        if p == expunged {
            return false
        }
        if atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) {
            return true
        }
    }
}
</code></pre>
<ul>
<li>
<p>• 在写流程中，倘若发现 read map 中已存在对应的 key-entry 对，则会对调用 tryStore 方法尝试进行更新；</p>
</li>
<li>
<p>• 倘若 entry 为 expunged 态，说明已被硬删除，dirty 中缺失该项数据，因此 tryStore 执行失败，回归主干流程；</p>
</li>
<li>
<p>• 倘若 entry 非 expunged 态，则直接执行 CAS 操作完成值的更新即可.</p>
</li>
</ul>
<h3 id="entryunexpungelocked">entry.unexpungeLocked()<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#entryunexpungelocked" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<pre><code>func (m *Map) Store(key, value any) {
    // ...
    m.mu.Lock()
    read, _ = m.read.Load().(readOnly)
    if e, ok := read.m[key]; ok {
        if e.unexpungeLocked() {
            m.dirty[key] = e
        }
        e.storeLocked(&amp;value)
    } 
    // ...
}


func (e *entry) unexpungeLocked() (wasExpunged bool) {
    return atomic.CompareAndSwapPointer(&amp;e.p, expunged, nil)
}
</code></pre>
<ul>
<li>
<p>• 在写流程加锁 double check 的过程中，倘若发现 read map 中存在对应的 key-entry 对，会执行该方法；</p>
</li>
<li>
<p>• 倘若 key-entry 为硬删除 expunged 态，该方法会基于 CAS 操作将其更新为软删除 nil 态，然后进一步在 dirty map 中补齐该 key-entry 对，实现从硬删除到软删除的恢复.</p>
</li>
</ul>
<h3 id="entrystorelocked">entry.storeLocked()<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#entrystorelocked" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<pre><code>func (m *Map) Store(key, value any) {
    // ...
    m.mu.Lock()
    read, _ = m.read.Load().(readOnly)
    if e, ok := read.m[key]; ok {
       // ...
        e.storeLocked(&amp;value)
    } else if e, ok := m.dirty[key]; ok {
        e.storeLocked(&amp;value)
    } 
    // ...
}


func (e *entry) storeLocked(i *any) {
    atomic.StorePointer(&amp;e.p, unsafe.Pointer)
}
</code></pre>
<p>写流程中，倘若 read map 或者 dirty map 存在对应 key-entry，最终会通过原子操作，将新值的指针存储到 entry.p 当中.</p>
<h3 id="syncmapdirtylocked">sync.Map.dirtyLocked()<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#syncmapdirtylocked" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZsUuTG80xphH43Ht3WJG36CcuBUenRpJGmoHvuTdQTX4BwgLVEAhjgTBomODX1LBibuibqd6VkaOcVQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"/></p>
<p>dirtyLock 方法</p>
<pre><code>func (m *Map) dirtyLocked() {
    if m.dirty != nil {
        return
    }


    read, _ := m.read.Load().(readOnly)
    m.dirty = make(map[any]*entry, len(read.m))
    for k, e := range read.m {
        if !e.tryExpungeLocked() {
            m.dirty[k] = e
        }
    }
}


func (e *entry) tryExpungeLocked() (isExpunged bool) {
    p := atomic.LoadPointer(&amp;e.p)
    for p == nil {
        if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) {
            return true
        }
        p = atomic.LoadPointer(&amp;e.p)
    }
    return p == expunged
}
</code></pre>
<ul>
<li>
<p>• 在写流程中，倘若需要将 key-entry 插入到兜底的 dirty map 中，并且此时 dirty map 为空（从未写入过数据或者刚发生过 missLocked），会进入 dirtyLocked 流程；</p>
</li>
<li>
<p>• 此时会遍历一轮 read map ，将未删除的 key-entry 对拷贝到 dirty map 当中；</p>
</li>
<li>
<p>• 在遍历时，还会将 read map 中软删除 nil 态的 entry 更新为硬删除 expunged 态，因为在此流程中，不会将其拷贝到 dirty map.</p>
</li>
</ul>
<h2 id="删流程">删流程<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#删流程" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZsUuTG80xphH43Ht3WJG36CRAuibb73ia2hJuBkpQNNiaowGY9HPic4MX2YPresfrfndXdIj6bTLIKblw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"/></p>
<p>Delete流程</p>
<h3 id="syncmapdelete">sync.Map.Delete()<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#syncmapdelete" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<pre><code>func (m *Map) Delete(key any) {
    m.LoadAndDelete(key)
}


func (m *Map) LoadAndDelete(key any) (value any, loaded bool) {
    read, _ := m.read.Load().(readOnly)
    e, ok := read.m[key]
    if !ok &amp;&amp; read.amended {
        m.mu.Lock()
        read, _ = m.read.Load().(readOnly)
        e, ok = read.m[key]
        if !ok &amp;&amp; read.amended {
            e, ok = m.dirty[key]
            delete(m.dirty, key)
            m.missLocked()
        }
        m.mu.Unlock()
    }
    if ok {
        return e.delete()
    }
    return nil, false
}
</code></pre>
<p>（1）倘若 read map 中存在 key，则直接基于 cas 操作将其删除；</p>
<p>（2）倘若read map 不存在 key，且 read map 有缺失（amended flag 为 true），则加锁 dou check；</p>
<p>（3）倘若加锁 double check 时，read map 仍不存在 key 且 read map 有缺失，则从 dirty map 中取元素，并且将 key-entry 对从 dirty map 中物理删除；</p>
<p>（4）走入步骤（3），删操作需要和 dirty map 交互，需要走进 3.3 小节介绍的 missLocked 流程；</p>
<p>（5）解锁；</p>
<p>（6）倘若从 read map 或 dirty map 中获取到了 key 对应的 entry，则走入 entry.delete() 方法逻辑删除 entry；</p>
<p>（7）倘若 read map 和 dirty map 中均不存在 key，返回 false 标识删除失败.  </p>
<h3 id="entrydelete">entry.delete()<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#entrydelete" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<pre><code>func (e *entry) delete() (value any, ok bool) {
    for {
        p := atomic.LoadPointer(&amp;e.p)
        if p == nil || p == expunged {
            return nil, false
        }
        if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) {
            return *(*any)(p), true
        }
    }
}
</code></pre>
<ul>
<li>
<p>• 该方法是 entry 的逻辑删除方法；</p>
</li>
<li>
<p>• 倘若 entry 此前已被删除，则直接返回 false 标识删除失败；</p>
</li>
<li>
<p>• 倘若 entry 当前仍存在，则通过 CAS 将 entry.p 指向 nil，标识其已进入软删除状态.</p>
</li>
</ul>
<h2 id="遍历流程-1">遍历流程<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#遍历流程-1" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZsUuTG80xphH43Ht3WJG36CkgF4rrYRgJjyxJMZG87pW5bN1sGWwmgm1jZLrnuCXL9UJZ5dUs5YHw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"/></p>
<p>遍历流程</p>
<pre><code>func (m *Map) Range(f func(key, value any) bool) {
    read, _ := m.read.Load().(readOnly)
    if read.amended {
        m.mu.Lock()
        read, _ = m.read.Load().(readOnly)
        if read.amended {
            read = readOnly{m: m.dirty}
            m.read.Store(read)
            m.dirty = nil
            m.misses = 0
        }
        m.mu.Unlock()
    }


    for k, e := range read.m {
        v, ok := e.load()
        if !ok {
            continue
        }
        if !f(k, v) {
            break
        }
    }
}
</code></pre>
<ul>
<li>
<p>（1）在遍历过程中，倘若发现 read map 数据不全（amended flag 为 true），会额外加一次锁，并使用 dirty map 覆盖 read map；</p>
</li>
<li>
<p>（2）遍历 read map（通过步骤（1）保证 read map 有全量数据），执行用户传入的回调函数，倘若某次回调时返回值为 false，则会终止全流程.</p>
</li>
</ul>
<h2 id="总结">总结<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#总结" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<h3 id="entry-的-expunged-态">entry 的 expunged 态<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#entry-的-expunged-态" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><strong>思考问题：</strong></p>
<p>为什么需要使用 expunged 态来区分软硬删除呢？仅用 nil 一种状态来标识删除不可以吗？</p>
<p><strong>回答：</strong></p>
<p>首先需要明确，无论是软删除(nil)还是硬删除(expunged),都表示在逻辑意义上 key-entry 对已经从 sync.Map 中删除，nil 和 expunged 的区别在于：</p>
<p>• 软删除态（nil）：read map 和 dirty map 在物理上仍保有该 key-entry 对，因此倘若此时需要对该 entry 执行写操作，可以直接 CAS 操作；</p>
<p>• 硬删除态（expunged）：dirty map 中已经没有该 key-entry 对，倘若执行写操作，必须加锁（dirty map 必须含有全量 key-entry 对数据）.</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZsUuTG80xphH43Ht3WJG36CAxye1O5PX8pnubKpT3wDbURickVwsYzqgWaBJ5GM07ms57giaiaiaM2n6g/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"/></p>
<p>复用 nil 态软删除的数据</p>
<p>设计 expunged 和 nil 两种状态的原因，就是为了优化在 dirtyLocked 前，针对同一个 key 先删后写的场景. 通过 expunged 态额外标识出 dirty map 中是否仍具有指向该 entry 的能力，这样能够实现对一部分 nil 态 key-entry 对的解放，能够基于 CAS 完成这部分内容写入操作而无需加锁.</p>
<h3 id="read-map-和-dirty-map-的数据流转">read map 和 dirty map 的数据流转<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#read-map-和-dirty-map-的数据流转" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>sync.Map 由两个 map 构成：</p>
<ul>
<li>
<p>• read map：访问时全程无锁；</p>
</li>
<li>
<p>• dirty map：是兜底的读写 map，访问时需要加锁.</p>
</li>
</ul>
<p>之所以这样处理，是希望能根据对读、删、更新、写操作频次的探测，来实时动态地调整操作方式，希望在读、更新、删频次较高时，更多地采用 CAS 的方式无锁化地完成操作；在写操作频次较高时，则直接了当地采用加锁操作完成.</p>
<p>因此， sync.Map 本质上采取了一种以空间换时间 + 动态调整策略的设计思路，下面对两个 map 间的数据流转过程进行详细介绍：</p>
<h4 id="两个-map">两个 map<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#两个-map" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZsUuTG80xphH43Ht3WJG36CIlk7IHD6tdMsFJ1DWggymJ72FEPEOLF5y6vWufWfILfeq27KSXFguw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"/></p>
<p>read map&amp; dirty map</p>
<ul>
<li>
<p>• 总体思想，希望能多用 read map，少用 dirty map，因为操作前者无锁，后者需要加锁；</p>
</li>
<li>
<p>• 除了 expunged 态的 entry 之外，read map 的内容为 dirty map 的子集；</p>
</li>
</ul>
<h4 id="dirty-map--read-map">dirty map <span>→</span> read map<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#dirty-map--read-map" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZsUuTG80xphH43Ht3WJG36CPMHoHZqRHibmVmXkCy09LefxEkmwS2w9MVWqHkzOxKtTgmDupA4mcibQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"/></p>
<p>dirty map 覆写 read map</p>
<ul>
<li>• 记录读/删流程中，通过 misses 记录访问 read map miss 由 dirty 兜底处理的次数，当 miss 次数达到阈值，则进入 missLocked 流程，进行新老 read/dirty 替换流程；此时将老 dirty 作为新 read，新 dirty map 则暂时为空，直到 dirtyLocked 流程完成对 dirty 的初始化；</li>
</ul>
<h4 id="read-map--dirty-map">read map <span>→</span> dirty map<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#read-map--dirty-map" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZsUuTG80xphH43Ht3WJG36CibxGwWWlfByvgeV1gjpbfpCvUYq1HHjMeyZckzLQh97zR2GkjDgCdXQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"/></p>
<p>遍历 read map 填充 dirty map</p>
<ul>
<li>
<p>• 发生 dirtyLocked 的前置条件：I dirty 暂时为空（此前没有写操作或者近期进行过 missLocked 流程）；II 接下来一次写操作访问 read 时 miss，需要由 dirty 兜底；</p>
</li>
<li>
<p>• 在 dirtyLocked 流程中，需要对 read 内的元素进行状态更新，因此需要遍历，是一个线性时间复杂度的过程，可能存在性能抖动；</p>
</li>
<li>
<p>• dirtyLocked 遍历中，会将 read 中未被删除的元素（非 nil 非 expunged）拷贝到 dirty 中；会将 read 中所有此前被删的元素统一置为 expunged 态.</p>
</li>
</ul>
<h1 id="go-map-和-sync-map-谁的性能好为什么">Go map 和 sync. Map 谁的性能好，为什么？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-map-和-sync-map-谁的性能好为什么" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>Go 语言的 <code>sync. Map</code> 支持并发读写，采取了 “空间换时间” 的机制，冗余了两个数据结构，分别是：read 和 dirty</p>
<pre><code>type Map struct {
   mu Mutex
   read atomic.Value // readOnly
   dirty map[interface{}]*entry
   misses int
}
</code></pre>
<p><strong>对比原始 map：</strong></p>
<p>和原始 map+RWLock 的实现并发的方式相比，减少了加锁对性能的影响。它做了一些优化：可以无锁访问 read map，而且会优先操作 read map，倘若只操作 read map 就可以满足要求，那就不用去操作 write map (dirty)，所以在某些特定场景中它发生锁竞争的频率会远远小于 map+RWLock 的实现方式</p>
<p><strong>优点：</strong></p>
<p>适合读多写少的场景</p>
<p><strong>缺点：</strong></p>
<p>写多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降</p></article></div><div class="right sidebar"><div class="graph"><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:false}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xml:space="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:true}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc" class><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#参考" data-for="参考">参考</a></li><li class="depth-0"><a href="#map-概述" data-for="map-概述">Map 概述</a></li><li class="depth-0"><a href="#map-初始化" data-for="map-初始化">Map 初始化</a></li><li class="depth-0"><a href="#map-的-key-可以是哪些类型可以嵌套-map-吗" data-for="map-的-key-可以是哪些类型可以嵌套-map-吗">Map 的 key 可以是哪些类型？可以嵌套 map 吗？</a></li><li class="depth-0"><a href="#map-读" data-for="map-读">Map 读</a></li><li class="depth-0"><a href="#map-的查询复杂度" data-for="map-的查询复杂度">Map 的查询复杂度</a></li><li class="depth-0"><a href="#map-写" data-for="map-写">Map 写</a></li><li class="depth-0"><a href="#map-删除" data-for="map-删除">Map 删除</a></li><li class="depth-0"><a href="#map-遍历" data-for="map-遍历">Map 遍历</a></li><li class="depth-0"><a href="#map-的底层实现原理" data-for="map-的底层实现原理">map 的底层实现原理？</a></li><li class="depth-1"><a href="#hash" data-for="hash">Hash</a></li><li class="depth-1"><a href="#桶数组" data-for="桶数组">桶数组</a></li><li class="depth-1"><a href="#map-冲突的解决方式" data-for="map-冲突的解决方式">map 冲突的解决方式？</a></li><li class="depth-1"><a href="#扩容" data-for="扩容">扩容</a></li><li class="depth-1"><a href="#hmap-结构体" data-for="hmap-结构体">hmap 结构体</a></li><li class="depth-1"><a href="#bmap-结构体" data-for="bmap-结构体">bmap 结构体</a></li><li class="depth-1"><a href="#mapextra-结构体" data-for="mapextra-结构体">mapextra 结构体</a></li><li class="depth-1"><a href="#map-的负载因子为什么是-65" data-for="map-的负载因子为什么是-65">Map 的负载因子为什么是 6.5？</a></li><li class="depth-1"><a href="#构造流程" data-for="构造流程">构造流程</a></li><li class="depth-1"><a href="#读流程" data-for="读流程">读流程</a></li><li class="depth-1"><a href="#写流程" data-for="写流程">写流程</a></li><li class="depth-1"><a href="#删除流程" data-for="删除流程">删除流程</a></li><li class="depth-1"><a href="#遍历流程" data-for="遍历流程">遍历流程</a></li><li class="depth-1"><a href="#扩容流程" data-for="扩容流程">扩容流程</a></li><li class="depth-2"><a href="#扩容类型" data-for="扩容类型">扩容类型</a></li><li class="depth-2"><a href="#何时扩容" data-for="何时扩容">何时扩容</a></li><li class="depth-2"><a href="#如何开启扩容模式" data-for="如何开启扩容模式">如何开启扩容模式</a></li><li class="depth-2"><a href="#扩容迁移规则" data-for="扩容迁移规则">扩容迁移规则</a></li><li class="depth-2"><a href="#渐进式扩容" data-for="渐进式扩容">渐进式扩容</a></li><li class="depth-0"><a href="#map-遍历为什么是无序的" data-for="map-遍历为什么是无序的">map 遍历为什么是无序的？</a></li><li class="depth-0"><a href="#map-为什么是非线程安全的" data-for="map-为什么是非线程安全的">map 为什么是非线程安全的？</a></li><li class="depth-0"><a href="#map-怎么知道自己处于竞争状态是-go-编码实现的还是底层硬件实现的" data-for="map-怎么知道自己处于竞争状态是-go-编码实现的还是底层硬件实现的">Map 怎么知道自己处于竞争状态？是 Go 编码实现的还是底层硬件实现的？</a></li><li class="depth-0"><a href="#map-的-panic-能被-recover-掉吗了解-panic-和-recover-的机制" data-for="map-的-panic-能被-recover-掉吗了解-panic-和-recover-的机制">Map 的 panic 能被 recover 掉吗？了解 panic 和 recover 的机制？</a></li><li class="depth-0"><a href="#go-中两个-map-对象如何比较" data-for="go-中两个-map-对象如何比较">Go 中两个 map 对象如何比较</a></li><li class="depth-0"><a href="#map-的优缺点以及改进" data-for="map-的优缺点以及改进">Map 的优缺点以及改进?</a></li><li class="depth-0"><a href="#sync-map-怎么使用" data-for="sync-map-怎么使用">Sync. Map 怎么使用</a></li><li class="depth-0"><a href="#sync-map-底层实现原理" data-for="sync-map-底层实现原理">Sync. Map 底层实现原理</a></li><li class="depth-1"><a href="#sync-map" data-for="sync-map">Sync. Map</a></li><li class="depth-1"><a href="#entry" data-for="entry">Entry</a></li><li class="depth-1"><a href="#readonly" data-for="readonly">readOnly</a></li><li class="depth-1"><a href="#读流程-1" data-for="读流程-1">读流程</a></li><li class="depth-2"><a href="#syncmapload" data-for="syncmapload">sync.Map.Load()</a></li><li class="depth-2"><a href="#entryload" data-for="entryload">entry.load()</a></li><li class="depth-2"><a href="#-syncmapmisslocked" data-for="-syncmapmisslocked"> sync.Map.missLocked()</a></li><li class="depth-1"><a href="#写流程-1" data-for="写流程-1"> 写流程</a></li><li class="depth-2"><a href="#syncmapstore" data-for="syncmapstore">sync.Map.Store()</a></li><li class="depth-2"><a href="#entrytrystore" data-for="entrytrystore">entry.tryStore()</a></li><li class="depth-2"><a href="#entryunexpungelocked" data-for="entryunexpungelocked">entry.unexpungeLocked()</a></li><li class="depth-2"><a href="#entrystorelocked" data-for="entrystorelocked">entry.storeLocked()</a></li><li class="depth-2"><a href="#syncmapdirtylocked" data-for="syncmapdirtylocked">sync.Map.dirtyLocked()</a></li><li class="depth-1"><a href="#删流程" data-for="删流程">删流程</a></li><li class="depth-2"><a href="#syncmapdelete" data-for="syncmapdelete">sync.Map.Delete()</a></li><li class="depth-2"><a href="#entrydelete" data-for="entrydelete">entry.delete()</a></li><li class="depth-1"><a href="#遍历流程-1" data-for="遍历流程-1">遍历流程</a></li><li class="depth-1"><a href="#总结" data-for="总结">总结</a></li><li class="depth-2"><a href="#entry-的-expunged-态" data-for="entry-的-expunged-态">entry 的 expunged 态</a></li><li class="depth-2"><a href="#read-map-和-dirty-map-的数据流转" data-for="read-map-和-dirty-map-的数据流转">read map 和 dirty map 的数据流转</a></li><li class="depth-0"><a href="#go-map-和-sync-map-谁的性能好为什么" data-for="go-map-和-sync-map-谁的性能好为什么">Go map 和 sync. Map 谁的性能好，为什么？</a></li></ul></div></div><div class="backlinks"><h3>Backlinks</h3><ul class="overflow"><li><a href="../../GO/八股文/并发" class="internal">并发</a></li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.2.3</a> © 2024</p><ul><li><a href="https://github.com/jackyzha0/quartz">GitHub</a></li><li><a href="https://discord.gg/cRFFHYye7t">Discord Community</a></li></ul></footer></div></body><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js" type="application/javascript"></script><script type="application/javascript">function c(){let t=this.parentElement;t.classList.toggle("is-collapsed");let l=t.classList.contains("is-collapsed")?this.scrollHeight:t.scrollHeight;t.style.maxHeight=l+"px";let o=t,e=t.parentElement;for(;e;){if(!e.classList.contains("callout"))return;let n=e.classList.contains("is-collapsed")?e.scrollHeight:e.scrollHeight+o.scrollHeight;e.style.maxHeight=n+"px",o=e,e=e.parentElement}}function i(){let t=document.getElementsByClassName("callout is-collapsible");for(let s of t){let l=s.firstElementChild;if(l){l.addEventListener("click",c),window.addCleanup(()=>l.removeEventListener("click",c));let e=s.classList.contains("is-collapsed")?l.scrollHeight:s.scrollHeight;s.style.maxHeight=e+"px"}}}document.addEventListener("nav",i);window.addEventListener("resize",i);
</script><script type="module">
          let mermaidImport = undefined
          document.addEventListener('nav', async () => {
            if (document.querySelector("code.mermaid")) {
              mermaidImport ||= await import('https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.7.0/mermaid.esm.min.mjs')
              const mermaid = mermaidImport.default
              const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
              mermaid.initialize({
                startOnLoad: false,
                securityLevel: 'loose',
                theme: darkMode ? 'dark' : 'default'
              })

              await mermaid.run({
                querySelector: '.mermaid'
              })
            }
          });
          </script><script src="../../postscript.js" type="module"></script></html>