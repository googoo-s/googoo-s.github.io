<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Channel 的大小是否对性能有影响 Channel 的大小对性能会产生一定的影响。Channel 的大小是指 Channel 可以容纳的元素数量，可以通过在创建 Channel 时指定容量大小来控制。当 Channel 的容量较小时，可能会导致发送和接收操作的阻塞，从而影响程序的性能。而当 Channel 的容量较大时，可能会增加系统的内存开销，也可能会导致 Channel 中的元素被占用的时间较长，从而影响程序的响应性。
Channel 的内存模型是什么 在 Go 语言中，Channel 的内存模型是基于通信顺序进程（Communicating Sequential Processes，CSP）模型的。CSP 模型是一种并发计算模型，它将并发程序看作是一组顺序进程，这些进程通过 Channel 进行通信和同步。"><meta property="og:title" content><meta property="og:description" content="Channel 的大小是否对性能有影响 Channel 的大小对性能会产生一定的影响。Channel 的大小是指 Channel 可以容纳的元素数量，可以通过在创建 Channel 时指定容量大小来控制。当 Channel 的容量较小时，可能会导致发送和接收操作的阻塞，从而影响程序的性能。而当 Channel 的容量较大时，可能会增加系统的内存开销，也可能会导致 Channel 中的元素被占用的时间较长，从而影响程序的响应性。
Channel 的内存模型是什么 在 Go 语言中，Channel 的内存模型是基于通信顺序进程（Communicating Sequential Processes，CSP）模型的。CSP 模型是一种并发计算模型，它将并发程序看作是一组顺序进程，这些进程通过 Channel 进行通信和同步。"><meta property="og:type" content="website"><meta property="og:image" content="https://googoo-s.github.io/icon.png"><meta property="og:url" content="https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/Channel/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Channel 的大小是否对性能有影响 Channel 的大小对性能会产生一定的影响。Channel 的大小是指 Channel 可以容纳的元素数量，可以通过在创建 Channel 时指定容量大小来控制。当 Channel 的容量较小时，可能会导致发送和接收操作的阻塞，从而影响程序的性能。而当 Channel 的容量较大时，可能会增加系统的内存开销，也可能会导致 Channel 中的元素被占用的时间较长，从而影响程序的响应性。
Channel 的内存模型是什么 在 Go 语言中，Channel 的内存模型是基于通信顺序进程（Communicating Sequential Processes，CSP）模型的。CSP 模型是一种并发计算模型，它将并发程序看作是一组顺序进程，这些进程通过 Channel 进行通信和同步。"><meta name=twitter:image content="https://googoo-s.github.io/icon.png"><title>googoo-s 😄😸😎</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://googoo-s.github.io//icon.png><link href=https://googoo-s.github.io/styles.19109a40042e9f0e72e952fda4442a34.min.css rel=stylesheet><link href=https://googoo-s.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://googoo-s.github.io/js/darkmode.953af745b0f9342644d632fc167f3727.min.js></script>
<script src=https://googoo-s.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://googoo-s.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://googoo-s.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://googoo-s.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://googoo-s.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://googoo-s.github.io/",fetchData=Promise.all([fetch("https://googoo-s.github.io/indices/linkIndex.3bfb24158f5e9d4aff66ae07a3a8bd0d.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://googoo-s.github.io/indices/contentIndex.8972f3e1fb9ffb8fdb949f104473fa8d.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://googoo-s.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://googoo-s.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/googoo-s.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=googoo-s.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://googoo-s.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://googoo-s.github.io/>googoo-s 😄😸😎</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Unknown</p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#channel-的大小是否对性能有影响>Channel 的大小是否对性能有影响</a></li><li><a href=#channel-的内存模型是什么>Channel 的内存模型是什么</a></li><li><a href=#channel-的读写操作是否是原子性的如何实现>Channel 的读写操作是否是原子性的，如何实现</a></li><li><a href=#如何避免在-channel-中出现死锁的情况>如何避免在 Channel 中出现死锁的情况</a></li><li><a href=#channel-在-go-中起什么作用>Channel 在 go 中起什么作用</a></li><li><a href=#channel-为什么需要两个队列实现>Channel 为什么需要两个队列实现</a></li><li><a href=#go-为什么要开发-channel而别的语言为什么没有>Go 为什么要开发 Channel，而别的语言为什么没有</a></li><li><a href=#channel-底层是使用锁控制并发的为什么不直接使用锁>Channel 底层是使用锁控制并发的，为什么不直接使用锁</a></li><li><a href=#channel-可以在多个-goroutine-之间传递什么类型的数据>Channel 可以在多个 goroutine 之间传递什么类型的数据</a></li><li><a href=#如何在-channel-中传递复杂的数据类型>如何在 Channel 中传递复杂的数据类型</a></li><li><a href=#在-go-语言中channel-和锁的使用场景有哪些区别>在 Go 语言中，Channel 和锁的使用场景有哪些区别</a></li><li><a href=#在使用-channel-时如何保证数据的同步性和一致性>在使用 Channel 时，如何保证数据的同步性和一致性</a></li><li><a href=#如何保证-channel-的安全性>如何保证 Channel 的安全性</a></li><li><a href=#channel-的应用场景>channel 的应用场景</a></li><li><a href=#给-channel-用空结构体的好处是什么>给 channel 用空结构体的好处是什么?</a></li><li><a href=#如何判断-channel-是否关闭>如何判断 channel 是否关闭?</a></li><li><a href=#怎么理解不要用共享内存来通信而是用通信来共享内存>怎么理解“不要用共享内存来通信，而是用通信来共享内存”</a></li><li><a href=#channel-和共享内存有什么优劣势>channel 和共享内存有什么优劣势?</a></li><li><a href=#go-里的-mutex-和-channel-的性能有区别吗>Go 里的 Mutex 和 channel 的性能有区别吗？</a></li><li><a href=#channel-的-ring-buffer-实现>Channel 的 ring buffer 实现</a></li><li><a href=#用-go-撸一个生产者消费型用-channel-通信怎么友好的关闭-chan>用 Go 撸一个生产者消费型，用 channel 通信，怎么友好的关闭 chan？</a></li><li><a href=#go-channel-的底层实现原理>Go channel 的底层实现原理</a></li><li><a href=#go-channel-有什么特点>Go channel 有什么特点？</a></li><li><a href=#go-channel-有无缓冲的区别>Go channel 有无缓冲的区别？</a></li><li><a href=#go-channel-为什么是线程安全的>Go channel 为什么是线程安全的？</a></li><li><a href=#go-channel-如何控制-goroutine-并发执行顺序>Go channel 如何控制 goroutine 并发执行顺序？</a></li><li><a href=#go-channel-共享内存有什么优劣势>Go channel 共享内存有什么优劣势？</a></li><li><a href=#go-channel-发送和接收什么情况下会死锁>Go channel 发送和接收什么情况下会死锁？</a></li></ol></nav></details></aside><a href=#channel-的大小是否对性能有影响><h1 id=channel-的大小是否对性能有影响><span class=hanchor arialabel=Anchor># </span>Channel 的大小是否对性能有影响</h1></a><p>Channel 的大小对性能会产生一定的影响。Channel 的大小是指 Channel 可以容纳的元素数量，可以通过在创建 Channel 时指定容量大小来控制。当 Channel 的容量较小时，可能会导致发送和接收操作的阻塞，从而影响程序的性能。而当 Channel 的容量较大时，可能会增加系统的内存开销，也可能会导致 Channel 中的元素被占用的时间较长，从而影响程序的响应性。</p><a href=#channel-的内存模型是什么><h1 id=channel-的内存模型是什么><span class=hanchor arialabel=Anchor># </span>Channel 的内存模型是什么</h1></a><p>在 Go 语言中，Channel 的内存模型是基于通信顺序进程（Communicating Sequential Processes，CSP）模型的。CSP 模型是一种并发计算模型，它将并发程序看作是一组顺序进程，这些进程通过 Channel 进行通信和同步。</p><p>在 CSP 模型中，每个进程都是独立的，它们之间通过 Channel 进行通信。Channel 是一个具有 FIFO 特性的数据结构，用于在多个进程之间传递数据。当一个进程向 Channel 发送数据时，它会阻塞等待，直到另一个进程从 Channel 中接收到数据。同样地，当一个进程从 Channel 中接收数据时，它也会阻塞等待，直到另一个进程向 Channel 发送数据。</p><p>在 Go 语言中，Channel 的内存模型采用了 CSP 模型的概念，即每个 Channel 都是一个独立的顺序进程。当一个进程向 Channel 发送数据时，数据会被复制到 Channel 的缓冲区或者直接发送到接收方。当一个进程从 Channel 中接收数据时，数据会被从 Channel 的缓冲区中取出或者等待发送方发送数据。</p><a href=#channel-的读写操作是否是原子性的如何实现><h1 id=channel-的读写操作是否是原子性的如何实现><span class=hanchor arialabel=Anchor># </span>Channel 的读写操作是否是原子性的，如何实现</h1></a><p>Channel 的读写操作是原子性的，并且是由 Go 语言内部的同步机制来保证的。</p><p>当一个 goroutine 进行 Channel 的读写操作时，Go 语言内部会自动进行同步，保证该操作的原子性和顺序性。这种同步机制主要涉及到两个部分：</p><ol><li>基于锁的同步：在 Channel 的底层实现中，使用了一种基于锁的同步机制，它可以保证每个读写操作都是原子性的，避免了多个 goroutine 同时读写导致的数据竞争问题。</li><li>基于等待的同步：当一个 goroutine 进行 Channel 的读写操作时，如果 Channel 当前为空或已满，它就会被添加到等待队列中，直到满足条件后才会被唤醒，这种等待的同步机制可以避免因 Channel 状态不满足条件而导致的死锁问题。</li></ol><p>通过这种基于锁和等待的同步机制，Go 语言保证了 Channel 的读写操作是原子性的，可以在多个 goroutine 之间安全地进行通信和同步。</p><a href=#如何避免在-channel-中出现死锁的情况><h1 id=如何避免在-channel-中出现死锁的情况><span class=hanchor arialabel=Anchor># </span>如何避免在 Channel 中出现死锁的情况</h1></a><ol><li>避免在单个 goroutine 中对 Channel 进行读写操作：如果一个 goroutine 同时进行 Channel 的读写操作，很容易出现死锁的情况，因为该 goroutine 无法切换到其他任务，导致无法释放 Channel 的读写锁。因此，在进行 Channel 的读写操作时，应该尽量将它们分配到不同的 goroutine 中，以便能够及时切换任务。</li><li>使用缓冲 Channel：缓冲 Channel 可以在一定程度上缓解读写操作的同步问题，避免因为 Channel 状态不满足条件而导致的死锁问题。如果 Channel 是非缓冲的，那么写操作必须等到读操作执行之后才能完成，反之亦然，这种同步会导致程序无法继续执行。而如果使用缓冲 Channel，就可以避免这种同步问题，即使读写操作之间存在时间差，也不会导致死锁。</li><li>使用 select 语句：select 语句可以在多个 Channel 之间进行选择操作，避免因为某个 Channel 状态不满足条件而导致的死锁问题。在使用 select 语句时，应该注意判断每个 Channel 的状态，避免出现同时等待多个 Channel 的情况，这可能导致死锁。</li><li>使用超时机制：在进行 Channel 的读写操作时，可以设置一个超时时间，避免因为 Channel 状态不满足条件而一直等待的情况。如果超过一定时间仍然无法读写 Channel，就可以选择放弃或者进行其他操作，以避免死锁。</li></ol><a href=#channel-在-go-中起什么作用><h1 id=channel-在-go-中起什么作用><span class=hanchor arialabel=Anchor># </span>Channel 在 go 中起什么作用</h1></a><p>在 Go 中，<code>channel</code> 是一种用于在 goroutine 之间传递数据的并发原语。<code>channel</code> 可以让 goroutine 在发送和接收操作之间同步，从而避免了竞态条件，从而更加安全地共享内存。</p><p><code>channel</code> 类似于一个队列，数据可以从一个 goroutine 中发送到 <code>channel</code>，然后从另一个 goroutine 中接收。<code>channel</code> 可以是有缓冲的，这意味着可以在 <code>channel</code> 中存储一定数量的值，而不仅仅是一个。如果 <code>channel</code> 是无缓冲的，则发送和接收操作将会同步阻塞，直到有 goroutine 准备好接收或发送数据。</p><a href=#channel-为什么需要两个队列实现><h1 id=channel-为什么需要两个队列实现><span class=hanchor arialabel=Anchor># </span>Channel 为什么需要两个队列实现</h1></a><p>一个 Channel 可以被看作是一个通信通道，用于在不同的进程之间传递数据。在具体的实现中，一个 Channel 通常需要使用两个队列来实现。这两个队列是发送队列和接收队列。</p><p>发送队列是用来存储将要发送的数据的队列。当一个进程想要通过 Channel 发送数据时，它会将数据添加到发送队列中。发送队列中的数据会按照先进先出的顺序被逐个发送到接收进程。如果发送队列已经满了，那么发送进程就需要等待，直到有足够的空间可以存储数据。</p><p>接收队列是用来存储接收进程已经准备好接收的数据的队列。当一个进程从 Channel 中接收数据时，它会从接收队列中取出数据。如果接收队列是空的，那么接收进程就需要等待，直到有新的数据可以接收。</p><p>使用两个队列实现 Channel 的主要原因是为了实现异步通信。发送进程可以在发送数据之后立即继续执行其他任务，而不需要等待接收进程确认收到数据。同样，接收进程也可以在等待数据到达的同时执行其他任务。这种异步通信的实现方式可以提高系统的吞吐量和响应速度。</p><a href=#go-为什么要开发-channel而别的语言为什么没有><h1 id=go-为什么要开发-channel而别的语言为什么没有><span class=hanchor arialabel=Anchor># </span>Go 为什么要开发 Channel，而别的语言为什么没有</h1></a><p>在 Go 语言中，Channel 是一种非常重要的并发原语。Go 语言将 Channel 作为语言内置的原语，可能是出于以下几个方面的考虑：</p><ol><li>并发安全：在多线程并发环境下，使用 Channel 可以保证数据的安全性，避免多个线程同时访问共享数据导致的数据竞争和锁的开销。</li><li>简单易用：Go 语言中的 Channel 是一种高度抽象的概念，可以非常方便地实现不同线程之间的数据传输和同步。通过 Channel，程序员不需要手动地管理锁、条件变量等底层的同步原语，使得程序的编写更加简单和高效。</li><li>天然支持并发：Go 语言中的 Channel 与 goroutine 密切相关，这使得 Channel 天然地支持并发。程序员可以通过使用 Channel 和 goroutine 来实现非常高效的并发编程。</li></ol><p>虽然其他编程语言中没有像 Go 语言中的 Channel 这样的内置并发原语，但是许多编程语言提供了类似于 Channel 的实现，比如 Java 的 ConcurrentLinkedQueue、Python 的 Queue、C++的 std:: queue 等。这些实现虽然没有 Go 语言中的 Channel 那么简单易用和高效，但也能够满足多线程编程中的数据传输和同步需求。</p><a href=#channel-底层是使用锁控制并发的为什么不直接使用锁><h1 id=channel-底层是使用锁控制并发的为什么不直接使用锁><span class=hanchor arialabel=Anchor># </span>Channel 底层是使用锁控制并发的，为什么不直接使用锁</h1></a><p>虽然在 Go 语言中，Channel 底层实现是使用锁控制并发的，但是 Channel 和锁的使用场景是不同的，具有不同的优势和适用性。</p><p>首先，Channel 比锁更加高级和抽象。Channel 可以实现多个 goroutine 之间的同步和数据传递，不需要程序员显式地使用锁来进行线程间的协调。Channel 可以避免常见的同步问题，比如死锁、饥饿等问题。</p><p>其次，Channel 在语言层面提供了一种更高效的并发模型。在使用锁进行并发控制时，需要程序员自己手动管理锁的获取和释放，这增加了代码复杂度和错误的风险。而使用 Channel 时，可以通过 goroutine 的调度和 Channel 的阻塞机制来实现更加高效和简单的并发控制。</p><p>此外，Channel 还可以避免一些由锁导致的性能问题，如锁竞争、锁粒度过大或过小等问题。Channel 提供了一种更加精细的控制机制，能够更好地平衡不同 goroutine 之间的并发性能。</p><p>总的来说，虽然 Channel 底层是使用锁控制并发的，但是 Channel 在语言层面提供了更加高级、抽象和高效的并发模型，可以使程序员更加方便和安全地进行并发编程。</p><a href=#channel-可以在多个-goroutine-之间传递什么类型的数据><h1 id=channel-可以在多个-goroutine-之间传递什么类型的数据><span class=hanchor arialabel=Anchor># </span>Channel 可以在多个 goroutine 之间传递什么类型的数据</h1></a><p>在 Go 语言中，Channel 可以在多个 goroutine 之间传递任何类型的数据，包括基本数据类型、复合数据类型、结构体、自定义类型等。这些数据类型在传递过程中都会被封装成对应的指针类型，并由 Channel 进行传递。</p><a href=#如何在-channel-中传递复杂的数据类型><h1 id=如何在-channel-中传递复杂的数据类型><span class=hanchor arialabel=Anchor># </span>如何在 Channel 中传递复杂的数据类型</h1></a><p>在 Go 语言中，Channel 可以传递任何类型的数据，包括复杂的数据类型。如果要在 Channel 中传递复杂的数据类型，可以将其定义为一个结构体，然后通过 Channel 进行传递。</p><p>例如，假设我们有一个结构体类型 Person，它包含姓名和年龄两个字段：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type Person struct {
</span></span><span class=line><span class=cl>    Name string
</span></span><span class=line><span class=cl>    Age  int
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>我们可以定义一个 Channel，用于传递 Person 类型的数据：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ch := make(chan Person)
</span></span></code></pre></td></tr></table></div></div><p>现在我们可以在不同的 Goroutine 中向 Channel 发送和接收 Person 类型的数据：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// 发送Person类型数据到Channel
</span></span><span class=line><span class=cl>go func() {
</span></span><span class=line><span class=cl>    p := Person{Name: &#34;Alice&#34;, Age: 18}
</span></span><span class=line><span class=cl>    ch &lt;- p
</span></span><span class=line><span class=cl>}()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 从Channel接收Person类型数据
</span></span><span class=line><span class=cl>p := &lt;-ch
</span></span><span class=line><span class=cl>fmt.Println(p.Name, p.Age)
</span></span></code></pre></td></tr></table></div></div><p>注意，如果要在 Channel 中传递复杂的数据类型，需要确保该类型是可导出的。</p><a href=#在-go-语言中channel-和锁的使用场景有哪些区别><h1 id=在-go-语言中channel-和锁的使用场景有哪些区别><span class=hanchor arialabel=Anchor># </span>在 Go 语言中，Channel 和锁的使用场景有哪些区别</h1></a><p>在 Go 语言中，Channel 和锁（sync. Mutex 等）都可以用于并发编程中的同步和共享数据，但它们的使用场景有一些区别。</p><p>Channel 通常用于 Goroutine 之间传递数据，并发的 Goroutine 之间可以通过 Channel 进行同步。使用 Channel 可以避免锁的问题，例如死锁、饥饿等问题。Channel 可以将数据在多个 Goroutine 之间进行传递和共享，而且在数据传递的过程中，不需要使用锁来保证数据的安全性，这也是 Channel 比锁更加安全和高效的原因之一。因此，当需要在不同的 Goroutine 之间传递数据时，使用 Channel 是比较合适的选择。</p><p>锁通常用于对共享资源进行保护，防止多个 Goroutine 同时访问和修改同一个共享资源，从而导致数据的竞争和不一致。使用锁可以保证同一时刻只有一个 Goroutine 能够访问和修改共享资源，从而保证数据的安全性和一致性。当需要对共享资源进行保护时，使用锁是比较合适的选择。</p><p>Channel 和锁都是 Go 语言中常用的并发编程工具，它们各自有不同的使用场景。在实际开发中，应根据具体的需求选择合适的并发编程工具来实现同步和共享数据。</p><a href=#在使用-channel-时如何保证数据的同步性和一致性><h1 id=在使用-channel-时如何保证数据的同步性和一致性><span class=hanchor arialabel=Anchor># </span>在使用 Channel 时，如何保证数据的同步性和一致性</h1></a><p>在使用 Channel 时，为了保证数据的同步性和一致性，可以采用以下几种方式：</p><ol><li>合理设计 Channel 的容量：当 Channel 容量过小时，容易出现发送者和接收者之间的阻塞，而当容量过大时，可能会出现数据不一致的问题。因此，在设计 Channel 时，需要根据实际情况合理设定容量大小，以避免数据同步性和一致性的问题。</li><li>使用互斥锁保证数据访问的互斥性：如果多个 goroutine 同时对某个共享的数据进行访问，可能会导致数据不一致的问题。此时，可以使用互斥锁来保证数据访问的互斥性，以避免多个 goroutine 同时对同一份数据进行访问。</li><li>使用同步机制实现数据同步：在某些情况下，我们可能需要在多个 goroutine 之间进行数据同步，以确保数据的一致性。此时，可以使用一些同步机制，例如 WaitGroup、Barrier、Cond 等，来实现数据同步。</li></ol><a href=#如何保证-channel-的安全性><h1 id=如何保证-channel-的安全性><span class=hanchor arialabel=Anchor># </span>如何保证 Channel 的安全性</h1></a><ol><li>确保 Channel 的正确使用：在使用 Channel 时，需要确保发送和接收操作的正确性。特别是在并发环境下，必须正确处理并发操作，避免出现竞争条件或死锁等问题。因此，在使用 Channel 时，需要根据实际情况选择合适的同步机制，例如互斥锁、条件变量、原子操作等，以确保 Channel 的正确使用。</li><li>避免 Channel 的泄漏：如果 Channel 没有被及时关闭，可能会导致资源泄漏和性能问题。因此，在使用 Channel 时，需要确保及时关闭 Channel，避免出现资源泄漏的情况。</li><li>避免 Channel 的阻塞：如果 Channel 的容量较小，可能会导致发送和接收操作的阻塞。此时，可以使用缓冲 Channel 或者带超时的发送和接收操作，避免 Channel 的阻塞。</li><li>避免 Channel 的死锁：如果多个 goroutine 之间出现死锁，可能会导致程序的停滞和性能问题。因此，在使用 Channel 时，需要避免死锁的情况，例如避免循环依赖、避免同时使用多个 Channel 等</li></ol><a href=#channel-的应用场景><h1 id=channel-的应用场景><span class=hanchor arialabel=Anchor># </span>channel 的应用场景</h1></a><p>Channel 适用于数据在多个协程中流动的场景，有很多实际应用：</p><ol><li>任务定时</li></ol><p>比如超时处理：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>select {
</span></span><span class=line><span class=cl>    case &lt;-time.After(time.Second):
</span></span></code></pre></td></tr></table></div></div><p>定时任务</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>select {
</span></span><span class=line><span class=cl>    case &lt;- time.Tick(time.Second)
</span></span></code></pre></td></tr></table></div></div><ol start=2><li>解耦生产者和消费者</li></ol><p>可以将生产者和消费者解耦出来，生产者只需要往 channel 发送数据，而消费者只管从 channel 中获取数据。</p><ol start=3><li>控制并发数</li></ol><p>以爬虫为例，比如需要爬取 1 w 条数据，需要并发爬取以提高效率，但并发量又不过过大，可以通过 channel 来控制并发规模，比如同时支持 5 个并发任务：ch := make (chan int, 5)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>for _, url := range urls {
</span></span><span class=line><span class=cl>go func() {
</span></span><span class=line><span class=cl>	ch &lt;- 1
</span></span><span class=line><span class=cl>	worker(url)
</span></span><span class=line><span class=cl>	&lt;- ch
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><ol start=4><li>协程间通信</li></ol><p>协程之间的通信. 通过 channel 传递数据, 实现通信</p><a href=#给-channel-用空结构体的好处是什么><h1 id=给-channel-用空结构体的好处是什么><span class=hanchor arialabel=Anchor># </span>给 channel 用空结构体的好处是什么?</h1></a><p>在 Go 语言中，使用空结构体作为通道（channel）元素的类型有一些优点和好处：</p><ol><li><strong>低内存开销</strong>：空结构体不包含任何字段，因此它的内存占用非常小，通常为零字节。这意味着使用空结构体的通道在存储元素时几乎没有内存开销。这对于需要大量通信的高并发应用程序非常有用，因为它可以减少内存占用，提高性能。</li><li><strong>高效的信号传递</strong>：空结构体通道通常用于实现信号传递或同步操作，而不是传递实际的数据。由于空结构体的内存占用极小，它的传输速度非常快，适用于高频率的通信，如控制并发数量的信号量。</li><li><strong>语义清晰</strong>：使用空结构体作为通道元素的类型可以传达出一种清晰的语义，即通道的目的是进行信号传递或同步，而不是传输实际的数据。这可以使代码更容易理解和维护。</li><li><strong>防止数据竞态</strong>：当通道用于多个协程之间的同步时，使用空结构体可以帮助防止数据竞态。因为空结构体通常不存储实际的数据，所以不会发生多个协程同时访问或修改相同数据的情况。</li><li><strong>编译时类型检查</strong>：使用空结构体作为通道元素可以在编译时进行类型检查，确保只有空结构体可以被发送到和接收到该通道，从而减少了在运行时出现类型错误的可能性。</li></ol><p>总的来说，使用空结构体作为通道元素的类型是一种有效的方式来实现轻量级的信号传递和同步，同时保持低内存开销和高性能。这在 Go 中的并发编程中非常有用，特别是在需要进行大量协程间通信的情况下</p><a href=#如何判断-channel-是否关闭><h1 id=如何判断-channel-是否关闭><span class=hanchor arialabel=Anchor># </span>如何判断 channel 是否关闭?</h1></a><p>首先官方没有提供判断 channel 是否关闭的接口，也不需要去判断，因此在使用的时候，需要保证好时序，避免往已关闭的 channel 中写入数据引发 panic。<br>但是可以通过以下几个办法判断：</p><ol><li>通过读来判断，s， ok := &lt;- c，如果 c 是个阻塞的，并且没有关闭的话，会阻塞在这，没办法正常调用。最好是结合 select 使用，而且要有 default 语句，不然又阻塞了！</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func isChanClose(ch chan int) bool {
</span></span><span class=line><span class=cl> 	select {
</span></span><span class=line><span class=cl> 		case _, received := &lt;- ch:
</span></span><span class=line><span class=cl>    		return !received
</span></span><span class=line><span class=cl> 		default:
</span></span><span class=line><span class=cl> 		}
</span></span><span class=line><span class=cl> 	return false
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><ol start=2><li>通过写来判断，立马 panic，可以捕捉一下进行判断，够野…</li></ol><a href=#怎么理解不要用共享内存来通信而是用通信来共享内存><h1 id=怎么理解不要用共享内存来通信而是用通信来共享内存><span class=hanchor arialabel=Anchor># </span>怎么理解“不要用共享内存来通信，而是用通信来共享内存”</h1></a><p>共享内存会涉及到多个线程同时访问修改数据的情况，为了保证数据的安全性，那就会加锁，加锁会让并行变为串行，cpu 此时也会忙于线程抢锁。另外使用过多的锁，容易使得程序的代码逻辑坚涩难懂，并且容易使程序死锁，死锁了以后排查问题相当困难，特别是很多锁同时存在的时候。</p><p>在这种情况下，不如换一种方式，把数据复制一份，每个线程有自己的，只要一个线程干完一件事其他线程不用去抢锁了，这就是一种通信方式，把共享的以通知方式交给线程，实现并发。Go 语言的 channel 就保证同一个时间只有一个 goroutine 能够访问里面的数据，为开发者提供了一种优雅简单的工具，所以 go 原生的做法就是使用 channel 来通信，而不是使用共享内存来通信。</p><a href=#channel-和共享内存有什么优劣势><h1 id=channel-和共享内存有什么优劣势><span class=hanchor arialabel=Anchor># </span>channel 和共享内存有什么优劣势?</h1></a><p><strong>“不要通过共享内存来通信，我们应该使用通信来共享内存”</strong> 这句话想必大家已经非常熟悉了，在官方的博客，初学时的教程，甚至是在 Go 的源码中都能看到</p><p>无论是通过共享内存来通信还是通过通信来共享内存，最终我们应用程序都是读取的内存当中的数据，只是前者是直接读取内存的数据，而后者是通过发送消息的方式来进行同步。而通过发送消息来同步的这种方式常见的就是 Go 采用的 CSP (Communication Sequential Process) 模型以及 Erlang 采用的 Actor 模型，这两种方式都是通过通信来共享内存。</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic02_Go%E8%BF%9B%E9%98%B603_blog_channel.png width=auto alt=02_Go进阶03_blog_channel.png></p><p>大部分的语言采用的都是第一种方式直接去操作内存，然后通过互斥锁，CAS 等操作来保证并发安全。Go 引入了 Channel 和 Goroutine 实现 CSP 模型将生产者和消费者进行了解耦，Channel 其实和消息队列很相似。而 Actor 模型和 CSP 模型都是通过发送消息来共享内存，但是它们之间最大的区别就是 Actor 模型当中并没有一个独立的 Channel 组件，而是 Actor 与 Actor 之间直接进行消息的发送与接收，每个 Actor 都有一个本地的“信箱”消息都会先发送到这个“信箱当中”。</p><p><strong>优点</strong></p><ul><li>使用 channel 可以帮助我们解耦生产者和消费者，可以降低并发当中的耦合</li></ul><p><strong>缺点</strong></p><ul><li>容易出现死锁的情况</li></ul><a href=#go-里的-mutex-和-channel-的性能有区别吗><h1 id=go-里的-mutex-和-channel-的性能有区别吗><span class=hanchor arialabel=Anchor># </span>Go 里的 Mutex 和 channel 的性能有区别吗？</h1></a><p>Channel 的底层也是用了 syns. Mutex, 算是对锁的封装，性能应该是有损耗的，用测试的数据更有说服力</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>channel</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;sync&#34;</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>mutex</span> <span class=p>=</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>ch</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{},</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>UseMutex</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>mutex</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>mutex</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>UseChan</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ch</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>	<span class=o>&lt;-</span><span class=nx>ch</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kn>package</span> <span class=nx>channel</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;testing&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BenchmarkUseMutex</span><span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>UseMutex</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BenchmarkUseChan</span><span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>UseChan</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>执行 bench 命令</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>go test -bench=.
</span></span></code></pre></td></tr></table></div></div><p>测试结果如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>BenchmarkUseMutex-8     87120927                13.61 ns/op
</span></span><span class=line><span class=cl>BenchmarkUseChan-8      42295345                26.47 ns/op
</span></span><span class=line><span class=cl>PASS
</span></span><span class=line><span class=cl>ok      mytest/channel  2.906s
</span></span></code></pre></td></tr></table></div></div><p><strong>根据压测结果来说 Mutex 比 channel 的性能快了两倍左右</strong></p><a href=#channel-的-ring-buffer-实现><h1 id=channel-的-ring-buffer-实现><span class=hanchor arialabel=Anchor># </span>Channel 的 ring buffer 实现</h1></a><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statisticimage-20230922140315653.png width=auto alt=image-20230922140315653></p><a href=#用-go-撸一个生产者消费型用-channel-通信怎么友好的关闭-chan><h1 id=用-go-撸一个生产者消费型用-channel-通信怎么友好的关闭-chan><span class=hanchor arialabel=Anchor># </span>用 Go 撸一个生产者消费型，用 channel 通信，怎么友好的关闭 chan？</h1></a><p>如何优雅的关闭 channel 记住两点</p><ol><li>向一个已关闭的 channel 发送数据会 panic</li><li>关闭一个已经关闭的 channel 会 panic</li></ol><p><strong>针对单个生产者在发送侧关闭 channel 即可</strong></p><p>单个生产者单个消费者模型</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func main() {
</span></span><span class=line><span class=cl>	var ch = make(chan int)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	// 单生产者
</span></span><span class=line><span class=cl>	go func() {
</span></span><span class=line><span class=cl>		for i := 1; i &lt; 100; i++ {
</span></span><span class=line><span class=cl>			ch &lt;- i
</span></span><span class=line><span class=cl>		}
</span></span><span class=line><span class=cl>		close(ch)
</span></span><span class=line><span class=cl>	}()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	// 消费者
</span></span><span class=line><span class=cl>	go func() {
</span></span><span class=line><span class=cl>		for elem := range ch {
</span></span><span class=line><span class=cl>			fmt.Println(elem)
</span></span><span class=line><span class=cl>		}
</span></span><span class=line><span class=cl>	}()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	select {}
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>单个生产者多个消费者模型</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func main() {
</span></span><span class=line><span class=cl>	var ch = make(chan int)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	// 单生产者
</span></span><span class=line><span class=cl>	go func() {
</span></span><span class=line><span class=cl>		for i := 1; i &lt; 100; i++ {
</span></span><span class=line><span class=cl>			ch &lt;- i
</span></span><span class=line><span class=cl>		}
</span></span><span class=line><span class=cl>		close(ch)
</span></span><span class=line><span class=cl>	}()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	// 多消费者
</span></span><span class=line><span class=cl>	for i := 0; i &lt; 100; i++ {
</span></span><span class=line><span class=cl>		go func() {
</span></span><span class=line><span class=cl>			for elem := range ch {
</span></span><span class=line><span class=cl>				fmt.Println(elem)
</span></span><span class=line><span class=cl>			}
</span></span><span class=line><span class=cl>		}()
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	select {}
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><strong>针对多个生产者不应该关闭生产者，消费者通知生产者不发送数据即可</strong></p><p>多生产者单消费者模型</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func main() {
</span></span><span class=line><span class=cl>	var ch = make(chan int)
</span></span><span class=line><span class=cl>	var stopCh = make(chan struct{})
</span></span><span class=line><span class=cl>	// 多生产者
</span></span><span class=line><span class=cl>	for i := 1; i &lt;= 100; i++ {
</span></span><span class=line><span class=cl>		go func(n int) {
</span></span><span class=line><span class=cl>			for {
</span></span><span class=line><span class=cl>				select {
</span></span><span class=line><span class=cl>				case ch &lt;- n:
</span></span><span class=line><span class=cl>				case &lt;-stopCh:
</span></span><span class=line><span class=cl>					return
</span></span><span class=line><span class=cl>				}
</span></span><span class=line><span class=cl>			}
</span></span><span class=line><span class=cl>		}(i)
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	// 单消费者
</span></span><span class=line><span class=cl>	go func() {
</span></span><span class=line><span class=cl>		for elem := range ch {
</span></span><span class=line><span class=cl>			fmt.Println(elem)
</span></span><span class=line><span class=cl>			if elem == 100{
</span></span><span class=line><span class=cl>				return
</span></span><span class=line><span class=cl>			}
</span></span><span class=line><span class=cl>		}
</span></span><span class=line><span class=cl>	}()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	select {}
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>多生产者多消费者模型</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func main() {
</span></span><span class=line><span class=cl>	var ch = make(chan int)
</span></span><span class=line><span class=cl>	// 停止信号
</span></span><span class=line><span class=cl>	var stopCh = make(chan struct{})
</span></span><span class=line><span class=cl>	// 协调者
</span></span><span class=line><span class=cl>	var toStopCh = make(chan struct{}, 1)
</span></span><span class=line><span class=cl>	// 多生产者
</span></span><span class=line><span class=cl>	for i := 1; i &lt;= 100; i++ {
</span></span><span class=line><span class=cl>		go func(n int) {
</span></span><span class=line><span class=cl>			for {
</span></span><span class=line><span class=cl>				select {
</span></span><span class=line><span class=cl>				case ch &lt;- n:
</span></span><span class=line><span class=cl>				case &lt;-stopCh:
</span></span><span class=line><span class=cl>					return
</span></span><span class=line><span class=cl>				}
</span></span><span class=line><span class=cl>			}
</span></span><span class=line><span class=cl>		}(i)
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	// 接收通知给协调者
</span></span><span class=line><span class=cl>	go func() {
</span></span><span class=line><span class=cl>		&lt;-toStopCh
</span></span><span class=line><span class=cl>		close(stopCh)
</span></span><span class=line><span class=cl>	}()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	// 多消费者
</span></span><span class=line><span class=cl>	for i := 0; i &lt; 100; i++ {
</span></span><span class=line><span class=cl>		go func() {
</span></span><span class=line><span class=cl>			for  {
</span></span><span class=line><span class=cl>				select {
</span></span><span class=line><span class=cl>				case elem := &lt;-ch:
</span></span><span class=line><span class=cl>					if elem == 100 {
</span></span><span class=line><span class=cl>						toStopCh &lt;- struct{}{}
</span></span><span class=line><span class=cl>						return
</span></span><span class=line><span class=cl>					}
</span></span><span class=line><span class=cl>					fmt.Println(elem)
</span></span><span class=line><span class=cl>				}
</span></span><span class=line><span class=cl>			}
</span></span><span class=line><span class=cl>		}()
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	select {}
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#go-channel-的底层实现原理><h1 id=go-channel-的底层实现原理><span class=hanchor arialabel=Anchor># </span>Go channel 的底层实现原理</h1></a><p><strong>概念：</strong></p><p>Go 中的 channel 是一个队列，遵循先进先出的原则，负责协程之间的通信（Go 语言提倡不要通过共享内存来通信，而要通过通信来实现内存共享，CSP (Communicating Sequential Process)并发模型，就是通过 goroutine 和 channel 来实现的）</p><p><strong>使用场景：</strong></p><p>停止信号监听</p><p>定时任务</p><p>生产方和消费方解耦</p><p>控制并发数</p><p><strong>底层数据结构：</strong></p><p>通过 var 声明或者 make 函数创建的 channel 变量是一个存储在函数栈帧上的指针，占用 8 个字节，指向堆上的 hchan 结构体</p><p>源码包中 <code>src/runtime/chan.go</code> 定义了 hchan 的数据结构：</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240225234031.png width=auto alt=image.png></p><p>Hchan 结构体：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type hchan struct {
</span></span><span class=line><span class=cl> closed   uint32   // channel是否关闭的标志
</span></span><span class=line><span class=cl> elemtype *_type   // channel中的元素类型
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> // channel分为无缓冲和有缓冲两种。
</span></span><span class=line><span class=cl> // 对于有缓冲的channel存储数据，使用了 ring buffer（环形缓冲区) 来缓存写入的数据，本质是循环数组
</span></span><span class=line><span class=cl> // 为啥是循环数组？普通数组不行吗，普通数组容量固定更适合指定的空间，弹出元素时，普通数组需要全部都前移
</span></span><span class=line><span class=cl> // 当下标超过数组容量后会回到第一个位置，所以需要有两个字段记录当前读和写的下标位置
</span></span><span class=line><span class=cl> buf      unsafe.Pointer // 指向底层循环数组的指针（环形缓冲区）
</span></span><span class=line><span class=cl> qcount   uint           // 循环数组中的元素数量
</span></span><span class=line><span class=cl> dataqsiz uint           // 循环数组的长度
</span></span><span class=line><span class=cl> elemsize uint16                 // 元素的大小
</span></span><span class=line><span class=cl> sendx    uint           // 下一次写下标的位置
</span></span><span class=line><span class=cl> recvx    uint           // 下一次读下标的位置
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl> // 尝试读取channel或向channel写入数据而被阻塞的goroutine
</span></span><span class=line><span class=cl> recvq    waitq  // 读等待队列
</span></span><span class=line><span class=cl> sendq    waitq  // 写等待队列
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> lock mutex //互斥锁，保证读写channel时不存在并发竞争问题
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>等待队列：</p><p>双向链表，包含一个头结点和一个尾结点</p><p>每个节点是一个 sudog 结构体变量，记录哪个协程在等待，等待的是哪个 channel，等待发送/接收的数据在哪里</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type hchan struct {
</span></span><span class=line><span class=cl> closed   uint32   // channel是否关闭的标志
</span></span><span class=line><span class=cl> elemtype *_type   // channel中的元素类型
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> // channel分为无缓冲和有缓冲两种。
</span></span><span class=line><span class=cl> // 对于有缓冲的channel存储数据，使用了 ring buffer（环形缓冲区) 来缓存写入的数据，本质是循环数组
</span></span><span class=line><span class=cl> // 为啥是循环数组？普通数组不行吗，普通数组容量固定更适合指定的空间，弹出元素时，普通数组需要全部都前移
</span></span><span class=line><span class=cl> // 当下标超过数组容量后会回到第一个位置，所以需要有两个字段记录当前读和写的下标位置
</span></span><span class=line><span class=cl> buf      unsafe.Pointer // 指向底层循环数组的指针（环形缓冲区）
</span></span><span class=line><span class=cl> qcount   uint           // 循环数组中的元素数量
</span></span><span class=line><span class=cl> dataqsiz uint           // 循环数组的长度
</span></span><span class=line><span class=cl> elemsize uint16                 // 元素的大小
</span></span><span class=line><span class=cl> sendx    uint           // 下一次写下标的位置
</span></span><span class=line><span class=cl> recvx    uint           // 下一次读下标的位置
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl> // 尝试读取channel或向channel写入数据而被阻塞的goroutine
</span></span><span class=line><span class=cl> recvq    waitq  // 读等待队列
</span></span><span class=line><span class=cl> sendq    waitq  // 写等待队列
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> lock mutex //互斥锁，保证读写channel时不存在并发竞争问题
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><strong>操作</strong>：</p><p><strong>创建</strong></p><p>使用 <code>make(chan T, cap)</code> 来创建 channel，make 语法会在编译时，转换为 <code>makechan64</code> 和 <code>makechan</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func makechan64(t *chantype, size int64) *hchan {
</span></span><span class=line><span class=cl>    if int64(int(size)) != size {
</span></span><span class=line><span class=cl>        panic(plainError(&#34;makechan: size out of range&#34;))
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return makechan(t, int(size))
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>创建 channel 有两种，一种是带缓冲的 channel，一种是不带缓冲的 channel</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// 带缓冲
</span></span><span class=line><span class=cl>ch := make(chan int, 3)
</span></span><span class=line><span class=cl>// 不带缓冲
</span></span><span class=line><span class=cl>ch := make(chan int)
</span></span></code></pre></td></tr></table></div></div><p>创建时会做一些检查:</p><ul><li>元素大小不能超过 64 K</li><li>元素的对齐大小不能超过 maxAlign 也就是 8 字节</li><li>计算出来的内存是否超过限制</li></ul><p>创建时的策略:</p><ul><li>如果是无缓冲的 channel，会直接给 hchan 分配内存</li><li>如果是有缓冲的 channel，并且元素不包含指针，那么会为 hchan 和底层数组分配一段连续的地址</li><li>如果是有缓冲的 channel，并且元素包含指针，那么会为 hchan 和底层数组分别分配地址</li></ul><p><strong>发送</strong></p><p>发送操作，编译时转换为 <code>runtime.chansend</code> 函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool 
</span></span></code></pre></td></tr></table></div></div><p>阻塞式：</p><p>调用 chansend 函数，并且 block=true</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool 
</span></span></code></pre></td></tr></table></div></div><p>非阻塞式：</p><p>调用 chansend 函数，并且 block=false</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>select {
</span></span><span class=line><span class=cl>    case ch &lt;- 10:
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  default
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>向 channel 中发送数据时大概分为两大块：检查和数据发送，数据发送流程如下：</p><ul><li>如果 channel 的读等待队列存在接收者 goroutine<ul><li>将数据<strong>直接发送</strong>给第一个等待的 goroutine， <strong>唤醒接收的 goroutine</strong></li></ul></li><li>如果 channel 的读等待队列不存在接收者 goroutine<ul><li>如果循环数组 buf 未满，那么将会把数据发送到循环数组 buf 的队尾</li><li>如果循环数组 buf 已满，这个时候就会走阻塞发送的流程，将当前 goroutine 加入写等待队列，并<strong>挂起等待唤醒</strong></li></ul></li></ul><p><strong>接收</strong></p><p>发送操作，编译时转换为 <code>runtime.chanrecv</code> 函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) 
</span></span></code></pre></td></tr></table></div></div><p>阻塞式：</p><p>调用 chanrecv 函数，并且 block=true</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&lt;-ch
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>v := &lt;-ch
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>v, ok := &lt;-ch
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 当channel关闭时，for循环会自动退出，无需主动监测channel是否关闭，可以防止读取已经关闭的channel,造成读到数据为通道所存储的数据类型的零值
</span></span><span class=line><span class=cl>for i := range ch {
</span></span><span class=line><span class=cl>    fmt.Println(i)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>非阻塞式：</p><p>调用 chanrecv 函数，并且 block=false</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>select {
</span></span><span class=line><span class=cl>    case &lt;-ch:
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  default
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>向 channel 中接收数据时大概分为两大块，检查和数据发送，而数据接收流程如下：</p><ul><li>如果 channel 的写等待队列存在发送者 goroutine<ul><li>如果是无缓冲 channel，<strong>直接</strong>从第一个发送者 goroutine 那里把数据拷贝给接收变量，<strong>唤醒发送的 goroutine</strong></li><li>如果是有缓冲 channel（已满），将循环数组 buf 的队首元素拷贝给接收变量，将第一个发送者 goroutine 的数据拷贝到 buf 循环数组队尾，<strong>唤醒发送的 goroutine</strong></li></ul></li><li>如果 channel 的写等待队列不存在发送者 goroutine<ul><li>如果循环数组 buf 非空，将循环数组 buf 的队首元素拷贝给接收变量</li><li>如果循环数组 buf 为空，这个时候就会走阻塞接收的流程，将当前 goroutine 加入读等待队列，并<strong>挂起等待唤醒</strong></li></ul></li></ul><p><strong>关闭</strong></p><p>关闭操作，调用 close 函数，编译时转换为 <code>runtime.closechan</code> 函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>close(ch)
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func closechan(c *hchan) 
</span></span></code></pre></td></tr></table></div></div><p><strong>案例分析：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;unsafe&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ch是长度为4的带缓冲的channel
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 初始hchan结构体重的buf为空，sendx和recvx均为0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>string</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>ch</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nx>ch</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>sendTask</span><span class=p>(</span><span class=nx>ch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>receiveTask</span><span class=p>(</span><span class=nx>ch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// G1是发送者
</span></span></span><span class=line><span class=cl><span class=c1>// 当G1向ch里发送数据时，首先会对buf加锁，然后将task存储的数据copy到buf中，然后sendx++，然后释放对buf的锁
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>sendTask</span><span class=p>(</span><span class=nx>ch</span> <span class=kd>chan</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>taskList</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;this&#34;</span><span class=p>,</span> <span class=s>&#34;is&#34;</span><span class=p>,</span> <span class=s>&#34;a&#34;</span><span class=p>,</span> <span class=s>&#34;demo&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>task</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>taskList</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=nx>task</span> <span class=c1>//发送任务到channel
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// G2是接收者
</span></span></span><span class=line><span class=cl><span class=c1>// 当G2消费ch的时候，会首先对buf加锁，然后将buf中的数据copy到task变量对应的内存里，然后recvx++,并释放锁
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>receiveTask</span><span class=p>(</span><span class=nx>ch</span> <span class=kd>chan</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>task</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>ch</span>                  <span class=c1>//接收任务
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;received&#34;</span><span class=p>,</span> <span class=nx>task</span><span class=p>)</span> <span class=c1>//处理任务
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>总结 hchan 结构体的主要组成部分有四个：</p><ul><li>用来保存 goroutine 之间传递数据的循环数组：buf</li><li>用来记录此循环数组当前发送或接收数据的下标值：sendx 和 recvx</li><li>用于保存向该 chan 发送和从该 chan 接收数据被阻塞的 goroutine 队列： sendq 和 recvq</li><li>保证 channel 写入和读取数据时线程安全的锁：lock</li></ul><a href=#go-channel-有什么特点><h1 id=go-channel-有什么特点><span class=hanchor arialabel=Anchor># </span>Go channel 有什么特点？</h1></a><p>Channel 有 2 种类型：无缓冲、有缓冲</p><p>Channel 有 3 种模式：写操作模式（单向通道）、读操作模式（单向通道）、读写操作模式（双向通道）</p><table><thead><tr><th>写操作模式</th><th>读操作模式</th><th>读写操作模式</th><th></th></tr></thead><tbody><tr><td>创建</td><td>make (chan&lt;- int)</td><td>make (&lt;-chan int)</td><td>make (chan int)</td></tr></tbody></table><p>Channel 有 3 种状态：未初始化、正常、关闭</p><table><thead><tr><th>未初始化</th><th>关闭</th><th>正常</th><th></th></tr></thead><tbody><tr><td>关闭</td><td>panic</td><td>panic</td><td>正常关闭</td></tr><tr><td>发送</td><td>永远阻塞导致死锁</td><td>panic</td><td>阻塞或者成功发送</td></tr><tr><td>接收</td><td>永远阻塞导致死锁</td><td>缓冲区为空则为零值, 否则可以继续读</td><td>阻塞或者成功接收</td></tr></tbody></table><p><strong>注意点</strong>：</p><ol><li>一个 channel 不能多次关闭，会导致 painc</li><li>如果多个 goroutine 都监听同一个 channel，那么 channel 上的数据都<strong>可能随机被某一个 goroutine 取走进行消费</strong></li><li>如果多个 goroutine 监听同一个 channel，如果这个 channel 被关闭，则所有 goroutine <strong>都能收到退出信号</strong></li></ol><a href=#go-channel-有无缓冲的区别><h1 id=go-channel-有无缓冲的区别><span class=hanchor arialabel=Anchor># </span>Go channel 有无缓冲的区别？</h1></a><p>无缓冲：一个送信人去你家送信，你不在家他不走，你一定要接下信，他才会走。</p><p>有缓冲：一个送信人去你家送信，扔到你家的信箱转身就走，除非你的信箱满了，他必须等信箱有多余空间才会走。</p><table><thead><tr><th>无缓冲</th><th>有缓冲</th><th></th></tr></thead><tbody><tr><td>创建方式</td><td>make (chan TYPE)</td><td>make (chan TYPE, SIZE)</td></tr><tr><td>发送阻塞</td><td>数据接收前发送阻塞</td><td>缓冲满时发送阻塞</td></tr><tr><td>接收阻塞</td><td>数据发送前接收阻塞</td><td>缓冲空时接收阻塞</td></tr></tbody></table><p><strong>非缓冲</strong> <code>channel</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>loop</span><span class=p>(</span><span class=nx>ch</span> <span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nx>i</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>ch</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;this  value of unbuffer channel&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>loop</span><span class=p>(</span><span class=nx>ch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这里会报错 <code>fatal error: all goroutines are asleep - deadlock!</code> 就是因为 <code>ch&lt;-1</code> 发送了，但是同时没有接收者，所以就发生了阻塞</p><p>但如果我们把 <code>ch &lt;- 1</code> 放到 <code>go loop(ch)</code> 下面，程序就会正常运行</p><p><strong>缓冲</strong> <code>channel</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>loop</span><span class=p>(</span><span class=nx>ch</span> <span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nx>i</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>ch</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;this  value of unbuffer channel&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>loop</span><span class=p>(</span><span class=nx>ch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这里也会报 fatal error: all goroutines are asleep - deadlock! ，这是因为 channel 的大小为 3 ，而我们要往里面塞 4 个数据，所以就会阻塞住，解决的办法有两个:</p><ol><li>把 channel 长度调大一点</li><li>把 channel 的信息发送者 ch &lt;- 1 这些代码移动到 go loop (ch) 下面，让 channel 实时消费就不会导致阻塞了</li></ol><a href=#go-channel-为什么是线程安全的><h1 id=go-channel-为什么是线程安全的><span class=hanchor arialabel=Anchor># </span>Go channel 为什么是线程安全的？</h1></a><p><strong>为什么设计成线程安全？</strong></p><p>不同协程通过 channel 进行通信，本身的使用场景就是多线程，为了保证数据的一致性，必须实现线程安全</p><p><strong>如何实现线程安全的？</strong></p><p>Channel 的底层实现中，hchan 结构体中采用 Mutex 锁来保证数据读写安全。在对循环数组 buf 中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作 channel 数据</p><a href=#go-channel-如何控制-goroutine-并发执行顺序><h1 id=go-channel-如何控制-goroutine-并发执行顺序><span class=hanchor arialabel=Anchor># </span>Go channel 如何控制 goroutine 并发执行顺序？</h1></a><p><strong>多个 goroutine 并发执行时，每一个 goroutine 抢到处理器的时间点不一致，gorouine 的执行本身不能保证顺序</strong>。即代码中先写的 gorouine 并不能保证先执行</p><p>思路：使用 channel 进行通信通知，用 channel 去传递信息，从而控制并发执行顺序</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;sync&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch1</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{},</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch2</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{},</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch3</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{},</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch1</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>start</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Unix</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nb>print</span><span class=p>(</span><span class=s>&#34;gorouine1&#34;</span><span class=p>,</span> <span class=nx>ch1</span><span class=p>,</span> <span class=nx>ch2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nb>print</span><span class=p>(</span><span class=s>&#34;gorouine2&#34;</span><span class=p>,</span> <span class=nx>ch2</span><span class=p>,</span> <span class=nx>ch3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nb>print</span><span class=p>(</span><span class=s>&#34;gorouine3&#34;</span><span class=p>,</span> <span class=nx>ch3</span><span class=p>,</span> <span class=nx>ch1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>end</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Unix</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;duration:%d\n&#34;</span><span class=p>,</span> <span class=nx>end</span><span class=o>-</span><span class=nx>start</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nb>print</span><span class=p>(</span><span class=nx>gorouine</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>inputchan</span> <span class=kd>chan</span> <span class=kd>struct</span><span class=p>{},</span> <span class=nx>outchan</span> <span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 模拟内部操作耗时
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>inputchan</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%s\n&#34;</span><span class=p>,</span> <span class=nx>gorouine</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>outchan</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>gorouine1
</span></span></span><span class=line><span class=cl><span class=cm>gorouine2
</span></span></span><span class=line><span class=cl><span class=cm>gorouine3
</span></span></span><span class=line><span class=cl><span class=cm>duration:1
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></td></tr></table></div></div><a href=#go-channel-共享内存有什么优劣势><h1 id=go-channel-共享内存有什么优劣势><span class=hanchor arialabel=Anchor># </span>Go channel 共享内存有什么优劣势？</h1></a><p><strong>“不要通过共享内存来通信，我们应该使用通信来共享内存”</strong> 这句话想必大家已经非常熟悉了，在官方的博客，初学时的教程，甚至是在 Go 的源码中都能看到</p><p>无论是通过共享内存来通信还是通过通信来共享内存，最终我们应用程序都是读取的内存当中的数据，只是前者是直接读取内存的数据，而后者是通过发送消息的方式来进行同步。而通过发送消息来同步的这种方式常见的就是 Go 采用的 CSP (Communication Sequential Process) 模型以及 Erlang 采用的 Actor 模型，这两种方式都是通过通信来共享内存。</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240225234650.png width=auto alt=image.png></p><p>大部分的语言采用的都是第一种方式直接去操作内存，然后通过互斥锁，CAS 等操作来保证并发安全。Go 引入了 Channel 和 Goroutine 实现 CSP 模型将生产者和消费者进行了解耦，Channel 其实和消息队列很相似。而 Actor 模型和 CSP 模型都是通过发送消息来共享内存，但是它们之间最大的区别就是 Actor 模型当中并没有一个独立的 Channel 组件，而是 Actor 与 Actor 之间直接进行消息的发送与接收，每个 Actor 都有一个本地的“信箱”消息都会先发送到这个“信箱当中”。</p><p><strong>优点</strong></p><ul><li>使用 channel 可以帮助我们解耦生产者和消费者，可以降低并发当中的耦合</li></ul><p><strong>缺点</strong></p><ul><li>容易出现死锁的情况</li></ul><a href=#go-channel-发送和接收什么情况下会死锁><h1 id=go-channel-发送和接收什么情况下会死锁><span class=hanchor arialabel=Anchor># </span>Go channel 发送和接收什么情况下会死锁？</h1></a><p><strong>死锁：</strong></p><ul><li>单个协程永久阻塞</li><li>两个或两个以上的协程的执行过程中，由于竞争资源或由于彼此通信而造成的一种阻塞的现象。</li></ul><p><strong>channel 死锁场景：</strong></p><ul><li>非缓存 channel 只写不读</li><li>非缓存 channel 读在写后面</li><li>缓存 channel 写入超过缓冲区数量</li><li>空读</li><li>多个协程互相等待</li></ul><p><strong>1、非缓存 channel 只写不读</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func deadlock1() {
</span></span><span class=line><span class=cl>    ch := make(chan int) 
</span></span><span class=line><span class=cl>    ch &lt;- 3 //  这里会发生一直阻塞的情况，执行不到下面一句
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><strong>2、非缓存 channel 读在写后面</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func deadlock2() {
</span></span><span class=line><span class=cl>    ch := make(chan int)
</span></span><span class=line><span class=cl>    ch &lt;- 3  //  这里会发生一直阻塞的情况，执行不到下面一句
</span></span><span class=line><span class=cl>    num := &lt;-ch
</span></span><span class=line><span class=cl>    fmt.Println(&#34;num=&#34;, num)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func deadlock2() {
</span></span><span class=line><span class=cl>    ch := make(chan int)
</span></span><span class=line><span class=cl>    ch &lt;- 100 //  这里会发生一直阻塞的情况，执行不到下面一句
</span></span><span class=line><span class=cl>    go func() {
</span></span><span class=line><span class=cl>        num := &lt;-ch
</span></span><span class=line><span class=cl>        fmt.Println(&#34;num=&#34;, num)
</span></span><span class=line><span class=cl>    }()
</span></span><span class=line><span class=cl>    time.Sleep(time.Second)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><strong>3、缓存 channel 写入超过缓冲区数量</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func deadlock3() {
</span></span><span class=line><span class=cl>    ch := make(chan int, 3)
</span></span><span class=line><span class=cl>    ch &lt;- 3
</span></span><span class=line><span class=cl>    ch &lt;- 4
</span></span><span class=line><span class=cl>    ch &lt;- 5
</span></span><span class=line><span class=cl>    ch &lt;- 6  //  这里会发生一直阻塞的情况
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><strong>4、空读</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func deadlock4() {
</span></span><span class=line><span class=cl>    ch := make(chan int)
</span></span><span class=line><span class=cl>    // ch := make(chan int, 1)
</span></span><span class=line><span class=cl>    fmt.Println(&lt;-ch)  //  这里会发生一直阻塞的情况
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><strong>5、多个协程互相等待</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func deadlock5() {
</span></span><span class=line><span class=cl>    ch1 := make(chan int)
</span></span><span class=line><span class=cl>    ch2 := make(chan int)
</span></span><span class=line><span class=cl>    // 互相等对方造成死锁
</span></span><span class=line><span class=cl>    go func() {
</span></span><span class=line><span class=cl>        for {
</span></span><span class=line><span class=cl>            select {
</span></span><span class=line><span class=cl>            case num := &lt;-ch1:
</span></span><span class=line><span class=cl>                fmt.Println(&#34;num=&#34;, num)
</span></span><span class=line><span class=cl>                ch2 &lt;- 100
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    for {
</span></span><span class=line><span class=cl>        select {
</span></span><span class=line><span class=cl>        case num := &lt;-ch2:
</span></span><span class=line><span class=cl>            fmt.Println(&#34;num=&#34;, num)
</span></span><span class=line><span class=cl>            ch1 &lt;- 300
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://googoo-s.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by googoo-s using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2024</p><ul><li><a href=https://googoo-s.github.io/>Home</a></li><li><a href=https://github.com/googoo-s>GitHub</a></li></ul></footer></div></div></body></html>