<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="参考  Golang map 实现原理 Golang sync.Map 实现原理
Map 概述 map 又称字典，是一种常用的数据结构，核心特征包含下述三点：
（1）存储基于 key-value 对映射的模式；
（2）基于 key 维度实现存储数据的去重；
（3）读、写、删操作控制，时间复杂度 O(1)."><meta property="og:title" content="Map"><meta property="og:description" content="参考  Golang map 实现原理 Golang sync.Map 实现原理
Map 概述 map 又称字典，是一种常用的数据结构，核心特征包含下述三点：
（1）存储基于 key-value 对映射的模式；
（2）基于 key 维度实现存储数据的去重；
（3）读、写、删操作控制，时间复杂度 O(1)."><meta property="og:type" content="website"><meta property="og:image" content="https://googoo-s.github.io/icon.png"><meta property="og:url" content="https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/Map-%E5%92%8CSync.map/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content="Map"><meta name=twitter:description content="参考  Golang map 实现原理 Golang sync.Map 实现原理
Map 概述 map 又称字典，是一种常用的数据结构，核心特征包含下述三点：
（1）存储基于 key-value 对映射的模式；
（2）基于 key 维度实现存储数据的去重；
（3）读、写、删操作控制，时间复杂度 O(1)."><meta name=twitter:image content="https://googoo-s.github.io/icon.png"><title>Map</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://googoo-s.github.io//icon.png><link href=https://googoo-s.github.io/styles.19109a40042e9f0e72e952fda4442a34.min.css rel=stylesheet><link href=https://googoo-s.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://googoo-s.github.io/js/darkmode.953af745b0f9342644d632fc167f3727.min.js></script>
<script src=https://googoo-s.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://googoo-s.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://googoo-s.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://googoo-s.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://googoo-s.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://googoo-s.github.io/",fetchData=Promise.all([fetch("https://googoo-s.github.io/indices/linkIndex.a2baaa58e30d0786b65f771aca40fd50.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://googoo-s.github.io/indices/contentIndex.a5a28c35fbe4e7216507c2f803c96b3b.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://googoo-s.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://googoo-s.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/googoo-s.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=googoo-s.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://googoo-s.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://googoo-s.github.io/>googoo-s 😄😸😎</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Map</h1><p class=meta>Last updated
Feb 26, 2024</p><ul class=tags><li><a href=https://googoo-s.github.io/tags/GO/%E5%85%AB%E8%82%A1%E6%96%87/>Go 八股文</a></li></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#参考>参考</a></li><li><a href=#map-概述>Map 概述</a></li><li><a href=#map-初始化>Map 初始化</a></li><li><a href=#map-的-key-可以是哪些类型可以嵌套-map-吗>Map 的 key 可以是哪些类型？可以嵌套 map 吗？</a></li><li><a href=#map-读>Map 读</a></li><li><a href=#map-的查询复杂度>Map 的查询复杂度</a></li><li><a href=#map-写>Map 写</a></li><li><a href=#map-删除>Map 删除</a></li><li><a href=#map-遍历>Map 遍历</a></li><li><a href=#map-的底层实现原理>map 的底层实现原理？</a><ol><li><a href=#hash>Hash</a></li><li><a href=#桶数组>桶数组</a></li><li><a href=#map-冲突的解决方式>map 冲突的解决方式？</a></li><li><a href=#扩容>扩容</a></li><li><a href=#hmap-结构体><strong>hmap 结构体</strong></a></li><li><a href=#bmap-结构体><strong>bmap 结构体</strong></a></li><li><a href=#mapextra-结构体><strong>mapextra 结构体</strong></a></li><li><a href=#map-的负载因子为什么是-65>Map 的负载因子为什么是 6.5？</a></li><li><a href=#构造流程>构造流程</a></li><li><a href=#读流程>读流程</a></li><li><a href=#写流程>写流程</a></li><li><a href=#删除流程>删除流程</a></li><li><a href=#遍历流程>遍历流程</a></li><li><a href=#扩容流程>扩容流程</a><ol><li><a href=#扩容类型>扩容类型</a></li><li><a href=#何时扩容>何时扩容</a></li><li><a href=#如何开启扩容模式>如何开启扩容模式</a></li><li><a href=#扩容迁移规则>扩容迁移规则</a></li><li><a href=#渐进式扩容>渐进式扩容</a></li></ol></li></ol></li><li><a href=#map-遍历为什么是无序的>map 遍历为什么是无序的？</a></li><li><a href=#map-为什么是非线程安全的>map 为什么是非线程安全的？</a></li><li><a href=#map-怎么知道自己处于竞争状态是-go-编码实现的还是底层硬件实现的>Map 怎么知道自己处于竞争状态？是 Go 编码实现的还是底层硬件实现的？</a></li><li><a href=#map-的-panic-能被-recover-掉吗了解-panic-和-recover-的机制>Map 的 panic 能被 recover 掉吗？了解 panic 和 recover 的机制？</a></li><li><a href=#go-中两个-map-对象如何比较>Go 中两个 map 对象如何比较</a></li><li><a href=#map-的优缺点以及改进>Map 的优缺点以及改进?</a></li><li><a href=#sync-map-怎么使用>Sync. Map 怎么使用</a></li><li><a href=#sync-map-底层实现原理>Sync. Map 底层实现原理</a><ol><li><a href=#sync-map>Sync. Map</a></li><li><a href=#entry>Entry</a></li><li><a href=#readonly>readOnly</a></li><li><a href=#读流程-1>读流程</a><ol><li><a href=#syncmapload>sync.Map.Load()</a></li><li><a href=#entryload>entry.load()</a></li><li><a href=#-syncmapmisslocked>## sync.Map.missLocked()</a></li></ol></li><li><a href=#写流程-1> 写流程</a><ol><li><a href=#syncmapstore>sync.Map.Store()</a></li><li><a href=#entrytrystore>entry.tryStore()</a></li><li><a href=#entryunexpungelocked>entry.unexpungeLocked()</a></li><li><a href=#entrystorelocked>entry.storeLocked()</a></li><li><a href=#syncmapdirtylocked>sync.Map.dirtyLocked()</a></li></ol></li><li><a href=#删流程>删流程</a><ol><li><a href=#syncmapdelete>sync.Map.Delete()</a></li><li><a href=#entrydelete>entry.delete()</a></li></ol></li><li><a href=#遍历流程-1>遍历流程</a></li><li><a href=#总结>总结</a><ol><li><a href=#entry-的-expunged-态>entry 的 expunged 态</a></li><li><a href=#read-map-和-dirty-map-的数据流转>read map 和 dirty map 的数据流转</a></li></ol></li></ol></li><li><a href=#go-map-和-sync-map-谁的性能好为什么>Go map 和 sync. Map 谁的性能好，为什么？</a></li></ol></nav></details></aside><a href=#参考><h1 id=参考><span class=hanchor arialabel=Anchor># </span>参考</h1></a><p><a href="https://mp.weixin.qq.com/s?__biz=MzkxMjQzMjA0OQ==&mid=2247483868&idx=1&sn=6e954af8e5e98ec0a9d9fc5c8ceb9072&chksm=c10c4f02f67bc614ff40a152a848508aa1631008eb5a600006c7552915d187179c08d4adf8d7&scene=178&cur_album_id=2709593649634033668#rd" rel=noopener>Golang map 实现原理</a>
<a href="https://mp.weixin.qq.com/s?__biz=MzkxMjQzMjA0OQ==&mid=2247483821&idx=1&sn=f45e9e2b4c4cb7edaa57d904e3bf7bd7&chksm=c10c4f73f67bc6655e7e7c9f808a318b1c74e76782824df18843f4c31e39ce512819d6abe156&scene=178&cur_album_id=2709593649634033668#rd" rel=noopener>Golang sync.Map 实现原理</a></p><a href=#map-概述><h1 id=map-概述><span class=hanchor arialabel=Anchor># </span>Map 概述</h1></a><p>map 又称字典，是一种常用的数据结构，核心特征包含下述三点：</p><p>（1）存储基于 key-value 对映射的模式；</p><p>（2）基于 key 维度实现存储数据的去重；</p><p>（3）读、写、删操作控制，时间复杂度 O(1).</p><a href=#map-初始化><h1 id=map-初始化><span class=hanchor arialabel=Anchor># </span>Map 初始化</h1></a><p>Golang 中，对 map 的初始化分为以下几种方式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>myMap1 := make(map[int]int,2)
</span></span><span class=line><span class=cl>//通过 make 关键字进行初始化，同时指定 map 预分配的容量.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>myMap2 := make(map[int]int)
</span></span><span class=line><span class=cl>//通过 make 关键字进行初始化，不显式声明容量，因此默认容量 为 0.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>myMap3 :=map[int]int{
</span></span><span class=line><span class=cl>  1:2,
</span></span><span class=line><span class=cl>  3:4,
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#map-的-key-可以是哪些类型可以嵌套-map-吗><h1 id=map-的-key-可以是哪些类型可以嵌套-map-吗><span class=hanchor arialabel=Anchor># </span>Map 的 key 可以是哪些类型？可以嵌套 map 吗？</h1></a><ul><li><p><strong>Map key 必须是可比较的类型</strong>，</p><ul><li>语言规范中定义了可比较的类型：boolean, numeric, string, pointer, channel, interface,以及仅包含这些类型的 struct 和 array 。</li><li>不能作为 map key 的类型有：slice，map, function。</li></ul></li><li><p>可以嵌套 map。</p></li></ul><a href=#map-读><h1 id=map-读><span class=hanchor arialabel=Anchor># </span>Map 读</h1></a><ul><li>第一种方式是直接读，倘若 key 存在，则获取到对应的 val，倘若 key 不存在或者 map 未初始化，会返回 val 类型的零值作为兜底</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>v1 := myMap[10]
</span></span></code></pre></td></tr></table></div></div><ul><li>第二种方式是读的同时添加一个 bool 类型的 flag 标识是否读取成功. 倘若 ok == false，<strong>说明读取失败， key 不存在，或者 map 未初始化.</strong></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>v2,ok := myMap[10]
</span></span></code></pre></td></tr></table></div></div><ul><li>如果 map 没有初始化,取值得到零值</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>myMap</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span> <span class=c1>// 未初始化的 map
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>value</span> <span class=o>:=</span> <span class=nx>myMap</span><span class=p>[</span><span class=s>&#34;some_key&#34;</span><span class=p>]</span> <span class=c1>// 尝试获取一个键的值
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>//panic: assignment to entry in nil map
</span></span></span></code></pre></td></tr></table></div></div><a href=#map-的查询复杂度><h1 id=map-的查询复杂度><span class=hanchor arialabel=Anchor># </span>Map 的查询复杂度</h1></a><p><strong>空间复杂度</strong>:
由于溢出桶数量超过 hash 桶数量时会触发缩容，所以最坏的情况是数据被集中在一条链上，hash 表基本是空的，这时空间浪费 O (n)。<br>最好的情况下，数据均匀散列在 hash 表上，没有元素溢出，这时最好的空间复杂度就是扩散因子决定了，当前 go 的扩散因子由全局变量决定，即 loadFactorNum/loadFactorDen = 6.5。即平均每个 hash 桶被分配到 6.5 个元素以上时，开始扩容。所以最小的空间浪费是 (8-6.5)/8 = 0.1875，即 O (0.1875n)</p><p>结论：go map 的空间复杂度（指除去正常存储元素所需空间之外的空间浪费）是 O (0.1875 n) ~ O (n)之间。<br>​ 具体细节：
<a href=https://blog.csdn.net/dongjijiaoxiangqu/article/details/109643025 rel=noopener>https://blog.csdn.net/dongjijiaoxiangqu/article/details/109643025</a> </p><p><strong>时间复杂度</strong>：</p><p>Go 采用的 hash 算法应是很成熟的算法，极端情况暂不考虑。所以综合情况下 go map 的时间复杂度应为 O(1)</p><a href=#map-写><h1 id=map-写><span class=hanchor arialabel=Anchor># </span>Map 写</h1></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>myMap[5] = 6
</span></span></code></pre></td></tr></table></div></div><p>倘若 map 未初始化，直接执行写操作会导致 panic：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>const plainError string
</span></span><span class=line><span class=cl>panic(plainError(&#34;assignment to entry in nil map&#34;))
</span></span></code></pre></td></tr></table></div></div><a href=#map-删除><h1 id=map-删除><span class=hanchor arialabel=Anchor># </span>Map 删除</h1></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>delete(myMap,5)
</span></span></code></pre></td></tr></table></div></div><p>执行 delete 方法时，倘若 key 存在，则会从 map 中将对应的 key-value 对删除；倘若 key 不存在或 map 未初始化，则方法直接结束，不会产生显式提示.</p><a href=#map-遍历><h1 id=map-遍历><span class=hanchor arialabel=Anchor># </span>Map 遍历</h1></a><p>遍历分为下面两种方式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>for k,v := range myMap{
</span></span><span class=line><span class=cl>// ...
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>基于 k,v 依次承接 map 中的 key-value 对；</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>for k := range myMap{  
</span></span><span class=line><span class=cl>// ...
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>基于 k 依次承接 map 中的 key，不关注 val 的取值.</p><p>需要注意的是，在执行 map 遍历操作时，<strong>获取的 key-value 对并没有一个固定的顺序，因此前后两次遍历顺序可能存在差异</strong>.</p><a href=#map-的底层实现原理><h1 id=map-的底层实现原理><span class=hanchor arialabel=Anchor># </span>map 的底层实现原理？</h1></a><p>map 又称为 hash map，在算法上基于 hash 实现 key 的映射和寻址；在数据结构上基于桶数组实现 key-value 对的存储.</p><p>以一组 key-value 对写入 map 的流程为例进行简述：</p><p>（1）通过哈希方法取得 key 的 hash 值；</p><p>（2）hash 值对桶数组长度取模，确定其所属的桶；</p><p>（3）在桶中插入 key-value 对.</p><a href=#hash><h2 id=hash><span class=hanchor arialabel=Anchor># </span>Hash</h2></a><p>hash 译作散列，是一种将任意长度的输入压缩到某一固定长度的输出摘要的过程</p><ul><li>（1）hash 的可重入性：相同的 key，必然产生相同的 hash 值；</li><li>（2）hash 的离散性：只要两个 key 不相同，不论其相似度的高低，产生的 hash 值会在整个输出域内均匀地离散化；</li><li>（3）hash 的单向性：企图通过 hash 值反向映射回 key 是无迹可寻的.</li><li>（4）hash 冲突：由于输入域（key）无穷大，输出域（hash 值）有限，因此必然存在不同 key 映射到相同 hash 值的情况，称之为 hash 冲突.</li></ul><a href=#桶数组><h2 id=桶数组><span class=hanchor arialabel=Anchor># </span>桶数组</h2></a><p>map 中，会通过长度为 2 的整数次幂的桶数组进行 key-value 对的存储：</p><p>（1）每个桶固定可以存放 8 个 key-value 对；</p><p>（2）倘若超过 8 个 key-value 对打到桶数组的同一个索引当中，此时会通过创建桶链表的方式来化解这一问题.</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226212728.png width=auto alt=image.png></p><a href=#map-冲突的解决方式><h2 id=map-冲突的解决方式><span class=hanchor arialabel=Anchor># </span>map 冲突的解决方式？</h2></a><p>比较常用的 Hash 冲突解决方案有链地址法和开放寻址法：</p><p><strong>链地址法</strong></p><p>当哈希冲突发生时，创建新<strong>单元</strong>，并将新单元添加到冲突单元所在链表的尾部. 在 Go 中将命中同一个桶的元素通过链表的形式进行链接，因此很便于动态扩展</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226213338.png width=auto alt=image.png></p><p><strong>开放寻址法</strong></p><p>当哈希冲突发生时，从发生冲突的那个<strong>单元</strong>起，按照一定的次序，从哈希表中寻找一个空闲的单元，然后把发生冲突的元素存入到该单元。<strong>开放寻址法需要的表长度要大于等于所需要存放的元素数量</strong></p><p>开放寻址法有多种方式：<strong>线性探测法、平方探测法、随机探测法和双重哈希法</strong>。这里以线性探测法来帮助读者理解开放寻址法思想</p><p><strong>两种解决方案比较</strong></p><table><thead><tr><th>方法</th><th>优点</th></tr></thead><tbody><tr><td>拉链法</td><td>简单常用；无需预先为元素分配内存.</td></tr><tr><td>开放寻址法</td><td>无需额外的指针用于链接元素；内存地址完全连续，可以基于局部性原理，充分利用 CPU 高速缓存.</td></tr></tbody></table><p><strong>总结</strong></p><p><strong>GO 中 实际上结合了拉链法和开放寻址法两种思路</strong>. 以 map 的插入写流程为例，进行思路阐述：</p><ul><li><p>（1）桶数组中的每个桶，严格意义上是一个单向桶链表，以桶为节点进行串联；</p></li><li><p>（2）每个桶固定可以存放 8 个 key-value 对；</p></li><li><p>（3）当 key 命中一个桶时，首先根据开放寻址法，在桶的 8 个位置中寻找空位进行插入；</p></li><li><p>（4）倘若桶的 8 个位置都已被占满，则基于桶的溢出桶指针，找到下一个桶，重复第（3）步；</p></li><li><p>（5）倘若遍历到链表尾部，仍未找到空位，则基于拉链法，在桶链表尾部续接新桶，并插入 key-value 对.</p></li></ul><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226213553.png width=auto alt=image.png></p><a href=#扩容><h2 id=扩容><span class=hanchor arialabel=Anchor># </span>扩容</h2></a><p>map 扩容机制的核心点包括：</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226221432.png width=auto alt=image.png></p><ul><li><p>（1）扩容分为增量扩容和等量扩容；</p><ul><li><strong>双倍扩容</strong>：新建一个 buckets 数组，<strong>新的 buckets 大小是原来的 2 倍</strong>，然后旧 buckets 数据搬迁到新的 buckets。该方法我们称之为<strong>双倍扩容</strong></li><li>等量扩容：<strong>并不扩大容量</strong>，buckets 数量维持不变，<strong>重新做一遍类似双倍扩容的搬迁动作，把松散的键值对重新排列一次</strong>，使得同一个 bucket 中的 key 排列地更紧密，节省空间，提高 bucket 利用率，进而保证更快的存取。该方法我们称之为等量扩容。</li></ul></li><li><p>（2）当桶内 key-value 总数/桶数组长度 > 6.5 时发生增量扩容，桶数组长度增长为原值的两倍；</p></li><li><p>（3）当桶内溢出桶数量大于等于 2^B 时( B 为桶数组长度的指数，B 最大取 15)，发生等量扩容，桶的长度保持为原值；</p></li><li><p>（4）采用渐进扩容的方式，当桶被实际操作到时，由使用者负责完成数据迁移，避免因为一次性的全量数据迁移引发性能抖动.</p></li></ul><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226214126.png width=auto alt=image.png></p><a href=#hmap-结构体><h2 id=hmap-结构体><span class=hanchor arialabel=Anchor># </span><strong>hmap 结构体</strong></h2></a><p>Go 中的 map 是一个应用，占用 8 个字节，指向 hmap 结构体</p><p>源码包中 <code>src/runtime/map.go</code> 定义了 hmap 的数据结构：</p><p>Hmap 包含若干个结构为 bmap 的数组，每个 bmap 底层都采用链表结构，bmap 通常叫其 bucket</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240225233011.png width=auto alt=image.png></p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226214237.png width=auto alt=image.png></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// A header for a Go map.
</span></span><span class=line><span class=cl>type hmap struct {
</span></span><span class=line><span class=cl>    count     int 
</span></span><span class=line><span class=cl>    // 代表哈希表中的元素个数，调用len(map)时，返回的就是该字段值。
</span></span><span class=line><span class=cl>    flags     uint8 
</span></span><span class=line><span class=cl>    // 状态标志（是否处于正在写入的状态等）
</span></span><span class=line><span class=cl>    B         uint8  
</span></span><span class=line><span class=cl>    // buckets（桶）的对数
</span></span><span class=line><span class=cl>    // 如果B=5，则buckets数组的长度 = 2^B=32，意味着有32个桶
</span></span><span class=line><span class=cl>    noverflow uint16 
</span></span><span class=line><span class=cl>    // 溢出桶的数量
</span></span><span class=line><span class=cl>    hash0     uint32 
</span></span><span class=line><span class=cl>    // 生成hash的随机数种子
</span></span><span class=line><span class=cl>    buckets    unsafe.Pointer 
</span></span><span class=line><span class=cl>    // 指向buckets数组的指针，数组大小为2^B，如果元素个数为0，它为nil。
</span></span><span class=line><span class=cl>    oldbuckets unsafe.Pointer 
</span></span><span class=line><span class=cl>    // 如果发生扩容，oldbuckets是指向老的buckets数组的指针，老的buckets数组大小是新的buckets的1/2;非扩容状态下，它为nil。
</span></span><span class=line><span class=cl>    nevacuate  uintptr        
</span></span><span class=line><span class=cl>    // 表示扩容进度，小于此地址的buckets代表已搬迁完成。
</span></span><span class=line><span class=cl>    extra *mapextra 
</span></span><span class=line><span class=cl>    // 存储溢出桶，这个字段是为了优化GC扫描而设计的，下面详细介绍
</span></span><span class=line><span class=cl> }
</span></span></code></pre></td></tr></table></div></div><ul><li><p>（1）count：map 中的 key-value 总数；</p></li><li><p>（2）flags：map 状态标识，可以标识出 map 是否被 goroutine 并发读写；</p></li><li><p>（3）B：桶数组长度的指数，桶数组长度为 2^B；</p></li><li><p>（4）noverflow：map 中溢出桶的数量；</p></li><li><p>（5）hash0：hash 随机因子，生成 key 的 hash 值时会使用到；</p></li><li><p>（6）buckets：桶数组；</p></li><li><p>（7）oldbuckets：扩容过程中老的桶数组；</p></li><li><p>（8）nevacuate：扩容时的进度标识，index 小于 nevacuate 的桶都已经由老桶转移到新桶中；</p></li><li><p>（9）extra：预申请的溢出桶.</p></li></ul><a href=#bmap-结构体><h2 id=bmap-结构体><span class=hanchor arialabel=Anchor># </span><strong>bmap 结构体</strong></h2></a><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226214340.png width=auto alt=image.png></p><p><code>bmap</code> 就是我们常说的“桶”，一个桶里面会最多装 8 个 key，</p><ul><li>这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，<strong>哈希结果的低 B 位是相同的</strong>，</li><li>在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有 8 个位置)。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// A bucket for a Go map.
</span></span><span class=line><span class=cl>type bmap struct {
</span></span><span class=line><span class=cl>    tophash [bucketCnt]uint8        
</span></span><span class=line><span class=cl>    // len为8的数组
</span></span><span class=line><span class=cl>    // 用来快速定位key是否在这个bmap中
</span></span><span class=line><span class=cl>    // 一个桶最多8个槽位，如果key所在的tophash值在tophash中，则代表该key在这个桶中
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>上面 bmap 结构是静态结构，在编译过程中 <code>runtime.bmap</code> 会拓展成以下结构体：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type bmap struct{
</span></span><span class=line><span class=cl>    tophash [8]uint8
</span></span><span class=line><span class=cl>    keys [8]keytype 
</span></span><span class=line><span class=cl>    // keytype 由编译器编译时候确定
</span></span><span class=line><span class=cl>    values [8]elemtype 
</span></span><span class=line><span class=cl>    // elemtype 由编译器编译时候确定
</span></span><span class=line><span class=cl>    overflow uintptr 
</span></span><span class=line><span class=cl>    // overflow指向下一个bmap，overflow是uintptr而不是*bmap类型，保证bmap完全不含指针，是为了减少gc，溢出桶存储到extra字段中
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><ul><li><p>Tophash 就是用于实现快速定位 key 的位置，在实现过程中<strong>会使用 key 的 hash 值的高 8 位作为 tophash 值</strong>，存放在 bmap 的 tophash 字段中</p></li><li><p>Tophash 字段不仅存储 key 哈希值的高 8 位，<strong>还会存储一些状态值，用来表明当前桶单元状态，这些状态值都是小于 minTopHash</strong> 的</p></li><li><p>为了避免 key 哈希值的高 8 位值和这些状态值相等，产生混淆情况，<strong>所以当 key 哈希值高 8 位若小于 minTopHash 时候，自动将其值加上 minTopHash 作为该 key 的 tophash</strong>。桶单元的状态值如下：</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>emptyRest      = 0 // 表明此桶单元为空，且更高索引的单元也是空
</span></span><span class=line><span class=cl>emptyOne       = 1 // 表明此桶单元为空
</span></span><span class=line><span class=cl>evacuatedX     = 2 // 用于表示扩容迁移到新桶前半段区间
</span></span><span class=line><span class=cl>evacuatedY     = 3 // 用于表示扩容迁移到新桶后半段区间
</span></span><span class=line><span class=cl>evacuatedEmpty = 4 // 用于表示此单元已迁移
</span></span><span class=line><span class=cl>minTopHash     = 5 // key的tophash值与桶状态值分割线值，小于此值的一定代表着桶单元的状态，大于此值的一定是key对应的tophash值
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func tophash(hash uintptr) uint8 {
</span></span><span class=line><span class=cl>    top := uint8(hash &gt;&gt; (goarch.PtrSize*8 - 8))
</span></span><span class=line><span class=cl>    if top &lt; minTopHash {
</span></span><span class=line><span class=cl>        top += minTopHash
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    return top
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><strong>总结</strong></p><p>Bmap（bucket）内存数据结构可视化如下:</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240225233151.png width=auto alt=image.png></p><a href=#mapextra-结构体><h2 id=mapextra-结构体><span class=hanchor arialabel=Anchor># </span><strong>mapextra 结构体</strong></h2></a><p>当 map 的 key 和 value 都不是指针类型时候，bmap 将完全不包含指针，那么 gc 时候就不用扫描 bmap。Bmap 指向溢出桶的字段 overflow 是 uintptr 类型，为了防止这些 overflow 桶被 gc 掉，所以需要 mapextra. Overflow 将它保存起来。如果 bmap 的 overflow 是 bmap 类型，那么 gc 扫描的是一个个拉链表，效率明显不如直接扫描一段内存 (hmap. Mapextra. Overflow)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type mapextra struct {
</span></span><span class=line><span class=cl>    overflow    *[]*bmap
</span></span><span class=line><span class=cl>    // overflow 包含的是 hmap.buckets 的 overflow 的 buckets
</span></span><span class=line><span class=cl>    oldoverflow *[]*bma
</span></span><span class=line><span class=cl>   // oldoverflow 包含扩容时 hmap.oldbuckets 的 overflow 的 bucket
</span></span><span class=line><span class=cl>    nextOverflow *bmap 
</span></span><span class=line><span class=cl>     // 指向空闲的 overflow bucket 的指针
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><strong>在 map 初始化时，倘若容量过大，会提前申请好一批溢出桶</strong>，以供后续使用，这部分溢出桶存放在 hmap.mapextra 当中：</p><p>（1）mapextra.overflow：供桶数组 buckets 使用的溢出桶；</p><p>（2）mapextra.oldoverFlow: 扩容流程中，供老桶数组 oldBuckets 使用的溢出桶；</p><p>（3）mapextra.nextOverflow：下一个可用的溢出桶.</p><a href=#map-的负载因子为什么是-65><h2 id=map-的负载因子为什么是-65><span class=hanchor arialabel=Anchor># </span>Map 的负载因子为什么是 6.5？</h2></a><p><strong>什么是负载因子?</strong></p><p><strong>负载因子（load factor），用于衡量当前哈希表中空间占用率的核心指标</strong>，也就是每个 bucket 桶存储的平均元素个数。</p><table><thead><tr><th>负载因子 = 哈希表存储的元素个数/桶个</th></tr></thead></table><p>另外负载因子<strong>与扩容、迁移</strong>等重新散列（rehash）行为有直接关系：</p><ul><li>在程序运行时，会不断地进行插入、删除等，会导致 bucket 不均，内存利用率低，需要迁移。</li><li>在程序运行时，出现负载因子过大，需要做扩容，解决 bucket 过大的问题。</li></ul><p>负载因子是哈希表中的一个重要指标，在各种版本的哈希表实现中都有类似的东西，主要目的是<strong>为了平衡 buckets 的存储空间大小和查找元素时的性能高低</strong>。</p><p>在接触各种哈希表时都可以关注一下，做不同的对比，看看各家的考量。</p><p><strong>为什么是 6.5?</strong></p><p>为什么 Go 语言中哈希表的负载因子是 6.5，为什么不是 8 ，也不是 1。这里面有可靠的数据支撑吗？</p><p><strong>测试报告</strong></p><p>实际上这是 Go 官方的经过认真的测试得出的数字，一起来看看官方的这份测试报告。</p><p>报告中共包含 4 个关键指标，如下：</p><table><thead><tr><th style=text-align:left>loadFactor</th><th style=text-align:left>%overflow</th><th style=text-align:left>bytes/entry</th><th style=text-align:left>hitprobe</th><th style=text-align:left>missprobe</th></tr></thead><tbody><tr><td style=text-align:left>4.00</td><td style=text-align:left>2.13</td><td style=text-align:left>20.77</td><td style=text-align:left>3.00</td><td style=text-align:left>4.00</td></tr><tr><td style=text-align:left>4.50</td><td style=text-align:left>4.05</td><td style=text-align:left>17.30</td><td style=text-align:left>3.25</td><td style=text-align:left>4.50</td></tr><tr><td style=text-align:left>5.00</td><td style=text-align:left>6.85</td><td style=text-align:left>14.77</td><td style=text-align:left>3.50</td><td style=text-align:left>5.00</td></tr><tr><td style=text-align:left>5.50</td><td style=text-align:left>10.55</td><td style=text-align:left>12.94</td><td style=text-align:left>3.75</td><td style=text-align:left>5.50</td></tr><tr><td style=text-align:left>6.00</td><td style=text-align:left>15.27</td><td style=text-align:left>11.67</td><td style=text-align:left>4.00</td><td style=text-align:left>6.00</td></tr><tr><td style=text-align:left>6.50</td><td style=text-align:left>20.90</td><td style=text-align:left>10.79</td><td style=text-align:left>4.25</td><td style=text-align:left>6.50</td></tr><tr><td style=text-align:left>7.00</td><td style=text-align:left>27.14</td><td style=text-align:left>10.15</td><td style=text-align:left>4.50</td><td style=text-align:left>7.00</td></tr><tr><td style=text-align:left>7.50</td><td style=text-align:left>34.03</td><td style=text-align:left>9.73</td><td style=text-align:left>4.75</td><td style=text-align:left>7.50</td></tr><tr><td style=text-align:left>8.00</td><td style=text-align:left>41.10</td><td style=text-align:left>9.40</td><td style=text-align:left>5.00</td><td style=text-align:left>8.00</td></tr></tbody></table><ul><li>LoadFactor：负载因子，也有叫装载因子。</li><li>%overflow：溢出率，有溢出 bukcet 的百分比。</li><li>Bytes/entry：平均每对 key/value 的开销字节数.</li><li>Hitprobe：查找一个存在的 key 时，要查找的平均个数。</li><li>Missprobe：查找一个不存在的 key 时，要查找的平均个数。</li></ul><p><strong>选择数值</strong></p><p>Go 官方发现：<strong>装载因子越大，填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。反之，装载因子越小，填入的元素越少，冲突发生的几率减小，但空间浪费也会变得更多，而且还会提高扩容操作的次数</strong></p><p>根据这份测试结果和讨论，Go 官方取了一个相对适中的值，把 Go 中的 map 的负载因子硬编码为 6.5，这就是 6.5 的选择缘由。</p><p>这意味着在 Go 语言中，<strong>当 map 存储的元素个数大于或等于 6.5 * 桶个数时，就会触发扩容行为</strong>。</p><a href=#构造流程><h2 id=构造流程><span class=hanchor arialabel=Anchor># </span>构造流程</h2></a><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226215050.png width=auto alt=image.png></p><p>创建 map 时，实际上会调用 runtime/map.go 文件中的 makemap 方法，下面对源码展开分析：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func makemap(t *maptype, hint int, h *hmap) *hmap {
</span></span><span class=line><span class=cl>    mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size)
</span></span><span class=line><span class=cl>    if overflow || mem &gt; maxAlloc {
</span></span><span class=line><span class=cl>        hint = 0
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if h == nil {
</span></span><span class=line><span class=cl>        h = new(hmap)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    h.hash0 = fastrand()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    B := uint8(0)
</span></span><span class=line><span class=cl>    for overLoadFactor(hint, B) {
</span></span><span class=line><span class=cl>        B++
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    h.B = B
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if h.B != 0 {
</span></span><span class=line><span class=cl>        var nextOverflow *bmap
</span></span><span class=line><span class=cl>        h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)
</span></span><span class=line><span class=cl>        if nextOverflow != nil {
</span></span><span class=line><span class=cl>            h.extra = new(mapextra)
</span></span><span class=line><span class=cl>            h.extra.nextOverflow = nextOverflow
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return 
</span></span></code></pre></td></tr></table></div></div><ul><li><p>（1）hint 为 map 拟分配的容量；在分配前，会提前对拟分配的内存大小进行判断，倘若超限，会将 hint 置为零；</p></li><li><p>（2）通过 new 方法初始化 hmap；</p></li><li><p>（3）调用 fastrand，构造 hash 因子：hmap.hash0；</p></li><li><p>（4）大致上基于 log2(B) >= hint 的思路，计算桶数组的容量 B；</p><ul><li>overLoadFactor 中实现</li><li>倘若 map 预分配容量小于等于 8，B 取 0，桶的个数为 1；</li><li>保证 map 预分配容量小于等于桶数组长度 * 6.5.</li></ul></li><li><p>（5）调用 makeBucketArray 方法，初始化桶数组 hmap.buckets</p><ul><li>makeBucketArray 方法会进行桶数组的初始化，并根据桶的数量决定是否需要提前作溢出桶的初始化.</li></ul></li><li><p>（6）倘若 map 容量较大，会提前申请一批溢出桶 hmap.extra.</p></li></ul><a href=#读流程><h2 id=读流程><span class=hanchor arialabel=Anchor># </span>读流程</h2></a><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226215347.png width=auto alt=image.png></p><p>map 读流程主要分为以下几步：</p><p>（1）根据 key 取 hash 值；</p><p>（2）根据 hash 值对桶数组取模，确定所在的桶；</p><p>（3）沿着桶链表依次遍历各个桶内的 key-value 对；</p><p>（4）命中相同的 key，则返回 value；倘若 key 不存在，则返回零值.</p><p>map 读操作最终会走进 runtime/map.go 的 mapaccess 方法中，下面开始阅读源码</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
</span></span><span class=line><span class=cl>    if h <mark> nil || h.count </mark> 0 {
</span></span><span class=line><span class=cl>        return unsafe.Pointer(&amp;zeroVal[0])
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    if h.flags&amp;hashWriting != 0 {
</span></span><span class=line><span class=cl>        fatal(&#34;concurrent map read and map write&#34;)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    hash := t.hasher(key, uintptr(h.hash0))
</span></span><span class=line><span class=cl>    m := bucketMask(h.B)
</span></span><span class=line><span class=cl>    b := (*bmap)(add(h.buckets, (hash&amp;m)*uintptr(t.bucketsize)))
</span></span><span class=line><span class=cl>    if c := h.oldbuckets; c != nil {
</span></span><span class=line><span class=cl>        if !h.sameSizeGrow() {
</span></span><span class=line><span class=cl>            m &gt;&gt;= 1
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        oldb := (*bmap)(add(c, (hash&amp;m)*uintptr(t.bucketsize)))
</span></span><span class=line><span class=cl>        if !evacuated(oldb) {
</span></span><span class=line><span class=cl>            b = oldb
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    top := tophash(hash)
</span></span><span class=line><span class=cl>bucketloop:
</span></span><span class=line><span class=cl>    for ; b != nil; b = b.overflow(t) {
</span></span><span class=line><span class=cl>        for i := uintptr(0); i &lt; bucketCnt; i++ {
</span></span><span class=line><span class=cl>            if b.tophash[i] != top {
</span></span><span class=line><span class=cl>                if b.tophash[i] == emptyRest {
</span></span><span class=line><span class=cl>                    break bucketloop
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                continue
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
</span></span><span class=line><span class=cl>            if t.indirectkey() {
</span></span><span class=line><span class=cl>                k = *((*unsafe.Pointer)(k))
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            if t.key.equal(key, k) {
</span></span><span class=line><span class=cl>                e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
</span></span><span class=line><span class=cl>                if t.indirectelem() {
</span></span><span class=line><span class=cl>                    e = *((*unsafe.Pointer)(e))
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                return e
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    return unsafe.Pointer(&amp;zeroVal[0])
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func (h *hmap) sameSizeGrow() bool {
</span></span><span class=line><span class=cl>    return h.flags&amp;sameSizeGrow != 0
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func evacuated(b *bmap) bool {
</span></span><span class=line><span class=cl>    h := b.tophash[0]
</span></span><span class=line><span class=cl>    return h &gt; emptyOne &amp;&amp; h &lt; minTopHash
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>（1）倘若 map 未初始化，或此时存在 key-value 对数量为 0，直接返回零值；</p><p>（2）倘若发现存在其他 goroutine 在写 map，直接抛出并发读写的 fatal error；其中，并发写标记，位于 hmap.flags 的第 3 个 bit 位；</p><p>（3）通过 maptype.hasher() 方法计算得到 key 的 hash 值，并对桶数组长度取模，取得对应的桶. 关于 hash 方法的内部实现，golang 并未暴露.</p><ul><li>其中，bucketMast 方法会根据 B 求得桶数组长度 - 1 的值，用于后续的 & 运算，实现取模的效果：</li></ul><p>（4）在取桶时，会关注当前 map 是否处于扩容的流程，倘若是的话，需要在老的桶数组 oldBuckets 中取桶，通过 evacuated 方法判断桶数据是已迁到新桶还是仍存留在老桶，倘若仍在老桶，需要取老桶进行遍历.</p><ul><li>在取老桶前，会先判断 map 的扩容流程是否是增量扩容，倘若是的话，说明老桶数组的长度是新桶数组的一半，需要将桶长度值 m 除以 2.</li></ul><p>（5）取 key hash 值的高 8 位值 top. 倘若该值 &lt; 5，会累加 5，以避开 0 ~ 4 的取值. 因为这几个值会用于枚举，具有一些特殊的含义.</p><p>（6）开启两层 for 循环进行遍历流程，外层基于桶链表，依次遍历首个桶和后续的每个溢出桶，内层依次遍历一个桶内的 key-value 对.</p><ul><li><p>内存遍历时，首先查询高 8 位的 tophash 值，看是否和 key 的 top 值匹配.</p></li><li><p>倘若不匹配且当前位置 tophash 值为 0，说明桶的后续位置都未放入过元素，当前 key 在 map 中不存在，可以直接打破循环，返回零值.</p></li><li><p>倘若找到了相等的 key，则通过地址偏移的方式取到 value 并返回.</p></li></ul><p>其中 dataOffset 为一个桶中 tophash 数组所占用的空间大小.</p><a href=#写流程><h2 id=写流程><span class=hanchor arialabel=Anchor># </span>写流程</h2></a><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226215900.png width=auto alt=image.png></p><p>map 写流程主要分为以下几步：</p><p>（1）根据 key 取 hash 值；</p><p>（2）根据 hash 值对桶数组取模，确定所在的桶；</p><p>（3）倘若 map 处于扩容，则迁移命中的桶，帮助推进渐进式扩容；</p><p>（4）沿着桶链表依次遍历各个桶内的 key-value 对；</p><p>（5）倘若命中相同的 key，则对 value 中进行更新；</p><p>（6）倘若 key 不存在，则插入 key-value 对；</p><p>（7）倘若发现 map 达成扩容条件，则会开启扩容模式，并重新返回第（2）步.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
</span></span><span class=line><span class=cl>    if h == nil {
</span></span><span class=line><span class=cl>        panic(plainError(&#34;assignment to entry in nil map&#34;))
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    if h.flags&amp;hashWriting != 0 {
</span></span><span class=line><span class=cl>        fatal(&#34;concurrent map writes&#34;)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    hash := t.hasher(key, uintptr(h.hash0))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    h.flags ^= hashWriting
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if h.buckets == nil {
</span></span><span class=line><span class=cl>        h.buckets = newobject(t.bucket) 
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>again:
</span></span><span class=line><span class=cl>    bucket := hash &amp; bucketMask(h.B)
</span></span><span class=line><span class=cl>    if h.growing() {
</span></span><span class=line><span class=cl>        growWork(t, h, bucket)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    b := (*bmap)(add(h.buckets, bucket*uintptr(t.bucketsize)))
</span></span><span class=line><span class=cl>    top := tophash(hash)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    var inserti *uint8
</span></span><span class=line><span class=cl>    var insertk unsafe.Pointer
</span></span><span class=line><span class=cl>    var elem unsafe.Pointer
</span></span><span class=line><span class=cl>bucketloop:
</span></span><span class=line><span class=cl>    for {
</span></span><span class=line><span class=cl>        for i := uintptr(0); i &lt; bucketCnt; i++ {
</span></span><span class=line><span class=cl>            if b.tophash[i] != top {
</span></span><span class=line><span class=cl>                if isEmpty(b.tophash[i]) &amp;&amp; inserti == nil {
</span></span><span class=line><span class=cl>                    inserti = &amp;b.tophash[i]
</span></span><span class=line><span class=cl>                    insertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
</span></span><span class=line><span class=cl>                    elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                if b.tophash[i] == emptyRest {
</span></span><span class=line><span class=cl>                    break bucketloop
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                continue
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
</span></span><span class=line><span class=cl>            if t.indirectkey() {
</span></span><span class=line><span class=cl>                k = *((*unsafe.Pointer)(k))
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            if !t.key.equal(key, k) {
</span></span><span class=line><span class=cl>                continue
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            if t.needkeyupdate() {
</span></span><span class=line><span class=cl>                typedmemmove(t.key, k, key)
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
</span></span><span class=line><span class=cl>            goto done
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        ovf := b.overflow(t)
</span></span><span class=line><span class=cl>        if ovf == nil {
</span></span><span class=line><span class=cl>            break
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        b = ovf
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if !h.growing() &amp;&amp; (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
</span></span><span class=line><span class=cl>        hashGrow(t, h)
</span></span><span class=line><span class=cl>        goto again 
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if inserti == nil {
</span></span><span class=line><span class=cl>        newb := h.newoverflow(t, b)
</span></span><span class=line><span class=cl>        inserti = &amp;newb.tophash[0]
</span></span><span class=line><span class=cl>        insertk = add(unsafe.Pointer(newb), dataOffset)
</span></span><span class=line><span class=cl>        elem = add(insertk, bucketCnt*uintptr(t.keysize))
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if t.indirectkey() {
</span></span><span class=line><span class=cl>        kmem := newobject(t.key)
</span></span><span class=line><span class=cl>        *(*unsafe.Pointer)(insertk) = kmem
</span></span><span class=line><span class=cl>        insertk = kmem
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    if t.indirectelem() {
</span></span><span class=line><span class=cl>        vmem := newobject(t.elem)
</span></span><span class=line><span class=cl>        *(*unsafe.Pointer)(elem) = vmem
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    typedmemmove(t.key, insertk, key)
</span></span><span class=line><span class=cl>    *inserti = top
</span></span><span class=line><span class=cl>    h.count++
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>done:
</span></span><span class=line><span class=cl>    if h.flags&amp;hashWriting == 0 {
</span></span><span class=line><span class=cl>        fatal(&#34;concurrent map writes&#34;)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    h.flags &amp;^= hashWriting
</span></span><span class=line><span class=cl>    if t.indirectelem() {
</span></span><span class=line><span class=cl>        elem = *((*unsafe.Pointer)(elem))
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    return 
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>（1）写操作时，倘若 map 未初始化，直接 panic；</p><p>（2）倘若其他 goroutine 在进行写或删操作，抛出并发写 fatal error；</p><p>（3）通过 maptype.hasher() 方法求得 key 对应的 hash 值；</p><p>（4）通过异或位运算，将 map.flags 的第 3 个 bit 位置为 1，添加写标记；</p><p>（5）倘若 map 的桶数组 buckets 未空，则对其进行初始化；</p><p>（6）找到当前 key 对应的桶索引 bucket；</p><p>（7）倘若发现当前 map 正处于扩容过程，则帮助其渐进扩容，具体内容在第 9 节中再作展开；</p><p>（8）从 map 的桶数组 buckets 出发，结合桶索引和桶容量大小，进行地址偏移，获得对应桶 b；</p><p>（9）取得 key 的高 8 位 tophash：</p><p>（10）提前声明好的三个指针，用于指向存放 key-value 的空槽:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>inserti：tophash 拟插入位置；
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>insertk：key 拟插入位置 ；
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>elem：val 拟插入位置；
</span></span></code></pre></td></tr></table></div></div><p>（11）开启两层 for 循环，外层沿着桶链表依次遍历，内层依次遍历桶内的 key-value 对：</p><p>(12）倘若 key 的 tophash 和当前位置 tophash 不同，则会尝试将 inserti、insertk elem 调整指向首个空位，用于后续的插入操作.</p><ul><li><p>倘若发现当前位置 tophash 标识为 emtpyRest（0），则说明当前桶链表后续位置都未空，无需继续遍历，直接 break 遍历流程即可.</p></li><li><p>倘若桶中某个位置的 tophash 标识为 emptyOne（1），说明当前位置未放入元素，倘若为 emptyRest（0），说明包括当前位置在内，此后的位置都为空.</p></li></ul><p>（13）倘若找到了相等的 key，则执行更新操作，并且直接跳转到方法的 done 标志位处，进行收尾处理</p><p>（14）倘若没找到相等的 key，会在执行插入操作前，判断 map 是否需要开启扩容模式. 这部分内容在第 9 节中作展开.</p><p>倘若需要扩容，会在开启扩容模式后，跳转回 again 标志位，重新开始桶的定位以及遍历流程.</p><p>（15）倘若遍历完桶链表，都没有为当前待插入的 key-value 对找到空位，则会创建一个新的溢出桶，挂载在桶链表的尾部，并将 inserti、insertk、elem 指向溢出桶的首个空位：</p><p>创建溢出桶时：</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226220556.png width=auto alt=image.png></p><ul><li><p>I 倘若 hmap.extra 中还有剩余可用的溢出桶，则直接获取 hmap.extra.nextOverflow，并将 nextOverflow 调整指向下一个空闲可用的溢出桶；</p></li><li><p>II 倘若 hmap 已经没有空闲溢出桶了，则创建一个新的溢出桶.</p></li><li><p>III hmap 的溢出桶数量 hmap.noverflow 累加 1；</p></li><li><p>IV 将新获得的溢出桶添加到原桶链表的尾部；</p></li><li><p>V 返回溢出桶.</p></li></ul><p>（16）将 tophash、key、value 插入到取得空位中，并且将 map 的 key-value 对计数器 count 值加 1；</p><p>（17）收尾环节，再次校验是否有其他协程并发写，倘若有，则抛 fatal error. 将 hmap.flags 中的写标记抹去，然后退出方法.</p><a href=#删除流程><h2 id=删除流程><span class=hanchor arialabel=Anchor># </span>删除流程</h2></a><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226220742.png width=auto alt=image.png></p><p>map 删楚 kv 对流程主要分为以下几步：</p><p>（1）根据 key 取 hash 值；</p><p>（2）根据 hash 值对桶数组取模，确定所在的桶；</p><p>（3）倘若 map 处于扩容，则迁移命中的桶，帮助推进渐进式扩容；</p><p>（4）沿着桶链表依次遍历各个桶内的 key-value 对；</p><p>（5）倘若命中相同的 key，删除对应的 key-value 对；并将当前位置的 tophash 置为 emptyOne，表示为空；</p><p>（6）倘若当前位置为末位，或者下一个位置的 tophash 为 emptyRest，则沿当前位置向前遍历，将毗邻的 emptyOne 统一更新为 emptyRest.</p><p>map 删操作最终会走进 runtime/map.go 的 mapdelete 方法中，下面开始阅读源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span><span class=lnt>87
</span><span class=lnt>88
</span><span class=lnt>89
</span><span class=lnt>90
</span><span class=lnt>91
</span><span class=lnt>92
</span><span class=lnt>93
</span><span class=lnt>94
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func mapdelete(t *maptype, h *hmap, key unsafe.Pointer) {
</span></span><span class=line><span class=cl>    if h <mark> nil || h.count </mark> 0 {
</span></span><span class=line><span class=cl>        return
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    if h.flags&amp;hashWriting != 0 {
</span></span><span class=line><span class=cl>        fatal(&#34;concurrent map writes&#34;)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    hash := t.hasher(key, uintptr(h.hash0))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    h.flags ^= hashWriting
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    bucket := hash &amp; bucketMask(h.B)
</span></span><span class=line><span class=cl>    if h.growing() {
</span></span><span class=line><span class=cl>        growWork(t, h, bucket)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    b := (*bmap)(add(h.buckets, bucket*uintptr(t.bucketsize)))
</span></span><span class=line><span class=cl>    bOrig := b
</span></span><span class=line><span class=cl>    top := tophash(hash)
</span></span><span class=line><span class=cl>search:
</span></span><span class=line><span class=cl>    for ; b != nil; b = b.overflow(t) {
</span></span><span class=line><span class=cl>        for i := uintptr(0); i &lt; bucketCnt; i++ {
</span></span><span class=line><span class=cl>            if b.tophash[i] != top {
</span></span><span class=line><span class=cl>                if b.tophash[i] == emptyRest {
</span></span><span class=line><span class=cl>                    break search
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                continue
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
</span></span><span class=line><span class=cl>            k2 := k
</span></span><span class=line><span class=cl>            if t.indirectkey() {
</span></span><span class=line><span class=cl>                k2 = *((*unsafe.Pointer)(k2))
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            if !t.key.equal(key, k2) {
</span></span><span class=line><span class=cl>                continue
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            // Only clear key if there are pointers in it.
</span></span><span class=line><span class=cl>            if t.indirectkey() {
</span></span><span class=line><span class=cl>                *(*unsafe.Pointer)(k) = nil
</span></span><span class=line><span class=cl>            } else if t.key.ptrdata != 0 {
</span></span><span class=line><span class=cl>                memclrHasPointers(k, t.key.size)
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
</span></span><span class=line><span class=cl>            if t.indirectelem() {
</span></span><span class=line><span class=cl>                *(*unsafe.Pointer)(e) = nil
</span></span><span class=line><span class=cl>            } else if t.elem.ptrdata != 0 {
</span></span><span class=line><span class=cl>                memclrHasPointers(e, t.elem.size)
</span></span><span class=line><span class=cl>            } else {
</span></span><span class=line><span class=cl>                memclrNoHeapPointers(e, t.elem.size)
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            b.tophash[i] = emptyOne
</span></span><span class=line><span class=cl>            if i == bucketCnt-1 {
</span></span><span class=line><span class=cl>                if b.overflow(t) != nil &amp;&amp; b.overflow(t).tophash[0] != emptyRest {
</span></span><span class=line><span class=cl>                    goto notLast
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>            } else {
</span></span><span class=line><span class=cl>                if b.tophash[i+1] != emptyRest {
</span></span><span class=line><span class=cl>                    goto notLast
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            for {
</span></span><span class=line><span class=cl>                b.tophash[i] = emptyRest
</span></span><span class=line><span class=cl>                if i == 0 {
</span></span><span class=line><span class=cl>                    if b == bOrig {
</span></span><span class=line><span class=cl>                        break
</span></span><span class=line><span class=cl>                    }
</span></span><span class=line><span class=cl>                    c := b
</span></span><span class=line><span class=cl>                    for b = bOrig; b.overflow(t) != c; b = b.overflow(t) {
</span></span><span class=line><span class=cl>                    }
</span></span><span class=line><span class=cl>                    i = bucketCnt - 1
</span></span><span class=line><span class=cl>                } else {
</span></span><span class=line><span class=cl>                    i--
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                if b.tophash[i] != emptyOne {
</span></span><span class=line><span class=cl>                    break
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        notLast:
</span></span><span class=line><span class=cl>            h.count--
</span></span><span class=line><span class=cl>            if h.count == 0 {
</span></span><span class=line><span class=cl>                h.hash0 = fastrand()
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            break search
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if h.flags&amp;hashWriting == 0 {
</span></span><span class=line><span class=cl>        fatal(&#34;concurrent map writes&#34;)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    h.flags &amp;^= hashWritin
</span></span></code></pre></td></tr></table></div></div><p>（1）倘若 map 未初始化或者内部 key-value 对数量为 0，删除时不会报错，直接返回；</p><p>（2）倘若存在其他 goroutine 在进行写或删操作，抛出并发写的 fatal error；</p><p>（3）通过 maptype.hasher() 方法求得 key 对应的 hash 值；</p><p>（4）通过异或位运算，将 map.flags 的第 3 个 bit 位置为 1，添加写标记；</p><p>（5）找到当前 key 对应的桶索引 bucket；</p><p>（6）倘若发现当前 map 正处于扩容过程，则帮助其渐进扩容</p><p>（7）从 map 的桶数组 buckets 出发，结合桶索引和桶容量大小，进行地址偏移，获得对应桶 b，并赋值给 bOrg</p><p>（8）取得 key 的高 8 位 tophash：</p><p>（9）开启两层 for 循环，外层沿着桶链表依次遍历，内层依次遍历桶内的 key-value 对</p><p>（10）遍历时，倘若发现当前位置 tophash 值为 emptyRest，则直接结束遍历流程：</p><p>（11）倘若 key 不相等，则继续遍历：</p><p>（12）倘若 key 相等，则删除对应的 key-value 对，并且将当前位置的 tophash 置为 emptyOne：</p><p>（13）倘若当前位置不位于最后一个桶的最后一个位置，或者当前位置的后置位 tophash 不为 emptyRest，则无需向前遍历更新 tophash 标识，直接跳转到 notLast 位置即可；</p><p>（14）向前遍历，将沿途的空位（ tophash 为 emptyOne ）的 tophash 都更新为 emptySet.</p><p>（15）倘若成功从 map 中删除了一组 key-value 对，则将 hmap 的计数器 count 值减 1. 倘若 map 中的元素全都被删除完了，会为 map 更换一个新的随机因子 hash0.</p><p>（16）收尾环节，再次校验是否有其他协程并发写，倘若有，则抛 fatal error. 将 hmap.flags 中的写标记抹去，然后退出方法.</p><a href=#遍历流程><h2 id=遍历流程><span class=hanchor arialabel=Anchor># </span>遍历流程</h2></a><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226221021.png width=auto alt=image.png></p><p>Map 的遍历流程首先会走进 runtime/map.go 的 mapiterinit() 方法当中，初始化用于遍历的迭代器 hiter；接着会调用 runtime/map.go 的 mapiternext() 方法开启遍历流程.</p><p><strong>迭代器数据结构</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type hiter struct {
</span></span><span class=line><span class=cl>    key         unsafe.Pointer 
</span></span><span class=line><span class=cl>    elem        unsafe.Pointer 
</span></span><span class=line><span class=cl>    t           *maptype
</span></span><span class=line><span class=cl>    h           *hmap
</span></span><span class=line><span class=cl>    buckets     unsafe.Pointer 
</span></span><span class=line><span class=cl>    bptr        *bmap         
</span></span><span class=line><span class=cl>    overflow    *[]*bmap      
</span></span><span class=line><span class=cl>    oldoverflow *[]*bmap      
</span></span><span class=line><span class=cl>    startBucket uintptr       
</span></span><span class=line><span class=cl>    offset      uint8         
</span></span><span class=line><span class=cl>    wrapped     bool         
</span></span><span class=line><span class=cl>    B           uint8
</span></span><span class=line><span class=cl>    i           uint8
</span></span><span class=line><span class=cl>    bucket      uintptr
</span></span><span class=line><span class=cl>    checkBucket uintptr
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>hiter 是遍历 map 时用于存放临时数据的迭代器：</p><p>（1）key：指向遍历得到 key 的指针；</p><p>（2）value：指向遍历得到 value 的指针；</p><p>（3）t：map 类型，包含了 key、value 类型大小等信息；</p><p>（4）h：map 的指针；</p><p>（5）buckets：map 的桶数组；</p><p>（6）bptr：当前遍历到的桶；</p><p>（7）overflow：新老桶数组对应的溢出桶；</p><p>（8）startBucket：遍历起始位置的桶索引；</p><p>（9）offset：遍历起始位置的 key-value 对索引；</p><p>（10）wrapped：遍历是否穿越桶数组尾端回到头部了；</p><p>（11）B：桶数组的长度指数；</p><p>（12）i：当前遍历到的 key-value 对在桶中的索引；</p><p>（13）bucket：当前遍历到的桶；</p><p>（14）checkBucket：因为扩容流程的存在，需要额外检查的桶.</p><p>map 遍历流程开始时，首先会走进 runtime/map.go 的 mapiterinit() 方法当中，此时会对创建 map 迭代器 hiter，并且通过取随机数的方式，决定遍历的起始桶号，以及起始 key-value 对索引号.</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226221137.png width=auto alt=image.png></p><p>1）遍历时发现其他 goroutine 在并发写，直接抛出 fatal error：</p><p>（2）开启最外圈的循环，依次遍历桶数组中的每个桶链表，通过 next 和 goto next 关键字实现循环代码块；</p><p>（3）倘若已经遍历完所有的桶，重新回到起始桶为止，则直接结束方法；</p><p>（4）倘若 map 处于扩容流程，取桶时兼容新老桶数组的逻辑. 倘若桶处于旧桶数组且未完成迁移，需要将 checkBucket 置为当前的桶号；</p><p>5）遍历的桶号加 1，倘若来到桶数组末尾，则将桶号置为 0. 将 key-value 对的遍历索引 i 置为 0.</p><p>（6）依次遍历各个桶中每个 key-value 对：</p><p>（7）倘若遍历到的桶属于旧桶数组未迁移完成的桶，需要按照其在新桶中的顺序完成遍历. 比如，增量扩容流程中，旧桶中的 key-value 对最终应该被分散迁移到新桶数组的 x、y 两个区域，则此时遍历时，哪怕 key-value 对仍存留在旧桶中未完成迁移，遍历时也应该严格按照其在新桶数组中的顺序来执行.</p><p>（8）执行 mapaccessK 方法，基于读流程方法获取 key-value 对，通过迭代 hiter 的 key、value 指针进行接收，用于对用户的遍历操作进行响应：</p><a href=#扩容流程><h2 id=扩容流程><span class=hanchor arialabel=Anchor># </span>扩容流程</h2></a><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226221610.png width=auto alt=image.png></p><a href=#扩容类型><h3 id=扩容类型><span class=hanchor arialabel=Anchor># </span>扩容类型</h3></a><p>（1）增量扩容</p><p>表现：扩容后，桶数组的长度增长为原长度的 2 倍；</p><p>目的：降低每个桶中 key-value 对的数量，优化 map 操作的时间复杂度.</p><p>（2）等量扩容</p><p>表现：扩容后，桶数组的长度和之前保持一致；但是溢出桶的数量会下降.</p><p>目的：提高桶主体结构的数据填充率，减少溢出桶数量，避免发生内存泄漏</p><a href=#何时扩容><h3 id=何时扩容><span class=hanchor arialabel=Anchor># </span>何时扩容</h3></a><p>（1）只有 map 的写流程可能开启扩容模式；</p><p>（2）写 map 新插入 key-value 对之前，会发起是否需要扩容的逻辑判断：</p><p>（3）根据 hmap 的 oldbuckets 是否空，可以判断 map 此前是否已开启扩容模式：</p><p>（4）倘若此前未进入扩容模式，且 map 中 key-value 对的数量超过 8 个，且大于桶数组长度的 6.5 倍，则进入增量扩容：</p><p>（5）倘若溢出桶的数量大于 2^B 个（即桶数组的长度；B 大于 15 时取15），则进入等量扩容：</p><a href=#如何开启扩容模式><h3 id=如何开启扩容模式><span class=hanchor arialabel=Anchor># </span>如何开启扩容模式</h3></a><p>开启扩容模式的方法位于 runtime/map.go 的 hashGrow 方法中：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func hashGrow(t *maptype, h *hmap) {
</span></span><span class=line><span class=cl>    bigger := uint8(1)
</span></span><span class=line><span class=cl>    if !overLoadFactor(h.count+1, h.B) {
</span></span><span class=line><span class=cl>        bigger = 0
</span></span><span class=line><span class=cl>        h.flags |= sameSizeGrow
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    oldbuckets := h.buckets
</span></span><span class=line><span class=cl>    newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    flags := h.flags &amp;^ (iterator | oldIterator)
</span></span><span class=line><span class=cl>    if h.flags&amp;iterator != 0 {
</span></span><span class=line><span class=cl>        flags |= oldIterator
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    // commit the grow (atomic wrt gc)
</span></span><span class=line><span class=cl>    h.B += bigger
</span></span><span class=line><span class=cl>    h.flags = flags
</span></span><span class=line><span class=cl>    h.oldbuckets = oldbuckets
</span></span><span class=line><span class=cl>    h.buckets = newbuckets
</span></span><span class=line><span class=cl>    h.nevacuate = 0
</span></span><span class=line><span class=cl>    h.noverflow = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if h.extra != nil &amp;&amp; h.extra.overflow != nil {
</span></span><span class=line><span class=cl>        // Promote current overflow buckets to the old generation.
</span></span><span class=line><span class=cl>        if h.extra.oldoverflow != nil {
</span></span><span class=line><span class=cl>            throw(&#34;oldoverflow is not nil&#34;)
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        h.extra.oldoverflow = h.extra.overflow
</span></span><span class=line><span class=cl>        h.extra.overflow = nil
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    if nextOverflow != nil {
</span></span><span class=line><span class=cl>        if h.extra == nil {
</span></span><span class=line><span class=cl>            h.extra = new(mapextra)
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        h.extra.nextOverflow = nextOverflow
</span></span><span class=line><span class=cl>    }
</span></span></code></pre></td></tr></table></div></div><p>（1）倘若是增量扩容，bigger 值取 1；倘若是等量扩容，bigger 值取 0，并将 hmap.flags 的第 4 个 bit 位置为 1，标识当前处于等量扩容流程
（2）将原桶数组赋值给 oldBuckets，并创建新的桶数组和一批新的溢出桶.</p><p>此处会通过变量 bigger，实现不同扩容模式下，新桶数组长度的区别处理.
（3）更新 hmap 的桶数组长度指数 B，flag 标识，并将新、老桶数组赋值给 hmap.oldBuckets 和 hmap.buckets；扩容迁移进度 hmap.nevacuate 标记为 0；新桶数组的溢出桶数量 hmap.noverflow 置为 0.</p><p>（4）将原本存量可用的溢出桶赋给 hmap.extra.oldoverflow；倘若存在下一个可用的溢出桶，赋给 hmap.extra.nextOverflow.</p><a href=#扩容迁移规则><h3 id=扩容迁移规则><span class=hanchor arialabel=Anchor># </span>扩容迁移规则</h3></a><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226222118.png width=auto alt=image.png></p><p>（1）在等量扩容中，<strong>新桶数组长度与原桶数组相同</strong>；</p><p>（2）key-value 对在新桶数组和老桶数组的中的索引号保持一致；</p><p>（3）在增量扩容中，<strong>新桶数组长度为原桶数组的两倍</strong>；</p><p>（4）把新桶数组中桶号对应于老桶数组的区域称为 x 区域，新扩展的区域称为 y 区域.</p><p>（5）实际上，一个 key 属于哪个桶，取决于其 hash 值对桶数组长度取模得到的结果，因此依赖于其低位的 hash 值结果.；</p><p>（6）在增量扩容流程中，新桶数组的长度会扩展一位，假定 key 原本从属的桶号为 i，则在新桶数组中从属的桶号只可能是 i （x 区域）或者 i + 老桶数组长度（y 区域）；</p><p>（7）当 key 低位 hash 值向左扩展一位的 bit 位为 0，则应该迁往 x 区域的 i 位置；倘若该 bit 位为 1，应该迁往 y 区域对应的 i + 老桶数组长度的位置.</p><a href=#渐进式扩容><h3 id=渐进式扩容><span class=hanchor arialabel=Anchor># </span>渐进式扩容</h3></a><p>map 采用的是<strong>渐进扩容</strong>的方式，避免因为一次性的全量数据迁移引发性能抖动.</p><p>当每次触发写、删操作时，会为处于扩容流程中的 map 完成两组桶的数据迁移：</p><p><strong>（1）一组桶是当前写、删操作所命中的桶；</strong></p><p><strong>（2）另一组桶是，当前未迁移的桶中，索引最小的那个桶.</strong></p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226222153.png width=auto alt=image.png></p><p>数据迁移的逻辑位于 runtime/map.go 的 evacuate 方法当中：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func evacuate(t *maptype, h *hmap, oldbucket uintptr) {
</span></span><span class=line><span class=cl>    // 入参中，oldbucket 为当前要迁移的桶在旧桶数组中的索引
</span></span><span class=line><span class=cl>    // 获取到待迁移桶的内存地址 b
</span></span><span class=line><span class=cl>    b := (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))
</span></span><span class=line><span class=cl>    // 获取到旧桶数组的容量 newbit
</span></span><span class=line><span class=cl>    newbit := h.noldbuckets()
</span></span><span class=line><span class=cl>    // evacuated 方法判断出桶 b 是否已经迁移过了，未迁移过，才进入此 if 分支进行迁移处理
</span></span><span class=line><span class=cl>    if !evacuated(b) {
</span></span><span class=line><span class=cl>        // 通过一个二元数组 xy 指向当前桶可能迁移到的目的桶
</span></span><span class=line><span class=cl>        // x = xy[0]，代表新桶数组中索引和旧桶数组一致的桶
</span></span><span class=line><span class=cl>        // y = xy[1]，代表新桶数组中，索引为原索引加上旧桶容量的桶，只在增量扩容中会使用到
</span></span><span class=line><span class=cl>        var xy [2]evacDst
</span></span><span class=line><span class=cl>        x := &amp;xy[0]
</span></span><span class=line><span class=cl>        x.b = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize)))
</span></span><span class=line><span class=cl>        x.k = add(unsafe.Pointer(x.b), dataOffset)
</span></span><span class=line><span class=cl>        x.e = add(x.k, bucketCnt*uintptr(t.keysize))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        // 只有进入增量扩容的分支，才需要对 y 进行初始化
</span></span><span class=line><span class=cl>        if !h.sameSizeGrow() {
</span></span><span class=line><span class=cl>            // Only calculate y pointers if we&#39;re growing bigger.
</span></span><span class=line><span class=cl>            // Otherwise GC can see bad pointers.
</span></span><span class=line><span class=cl>            y := &amp;xy[1]
</span></span><span class=line><span class=cl>            y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize)))
</span></span><span class=line><span class=cl>            y.k = add(unsafe.Pointer(y.b), dataOffset)
</span></span><span class=line><span class=cl>            y.e = add(y.k, bucketCnt*uintptr(t.keysize))
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        // 外层 for 循环，遍历桶 b 和对应的溢出桶
</span></span><span class=line><span class=cl>        for ; b != nil; b = b.overflow(t) {
</span></span><span class=line><span class=cl>            // k,e 分别记录遍历桶时，当前的 key 和 value 的指针
</span></span><span class=line><span class=cl>            k := add(unsafe.Pointer(b), dataOffset)
</span></span><span class=line><span class=cl>            e := add(k, bucketCnt*uintptr(t.keysize))
</span></span><span class=line><span class=cl>            // 遍历桶内的 key-value 对
</span></span><span class=line><span class=cl>            for i := 0; i &lt; bucketCnt; i, k, e = i+1, add(k, uintptr(t.keysize)), add(e, uintptr(t.elemsize)) {
</span></span><span class=line><span class=cl>                top := b.tophash[i]
</span></span><span class=line><span class=cl>                if isEmpty(top) {
</span></span><span class=line><span class=cl>                    b.tophash[i] = evacuatedEmpty
</span></span><span class=line><span class=cl>                    continue
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                if top &lt; minTopHash {
</span></span><span class=line><span class=cl>                    throw(&#34;bad map state&#34;)
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                k2 := k
</span></span><span class=line><span class=cl>                if t.indirectkey() {
</span></span><span class=line><span class=cl>                    k2 = *((*unsafe.Pointer)(k2))
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                var useY uint8
</span></span><span class=line><span class=cl>                if !h.sameSizeGrow() {
</span></span><span class=line><span class=cl>                    // Compute hash to make our evacuation decision (whether we need
</span></span><span class=line><span class=cl>                    // to send this key/elem to bucket x or bucket y).
</span></span><span class=line><span class=cl>                    hash := t.hasher(k2, uintptr(h.hash0))
</span></span><span class=line><span class=cl>                    if hash&amp;newbit != 0 {
</span></span><span class=line><span class=cl>                       useY = 1
</span></span><span class=line><span class=cl>                    }
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                b.tophash[i] = evacuatedX + useY // evacuatedX + 1 == evacuatedY
</span></span><span class=line><span class=cl>                dst := &amp;xy[useY]                 // evacuation destination
</span></span><span class=line><span class=cl>                if dst.i == bucketCnt {
</span></span><span class=line><span class=cl>                    dst.b = h.newoverflow(t, dst.b)
</span></span><span class=line><span class=cl>                    dst.i = 0
</span></span><span class=line><span class=cl>                    dst.k = add(unsafe.Pointer(dst.b), dataOffset)
</span></span><span class=line><span class=cl>                    dst.e = add(dst.k, bucketCnt*uintptr(t.keysize))
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                dst.b.tophash[dst.i&amp;(bucketCnt-1)] = top // mask dst.i as an optimization, to avoid a bounds check
</span></span><span class=line><span class=cl>                if t.indirectkey() {
</span></span><span class=line><span class=cl>                    *(*unsafe.Pointer)(dst.k) = k2 // copy pointer
</span></span><span class=line><span class=cl>                } else {
</span></span><span class=line><span class=cl>                    typedmemmove(t.key, dst.k, k) // copy elem
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                if t.indirectelem() {
</span></span><span class=line><span class=cl>                    *(*unsafe.Pointer)(dst.e) = *(*unsafe.Pointer)(e)
</span></span><span class=line><span class=cl>                } else {
</span></span><span class=line><span class=cl>                    typedmemmove(t.elem, dst.e, e)
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                dst.i++
</span></span><span class=line><span class=cl>                dst.k = add(dst.k, uintptr(t.keysize))
</span></span><span class=line><span class=cl>                dst.e = add(dst.e, uintptr(t.elemsize))
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        // Unlink the overflow buckets &amp; clear key/elem to help GC.
</span></span><span class=line><span class=cl>        if h.flags&amp;oldIterator == 0 &amp;&amp; t.bucket.ptrdata != 0 {
</span></span><span class=line><span class=cl>            b := add(h.oldbuckets, oldbucket*uintptr(t.bucketsize))
</span></span><span class=line><span class=cl>            // Preserve b.tophash because the evacuation
</span></span><span class=line><span class=cl>            // state is maintained there.
</span></span><span class=line><span class=cl>            ptr := add(b, dataOffset)
</span></span><span class=line><span class=cl>            n := uintptr(t.bucketsize) - dataOffset
</span></span><span class=line><span class=cl>            memclrHasPointers(ptr, n)
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if oldbucket == h.nevacuate {
</span></span><span class=line><span class=cl>        advanceEvacuationMark(h, t, newbit)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func (h *hmap) noldbuckets() uintptr {
</span></span><span class=line><span class=cl>    oldB := h.B
</span></span><span class=line><span class=cl>    if !h.sameSizeGrow() {
</span></span><span class=line><span class=cl>        oldB--
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    return bucketShift(oldB)
</span></span></code></pre></td></tr></table></div></div><p>（1）从老桶数组中获取到待迁移的桶 b；</p><p>（2）获取到老桶数组的长度 newbit；</p><p>（3）倘若当前桶已经完成了迁移，则无需处理；</p><p>（4）创建一个二元数组 xy，分别承载 x 区域和 y 区域（含义定义见 9.4 小节）中的新桶位置，用于接受来自老桶数组的迁移数组；只有在增量扩容的流程中，才存在 y 区域，因此才需要对 xy 中的 y 进行定义；</p><p>（5）开启两层 for 循环，外层遍历桶链表，内层遍历每个桶中的 key-value 对：</p><p>（6）取每个位置的 tophash 值进行判断，倘若当前是个空位，则将当前位置 tophash 值置为 evacuatedEmpty，开始遍历下一个位置：</p><p>（7）基于 9.4 的规则，寻找到迁移的目的桶；</p><p>其中目的桶的类型定义如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type evacDst struct {
</span></span><span class=line><span class=cl>    b *bmap          // current destination bucket
</span></span><span class=line><span class=cl>    i int            // key/elem index into b
</span></span><span class=line><span class=cl>    k unsafe.Pointer // pointer to current key storage
</span></span><span class=line><span class=cl>    e unsafe.Pointer // pointer to current elem storage
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>I evacDst.b：目的地的所在桶；</p><p>II evacDst.i：即将入桶的 key-value 对在桶中的索引；</p><p>III evacDst.k：入桶 key 的存储指针；</p><p>IV evacDst.e：入桶 value 的存储指针.</p><p>（8）将 key-value 对迁移到目的桶中，并且更新目的桶结构内几个指针的指向：</p><p>（9）倘若当前迁移的桶是旧桶数组未迁移的桶中索引最小的一个，则 hmap.nevacuate 累加 1.</p><p>倘若已经迁移完所有的旧桶，则会确保 hmap.flags 中，等量扩容的标识位被置为 0.</p><a href=#map-遍历为什么是无序的><h1 id=map-遍历为什么是无序的><span class=hanchor arialabel=Anchor># </span>map 遍历为什么是无序的？</h1></a><p>使用 range 多次遍历 map 时输出的 key 和 value 的顺序可能不同。这是 Go 语言的设计者们<strong>有意为之</strong>，旨在提示开发者们，Go 底层实现并不保证 map 遍历顺序稳定，请大家不要依赖 range 遍历结果顺序</p><p>主要原因有 2 点：</p><ul><li>Map 在遍历时，并不是从固定的 0 号 bucket 开始遍历的，每次遍历，都会从一个<strong>随机值序号的 bucket</strong>，再从其中<strong>随机的 cell</strong>开始遍历</li><li>Map 遍历时，是按序遍历 bucket，同时按需遍历 bucket 中和其 overflow bucket 中的 cell。但是 map 在扩容后，会发生 key 的搬迁，这造成原来落在一个 bucket 中的 key，搬迁后，有可能会落到其他 bucket 中了，从这个角度看，遍历 map 的结果就不可能是按照原来的顺序了</li></ul><p>Map 本身是无序的，且遍历时顺序还会被随机化，如果想顺序遍历 map，需要对 map key 先排序，再按照 key 的顺序遍历 map。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func TestMapRange(t *testing.T) {
</span></span><span class=line><span class=cl>    m := map[int]string{1: &#34;a&#34;, 2: &#34;b&#34;, 3: &#34;c&#34;}
</span></span><span class=line><span class=cl>    t.Log(&#34;first range:&#34;)
</span></span><span class=line><span class=cl>    for i, v := range m {
</span></span><span class=line><span class=cl>        t.Logf(&#34;m[%v]=%v &#34;, i, v)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    t.Log(&#34;\nsecond range:&#34;)
</span></span><span class=line><span class=cl>    for i, v := range m {
</span></span><span class=line><span class=cl>        t.Logf(&#34;m[%v]=%v &#34;, i, v)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // 实现有序遍历
</span></span><span class=line><span class=cl>    var sl []int
</span></span><span class=line><span class=cl>    // 把 key 单独取出放到切片
</span></span><span class=line><span class=cl>    for k := range m {
</span></span><span class=line><span class=cl>        sl = append(sl, k)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    // 排序切片
</span></span><span class=line><span class=cl>    sort.Ints(sl)
</span></span><span class=line><span class=cl>    // 以切片中的 key 顺序遍历 map 就是有序的了
</span></span><span class=line><span class=cl>    for _, k := range sl {
</span></span><span class=line><span class=cl>        t.Log(k, m[k])
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#map-为什么是非线程安全的><h1 id=map-为什么是非线程安全的><span class=hanchor arialabel=Anchor># </span>map 为什么是非线程安全的？</h1></a><p>Map 默认是并发不安全的，同时对 map 进行并发读写时，程序会 panic，原因如下：</p><p>Go 官方在经过了长时间的讨论后，认为 Go map 更应适配典型使用场景（不需要从多个 goroutine 中进行安全访问），而不是为了小部分情况（并发访问），导致大部分程序付出加锁代价（性能），决定了不支持。</p><p>场景: 2 个协程同时读和写，以下程序会出现致命错误：fatal error: concurrent map writes</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>s</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>100</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>        <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>100</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;map第%d个元素值是%d\n&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>如果想实现 map 线程安全，有两种方式：</p><p>方式一：使用读写锁 <code>map</code> + <code>sync.RWMutex</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;sync&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>lock</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
</span></span><span class=line><span class=cl>    <span class=nx>s</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>100</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>            <span class=nx>lock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>100</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>lock</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;map第%d个元素值是%d\n&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=nx>lock</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>方式二：使用 Go 提供的 <code>sync.Map</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;sync&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>m</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Map</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>100</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>m</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>100</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>v</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nf>Load</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Load: %v, %v\n&#34;</span><span class=p>,</span> <span class=nx>v</span><span class=p>,</span> <span class=nx>ok</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#map-怎么知道自己处于竞争状态是-go-编码实现的还是底层硬件实现的><h1 id=map-怎么知道自己处于竞争状态是-go-编码实现的还是底层硬件实现的><span class=hanchor arialabel=Anchor># </span>Map 怎么知道自己处于竞争状态？是 Go 编码实现的还是底层硬件实现的？</h1></a><ul><li><p>代码实现的，在查找、赋值、遍历、删除的过程中**都会检测写标志 flags，一旦发现写标志置位 (等于 1)，抛出 fatal error，无法使用 recover 进行恢复。</p></li><li><p>赋值和删除函数载检测完标志是复位状态 (等于 0)之后，先将写标志位置位，才会进行之后的操作。</p></li></ul><a href=#map-的-panic-能被-recover-掉吗了解-panic-和-recover-的机制><h1 id=map-的-panic-能被-recover-掉吗了解-panic-和-recover-的机制><span class=hanchor arialabel=Anchor># </span>Map 的 panic 能被 recover 掉吗？了解 panic 和 recover 的机制？</h1></a><p><strong>抛出 fatal error，无法使用 recover 进行恢复</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func main() {
</span></span><span class=line><span class=cl>    defer errorHandler()
</span></span><span class=line><span class=cl>    m := map[string]int{}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    go func() {
</span></span><span class=line><span class=cl>        for {
</span></span><span class=line><span class=cl>            m[&#34;x&#34;] = 1
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }()
</span></span><span class=line><span class=cl>    for {
</span></span><span class=line><span class=cl>        _ = m[&#34;x&#34;]
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func errorHandler() {
</span></span><span class=line><span class=cl>    if r := recover(); r != nil {
</span></span><span class=line><span class=cl>        fmt.Println(r)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}//不能
</span></span></code></pre></td></tr></table></div></div><p>Map 由于不是线程安全的，所以在遇到并发读写的时候会抛出 concurrent map read and map write 异常，从而使程序直接退出。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer {
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    if h.flags&amp;hashWriting != 0 {
</span></span><span class=line><span class=cl>        throw(&#34;concurrent map read and map write&#34;)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>｝
</span></span></code></pre></td></tr></table></div></div><p>这里的 throw 和上面一样，最终会调用到 exit 执行退出。</p><a href=#go-中两个-map-对象如何比较><h1 id=go-中两个-map-对象如何比较><span class=hanchor arialabel=Anchor># </span>Go 中两个 map 对象如何比较</h1></a><p>使用 reflect. DeepEqual 这个函数进行比较。使用 reflect. DeepEqual 有一点注意：由于使用了反射，所以有性能的损失。如果你多做一些测试，那么你会发现 reflect. DeepEqual 会比 == 慢 100 倍以上。</p><a href=#map-的优缺点以及改进><h1 id=map-的优缺点以及改进><span class=hanchor arialabel=Anchor># </span>Map 的优缺点以及改进?</h1></a><p><strong>优点</strong>：</p><ol><li><p>Map 类似其他语言中的哈希表或字典，以 key-value 形式存储数据</p></li><li><p>Key 必须是支持==或!=比较运算的类型，不可以是函数、map 或 slice</p></li><li><p>Map 通过 key 查找 value 比线性搜索快很多。</p></li><li><p>Map 使用 make ()创建，支持:=这种简写方式</p></li><li><p>超出容量时会自动扩容，</p></li><li><p>当键值对不存在时自动添加，使用 delete ()删除某键值对</p></li></ol><p><strong>缺点：</strong></p><p>并发中的 map 不是安全的</p><a href=#sync-map-怎么使用><h1 id=sync-map-怎么使用><span class=hanchor arialabel=Anchor># </span>Sync. Map 怎么使用</h1></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;sync&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>scene</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Map</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 将键值对保存到sync.Map
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>scene</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=s>&#34;1&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>scene</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=s>&#34;2&#34;</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>scene</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=s>&#34;3&#34;</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 从sync.Map中根据键取值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>scene</span><span class=p>.</span><span class=nf>Load</span><span class=p>(</span><span class=s>&#34;1&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 根据键删除对应的键值对
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>scene</span><span class=p>.</span><span class=nf>Delete</span><span class=p>(</span><span class=s>&#34;1&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 遍历所有sync.Map中的键值对
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>scene</span><span class=p>.</span><span class=nf>Range</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;iterate:&#34;</span><span class=p>,</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#sync-map-底层实现原理><h1 id=sync-map-底层实现原理><span class=hanchor arialabel=Anchor># </span>Sync. Map 底层实现原理</h1></a><a href=#sync-map><h2 id=sync-map><span class=hanchor arialabel=Anchor># </span>Sync. Map</h2></a><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226223137.png width=auto alt=image.png></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type Map struct {
</span></span><span class=line><span class=cl>    mu Mutex
</span></span><span class=line><span class=cl>    read atomic.Value 
</span></span><span class=line><span class=cl>    dirty map[any]*entry
</span></span><span class=line><span class=cl>    misses int
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>sync.Map 主类中包含以下核心字段：</p><ul><li><p>read：无锁化的只读 map，实际类型为 readOnly，2.3 小节会进一步介绍；</p></li><li><p>dirty：加锁处理的读写 map；</p></li><li><p>misses：记录访问 read 的失效次数，累计达到阈值时，会进行 read map/dirty map 的更新轮换；</p></li><li><p>mu：一把互斥锁，实现 dirty 和 misses 的并发管理.</p></li></ul><p>可见，sync.Map 的特点是冗余了两份 map：read map 和 dirty map，后续的所介绍的交互流程也和这两个 map 息息相关，基本可以归结为两条主线</p><ul><li><p>主线一：首先基于无锁操作访问 read map；倘若 read map 不存在该 key，则加锁并使用 dirty map 兜底；</p></li><li><p>主线二：read map 和 dirty map 之间会交替轮换更新</p></li></ul><a href=#entry><h2 id=entry><span class=hanchor arialabel=Anchor># </span>Entry</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type entry struct {
</span></span><span class=line><span class=cl>    p unsafe.Pointer 
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>kv 对中的 value，统一采用 unsafe.Pointer 的形式进行存储，通过 entry.p 的指针进行链接.</p><p>entry.p 的指向分为三种情况：</p><ul><li><p>I 存活态：正常指向元素；</p></li><li><p>II 软删除态：指向 nil；</p></li><li><p>III 硬删除态：指向固定的全局变量 expunged.</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>var expunged = unsafe.Pointer(new(any))
</span></span></code></pre></td></tr></table></div></div><blockquote><ul><li><p>存活态很好理解，即 key-entry 对仍未删除；</p></li><li><p>nil 态表示软删除，read map 和 dirty map 底层的 map 结构仍存在 key-entry 对，但在逻辑上该 key-entry 对已经被删除，因此无法被用户查询到；<br>  * expunged 态表示硬删除，dirty map 中已不存在该 key-entry 对.</p></li></ul></blockquote><a href=#readonly><h2 id=readonly><span class=hanchor arialabel=Anchor># </span>readOnly</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type readOnly struct {
</span></span><span class=line><span class=cl>    m       map[any]*entry
</span></span><span class=line><span class=cl>    amended bool // true if the dirty map contains some key not in m.
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>sync.Map 中的只读 map：read 内部包含两个成员属性：</p><ul><li><p>m：真正意义上的 read map，实现从 key 到 entry 的映射；</p></li><li><p>amended：标识 read map 中的 key-entry 对是否存在缺失，需要通过 dirty map 兜底.</p></li></ul><a href=#读流程-1><h2 id=读流程-1><span class=hanchor arialabel=Anchor># </span>读流程</h2></a><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226223946.png width=auto alt=image.png></p><a href=#syncmapload><h3 id=syncmapload><span class=hanchor arialabel=Anchor># </span>sync.Map.Load()</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (m *Map) Load(key any) (value any, ok bool) {
</span></span><span class=line><span class=cl>    read, _ := m.read.Load().(readOnly)
</span></span><span class=line><span class=cl>    e, ok := read.m[key]
</span></span><span class=line><span class=cl>    if !ok &amp;&amp; read.amended {
</span></span><span class=line><span class=cl>        m.mu.Lock()
</span></span><span class=line><span class=cl>        read, _ = m.read.Load().(readOnly)
</span></span><span class=line><span class=cl>        e, ok = read.m[key]
</span></span><span class=line><span class=cl>        if !ok &amp;&amp; read.amended {
</span></span><span class=line><span class=cl>            e, ok = m.dirty[key]
</span></span><span class=line><span class=cl>            m.missLocked()
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        m.mu.Unlock()
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    if !ok {
</span></span><span class=line><span class=cl>        return nil, false
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    return e.load()
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><ul><li><p>查看 read map 中是否存在 key-entry 对，若存在，则直接读取 entry 返回；</p></li><li><p>倘若第一轮 read map 查询 miss，且 read map 不全，则需要加锁 double check；</p></li><li><p>第二轮 read map 查询仍 miss（加锁后），且 read map 不全，则查询 dirty map 兜底；</p></li><li><p> 查询操作涉及到与 dirty map 的交互，misses 加一；</p></li><li><p> 解锁，返回查得的结果.</p></li></ul><a href=#entryload><h3 id=entryload><span class=hanchor arialabel=Anchor># </span>entry.load()</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (e *entry) load() (value any, ok bool) {
</span></span><span class=line><span class=cl>    p := atomic.LoadPointer(&amp;e.p)
</span></span><span class=line><span class=cl>    if p <mark> nil || p </mark> expunged {
</span></span><span class=line><span class=cl>        return nil, false
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    return *(*any)(p), true
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><ul><li><p>sync.Map 中，kv 对的 value 是基于 entry 指针封装的形式；</p></li><li><p> 从 map 取得 entry 后，最终需要调用 entry.load 方法读取指针指向的内容；</p></li><li><p>倘若 entry 的指针状态为 nil 或者 expunged，说明 key-entry 对已被删除，则返回 nil；</p></li><li><p> 倘若 entry 未被删除，则读取指针内容，并且转为 any 的形式进行返回.</p></li></ul><a href=#-syncmapmisslocked><h3 id=-syncmapmisslocked><span class=hanchor arialabel=Anchor># </span>## sync.Map.missLocked()</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (m *Map) missLocked() {
</span></span><span class=line><span class=cl>    m.misses++
</span></span><span class=line><span class=cl>    if m.misses &lt; len(m.dirty) {
</span></span><span class=line><span class=cl>        return
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    m.read.Store(readOnly{m: m.dirty})
</span></span><span class=line><span class=cl>    m.dirty = nil
</span></span><span class=line><span class=cl>    m.misses = 0
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><ul><li><p> 在读流程中，倘若未命中 read map，且由于 read map 内容存在缺失需要和 dirty map 交互时，会走进 missLocked 流程；</p></li><li><p> 在 missLocked 流程中，首先 misses 计数器累加 1；</p></li><li><p> 倘若 miss 次数小于 dirty map 中存在的 key-entry 对数量，直接返回即可；</p></li><li><p> 倘若 miss 次数大于等于 dirty map 中存在的 key-entry 对数量，则使用 dirty map 覆盖 read map，并将 read map 的 amended flag 置为 false；</p></li><li><p> 新的 dirty map 置为 nil，misses 计数器清零.</p></li></ul><a href=#写流程-1><h2 id=写流程-1><span class=hanchor arialabel=Anchor># </span> 写流程</h2></a><p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZsUuTG80xphH43Ht3WJG36CEl8AXCYgWOicSKtS6hNVcTzjJwoG6VrEqImiahxnV3aeImfEyNh9IsqQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" width=auto alt=图片></p><p>sync.Map 写流程</p><a href=#syncmapstore><h3 id=syncmapstore><span class=hanchor arialabel=Anchor># </span>sync.Map.Store()</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (m *Map) Store(key, value any) {
</span></span><span class=line><span class=cl>    read, _ := m.read.Load().(readOnly)
</span></span><span class=line><span class=cl>    if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) {
</span></span><span class=line><span class=cl>        return
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    m.mu.Lock()
</span></span><span class=line><span class=cl>    read, _ = m.read.Load().(readOnly)
</span></span><span class=line><span class=cl>    if e, ok := read.m[key]; ok {
</span></span><span class=line><span class=cl>        if e.unexpungeLocked() {
</span></span><span class=line><span class=cl>            m.dirty[key] = e
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        e.storeLocked(&amp;value)
</span></span><span class=line><span class=cl>    } else if e, ok := m.dirty[key]; ok {
</span></span><span class=line><span class=cl>        e.storeLocked(&amp;value)
</span></span><span class=line><span class=cl>    } else {
</span></span><span class=line><span class=cl>        if !read.amended {
</span></span><span class=line><span class=cl>            m.dirtyLocked()
</span></span><span class=line><span class=cl>            m.read.Store(readOnly{m: read.m, amended: true})
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        m.dirty[key] = newEntry(value)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    m.mu.Unlock()
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func (e *entry) storeLocked(i *any) {
</span></span><span class=line><span class=cl>    atomic.StorePointer(&amp;e.p, unsafe.Pointe
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>（1）倘若 read map 存在拟写入的 key，且 entry 不为 expunged 状态，说明这次操作属于更新而非插入，直接基于 CAS 操作进行 entry 值的更新，并直接返回（存活态或者软删除，直接覆盖更新）；</p><p>（2）倘若未命中（1）的分支，则需要加锁 double check；</p><p>（3）倘若第二轮检查中发现 read map 或者 dirty map 中存在 key-entry 对，则直接将 entry 更新为新值即可（存活态或者软删除，直接覆盖更新）；</p><p>（4）在第（3）步中，如果发现 read map 中该 key-entry 为 expunged 态，需要在 dirty map 先补齐 key-entry 对，再更新 entry 值（从硬删除中恢复，然后覆盖更新）；</p><p>（5）倘若 read map 和 dirty map 均不存在，则在 dirty map 中插入新 key-entry 对，并且保证 read map 的 amended flag 为 true.（插入）</p><p>（6）第（5）步的分支中，倘若发现 dirty map 未初始化，需要前置执行 dirtyLocked 流程；</p><p>（7）解锁返回.  </p><p>下面补充介绍 Store() 方法中涉及到的几个子方法.</p><a href=#entrytrystore><h3 id=entrytrystore><span class=hanchor arialabel=Anchor># </span>entry.tryStore()</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (m *Map) Store(key, value any) {
</span></span><span class=line><span class=cl>    read, _ := m.read.Load().(readOnly)
</span></span><span class=line><span class=cl>    if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) {
</span></span><span class=line><span class=cl>        return
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    m.mu.Lock()
</span></span><span class=line><span class=cl>   // ...
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func (e *entry) tryStore(i *any) bool {
</span></span><span class=line><span class=cl>    for {
</span></span><span class=line><span class=cl>        p := atomic.LoadPointer(&amp;e.p)
</span></span><span class=line><span class=cl>        if p == expunged {
</span></span><span class=line><span class=cl>            return false
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        if atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) {
</span></span><span class=line><span class=cl>            return true
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><ul><li><p>• 在写流程中，倘若发现 read map 中已存在对应的 key-entry 对，则会对调用 tryStore 方法尝试进行更新；</p></li><li><p>• 倘若 entry 为 expunged 态，说明已被硬删除，dirty 中缺失该项数据，因此 tryStore 执行失败，回归主干流程；</p></li><li><p>• 倘若 entry 非 expunged 态，则直接执行 CAS 操作完成值的更新即可.</p></li></ul><a href=#entryunexpungelocked><h3 id=entryunexpungelocked><span class=hanchor arialabel=Anchor># </span>entry.unexpungeLocked()</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (m *Map) Store(key, value any) {
</span></span><span class=line><span class=cl>    // ...
</span></span><span class=line><span class=cl>    m.mu.Lock()
</span></span><span class=line><span class=cl>    read, _ = m.read.Load().(readOnly)
</span></span><span class=line><span class=cl>    if e, ok := read.m[key]; ok {
</span></span><span class=line><span class=cl>        if e.unexpungeLocked() {
</span></span><span class=line><span class=cl>            m.dirty[key] = e
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        e.storeLocked(&amp;value)
</span></span><span class=line><span class=cl>    } 
</span></span><span class=line><span class=cl>    // ...
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func (e *entry) unexpungeLocked() (wasExpunged bool) {
</span></span><span class=line><span class=cl>    return atomic.CompareAndSwapPointer(&amp;e.p, expunged, nil)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><ul><li><p>• 在写流程加锁 double check 的过程中，倘若发现 read map 中存在对应的 key-entry 对，会执行该方法；</p></li><li><p>• 倘若 key-entry 为硬删除 expunged 态，该方法会基于 CAS 操作将其更新为软删除 nil 态，然后进一步在 dirty map 中补齐该 key-entry 对，实现从硬删除到软删除的恢复.</p></li></ul><a href=#entrystorelocked><h3 id=entrystorelocked><span class=hanchor arialabel=Anchor># </span>entry.storeLocked()</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (m *Map) Store(key, value any) {
</span></span><span class=line><span class=cl>    // ...
</span></span><span class=line><span class=cl>    m.mu.Lock()
</span></span><span class=line><span class=cl>    read, _ = m.read.Load().(readOnly)
</span></span><span class=line><span class=cl>    if e, ok := read.m[key]; ok {
</span></span><span class=line><span class=cl>       // ...
</span></span><span class=line><span class=cl>        e.storeLocked(&amp;value)
</span></span><span class=line><span class=cl>    } else if e, ok := m.dirty[key]; ok {
</span></span><span class=line><span class=cl>        e.storeLocked(&amp;value)
</span></span><span class=line><span class=cl>    } 
</span></span><span class=line><span class=cl>    // ...
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func (e *entry) storeLocked(i *any) {
</span></span><span class=line><span class=cl>    atomic.StorePointer(&amp;e.p, unsafe.Pointer)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>写流程中，倘若 read map 或者 dirty map 存在对应 key-entry，最终会通过原子操作，将新值的指针存储到 entry.p 当中.</p><a href=#syncmapdirtylocked><h3 id=syncmapdirtylocked><span class=hanchor arialabel=Anchor># </span>sync.Map.dirtyLocked()</h3></a><p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZsUuTG80xphH43Ht3WJG36CcuBUenRpJGmoHvuTdQTX4BwgLVEAhjgTBomODX1LBibuibqd6VkaOcVQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" width=auto alt=图片></p><p>dirtyLock 方法</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (m *Map) dirtyLocked() {
</span></span><span class=line><span class=cl>    if m.dirty != nil {
</span></span><span class=line><span class=cl>        return
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    read, _ := m.read.Load().(readOnly)
</span></span><span class=line><span class=cl>    m.dirty = make(map[any]*entry, len(read.m))
</span></span><span class=line><span class=cl>    for k, e := range read.m {
</span></span><span class=line><span class=cl>        if !e.tryExpungeLocked() {
</span></span><span class=line><span class=cl>            m.dirty[k] = e
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func (e *entry) tryExpungeLocked() (isExpunged bool) {
</span></span><span class=line><span class=cl>    p := atomic.LoadPointer(&amp;e.p)
</span></span><span class=line><span class=cl>    for p == nil {
</span></span><span class=line><span class=cl>        if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) {
</span></span><span class=line><span class=cl>            return true
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        p = atomic.LoadPointer(&amp;e.p)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    return p == expunged
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><ul><li><p>• 在写流程中，倘若需要将 key-entry 插入到兜底的 dirty map 中，并且此时 dirty map 为空（从未写入过数据或者刚发生过 missLocked），会进入 dirtyLocked 流程；</p></li><li><p>• 此时会遍历一轮 read map ，将未删除的 key-entry 对拷贝到 dirty map 当中；</p></li><li><p>• 在遍历时，还会将 read map 中软删除 nil 态的 entry 更新为硬删除 expunged 态，因为在此流程中，不会将其拷贝到 dirty map.</p></li></ul><a href=#删流程><h2 id=删流程><span class=hanchor arialabel=Anchor># </span>删流程</h2></a><p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZsUuTG80xphH43Ht3WJG36CRAuibb73ia2hJuBkpQNNiaowGY9HPic4MX2YPresfrfndXdIj6bTLIKblw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" width=auto alt=图片></p><p>Delete流程</p><a href=#syncmapdelete><h3 id=syncmapdelete><span class=hanchor arialabel=Anchor># </span>sync.Map.Delete()</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (m *Map) Delete(key any) {
</span></span><span class=line><span class=cl>    m.LoadAndDelete(key)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>func (m *Map) LoadAndDelete(key any) (value any, loaded bool) {
</span></span><span class=line><span class=cl>    read, _ := m.read.Load().(readOnly)
</span></span><span class=line><span class=cl>    e, ok := read.m[key]
</span></span><span class=line><span class=cl>    if !ok &amp;&amp; read.amended {
</span></span><span class=line><span class=cl>        m.mu.Lock()
</span></span><span class=line><span class=cl>        read, _ = m.read.Load().(readOnly)
</span></span><span class=line><span class=cl>        e, ok = read.m[key]
</span></span><span class=line><span class=cl>        if !ok &amp;&amp; read.amended {
</span></span><span class=line><span class=cl>            e, ok = m.dirty[key]
</span></span><span class=line><span class=cl>            delete(m.dirty, key)
</span></span><span class=line><span class=cl>            m.missLocked()
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        m.mu.Unlock()
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    if ok {
</span></span><span class=line><span class=cl>        return e.delete()
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    return nil, false
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>（1）倘若 read map 中存在 key，则直接基于 cas 操作将其删除；</p><p>（2）倘若read map 不存在 key，且 read map 有缺失（amended flag 为 true），则加锁 dou check；</p><p>（3）倘若加锁 double check 时，read map 仍不存在 key 且 read map 有缺失，则从 dirty map 中取元素，并且将 key-entry 对从 dirty map 中物理删除；</p><p>（4）走入步骤（3），删操作需要和 dirty map 交互，需要走进 3.3 小节介绍的 missLocked 流程；</p><p>（5）解锁；</p><p>（6）倘若从 read map 或 dirty map 中获取到了 key 对应的 entry，则走入 entry.delete() 方法逻辑删除 entry；</p><p>（7）倘若 read map 和 dirty map 中均不存在 key，返回 false 标识删除失败.  </p><a href=#entrydelete><h3 id=entrydelete><span class=hanchor arialabel=Anchor># </span>entry.delete()</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (e *entry) delete() (value any, ok bool) {
</span></span><span class=line><span class=cl>    for {
</span></span><span class=line><span class=cl>        p := atomic.LoadPointer(&amp;e.p)
</span></span><span class=line><span class=cl>        if p <mark> nil || p </mark> expunged {
</span></span><span class=line><span class=cl>            return nil, false
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) {
</span></span><span class=line><span class=cl>            return *(*any)(p), true
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><ul><li><p>• 该方法是 entry 的逻辑删除方法；</p></li><li><p>• 倘若 entry 此前已被删除，则直接返回 false 标识删除失败；</p></li><li><p>• 倘若 entry 当前仍存在，则通过 CAS 将 entry.p 指向 nil，标识其已进入软删除状态.</p></li></ul><a href=#遍历流程-1><h2 id=遍历流程-1><span class=hanchor arialabel=Anchor># </span>遍历流程</h2></a><p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZsUuTG80xphH43Ht3WJG36CkgF4rrYRgJjyxJMZG87pW5bN1sGWwmgm1jZLrnuCXL9UJZ5dUs5YHw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" width=auto alt=图片></p><p>遍历流程</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func (m *Map) Range(f func(key, value any) bool) {
</span></span><span class=line><span class=cl>    read, _ := m.read.Load().(readOnly)
</span></span><span class=line><span class=cl>    if read.amended {
</span></span><span class=line><span class=cl>        m.mu.Lock()
</span></span><span class=line><span class=cl>        read, _ = m.read.Load().(readOnly)
</span></span><span class=line><span class=cl>        if read.amended {
</span></span><span class=line><span class=cl>            read = readOnly{m: m.dirty}
</span></span><span class=line><span class=cl>            m.read.Store(read)
</span></span><span class=line><span class=cl>            m.dirty = nil
</span></span><span class=line><span class=cl>            m.misses = 0
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        m.mu.Unlock()
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    for k, e := range read.m {
</span></span><span class=line><span class=cl>        v, ok := e.load()
</span></span><span class=line><span class=cl>        if !ok {
</span></span><span class=line><span class=cl>            continue
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        if !f(k, v) {
</span></span><span class=line><span class=cl>            break
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><ul><li><p>（1）在遍历过程中，倘若发现 read map 数据不全（amended flag 为 true），会额外加一次锁，并使用 dirty map 覆盖 read map；</p></li><li><p>（2）遍历 read map（通过步骤（1）保证 read map 有全量数据），执行用户传入的回调函数，倘若某次回调时返回值为 false，则会终止全流程.</p></li></ul><a href=#总结><h2 id=总结><span class=hanchor arialabel=Anchor># </span>总结</h2></a><a href=#entry-的-expunged-态><h3 id=entry-的-expunged-态><span class=hanchor arialabel=Anchor># </span>entry 的 expunged 态</h3></a><p><strong>思考问题：</strong></p><p>为什么需要使用 expunged 态来区分软硬删除呢？仅用 nil 一种状态来标识删除不可以吗？</p><p><strong>回答：</strong></p><p>首先需要明确，无论是软删除(nil)还是硬删除(expunged),都表示在逻辑意义上 key-entry 对已经从 sync.Map 中删除，nil 和 expunged 的区别在于：</p><p>• 软删除态（nil）：read map 和 dirty map 在物理上仍保有该 key-entry 对，因此倘若此时需要对该 entry 执行写操作，可以直接 CAS 操作；</p><p>• 硬删除态（expunged）：dirty map 中已经没有该 key-entry 对，倘若执行写操作，必须加锁（dirty map 必须含有全量 key-entry 对数据）.</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZsUuTG80xphH43Ht3WJG36CAxye1O5PX8pnubKpT3wDbURickVwsYzqgWaBJ5GM07ms57giaiaiaM2n6g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" width=auto alt=图片></p><p>复用 nil 态软删除的数据</p><p>设计 expunged 和 nil 两种状态的原因，就是为了优化在 dirtyLocked 前，针对同一个 key 先删后写的场景. 通过 expunged 态额外标识出 dirty map 中是否仍具有指向该 entry 的能力，这样能够实现对一部分 nil 态 key-entry 对的解放，能够基于 CAS 完成这部分内容写入操作而无需加锁.</p><a href=#read-map-和-dirty-map-的数据流转><h3 id=read-map-和-dirty-map-的数据流转><span class=hanchor arialabel=Anchor># </span>read map 和 dirty map 的数据流转</h3></a><p>sync.Map 由两个 map 构成：</p><ul><li><p>• read map：访问时全程无锁；</p></li><li><p>• dirty map：是兜底的读写 map，访问时需要加锁.</p></li></ul><p>之所以这样处理，是希望能根据对读、删、更新、写操作频次的探测，来实时动态地调整操作方式，希望在读、更新、删频次较高时，更多地采用 CAS 的方式无锁化地完成操作；在写操作频次较高时，则直接了当地采用加锁操作完成.</p><p>因此， sync.Map 本质上采取了一种以空间换时间 + 动态调整策略的设计思路，下面对两个 map 间的数据流转过程进行详细介绍：</p><a href=#两个-map><h4 id=两个-map><span class=hanchor arialabel=Anchor># </span>两个 map</h4></a><p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZsUuTG80xphH43Ht3WJG36CIlk7IHD6tdMsFJ1DWggymJ72FEPEOLF5y6vWufWfILfeq27KSXFguw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" width=auto alt=图片></p><p>read map& dirty map</p><ul><li><p>• 总体思想，希望能多用 read map，少用 dirty map，因为操作前者无锁，后者需要加锁；</p></li><li><p>• 除了 expunged 态的 entry 之外，read map 的内容为 dirty map 的子集；</p></li></ul><a href=#dirty-map---read-map><h4 id=dirty-map---read-map><span class=hanchor arialabel=Anchor># </span>dirty map -> read map</h4></a><p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZsUuTG80xphH43Ht3WJG36CPMHoHZqRHibmVmXkCy09LefxEkmwS2w9MVWqHkzOxKtTgmDupA4mcibQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" width=auto alt=图片></p><p>dirty map 覆写 read map</p><ul><li>• 记录读/删流程中，通过 misses 记录访问 read map miss 由 dirty 兜底处理的次数，当 miss 次数达到阈值，则进入 missLocked 流程，进行新老 read/dirty 替换流程；此时将老 dirty 作为新 read，新 dirty map 则暂时为空，直到 dirtyLocked 流程完成对 dirty 的初始化；</li></ul><a href=#read-map---dirty-map><h4 id=read-map---dirty-map><span class=hanchor arialabel=Anchor># </span>read map -> dirty map</h4></a><p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZsUuTG80xphH43Ht3WJG36CibxGwWWlfByvgeV1gjpbfpCvUYq1HHjMeyZckzLQh97zR2GkjDgCdXQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" width=auto alt=图片></p><p>遍历 read map 填充 dirty map</p><ul><li><p>• 发生 dirtyLocked 的前置条件：I dirty 暂时为空（此前没有写操作或者近期进行过 missLocked 流程）；II 接下来一次写操作访问 read 时 miss，需要由 dirty 兜底；</p></li><li><p>• 在 dirtyLocked 流程中，需要对 read 内的元素进行状态更新，因此需要遍历，是一个线性时间复杂度的过程，可能存在性能抖动；</p></li><li><p>• dirtyLocked 遍历中，会将 read 中未被删除的元素（非 nil 非 expunged）拷贝到 dirty 中；会将 read 中所有此前被删的元素统一置为 expunged 态.</p></li></ul><a href=#go-map-和-sync-map-谁的性能好为什么><h1 id=go-map-和-sync-map-谁的性能好为什么><span class=hanchor arialabel=Anchor># </span>Go map 和 sync. Map 谁的性能好，为什么？</h1></a><p>Go 语言的 <code>sync. Map</code> 支持并发读写，采取了 “空间换时间” 的机制，冗余了两个数据结构，分别是：read 和 dirty</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type Map struct {
</span></span><span class=line><span class=cl>   mu Mutex
</span></span><span class=line><span class=cl>   read atomic.Value // readOnly
</span></span><span class=line><span class=cl>   dirty map[interface{}]*entry
</span></span><span class=line><span class=cl>   misses int
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><strong>对比原始 map：</strong></p><p>和原始 map+RWLock 的实现并发的方式相比，减少了加锁对性能的影响。它做了一些优化：可以无锁访问 read map，而且会优先操作 read map，倘若只操作 read map 就可以满足要求，那就不用去操作 write map (dirty)，所以在某些特定场景中它发生锁竞争的频率会远远小于 map+RWLock 的实现方式</p><p><strong>优点：</strong></p><p>适合读多写少的场景</p><p><strong>缺点：</strong></p><p>写多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://googoo-s.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by googoo-s using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2024</p><ul><li><a href=https://googoo-s.github.io/>Home</a></li><li><a href=https://github.com/googoo-s>GitHub</a></li></ul></footer></div></div></body></html>