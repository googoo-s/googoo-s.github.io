<!DOCTYPE html>
<html lang="en"><head><title>并发</title><meta charset="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Schibsted Grotesk:wght@400;700&amp;family=Source Sans Pro:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="并发"/><meta property="og:description" content="go 语言怎么支持的并发请求 Go 中有 goroutine，所以可以采用多协程来解决并发问题。Accept 连接后，将连接丢给 goroutine 处理后续的读写操作。在开发者看到的这个 goroutine 中业务逻辑是同步的，也不用考虑 IO 是否阻塞。 Golang 的协程通信有哪些方式 1）共享内存 共享内存是指多个协程直接访问共享变量的方式，这种方式不需要显式地进行通信，但需要考虑并发访问时的竞态问题，需要使用互斥锁等机制来确保同步和一致性。 ..."/><meta property="og:image" content="https://googoo-s.github.io/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../../static/icon.png"/><meta name="description" content="go 语言怎么支持的并发请求 Go 中有 goroutine，所以可以采用多协程来解决并发问题。Accept 连接后，将连接丢给 goroutine 处理后续的读写操作。在开发者看到的这个 goroutine 中业务逻辑是同步的，也不用考虑 IO 是否阻塞。 Golang 的协程通信有哪些方式 1）共享内存 共享内存是指多个协程直接访问共享变量的方式，这种方式不需要显式地进行通信，但需要考虑并发访问时的竞态问题，需要使用互斥锁等机制来确保同步和一致性。 ..."/><meta name="generator" content="Quartz"/><link href="../../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><script src="../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch("../../static/contentIndex.json").then(data => data.json())</script></head><body data-slug="GO/八股文/并发"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title"><a href="../..">googoo-s</a></h1><div class="spacer mobile-only"></div><div class="search"><div id="search-icon"><p>Search</p><div></div><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="search-layout" data-preview="true"></div></div></div></div><div class="explorer desktop-only"><button type="button" id="explorer" data-behavior="collapse" data-collapsed="collapsed" data-savestate="true" data-tree="[{&quot;path&quot;:&quot;elastic&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;GO&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;GO/八股文&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;lua&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Obsidian&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;zookeeper&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;工具和环境&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;工具和环境/emacs&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;工具和环境/git&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;工具和环境/maven&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;工具和环境/msys2&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;系统设计&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;系统设计/场景题&quot;,&quot;collapsed&quot;:true}]"><h1>Explorer</h1><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="explorer-content"><ul class="overflow" id="explorer-ul"><li><div class="folder-outer open"><ul style="padding-left:0;" class="content" data-folderul><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="elastic"><button class="folder-button"><span class="folder-title">elastic</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="elastic"><li><a href="../../elastic/KQL" data-for="elastic/KQL">KQL</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="GO"><button class="folder-button"><span class="folder-title">GO</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="GO"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="GO/八股文"><button class="folder-button"><span class="folder-title">八股文</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="GO/八股文"><li><a href="../../GO/八股文/Context" data-for="GO/八股文/Context">Context</a></li><li><a href="../../GO/八股文/Golang基础" data-for="GO/八股文/Golang基础">Golang基础</a></li><li><a href="../../GO/八股文/Map-和Sync.map" data-for="GO/八股文/Map-和Sync.map">Map</a></li><li><a href="../../GO/八股文/Slice" data-for="GO/八股文/Slice">Slice</a></li><li><a href="../../GO/八股文/内存管理和GC" data-for="GO/八股文/内存管理和GC">内存管理</a></li><li><a href="../../GO/八股文/并发" data-for="GO/八股文/并发">并发</a></li></ul></div></li></ul></div></li><li><div class="folder-outer "><ul style="padding-left:0;" class="content" data-folderul></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="lua"><button class="folder-button"><span class="folder-title">lua</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="lua"><li><a href="../../lua/lua基础" data-for="lua/lua基础">lua基础</a></li><li><a href="../../lua/Lua高级" data-for="lua/Lua高级">Lua高级</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="Obsidian"><button class="folder-button"><span class="folder-title">Obsidian</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="Obsidian"><li><a href="../../Obsidian/dataview" data-for="Obsidian/dataview">dataview</a></li><li><a href="../../Obsidian/excalidraw" data-for="Obsidian/excalidraw">excalidraw</a></li><li><a href="../../Obsidian/Front-Matter" data-for="Obsidian/Front-Matter">Front Matter</a></li><li><a href="../../Obsidian/obsidian-overview" data-for="Obsidian/obsidian-overview">obsidian overview</a></li><li><a href="../../Obsidian/Obsidian-plugin" data-for="Obsidian/Obsidian-plugin">Obsidian-plugin</a></li><li><a href="../../Obsidian/publish" data-for="Obsidian/publish">publish</a></li><li><a href="../../Obsidian/template" data-for="Obsidian/template">template</a></li><li><a href="../../Obsidian/使用quartz发布obsidian--vault" data-for="Obsidian/使用quartz发布obsidian--vault">使用quartz发布obsidian  vault</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="zookeeper"><button class="folder-button"><span class="folder-title">zookeeper</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="zookeeper"><li><a href="../../zookeeper/Zookeeper-教程" data-for="zookeeper/Zookeeper-教程">Zookeeper 教程</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="工具和环境"><button class="folder-button"><span class="folder-title">工具和环境</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="工具和环境"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="工具和环境/emacs"><button class="folder-button"><span class="folder-title">emacs</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="工具和环境/emacs"><li><a href="../../工具和环境/emacs/安装" data-for="工具和环境/emacs/安装">安装</a></li><li><a href="../../工具和环境/emacs/快捷键" data-for="工具和环境/emacs/快捷键">快捷键</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="工具和环境/git"><button class="folder-button"><span class="folder-title">git</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="工具和环境/git"><li><a href="../../工具和环境/git/git" data-for="工具和环境/git/git">git</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="工具和环境/maven"><button class="folder-button"><span class="folder-title">maven</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="工具和环境/maven"><li><a href="../../工具和环境/maven/maven基础" data-for="工具和环境/maven/maven基础">maven基础</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="工具和环境/msys2"><button class="folder-button"><span class="folder-title">msys2</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="工具和环境/msys2"><li><a href="../../工具和环境/msys2/pacman" data-for="工具和环境/msys2/pacman">pacman</a></li><li><a href="../../工具和环境/msys2/再-msys-中使用fish" data-for="工具和环境/msys2/再-msys-中使用fish">再 msys 中使用fish</a></li></ul></div></li><li><a href="../../工具和环境/工具" data-for="工具和环境/工具">工具</a></li><li><a href="../../工具和环境/环境搭建" data-for="工具和环境/环境搭建">环境搭建</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="系统设计"><button class="folder-button"><span class="folder-title">系统设计</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="系统设计"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="系统设计/场景题"><button class="folder-button"><span class="folder-title">场景题</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="系统设计/场景题"><li><a href="../../系统设计/场景题/如何设计一个排行榜？" data-for="系统设计/场景题/如何设计一个排行榜？">如何设计一个排行榜？</a></li></ul></div></li></ul></div></li></ul></div></li><li id="explorer-end"></li></ul></div></div></div><div class="center"><div class="page-header"><div class="popover-hint"><nav class="breadcrumb-container" aria-label="breadcrumbs"><div class="breadcrumb-element"><a href="../../">Home</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../../GO/">GO</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../../GO/八股文/">八股文</a><p> ❯ </p></div><div class="breadcrumb-element"><a href>并发</a></div></nav><h1 class="article-title">并发</h1><p show-comma="true" class="content-meta"><span>Feb 26, 2024</span><span>46 min read</span></p><ul class="tags"><li><a href="../../tags/GO/八股文" class="internal tag-link">GO/八股文</a></li></ul></div></div><article class="popover-hint"><h1 id="go-语言怎么支持的并发请求"><strong>go 语言怎么支持的并发请求</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-语言怎么支持的并发请求" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p><code>Go</code> 中有 goroutine，所以可以采用多协程来解决并发问题。Accept 连接后，将连接丢给 goroutine 处理后续的读写操作。在开发者看到的这个 goroutine 中业务逻辑是同步的，也不用考虑 IO 是否阻塞。</p>
<p>Golang 的协程通信有哪些方式</p>
<p>1）共享内存</p>
<ul>
<li>共享内存是指多个协程直接访问共享变量的方式，这种方式不需要显式地进行通信，但需要考虑并发访问时的竞态问题，需要使用互斥锁等机制来确保同步和一致性。</li>
</ul>
<p>2）通道</p>
<ul>
<li>通道是 Go 语言中一个重要的并发原语，它是一种线程安全的、带缓冲的 FIFO 队列。通道支持阻塞式读写，可以用来在不同的协程之间传递数据，也可以用来进行同步操作。通道在多个协程之间传递数据时，会自动进行同步，不需要程序员显式地进行加锁和解锁操作。</li>
</ul>
<p>3）选择器</p>
<ul>
<li>选择器是 Go 语言中的一种控制结构，可以同时监听多个通道的操作，并选择其中一个可以进行操作的通道。选择器可以用来实现非阻塞的通信操作，避免了因等待某个通道操作而导致的阻塞。选择器通常与通道配合使用，用于多个协程之间的协作和同步。</li>
</ul>
<p>4）条件变量（Cond）</p>
<ul>
<li>条件变量用于在协程之间进行复杂的通信和协调。在 Go 中，可以使用 <code>sync</code> 包中的 <code>Cond</code> 类型来实现条件变量。它通常与互斥锁一起使用，以便协程可以在特定条件下等待或被唤醒。</li>
</ul>
<p>5）原子操作（Atomic Operations）</p>
<ul>
<li>Go 语言提供了 <code>sync/atomic</code> 包，用于执行原子操作，这些操作通常用于共享资源的更新，以避免竞态条件。原子操作可以用于对变量的读取、写入、加法等操作，而不需要额外的锁定。</li>
</ul>
<p>总之，Go 协程之间的通信是非常重要的，不同的应用场景需要选择不同的通信方式，以确保程序的正确性和性能。共享内存通常用于需要高性能的并发场景，但需要注意线程安全和同步问题；通道是一种简单、安全、高效的通信方式，适用于大多数并发场景；选择器则适用于多通道协作和同步的场景。</p>
<h1 id="go-常用的并发模型">Go 常用的并发模型？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-常用的并发模型" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>并发模型说的是系统中的线程如何协作完成并发任务，不同的并发模型，线程以不同的方式进行<strong>通信</strong>和协作。</p>
<h2 id="线程间通信方式">线程间通信方式<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#线程间通信方式" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>线程间通信方式有两种：共享内存和消息传递，无论是哪种通信模型，线程或者协程最终都会从内存中获取数据，所以更为准确的说法是直接共享内存、发送消息的方式来同步信息</p>
<h3 id="共享内存"><strong>共享内存</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#共享内存" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><strong>抽象层级</strong>：抽象层级低，当我们遇到对资源进行更细粒度的控制或者对性能有极高要求的场景才应该考虑抽象层级更低的方法</p>
<p><strong>耦合</strong>：高，线程需要在读取或者写入数据时先获取保护该资源的互斥锁</p>
<p><strong>线程竞争</strong>：需要加锁，才能避免线程竞争和数据冲突</p>
<h3 id="发送消息"><strong>发送消息</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#发送消息" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><strong>抽象层级</strong>：抽象层级高，提供了更良好的封装和与领域更相关和契合的设计，比如 Go 语言中的 <code>Channel</code> 就提供了 Goroutine 之间用于传递信息的方式，它在内部实现时就广泛用到了共享内存和锁，通过对两者进行的组合提供了更高级的同步机制</p>
<p><strong>耦合</strong>：低，生产消费者模型</p>
<p><strong>线程竞争</strong>：保证同一时间只有一个活跃的线程能够访问数据，channel 维护所有被该 chanel 阻塞的协程，保证有资源的时候只唤醒一个协程，从而避免竞争</p>
<p>Go 语言中实现了两种并发模型，一种是共享内存并发模型，另一种则是 CSP 模型。</p>
<h2 id="共享内存并发模型">共享内存并发模型<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#共享内存并发模型" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>通过直接共享内存 + 锁的方式同步信息，传统多线程并发</p>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226005141.png" alt="image.png"/></p>
<h2 id="csp-并发模型">CSP 并发模型<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#csp-并发模型" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>通过发送消息的方式来同步信息，Go 语言推荐使用的_通信顺序进程_（communicating sequential processes）并发模型，通过 goroutine 和 channel 来实现</p>
<ul>
<li><code>goroutine</code> 是 Go 语言中并发的执行单位，可以理解为”线程“</li>
<li><code>channel</code> 是 Go 语言中各个并发结构体 (<code>goroutine</code>)之前的通信机制。通俗的讲，就是各个 <code>goroutine</code> 之间通信的”管道“，类似于 Linux 中的管道</li>
</ul>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226005155.png" alt="image.png"/></p>
<h1 id="go-为啥使用-csp-模型来实现并发">Go 为啥使用 CSP 模型来实现并发?<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-为啥使用-csp-模型来实现并发" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>Go 语言使用 CSP（Communicating Sequential Processes，通信顺序进程）模型来实现并发，这是由 Go 语言设计者选择的一种并发模型，有以下几个重要的原因：</p>
<ol>
<li><strong>简单性和清晰性</strong>：CSP 模型提供了一种清晰且直观的方式来表达并发程序。它基于协程之间的通信来进行协作，通过通道（channel）进行消息传递，使得并发程序的结构和逻辑更加简单和可读。</li>
<li><strong>避免共享状态</strong>：CSP 模型强调避免共享状态，而是通过通信共享数据。共享状态是许多并发程序中的错误和难点来源之一，而 CSP 模型可以减少竞态条件（race condition）等问题的出现。</li>
<li><strong>安全性</strong>：Go 的 CSP 模型通过通道提供了一种安全的并发机制。通道的发送和接收操作都是原子的，不需要额外的锁定，因此减少了程序中出现的锁定问题，如死锁和竞态条件。</li>
<li><strong>可扩展性</strong>：CSP 模型可以轻松扩展到大量的协程，因为通道和协程的创建成本相对较低。这使得 Go 非常适合构建高并发的系统，如 Web 服务器、分布式系统和网络服务。</li>
<li><strong>编译器和运行时支持</strong>：Go 编译器和运行时系统针对 CSP 模型进行了优化。Go 的并发原语在语言级别得到支持，而不是通过库的方式实现，这使得并发编程更加容易。</li>
</ol>
<p>总之，Go 选择 CSP 模型是为了提供一种简单、安全、高效和可扩展的并发编程模型，以便开发者能够更轻松地构建并发程序，同时避免共享状态和典型的并发问题。这使得 Go 成为了一个流行的选择，特别适用于需要高度并发性能的应用程序和系统。</p>
<h1 id="有没有什么线程安全的办法">有没有什么线程安全的办法？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#有没有什么线程安全的办法" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>在 Go 语言中，线程安全一般指协程安全，因为 Go 一般使用协程进行调度；而 Go 中为了保证其协程安全，有以下几种机制：</p>
<p>1、互斥锁：在 Go 的标准库中有 sync 包，sync. Mutex 就是解决并发冲突导致的安全性问题的一种方式。</p>
<p>2、读写锁：是在互斥锁上的进一步升级版本，主要为了解决并发多写少读、少写多读两种高并发的情况</p>
<p>3、如果不是需要强制使用同一个对象，那么也可以采用创建对象副本的方式，每个协程独占一个对象，相互之间不关联，但是这显然不符合我们的要求。</p>
<p>综上，使用互斥锁或者读写锁就能很好的解决问题。</p>
<h1 id="select-可以用于什么">select 可以用于什么<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#select-可以用于什么" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>Go 的通道有两种操作方式，一种是带 range 子句的 for 语句，另一种则是 select 语句，它是专门为了操作通道而存在的。这里主要介绍 select 的用法。</p>
<p>Select 的语法如下：</p>
<pre><code>select {
   case &lt;-ch1 :
     statement(s)   
   case ch2 &lt;- 1 :
      statement(s)
    …
   default : /* 可选 */
      statement(s)
}
</code></pre>
<p>这里要注意：</p>
<ul>
<li>每个 case 都必须是一个通信。由于 select 语句是专为通道设计的，所以每个 case 表达式中都只能包含操作通道的表达式，比如接收表达式。</li>
<li>如果有多个 case 都可以运行，select 会随机公平地选出一个执行，其他不会执行。</li>
<li>如果多个 case 都不能运行，若有 default 子句，则执行该语句，反之，select 将阻塞，直到某个 case 可以运行。</li>
<li>所有 channel 表达式都会被求值。</li>
<li>Select 机制⽤来处理异步 IO 问题。</li>
<li>Select 机制最⼤的⼀条限制就是每个 case 语句⾥必须是⼀个 IO 操作。</li>
</ul>
<p><strong>实例</strong></p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;math/rand&quot;
)

func main() {
    // 准备好几个通道。
    intChannels := [5]chan int{
        make(chan int, 1),
        make(chan int, 1),
        make(chan int, 1),
        make(chan int, 1),
        make(chan int, 1)，
    }
    // 随机选择一个通道，并向它发送元素值。
    index := rand.Intn(5)
    fmt.Printf(&quot;The index: %d&quot;, index)
    intChannels[index] &lt;- index
    // 哪一个通道中有可取的元素值，哪个对应的分支就会被执行。
    select {
        case &lt;-intChannels[0]:
            fmt.Println(&quot;The first candidate case is selected.&quot;)
        case &lt;-intChannels[1]:
            fmt.Println(&quot;The second candidate case is selected.&quot;)
        case elem := &lt;-intChannels[2]:
            fmt.Printf(&quot;The third candidate case is selected. The element is %d.&quot;, elem)
        default:
            fmt.Println(&quot;No candidate case is selected!&quot;)
    }
}
</code></pre>
<h2 id="select-死锁"><strong>select 死锁</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#select-死锁" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Select 使用不当会发生死锁。如果通道没有数据发送，但 select 中有存在接收通道数据的语句，将发生死锁。</p>
<pre><code>func main() {  
        ch := make(chan string)
        select {
            case &lt;-ch:
        }
}
/*
fatal error: all goroutines are asleep - deadlock!
goroutine 1 [chan receive]:
main.main()
/workspace/src/test.go:5 +0x52
exit status 2
*/
//可以添加 default 语句来避免产生死锁。
</code></pre>
<h2 id="空-select"><strong>空 select{}</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#空-select" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>对于空的 select 语句，程序会被阻塞，确切的说是当前协程被阻塞，同时 <strong>Go 自带死锁检测机制，当发现当前协程再也没有机会被唤醒时，则会发生 panic</strong>。所以上述程序会 panic。</p>
<pre><code>func main() {  
        select {}
}

/*
fatal error: all goroutines are asleep - deadlock!
goroutine 1 [select (no cases)]:
main.main()
	/workspace/src/test.go:3 +0x20
exit status 2
*/
</code></pre>
<h2 id="select-和-for-结合使用"><strong>select 和 for 结合使用</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#select-和-for-结合使用" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Select 语句只能对其中的每一个 case 表达式各求值一次。所以，如果想连续或定时地操作其中的通道的话，就需要通过在 for 语句中嵌入 select 语句的方式实现。</p>
<pre><code>func main() {
    tick := time.Tick(time.Second)
    for {
        select {
            case t := &lt;-tick:
                fmt.Println(t)
                break
            }
    }
    fmt.Println(&quot;end&quot;)
}
</code></pre>
<p>你会发现 break 只跳出了 select，无法跳出 for。解决办法有两种：</p>
<h3 id="使用-goto-跳出循环"><strong>使用 goto 跳出循环</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#使用-goto-跳出循环" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<pre><code>func main() {
    tick := time.Tick(time.Second)
    for {
        select {
            case t := &lt;-tick:
                fmt.Println(t)
                //跳到指定位置
                goto END
            }
        }
END:
        fmt.Println(&quot;end&quot;)
    }
</code></pre>
<h3 id="使用标签"><strong>使用标签</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#使用标签" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<pre><code>func main() {
    tick := time.Tick(time.Second)
//这是标签
FOREND:
    for {
        select {
            case t := &lt;-tick:
                fmt.Println(t)
                //跳出FOREND标签
                break ForEnd
            }
        }
END:
        fmt.Println(&quot;end&quot;)
    }
</code></pre>
<h2 id="select-实现超时机制"><strong>select 实现超时机制</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#select-实现超时机制" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>主要使用的 time. After 实现超时控制。</p>
<pre><code>func main() {
    ch := make(chan int)
    quit := make(chan bool)

    go func() {
        for {
            select {
                case num := &lt;-ch:  //如果有数据，下面打印。但是有可能ch一直没数据
                 fmt.Println(&quot;num = &quot;, num)
                case &lt;-time.After(3 * time.Second): //上面的ch如果一直没数据会阻塞，那么select也会检测其他case条件，检测到后3秒超时
                 fmt.Println(&quot;超时&quot;)
                 quit &lt;- true  //写入
            }
        }

    }()

    for i := 0; i &lt; 5; i++ {
        ch &lt;- i
        time.Sleep(time.Second)
    }
    &lt;-quit //这里暂时阻塞，直到可读
    fmt.Println(&quot;程序结束&quot;)
}
</code></pre>
<p>执行后，可以观察到：依次打印出 0-4，几秒过后打印出“超时”和“程序结束”，打印结果如下：</p>
<pre><code>num =  0
num =  1
num =  2
num =  3
num =  4
超时
程序结束
</code></pre>
<h1 id="select-底层原理">Select 底层原理<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#select-底层原理" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>select 的底层原理：<a href="https://juejin.cn/post/7123037385419407374?searchId=20230920141239DA74937FA19C8E97461E#heading-2" class="external">Go select使用与底层原理<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> </p>
<ol>
<li>每一个 case 对应的 channl 都会被封装到一个结构体中；</li>
<li>当第一次执行到 select 时，会锁住所有的 channl 并且，打乱 case 结构体的顺序；</li>
<li>按照打乱的顺序遍历，如果有就绪的信号，就直接走对应 case 的代码段，之后跳出 select；</li>
<li>如果没有就绪的代码段，但是有 default 字段，那就走 default 的代码段，之后跳出 select；</li>
<li>如果没有 default，那就将当前 goroutine 加入所有 channl 的对应等待队列；</li>
<li>当某一个等待队列就绪时，再次锁住所有的 channl，遍历一遍，将所有等待队列中的 goroutine 取出，之后执行就绪的代码段，跳出select。</li>
</ol>
<h2 id="数据结构">数据结构<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#数据结构" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>每一个 case 对应的数据结构如下：</p>
<pre><code>type scase struct {
    c           *hchan         // chan
    elem        unsafe.Pointer // 读或者写的缓冲区地址
    kind        uint16   //case语句的类型，是default、传值写数据(channel &lt;-) 还是  取值读数据(&lt;- channel)
    pc          uintptr // race pc (for race detector / msan)
    releasetime int64
}
</code></pre>
<h1 id="go-有哪些并发同步原语">Go 有哪些并发同步原语？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-有哪些并发同步原语" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>Go 是一门以并发编程见长的语言，它提供了一系列的同步原语方便开发者使用
<img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226005223.png" alt="image.png"/></p>
<h2 id="原子操作">原子操作<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#原子操作" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Mutex、RWMutex 等并发原语的底层实现是通过 atomic 包中的一些原子操作来实现的，原子操作是最基础的并发原语. Go atomic 包是最轻量级的锁（也称无锁结构），可以在<strong>不形成临界区和创建互斥量的情况下完成并发安全的值替换操作</strong>，不过这个包只支持 int 32/int 64/uint 32/uint 64/uintptr 这几种数据类型的一些基础操作（增减、交换、载入、存储等）</p>
<h3 id="概念">概念<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#概念" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>原子操作仅会由一个独立的 CPU 指令代表和完成。原子操作是无锁的，常常直接通过 CPU 指令直接实现。事实上，其它同步技术的实现常常依赖于原子操作。</p>
<h3 id="使用场景">使用场景<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#使用场景" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>当我们想要对<strong>某个变量</strong>并发安全的修改，除了使用官方提供的 <code>mutex</code>，还可以使用 sync/atomic 包的原子操作，它能够保证对变量的读取或修改期间不被其他的协程所影响。</p>
<p>Atomic 包提供的原子操作能够确保任一时刻只有一个 goroutine 对变量进行操作，善用 atomic 能够避免程序中出现大量的锁操作。</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;sync/atomic&quot;
)

var opts int64 = 0

func main() {
    add(&amp;opts, 3)
    load(&amp;opts)
    compareAndSwap(&amp;opts, 3, 4)
    swap(&amp;opts, 5)
    store(&amp;opts, 6)
}

func add(addr *int64, delta int64) {
    atomic.AddInt64(addr, delta) //加操作
    fmt.Println(&quot;add opts: &quot;, *addr)
}

func load(addr *int64) {
    fmt.Println(&quot;load opts: &quot;, atomic.LoadInt64(&amp;opts))
}

func compareAndSwap(addr *int64, oldValue int64, newValue int64) {
    if atomic.CompareAndSwapInt64(addr, oldValue, newValue) {
        fmt.Println(&quot;cas opts: &quot;, *addr)
        return
    }
}

func swap(addr *int64, newValue int64) {
    atomic.SwapInt64(addr, newValue)
    fmt.Println(&quot;swap opts: &quot;, *addr)
}

func store(addr *int64, newValue int64) {
    atomic.StoreInt64(addr, newValue)
    fmt.Println(&quot;store opts: &quot;, *addr)
}
</code></pre>
<h3 id="常见操作">常见操作<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#常见操作" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<ul>
<li>增减 Add</li>
<li>载入 Load</li>
<li>比较并交换 CompareAndSwap</li>
<li>交换 Swap</li>
<li>存储 Store</li>
</ul>
<p>Atomic 操作的对象是一个地址，你需要把可寻址的变量的地址作为参数传递给方法，而不是把变量的值传递给方法</p>
<p>下面将分别介绍这些操作：</p>
<h4 id="增减操作"><strong>增减操作</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#增减操作" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>此类操作的前缀为 <code>Add</code></p>
<pre><code>func AddInt32(addr *int32, delta int32) (new int32)

func AddInt64(addr *int64, delta int64) (new int64)

func AddUint32(addr *uint32, delta uint32) (new uint32)

func AddUint64(addr *uint64, delta uint64) (new uint64)

func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)
</code></pre>
<p>需要注意的是，第一个参数必须是指针类型的值，通过指针变量可以获取被操作数在内存中的地址，从而施加特殊的 CPU 指令，确保同一时间只有一个 goroutine 能够进行操作。</p>
<p>使用举例：</p>
<pre><code>func add(addr *int64, delta int64) {
    atomic.AddInt64(addr, delta) //加操作
    fmt.Println(&quot;add opts: &quot;, *addr)
}
</code></pre>
<h4 id="载入操作"><strong>载入操作</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#载入操作" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>此类操作的前缀为 <code>Load</code></p>
<pre><code>func LoadInt32(addr *int32) (val int32)

func LoadInt64(addr *int64) (val int64)

func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)

func LoadUint32(addr *uint32) (val uint32)

func LoadUint64(addr *uint64) (val uint64)

func LoadUintptr(addr *uintptr) (val uintptr)

// 特殊类型： Value类型，常用于配置变更
func (v *Value) Load() (x interface{}) {}
</code></pre>
<p>载入操作能够保证原子的读变量的值，当读取的时候，任何其他 CPU 操作都无法对该变量进行读写，其实现机制受到底层硬件的支持。</p>
<p>使用示例:</p>
<pre><code>func load(addr *int64) {
    fmt.Println(&quot;load opts: &quot;, atomic.LoadInt64(&amp;opts))
}
</code></pre>
<h4 id="比较并交换"><strong>比较并交换</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#比较并交换" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>此类操作的前缀为 <code>CompareAndSwap</code>, 该操作简称 CAS，可以用来实现乐观锁</p>
<pre><code>func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)

func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)

func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)

func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)

func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)

func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)
</code></pre>
<p>该操作在进行交换前首先确保变量的值未被更改，即仍然保持参数 <code>old</code> 所记录的值，满足此前提下才进行交换操作。CAS 的做法类似操作数据库时常见的乐观锁机制。</p>
<p>需要注意的是，当有大量的 goroutine 对变量进行读写操作时，可能导致 CAS 操作无法成功，这时可以利用 for 循环多次尝试。</p>
<p>使用示例：</p>
<pre><code>func compareAndSwap(addr *int64, oldValue int64, newValue int64) {
    if atomic.CompareAndSwapInt64(addr, oldValue, newValue) {
        fmt.Println(&quot;cas opts: &quot;, *addr)
        return
    }
}
</code></pre>
<h4 id="交换"><strong>交换</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#交换" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>此类操作的前缀为 <code>Swap</code>：</p>
<pre><code>func SwapInt32(addr *int32, new int32) (old int32)

func SwapInt64(addr *int64, new int64) (old int64)

func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)

func SwapUint32(addr *uint32, new uint32) (old uint32)

func SwapUint64(addr *uint64, new uint64) (old uint64)

func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)
</code></pre>
<p>相对于 CAS，明显此类操作更为暴力直接，<strong>并不管变量的旧值是否被改变，直接赋予新值然后返回背替换的值</strong>。</p>
<pre><code>func swap(addr *int64, newValue int64) {
    atomic.SwapInt64(addr, newValue)
    fmt.Println(&quot;swap opts: &quot;, *addr)
}
</code></pre>
<h4 id="存储"><strong>存储</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#存储" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>此类操作的前缀为 <code>Store</code>：</p>
<pre><code>func StoreInt32(addr *int32, val int32)

func StoreInt64(addr *int64, val int64)

func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)

func StoreUint32(addr *uint32, val uint32)

func StoreUint64(addr *uint64, val uint64)

func StoreUintptr(addr *uintptr, val uintptr)

// 特殊类型： Value类型，常用于配置变更
func (v *Value) Store(x interface{})
</code></pre>
<p>此类操作确保了写变量的原子性，避免其他操作读到了修改变量过程中的脏数据。</p>
<pre><code>func store(addr *int64, newValue int64) {
    atomic.StoreInt64(addr, newValue)
    fmt.Println(&quot;store opts: &quot;, *addr)
}
</code></pre>
<h3 id="go-原子操作和锁的区别">Go 原子操作和锁的区别？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-原子操作和锁的区别" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<ul>
<li>原子操作由底层硬件支持，而锁是基于原子操作+信号量完成的。若实现相同的功能，前者通常会更有效率</li>
<li>原子操作是单个指令的互斥操作；互斥锁/读写锁是一种数据结构，可以完成临界区（多个指令）的互斥操作，扩大原子操作的范围</li>
<li>原子操作是无锁操作，属于乐观锁；说起锁的时候，一般属于悲观锁</li>
<li>原子操作存在于各个指令/语言层级，比如“机器指令层级的原子操作”，“汇编指令层级的原子操作”，“Go 语言层级的原子操作”等。</li>
<li>锁也存在于各个指令/语言层级中，比如“机器指令层级的锁”，“汇编指令层级的锁”，“Go 语言层级的锁”等</li>
</ul>
<h2 id="channel">Channel<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#channel" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><a href="../../GO/八股文/Channel" class="internal alias" data-slug="GO/八股文/Channel">Channel</a></p>
<p><code>channel</code> 管道，高级同步原语，goroutine 之间通信的桥梁</p>
<p>使用场景：消息队列、数据传递、信号通知、任务编排、锁</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    c := make(chan struct{}, 1)
    for i := 0; i &lt; 10; i++ {
        go func() {
            c &lt;- struct{}{}
            time.Sleep(1 * time.Second)
            fmt.Println(&quot;通过ch访问临界区&quot;)
            &lt;-c
        }()
    }
    for {
    }
}
</code></pre>
<h2 id="基本并发原语">基本并发原语<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#基本并发原语" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Go 语言在 <code>sync</code> 包中提供了用于同步的一些基本原语，这些基本原语提供了较为基础的同步功能，但是它们是一种相对原始的同步机制，在多数情况下，我们都应该使用抽象层级更高的 Channel 实现同步。</p>
<p>常见的并发原语如下：<code>sync.Mutex</code>、<code>sync.RWMutex</code>、<code>sync.WaitGroup</code>、<code>sync.Cond</code>、<code>sync.Once</code>、<code>sync.Pool</code>、<code>sync.Context</code></p>
<h3 id="sync-mutex"><strong>sync. Mutex</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#sync-mutex" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><a href="../../GO/八股文/Mutex和RWMutex" class="internal alias" data-slug="GO/八股文/Mutex和RWMutex">Mutex和RWMutex</a></p>
<p><code>sync.Mutex</code> （互斥锁） 可以限制对临界资源的访问，保证只有一个 goroutine 访问共享资源</p>
<p>使用场景：大量读写，比如多个 goroutine 并发更新同一个资源，像计数器</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

func main() {
    // 封装好的计数器
    var counter Counter
    var wg sync.WaitGroup
    var gNum = 1000
    wg.Add(gNum)
    // 启动10个goroutine
    for i := 0; i &lt; gNum; i++ {
        go func() {
            defer wg.Done()
            counter.Incr() // 受到锁保护的方法
        }()
    }
    wg.Wait()
    fmt.Println(counter.Count())
}

// 线程安全的计数器类型
type Counter struct {
    mu    sync.Mutex
    count uint64
}

// 加1的方法，内部使用互斥锁保护
func (c *Counter) Incr() {
    c.mu.Lock()
    c.count++
    c.mu.Unlock()
}

// 得到计数器的值，也需要锁保护
func (c *Counter) Count() uint64 {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.count
}
</code></pre>
<h3 id="sync-rwmutex">sync. RWMutex<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#sync-rwmutex" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><a href="../../GO/八股文/Mutex和RWMutex" class="internal alias" data-slug="GO/八股文/Mutex和RWMutex">Mutex和RWMutex</a></p>
<p><code>sync.RWMutex</code> （读写锁） 可以限制对临界资源的访问，保证只有一个 goroutine 写共享资源，可以有多个 goroutine 读共享资源</p>
<p>使用场景：大量并发读，少量并发写，有强烈的性能要求</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

func main() {
    // 封装好的计数器
    var counter Counter
    var gNum = 1000
    // 启动10个goroutine
    for i := 0; i &lt; gNum; i++ {
        go func() {
            counter.Count() // 受到锁保护的方法
        }()
    }
    for { // 一个writer
        counter.Incr() // 计数器写操作
        fmt.Println(&quot;incr&quot;)
        time.Sleep(time.Second)
    }
}

// 线程安全的计数器类型
type Counter struct {
    mu    sync.RWMutex
    count uint64
}

// 加1的方法，内部使用互斥锁保护
func (c *Counter) Incr() {
    c.mu.Lock()
    c.count++
    c.mu.Unlock()
}

// 得到计数器的值，也需要锁保护
func (c *Counter) Count() uint64 {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return c.count
}
</code></pre>
<h3 id="sync-waitgroup"><strong>sync. WaitGroup</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#sync-waitgroup" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><code>sync.WaitGroup</code> 可以等待一组 Goroutine 的返回</p>
<pre><code>// A WaitGroup must not be copied after first use.
type WaitGroup struct {
 noCopy noCopy
 state1 [3]uint32
}
</code></pre>
<h4 id="底层数据结构">底层数据结构<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#底层数据结构" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>其中 <code>noCopy</code> 是 golang 源码中检测禁止拷贝的技术。如果程序中有 WaitGroup 的赋值行为，使用 <code>go vet</code> 检查程序时，就会发现有报错。但需要注意的是，noCopy 不会影响程序正常的编译和运行。</p>
<p><code>state 1</code> 主要是存储着状态和信号量，状态维护了 2 个计数器，一个是请求计数器 counter ，另外一个是等待计数器 waiter（已调用 <code>WaitGroup. Wait</code> 的 goroutine 的个数）</p>
<p>当数组的首地址是处于一个 <code>8</code> 字节对齐的位置上时，那么就将这个数组的前 <code>8</code> 个字节作为 <code>64</code> 位值使用表示状态，后 <code>4</code> 个字节作为 <code>32</code> 位值表示信号量 (<code>semaphore</code>)；同理如果首地址没有处于 <code>8</code> 字节对齐的位置上时，那么就将前 <code>4</code> 个字节作为 <code>semaphore</code>，后 <code>8</code> 个字节作为 <code>64</code> 位数值。
<img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226005747.png" alt="image.png"/></p>
<h4 id="使用场景-1">使用场景<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#使用场景-1" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>并发等待，任务编排，一个比较常见的使用场景是批量发出 RPC 或者 HTTP 请求</p>
<h4 id="使用方法">使用方法<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#使用方法" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>在 WaitGroup 里主要有 3 个方法：</p>
<ul>
<li><code>WaitGroup.Add ()</code>：可以添加或减少请求的 goroutine 数量，<em><code>Add (n)</code> 将会导致 <code>counter += n</code></em></li>
<li><code>WaitGroup.Done ()</code>：相当于 Add (-1)，<code>Done ()</code> 将导致 <code>counter -=1</code>，请求计数器 counter 为 0 时通过信号量调用 <code>runtime_Semrelease</code> 唤醒 waiter 线程</li>
<li><code>WaitGroup.Wait ()</code>：会将 <code>waiter++</code>，同时通过信号量调用 <code>runtime_Semacquire (semap)</code> 阻塞当前 goroutine</li>
</ul>
<pre><code>func main() {
    var wg sync.WaitGroup
    for i := 1; i &lt;= 5; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            println(&quot;hello&quot;)
        }()
    }

    wg.Wait()
}
</code></pre>
<h4 id="waitgroup-的坑">WaitGroup 的坑<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#waitgroup-的坑" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<ol>
<li>Add 一个负数</li>
</ol>
<blockquote>
<p>如果计数器的值小于 0 会直接 panic</p>
</blockquote>
<ol start="2">
<li>Add 在 Wait 之后调用</li>
</ol>
<blockquote>
<p>比如一些子协程开头调用 Add 结束调用 Wait，这些 Wait 无法阻塞子协程。正确做法是在开启子协程之前先 Add 特定的值。</p>
</blockquote>
<ol start="3">
<li>未置为 0 就重用</li>
</ol>
<blockquote>
<p>WaitGroup 可以完成一次编排任务，计数值降为 0 后可以继续被其他任务所用，但是不要在还没使用完的时候就用于其他任务，这样由于带着计数值，很可能出问题。</p>
</blockquote>
<ol start="4">
<li>复制 waitgroup</li>
</ol>
<blockquote>
<p>WaitGroup 有 nocopy 字段，不能被复制。也意味着 WaitGroup 不能作为函数的参数。</p>
</blockquote>
<h4 id="深入理解-sync-waitgroup">深入理解 sync. Waitgroup<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#深入理解-sync-waitgroup" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p><a href="https://juejin.cn/post/7181812988461252667" class="external">https://juejin.cn/post/7181812988461252667<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> </p>
<p><code>WaitGroup</code> 内部<strong>通过一个计数器来统计有多少协程被等待</strong>。</p>
<ul>
<li>这个计数器的值在我们启动 goroutine 之前先写入（使用 <code>Add</code> 方法），</li>
<li>然后在 goroutine 结束的时候，将这个计数器减 1（使用 <code>Done</code> 方法）。</li>
<li>除此之外，在启动这些 goroutine 的协程中，会调用 <code>Wait</code> 来进行等待，在 <code>Wait</code> 调用的地方会阻塞，直到 <code>WaitGroup</code> 内部的计数器减到 0。 <strong>也就实现了等待一组 goroutine 的目的</strong></li>
</ul>
<h3 id="sync-cond"><strong>sync. Cond</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#sync-cond" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><code>sync.Cond</code> 可以让一组的 Goroutine 都在满足特定条件时被唤醒, <code>Go</code> 标准库提供了 <code>Cond</code> 原语</p>
<pre><code>type Cond struct {
    noCopy noCopy

    // L is held while observing or changing the condition
    L Locker

    notify  notifyList
    checker copyChecker
}

type notifyList struct {
    wait   uint32
    notify uint32
    lock   uintptr // key field of the mutex
    head   unsafe.Pointer
    tail   unsafe.Pointer
}
</code></pre>
<h4 id="底层数据结构-1">底层数据结构<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#底层数据结构-1" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>主要有 <code>4</code> 个字段：</p>
<ul>
<li><code>nocopy</code> ： golang 源码中检测禁止拷贝的技术。如果程序中有 WaitGroup 的赋值行为，使用 <code>go vet</code> 检查程序时，就会发现有报错，但需要注意的是，noCopy 不会影响程序正常的编译和运行</li>
<li><code>checker</code>：用于禁止运行期间发生拷贝，双重检查 (<code>Double check</code>)</li>
<li><code>L</code>：可以传入一个读写锁或互斥锁，当修改条件或者调用 <code>Wait</code> 方法时需要加锁</li>
<li><code>notify</code>：通知链表，调用 <code>Wait ()</code> 方法的 <code>Goroutine</code> 会放到这个链表中，从这里获取需被唤醒的 Goroutine 列表</li>
</ul>
<h4 id="使用场景-2">使用场景<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#使用场景-2" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>利用等待 / 通知机制实现阻塞或者唤醒</p>
<h4 id="使用方法-1">使用方法<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#使用方法-1" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>在 Cond 里主要有 3 个方法：</p>
<ul>
<li><code>sync.NewCond (l Locker)</code>: 新建一个 sync. Cond 变量，注意该函数需要一个 Locker 作为必填参数，这是因为在 <code>cond.Wait ()</code> 中底层会涉及到 Locker 的锁操作</li>
<li><code>Cond.Wait ()</code>: 阻塞等待被唤醒，调用 Wait 函数前<strong>需要先加锁</strong>；并且由于 Wait 函数被唤醒时存在虚假唤醒等情况，导致唤醒后发现，条件依旧不成立，因此需要使用 for 语句来循环地进行等待，直到条件成立为止</li>
<li><code>Cond.Signal ()</code>: 只唤醒一个最先 Wait 的 goroutine，可以不用加锁</li>
<li><code>Cond.Broadcast ()</code>: 唤醒所有 Wait 的 goroutine，可以不用加锁</li>
</ul>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;sync/atomic&quot;
    &quot;time&quot;
)



var status int64

  

func TestCond(t *testing.T) {

    c := sync.NewCond(&amp;sync.Mutex{})

    for i := 0; i &lt; 10; i++ {

        go listen(c)

    }

    time.Sleep(1 * time.Second)

    go broadcast(c)

    time.Sleep(1 * time.Second)

}

  

func broadcast(c *sync.Cond) {

    // 原子操作

    atomic.StoreInt64(&amp;status, 1)

    c.Broadcast()

}

  

func listen(c *sync.Cond) {

    c.L.Lock()

    fmt.Println(&quot;wait&quot;)

    c.Wait()

     // Wait 内部会先调用 c.L.Unlock()，来先释放锁，如果调用方不先加锁的话，会报错

    fmt.Println(&quot;listen&quot;)

    c.L.Unlock()

}
</code></pre>
<h3 id="sync-once"><strong>sync. Once</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#sync-once" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<h4 id="什么是sync-once"><strong>什么是</strong> sync. Once<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#什么是sync-once" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>Once 可以用来执行且仅仅执行一次动作，常常用于单例对象的初始化场景。</p>
<p>Once 常常用来初始化单例资源，或者并发访问只需初始化⼀次的共享资源，或者在测试的时候初始化⼀次测试资源。</p>
<p><strong>源码</strong></p>
<pre><code>type Once struct {
	m    Mutex
	done uint32
}

func (o *Once) Do(f func()) {
	if atomic.LoadUint32(&amp;o.done) == 1 {
		return
	}
	o.m.Lock()
	defer o.m.Unlock()
	if o.done == 0 {
		defer atomic.StoreUint32(&amp;o.done, 1)
		f()
	}
}
</code></pre>
<p><code>sync.Once</code> 可以保证在 Go 程序运行期间的某段代码只会执行一次</p>
<p>使用场景：常常用于单例对象的初始化场景</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

func main() {
    o := &amp;sync.Once{}
    for i := 0; i &lt; 10; i++ {
        o.Do(func() {
            fmt.Println(&quot;only once&quot;)
        })
    }
}
</code></pre>
<h3 id="sync-pool"><strong>sync. Pool</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#sync-pool" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>对于很多需要重复分配、回收内存的地方，sync. Pool 是一个很好的选择。频繁地分配、回收内存会给 GC 带来一定的负担，严重的时候会引起 CPU 的毛刺，而<strong>sync. Pool 可以将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存</strong>，减轻 GC 的压力，提升系统的性能。</p>
<p><code>sync.Pool</code> 是 sync 包下的一个组件，可以作为保存临时取还对象的一个“池子”。个人觉得它的名字有一定的误导性，因为 Pool 里装的对象可以被无通知地被回收，可能 <code>sync.Cache</code> 是一个更合适的名字。</p>
<p><a href="https://zhuanlan.zhihu.com/p/399150710" class="external">sync.Pool底层原理<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> </p>
<p><a href="https://zhuanlan.zhihu.com/p/133638023" class="external"># 深度解密 Go 语言之 sync.Pool<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></p>
<h4 id="使用场景-3">使用场景<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#使用场景-3" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>对于很多需要重复分配、回收内存的地方，<code>sync.Pool</code> 是一个很好的选择。频繁地分配、回收内存会给 GC 带来一定的负担，严重的时候会引起 CPU 的毛刺，而 <code>sync.Pool</code> 可以将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力，提升系统的性能。</p>
<p>对象池化， TCP 连接池、数据库连接池、Worker Pool</p>
<h4 id="使用方法-2">使用方法<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#使用方法-2" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>首先，<code>sync.Pool</code> 是协程安全的，这对于使用者来说是极其方便的。使用前，设置好对象的 <code>New</code> 函数，用于在 <code>Pool</code> 里没有缓存的对象时，创建一个。之后，在程序的任何地方、任何时候仅通过 <code>Get()</code>、<code>Put()</code> 方法就可以取、还对象了。</p>
<p>首先来看一个简单的例子：</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="text" data-theme="github-light github-dark"><code data-language="text" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>package main</span></span>
<span data-line><span>import (</span></span>
<span data-line><span>    &quot;fmt&quot;</span></span>
<span data-line><span>    &quot;sync&quot;</span></span>
<span data-line><span>)</span></span>
<span data-line> </span>
<span data-line><span>var pool *sync.Pool</span></span>
<span data-line> </span>
<span data-line><span>type Person struct {</span></span>
<span data-line><span>    Name string</span></span>
<span data-line><span>}</span></span>
<span data-line> </span>
<span data-line><span>func initPool() {</span></span>
<span data-line><span>    pool = &amp;sync.Pool {</span></span>
<span data-line><span>        New: func()interface{} {</span></span>
<span data-line><span>            fmt.Println(&quot;Creating a new Person&quot;)</span></span>
<span data-line><span>            return new(Person)</span></span>
<span data-line><span>        },</span></span>
<span data-line><span>    }</span></span>
<span data-line><span>}</span></span>
<span data-line> </span>
<span data-line><span>func main() {</span></span>
<span data-line><span>    initPool()</span></span>
<span data-line> </span>
<span data-line><span>    p := pool.Get().(*Person)</span></span>
<span data-line><span>    fmt.Println(&quot;首次从 pool 里获取：&quot;, p)</span></span>
<span data-line> </span>
<span data-line><span>    p.Name = &quot;first&quot;</span></span>
<span data-line><span>    fmt.Printf(&quot;设置 p.Name = %s\n&quot;, p.Name)</span></span>
<span data-line> </span>
<span data-line><span>    pool.Put(p)</span></span>
<span data-line> </span>
<span data-line><span>    fmt.Println(&quot;Pool 里已有一个对象：&amp;{first}，调用 Get: &quot;, pool.Get().(*Person))</span></span>
<span data-line><span>    fmt.Println(&quot;Pool 没有对象了，调用 Get: &quot;, pool.Get().(*Person))</span></span>
<span data-line><span>}</span></span></code></pre></figure>
<p>运行结果：</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="text" data-theme="github-light github-dark"><code data-language="text" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>Creating a new Person</span></span>
<span data-line><span>首次从 pool 里获取： &amp;{}</span></span>
<span data-line><span>设置 p.Name = first</span></span>
<span data-line><span>Pool 里已有一个对象：&amp;{first}，Get:  &amp;{first}</span></span>
<span data-line><span>Creating a new Person</span></span>
<span data-line><span>Pool 没有对象了，Get:  &amp;{}</span></span></code></pre></figure>
<h3 id="sync-map"><strong>sync. Map</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#sync-map" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><a href="../../GO/八股文/Map-和Sync.map" class="internal alias" data-slug="GO/八股文/Map-和Sync.map">Map 和Sync.map</a></p>
<p><code>sync.Map</code> 线程安全的 map</p>
<p>使用场景：map 并发读写</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

func main() {
    var scene sync.Map
    // 将键值对保存到sync.Map
    scene.Store(&quot;1&quot;, 1)
    scene.Store(&quot;2&quot;, 2)
    scene.Store(&quot;3&quot;, 3)
    // 从sync.Map中根据键取值
    fmt.Println(scene.Load(&quot;1&quot;))
    // 根据键删除对应的键值对
    scene.Delete(&quot;1&quot;)
    // 遍历所有sync.Map中的键值对
    scene.Range(func(k, v interface{}) bool {
        fmt.Println(&quot;iterate:&quot;, k, v)
        return true
    })
}
</code></pre>
<h4 id="sync-context"><strong>sync. Context</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#sync-context" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p><a href="../../GO/八股文/Context" class="internal alias" data-slug="GO/八股文/Context">Context</a></p>
<p><code>sync.Context</code> 可以进行上下文信息传递、提供超时和取消机制、控制子 goroutine 的执行</p>
<p>使用场景：取消一个 goroutine 的执行</p>
<pre><code>package main

import (
    &quot;context&quot;
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    go func() {
        defer func() {
            fmt.Println(&quot;goroutine exit&quot;)
        }()
        for {
            select {
            case &lt;-ctx.Done():
                fmt.Println(&quot;receive cancel signal!&quot;)
                return
            default:
                fmt.Println(&quot;default&quot;)
                time.Sleep(time.Second)
            }
        }
    }()
    time.Sleep(time.Second)
    cancel()
    time.Sleep(2 * time.Second)
}
</code></pre>
<h2 id="扩展并发原语">扩展并发原语<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#扩展并发原语" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<h3 id="errgroup"><strong>ErrGroup</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#errgroup" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><code>errgroup</code> 可以在一组 Goroutine 中提供了同步、错误传播以及上下文取消的功能</p>
<p>如果协程中 panic 依然会</p>
<p>使用场景：只要一个 goroutine 出错我们就不再等其他 goroutine 了，减少资源浪费，并且返回错误</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;

    &quot;golang.org/x/sync/errgroup&quot;
)

func main() {
    var g errgroup.Group
    var urls = []string{
        &quot;http://www.baidu.com/&quot;,
        &quot;https://www.sina.com.cn/&quot;,
    }
    for i := range urls {
        url := urls[i]
        g.Go(func() error {
            resp, err := http.Get(url)
            if err == nil {
                resp.Body.Close()
            }
            return err
        })
    }
    err := g.Wait()
    if err == nil {
        fmt.Println(&quot;Successfully fetched all URLs.&quot;)
    } else {
        fmt.Println(&quot;fetched error:&quot;, err.Error())
    }
}
</code></pre>
<h3 id="semaphore"><strong>Semaphore</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#semaphore" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><code>Semaphore</code> 带权重的信号量，控制多个 goroutine 同时访问资源</p>
<p>使用场景：控制 goroutine 的阻塞和唤醒</p>
<pre><code>package main

import (
    &quot;context&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;runtime&quot;
    &quot;time&quot;

    &quot;golang.org/x/sync/semaphore&quot;
)

var (
    maxWorkers = runtime.GOMAXPROCS(0)
    sema       = semaphore.NewWeighted(int64(maxWorkers)) //信号量
    task       = make([]int, maxWorkers*4)

// 任务数，是worker的四
)

func main() {
    ctx := context.Background()
    for i := range task {
        // 如果没有worker可用，会阻塞在这里，直到某个worker被释放
        if err := sema.Acquire(ctx, 1); err != nil {
            break
        }
        // 启动worker goroutine
        go func(i int) {
            defer sema.Release(1)
            time.Sleep(100 * time.Millisecond) // 模拟一个耗时操作
            task[i] = i + 1
        }(i)
    }
    // 请求所有的worker,这样能确保前面的worker都执行完
    if err := sema.Acquire(ctx, int64(maxWorkers)); err != nil {
        log.Printf(&quot;获取所有的worker失败: %v&quot;, err)
    }
    fmt.Println(maxWorkers, task)
}
</code></pre>
<h3 id="singleflight"><strong>SingleFlight</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#singleflight" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>用于抑制对下游的重复请求</p>
<p>使用场景：访问缓存、数据库等场景，缓存过期时只有一个请求去更新数据库</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;sync/atomic&quot;
    &quot;time&quot;

    &quot;golang.org/x/sync/singleflight&quot;
)

// 模拟从数据库读取
func getArticle(id int) (article string, err error) {
    // 假设这里会对数据库进行调用, 模拟不同并发下耗时不同
    atomic.AddInt32(&amp;count, 1)
    time.Sleep(time.Duration(count) * time.Millisecond)

    return fmt.Sprintf(&quot;article: %d&quot;, id), nil
}

// 模拟优先读缓存，缓存不存在读取数据库，并且只有一个请求读取数据库，其它请求等待
func singleflightGetArticle(sg *singleflight.Group, id int) (string, error) {
    v, err, _ := sg.Do(fmt.Sprintf(&quot;%d&quot;, id), func() (interface{}, error) {
        return getArticle(id)
    })

    return v.(string), err
}

var count int32

func main() {
    time.AfterFunc(1*time.Second, func() {
        atomic.AddInt32(&amp;count, -count)
    })

    var (
        wg  sync.WaitGroup
        now = time.Now()
        n   = 1000
        sg  = &amp;singleflight.Group{}
    )

    for i := 0; i &lt; n; i++ {
        wg.Add(1)
        go func() {
            res, _ := singleflightGetArticle(sg, 1)
            // res, _ := getArticle(1)
            if res != &quot;article: 1&quot; {
                panic(&quot;err&quot;)
            }
            wg.Done()
        }()
    }

    wg.Wait()
    fmt.Printf(&quot;同时发起 %d 次请求，耗时: %s&quot;, n, time.Since(now))
}
</code></pre>
<h1 id="go-有哪些方式安全读写共享变量">Go 有哪些方式安全读写共享变量？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-有哪些方式安全读写共享变量" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>

























<div class="table-container"><table><thead><tr><th>方法</th><th>并发原语</th><th>备注</th></tr></thead><tbody><tr><td>不要修改变量</td><td>sync. Once</td><td>不要去写变量，变量只初始化一次</td></tr><tr><td>只允许一个 goroutine 访问变量</td><td>Channel</td><td>不要通过共享变量来通信，通过通信 (channel)来共享变量</td></tr><tr><td>允许多个 goroutine 访问变量，但是同一时间只允许一个 goroutine 访问</td><td>sync. Mutex、sync. RWMutex、原子操作</td><td>实现锁机制，同时只有一个线程能拿到</td></tr></tbody></table></div>
<h1 id="go-如何排查数据竞争问题">Go 如何排查数据竞争问题？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-如何排查数据竞争问题" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<h2 id="概念-1">概念<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#概念-1" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>只要有两个以上的 goroutine 并发访问同一变量，且至少其中的一个是写操作的时候就会发生数据竞争；全是读的情况下是不存在数据竞争的。</p>
<h2 id="排查方式">排查方式<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#排查方式" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<pre><code>package main

import &quot;fmt&quot;

func main() {
    i := 0

    go func() {
        i++ // write i
    }()

    fmt.Println(i) // read i
}
</code></pre>
<p><code>go 命令行</code>有个参数<code>race</code>可以帮助检测代码中的数据竞争</p>
<pre><code>$ go run -race main.go

WARNING: DATA RACE
Write at 0x00c0000ba008 by goroutine 7:
exit status 66
</code></pre>
<h1 id="go-语言怎么做的连接复用">Go 语言怎么做的连接复用<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-语言怎么做的连接复用" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>Go 的 netpoll 是怎么实现的像阻塞 read 一样去使用底层的非阻塞 read</p>
<p><a href="https://www.cnblogs.com/luozhiyun/p/14390824.html" class="external">Golang的IO多路复用的netpoll模型<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> </p>
<p>Go 语言中 IO 多路复用使用 netpoll 模型
Netpoll 本质上是对 I/O 多路复用技术的封装，所以自然也是和 epoll 一样脱离不了下面几步：</p>
<ol>
<li>Netpoll 创建及其初始化；</li>
<li>向 netpoll 中加入待监控的任务；</li>
<li>从 netpoll 获取触发的事件；
在 go 中对 epoll 提供的三个函数进行了封装</li>
</ol>
<pre><code>func netpollinit()
func netpollopen(fd uintptr, pd *pollDesc) int32
func netpoll(delay int64) gList
</code></pre>
<p>Netpollinit 函数负责初始化 netpoll；
Netpollopen 负责监听文件描述符上的事件；
Netpoll 会阻塞等待返回一组已经准备就绪的 Goroutine；</p>
<h1 id="data-race-问题怎么解决能不能不加锁解决这个问题">Data Race 问题怎么解决？能不能不加锁解决这个问题？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#data-race-问题怎么解决能不能不加锁解决这个问题" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statisticimage-20230724164303002.png" alt="image-20230724164303002"/></p>
<h1 id="runtime-提供常见的方法">runtime 提供常见的方法<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#runtime-提供常见的方法" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<ol>
<li>
<p><strong>Gosched ()</strong>：让当前线程让出 cpu 以让其它线程运行，它不会挂起当前线程，因此当前线程未来会继续执行。</p>
</li>
<li>
<p><strong>NumCPU ()</strong>：返回当前系统的 CPU 核数量。</p>
</li>
<li>
<p><strong>GOMAXPROCS ()</strong>：设置最大的可同时使用的 CPU 核数。</p>
<ol>
<li>通过 runtime. GOMAXPROCS 函数，应用程序可以设置运行时系统中的 P 最大数量。注意，如果在运行期间设置该值的话，会引起“Stop the World”。所以，应在应用程序最早期调用，并且最好是在运行 Go 程序之前设置好操作程序的环境变量 GOMAXPROCS，而不是在程序中调用 runtime. GOMAXPROCS 不能作为函数的参数。</li>
<li>无论我们传递给函数的整数值是什么值，运行时系统的 P 最大值总会在 1~256 之间。</li>
<li>Go 1.8 后，默认让程序运行在多个核上，可以不用设置了。</li>
<li>Go 1.8 前，还是要设置一下，可以更高效的利用 cpu。</li>
</ol>
</li>
<li>
<p><strong>Goexit ()</strong>：退出当前 goroutine（但是 defer 语句会照常执行）。</p>
</li>
<li>
<p><strong>NumGoroutine</strong>：返回正在执行和排队的任务总数。</p>
<ol>
<li>Runtime. NumGoroutine 函数在被调用后，会返回系统中的处于特定状态的 Goroutine 的数量。这里的特定状态是指 GrunnableGruningGsyscallGwaition。处于这些状态的 Goroutine 即被看做是活跃的或者说正在被调度。</li>
<li>注意：垃圾回收所在 Goroutine 的状态也处于这个范围内的话，也会被纳入该计数器。</li>
</ol>
</li>
<li>
<p><strong>GOOS</strong>：查看目标操作系统。很多时候，我们会根据平台的不同实现不同的操作，就可以用 GOOS 来查看自己所在的操作系统。</p>
</li>
<li>
<p><strong>runtime. GC</strong>：会让运行时系统进行一次强制性的垃圾收集。<br/>
强制的垃圾回收：不管怎样，都要进行的垃圾回收。非强制的垃圾回收：只会在一定条件下进行的垃圾回收（即运行时，系统自上次垃圾回收之后新申请的堆内存的单元（也成为单元增量）达到指定的数值）。</p>
</li>
<li>
<p><strong>GOROOT ()</strong>：获取 goroot 目录。</p>
</li>
<li>
<p><strong>runtime. LockOSThread 和 runtime. UnlockOSThread 函数</strong>：前者调用会使调用他的 Goroutine 与当前运行它的 M 锁定到一起，后者调用会解除这样的锁定。</p>
</li>
</ol></article></div><div class="right sidebar"><div class="darkmode"><input class="toggle" id="darkmode-toggle" type="checkbox" tabindex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35" xml:space="preserve"><title>Dark mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100" xml:space="preserve"><title>Light mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div><div class="toc desktop-only"><button type="button" id="toc" class><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#go-语言怎么支持的并发请求" data-for="go-语言怎么支持的并发请求">go 语言怎么支持的并发请求</a></li><li class="depth-0"><a href="#go-常用的并发模型" data-for="go-常用的并发模型">Go 常用的并发模型？</a></li><li class="depth-1"><a href="#线程间通信方式" data-for="线程间通信方式">线程间通信方式</a></li><li class="depth-2"><a href="#共享内存" data-for="共享内存">共享内存</a></li><li class="depth-2"><a href="#发送消息" data-for="发送消息">发送消息</a></li><li class="depth-1"><a href="#共享内存并发模型" data-for="共享内存并发模型">共享内存并发模型</a></li><li class="depth-1"><a href="#csp-并发模型" data-for="csp-并发模型">CSP 并发模型</a></li><li class="depth-0"><a href="#go-为啥使用-csp-模型来实现并发" data-for="go-为啥使用-csp-模型来实现并发">Go 为啥使用 CSP 模型来实现并发?</a></li><li class="depth-0"><a href="#有没有什么线程安全的办法" data-for="有没有什么线程安全的办法">有没有什么线程安全的办法？</a></li><li class="depth-0"><a href="#select-可以用于什么" data-for="select-可以用于什么">select 可以用于什么</a></li><li class="depth-1"><a href="#select-死锁" data-for="select-死锁">select 死锁</a></li><li class="depth-1"><a href="#空-select" data-for="空-select">空 select{}</a></li><li class="depth-1"><a href="#select-和-for-结合使用" data-for="select-和-for-结合使用">select 和 for 结合使用</a></li><li class="depth-2"><a href="#使用-goto-跳出循环" data-for="使用-goto-跳出循环">使用 goto 跳出循环</a></li><li class="depth-2"><a href="#使用标签" data-for="使用标签">使用标签</a></li><li class="depth-1"><a href="#select-实现超时机制" data-for="select-实现超时机制">select 实现超时机制</a></li><li class="depth-0"><a href="#select-底层原理" data-for="select-底层原理">Select 底层原理</a></li><li class="depth-1"><a href="#数据结构" data-for="数据结构">数据结构</a></li><li class="depth-0"><a href="#go-有哪些并发同步原语" data-for="go-有哪些并发同步原语">Go 有哪些并发同步原语？</a></li><li class="depth-1"><a href="#原子操作" data-for="原子操作">原子操作</a></li><li class="depth-2"><a href="#概念" data-for="概念">概念</a></li><li class="depth-2"><a href="#使用场景" data-for="使用场景">使用场景</a></li><li class="depth-2"><a href="#常见操作" data-for="常见操作">常见操作</a></li><li class="depth-2"><a href="#go-原子操作和锁的区别" data-for="go-原子操作和锁的区别">Go 原子操作和锁的区别？</a></li><li class="depth-1"><a href="#channel" data-for="channel">Channel</a></li><li class="depth-1"><a href="#基本并发原语" data-for="基本并发原语">基本并发原语</a></li><li class="depth-2"><a href="#sync-mutex" data-for="sync-mutex">sync. Mutex</a></li><li class="depth-2"><a href="#sync-rwmutex" data-for="sync-rwmutex">sync. RWMutex</a></li><li class="depth-2"><a href="#sync-waitgroup" data-for="sync-waitgroup">sync. WaitGroup</a></li><li class="depth-2"><a href="#sync-cond" data-for="sync-cond">sync. Cond</a></li><li class="depth-2"><a href="#sync-once" data-for="sync-once">sync. Once</a></li><li class="depth-2"><a href="#sync-pool" data-for="sync-pool">sync. Pool</a></li><li class="depth-2"><a href="#sync-map" data-for="sync-map">sync. Map</a></li><li class="depth-1"><a href="#扩展并发原语" data-for="扩展并发原语">扩展并发原语</a></li><li class="depth-2"><a href="#errgroup" data-for="errgroup">ErrGroup</a></li><li class="depth-2"><a href="#semaphore" data-for="semaphore">Semaphore</a></li><li class="depth-2"><a href="#singleflight" data-for="singleflight">SingleFlight</a></li><li class="depth-0"><a href="#go-有哪些方式安全读写共享变量" data-for="go-有哪些方式安全读写共享变量">Go 有哪些方式安全读写共享变量？</a></li><li class="depth-0"><a href="#go-如何排查数据竞争问题" data-for="go-如何排查数据竞争问题">Go 如何排查数据竞争问题？</a></li><li class="depth-1"><a href="#概念-1" data-for="概念-1">概念</a></li><li class="depth-1"><a href="#排查方式" data-for="排查方式">排查方式</a></li><li class="depth-0"><a href="#go-语言怎么做的连接复用" data-for="go-语言怎么做的连接复用">Go 语言怎么做的连接复用</a></li><li class="depth-0"><a href="#data-race-问题怎么解决能不能不加锁解决这个问题" data-for="data-race-问题怎么解决能不能不加锁解决这个问题">Data Race 问题怎么解决？能不能不加锁解决这个问题？</a></li><li class="depth-0"><a href="#runtime-提供常见的方法" data-for="runtime-提供常见的方法">runtime 提供常见的方法</a></li></ul></div></div><div class="graph"><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:false}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xml:space="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:true}"></div></div></div><div class="backlinks"><h3>Backlinks</h3><ul class="overflow"><li>No backlinks found</li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.2.3</a> © 2024</p><ul><li><a href="https://github.com/googoo-s">GitHub</a></li></ul></footer></div></body><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js" type="application/javascript"></script><script type="application/javascript">function c(){let t=this.parentElement;t.classList.toggle("is-collapsed");let l=t.classList.contains("is-collapsed")?this.scrollHeight:t.scrollHeight;t.style.maxHeight=l+"px";let o=t,e=t.parentElement;for(;e;){if(!e.classList.contains("callout"))return;let n=e.classList.contains("is-collapsed")?e.scrollHeight:e.scrollHeight+o.scrollHeight;e.style.maxHeight=n+"px",o=e,e=e.parentElement}}function i(){let t=document.getElementsByClassName("callout is-collapsible");for(let s of t){let l=s.firstElementChild;if(l){l.addEventListener("click",c),window.addCleanup(()=>l.removeEventListener("click",c));let e=s.classList.contains("is-collapsed")?l.scrollHeight:s.scrollHeight;s.style.maxHeight=e+"px"}}}document.addEventListener("nav",i);window.addEventListener("resize",i);
</script><script type="module">
          let mermaidImport = undefined
          document.addEventListener('nav', async () => {
            if (document.querySelector("code.mermaid")) {
              mermaidImport ||= await import('https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.7.0/mermaid.esm.min.mjs')
              const mermaid = mermaidImport.default
              const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
              mermaid.initialize({
                startOnLoad: false,
                securityLevel: 'loose',
                theme: darkMode ? 'dark' : 'default'
              })

              await mermaid.run({
                querySelector: '.mermaid'
              })
            }
          });
          </script><script src="../../postscript.js" type="module"></script></html>