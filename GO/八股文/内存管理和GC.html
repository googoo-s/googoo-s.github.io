<!DOCTYPE html>
<html lang="en"><head><title>内存管理</title><meta charset="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Schibsted Grotesk:wght@400;700&amp;family=Source Sans Pro:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="内存管理"/><meta property="og:description" content="内存管理 Golang 的内存模型，为什么小对象多了会造成 gc 压力。 通常小对象过多会导致 GC 三色法消耗过多的 GPU。优化思路是，减少对象分配。 Go 语言什么时候垃圾回收，写代码的时候如何减少对象分配 当 goroutine 申请新的内存管理单元时触发垃圾回收。 写代码的时候如何减少对象分配，这是一个关于性能的问题， ..."/><meta property="og:image" content="https://googoo-s.github.io/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../../static/icon.png"/><meta name="description" content="内存管理 Golang 的内存模型，为什么小对象多了会造成 gc 压力。 通常小对象过多会导致 GC 三色法消耗过多的 GPU。优化思路是，减少对象分配。 Go 语言什么时候垃圾回收，写代码的时候如何减少对象分配 当 goroutine 申请新的内存管理单元时触发垃圾回收。 写代码的时候如何减少对象分配，这是一个关于性能的问题， ..."/><meta name="generator" content="Quartz"/><link href="../../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><script src="../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch("../../static/contentIndex.json").then(data => data.json())</script></head><body data-slug="GO/八股文/内存管理和GC"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title"><a href="../..">googoo-s</a></h1><div class="spacer mobile-only"></div><div class="search"><div id="search-icon"><p>Search</p><div></div><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="search-layout" data-preview="true"></div></div></div></div><div class="darkmode"><input class="toggle" id="darkmode-toggle" type="checkbox" tabindex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35" xml:space="preserve"><title>Dark mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100" xml:space="preserve"><title>Light mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div><div class="explorer desktop-only"><button type="button" id="explorer" data-behavior="collapse" data-collapsed="collapsed" data-savestate="true" data-tree="[{&quot;path&quot;:&quot;awesome&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;elastic&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;GO&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;GO/八股文&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;GO/并发编程&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;GO/并发编程/Channel&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;GO/并发编程/分布式并发原语&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;GO/并发编程/原子操作&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;GO/并发编程/基础并发原语&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;GO/并发编程/扩展并发原语&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Java&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Java/netty&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Java/Spring&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Java/Spring/Spring-cloud&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;journal&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;lua&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;lua/用Go实现Lua&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Obsidian&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;zookeeper&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;分布式高并发高性能高可用&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;分布式高并发高性能高可用/日志&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;分布式高并发高性能高可用/监控&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;工具和环境&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;工具和环境/emacs&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;工具和环境/git&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;工具和环境/msys2&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;消息队列&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;消息队列/Pulsar&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;系统设计&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;系统设计/场景题&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;资源&quot;,&quot;collapsed&quot;:true}]"><h1>Explorer</h1><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="explorer-content"><ul class="overflow" id="explorer-ul"><li><div class="folder-outer open"><ul style="padding-left:0;" class="content" data-folderul><li><div class="folder-outer "><ul style="padding-left:0;" class="content" data-folderul></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="awesome"><button class="folder-button"><span class="folder-title">awesome</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="awesome"><li><a href="../../awesome/JavaGuide-知识星球优质主题汇总" data-for="awesome/JavaGuide-知识星球优质主题汇总">JavaGuide 知识星球优质主题汇总</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="elastic"><button class="folder-button"><span class="folder-title">elastic</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="elastic"><li><a href="../../elastic/KQL" data-for="elastic/KQL">KQL</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="GO"><button class="folder-button"><span class="folder-title">GO</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="GO"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="GO/八股文"><button class="folder-button"><span class="folder-title">八股文</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="GO/八股文"><li><a href="../../GO/八股文/Context" data-for="GO/八股文/Context">Context</a></li><li><a href="../../GO/八股文/Golang基础" data-for="GO/八股文/Golang基础">Golang基础</a></li><li><a href="../../GO/八股文/Map-和Sync.map" data-for="GO/八股文/Map-和Sync.map">Map</a></li><li><a href="../../GO/八股文/Slice" data-for="GO/八股文/Slice">Slice</a></li><li><a href="../../GO/八股文/内存管理和GC" data-for="GO/八股文/内存管理和GC">内存管理</a></li><li><a href="../../GO/八股文/并发" data-for="GO/八股文/并发">并发</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="GO/并发编程"><button class="folder-button"><span class="folder-title">并发编程</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="GO/并发编程"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="GO/并发编程/Channel"><button class="folder-button"><span class="folder-title">Channel</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="GO/并发编程/Channel"><li><a href="../../GO/并发编程/Channel/channel" data-for="GO/并发编程/Channel/channel">channel</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="GO/并发编程/分布式并发原语"><button class="folder-button"><span class="folder-title">分布式并发原语</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="GO/并发编程/分布式并发原语"><li><a href="../../GO/并发编程/分布式并发原语/Leader选举互斥锁和读写锁" data-for="GO/并发编程/分布式并发原语/Leader选举互斥锁和读写锁">Leader选举互斥锁和读写锁</a></li><li><a href="../../GO/并发编程/分布式并发原语/队列、栅栏和STM" data-for="GO/并发编程/分布式并发原语/队列、栅栏和STM">队列、栅栏和STM</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="GO/并发编程/原子操作"><button class="folder-button"><span class="folder-title">原子操作</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="GO/并发编程/原子操作"><li><a href="../../GO/并发编程/原子操作/atomic" data-for="GO/并发编程/原子操作/atomic">atomic</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="GO/并发编程/基础并发原语"><button class="folder-button"><span class="folder-title">基础并发原语</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="GO/并发编程/基础并发原语"><li><a href="../../GO/并发编程/基础并发原语/Cond" data-for="GO/并发编程/基础并发原语/Cond">Cond</a></li><li><a href="../../GO/并发编程/基础并发原语/Context" data-for="GO/并发编程/基础并发原语/Context">Context</a></li><li><a href="../../GO/并发编程/基础并发原语/map" data-for="GO/并发编程/基础并发原语/map">map</a></li><li><a href="../../GO/并发编程/基础并发原语/Mutex" data-for="GO/并发编程/基础并发原语/Mutex">Mutex</a></li><li><a href="../../GO/并发编程/基础并发原语/Once" data-for="GO/并发编程/基础并发原语/Once">Once</a></li><li><a href="../../GO/并发编程/基础并发原语/Pool" data-for="GO/并发编程/基础并发原语/Pool">Pool</a></li><li><a href="../../GO/并发编程/基础并发原语/RWMutex" data-for="GO/并发编程/基础并发原语/RWMutex">RWMutex</a></li><li><a href="../../GO/并发编程/基础并发原语/WaitGroup" data-for="GO/并发编程/基础并发原语/WaitGroup">WaitGroup</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="GO/并发编程/扩展并发原语"><button class="folder-button"><span class="folder-title">扩展并发原语</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="GO/并发编程/扩展并发原语"><li><a href="../../GO/并发编程/扩展并发原语/Semaphore-信号量" data-for="GO/并发编程/扩展并发原语/Semaphore-信号量">Semaphore-信号量</a></li><li><a href="../../GO/并发编程/扩展并发原语/SingleFlight-和-CyclicBarrier-请求合并和循环栅栏" data-for="GO/并发编程/扩展并发原语/SingleFlight-和-CyclicBarrier-请求合并和循环栅栏">SingleFlight 和 CyclicBarrier-请求合并和循环栅栏</a></li><li><a href="../../GO/并发编程/扩展并发原语/分组操作" data-for="GO/并发编程/扩展并发原语/分组操作">分组操作</a></li></ul></div></li><li><a href="../../GO/并发编程/开篇词" data-for="GO/并发编程/开篇词">开篇词</a></li></ul></div></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="Java"><button class="folder-button"><span class="folder-title">Java</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="Java"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="Java/netty"><button class="folder-button"><span class="folder-title">netty</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="Java/netty"><li><a href="../../Java/netty/1.-概念和体系结构" data-for="Java/netty/1.-概念和体系结构">1. 概念和体系结构</a></li><li><a href="../../Java/netty/BootStrap" data-for="Java/netty/BootStrap">BootStrap</a></li><li><a href="../../Java/netty/ByteBuf" data-for="Java/netty/ByteBuf">ByteBuf</a></li><li><a href="../../Java/netty/ChannelHandler、ChannelPipeline、ChannelContext" data-for="Java/netty/ChannelHandler、ChannelPipeline、ChannelContext">ChannelHandler、ChannelPipeline、ChannelContext</a></li><li><a href="../../Java/netty/EventLoop-和线程模型" data-for="Java/netty/EventLoop-和线程模型">EventLoop 和线程模型</a></li><li><a href="../../Java/netty/传输和Channel" data-for="Java/netty/传输和Channel">传输和Channel</a></li><li><a href="../../Java/netty/编解码器" data-for="Java/netty/编解码器">编解码器</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="Java/Spring"><button class="folder-button"><span class="folder-title">Spring</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="Java/Spring"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="Java/Spring/Spring-cloud"><button class="folder-button"><span class="folder-title">Spring cloud</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="Java/Spring/Spring-cloud"><li><a href="../../Java/Spring/Spring-cloud/spring-cloud-alibaba" data-for="Java/Spring/Spring-cloud/spring-cloud-alibaba">spring cloud alibaba</a></li></ul></div></li></ul></div></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="journal"><button class="folder-button"><span class="folder-title">journal</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="journal"><li><a href="../../journal/2023-07-25" data-for="journal/2023-07-25">2023-07-25</a></li><li><a href="../../journal/2023-07-26" data-for="journal/2023-07-26">2023-07-26</a></li><li><a href="../../journal/2023-07-27" data-for="journal/2023-07-27">2023-07-27</a></li><li><a href="../../journal/2023-07-31" data-for="journal/2023-07-31">2023-07-31</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="lua"><button class="folder-button"><span class="folder-title">lua</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="lua"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="lua/用Go实现Lua"><button class="folder-button"><span class="folder-title">用Go实现Lua</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="lua/用Go实现Lua"><li><a href="../../lua/用Go实现Lua/1.二进制Chunk" data-for="lua/用Go实现Lua/1.二进制Chunk">1.二进制Chunk</a></li><li><a href="../../lua/用Go实现Lua/2.指令集" data-for="lua/用Go实现Lua/2.指令集">2.指令集</a></li><li><a href="../../lua/用Go实现Lua/3.lua-API" data-for="lua/用Go实现Lua/3.lua-API">3.lua API</a></li><li><a href="../../lua/用Go实现Lua/前言" data-for="lua/用Go实现Lua/前言">前言</a></li></ul></div></li><li><a href="../../lua/lua基础" data-for="lua/lua基础">lua基础</a></li><li><a href="../../lua/Lua高级" data-for="lua/Lua高级">Lua高级</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="Obsidian"><button class="folder-button"><span class="folder-title">Obsidian</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="Obsidian"><li><a href="../../Obsidian/dataview" data-for="Obsidian/dataview">dataview</a></li><li><a href="../../Obsidian/excalidraw" data-for="Obsidian/excalidraw">excalidraw</a></li><li><a href="../../Obsidian/Front-Matter" data-for="Obsidian/Front-Matter">Front Matter</a></li><li><a href="../../Obsidian/obsidian-overview" data-for="Obsidian/obsidian-overview">obsidian overview</a></li><li><a href="../../Obsidian/Obsidian-plugin" data-for="Obsidian/Obsidian-plugin">Obsidian-plugin</a></li><li><a href="../../Obsidian/publish" data-for="Obsidian/publish">publish</a></li><li><a href="../../Obsidian/template" data-for="Obsidian/template">template</a></li><li><a href="../../Obsidian/使用quartz发布obsidian--vault" data-for="Obsidian/使用quartz发布obsidian--vault">使用quartz发布obsidian  vault</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="zookeeper"><button class="folder-button"><span class="folder-title">zookeeper</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="zookeeper"><li><a href="../../zookeeper/Zookeeper-教程" data-for="zookeeper/Zookeeper-教程">Zookeeper 教程</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="分布式高并发高性能高可用"><button class="folder-button"><span class="folder-title">分布式高并发高性能高可用</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="分布式高并发高性能高可用"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="分布式高并发高性能高可用/日志"><button class="folder-button"><span class="folder-title">日志</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="分布式高并发高性能高可用/日志"><li><a href="../../分布式高并发高性能高可用/日志/服务治理：分布式下如何进行日志管理？" data-for="分布式高并发高性能高可用/日志/服务治理：分布式下如何进行日志管理？">服务治理：分布式下如何进行日志管理？</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="分布式高并发高性能高可用/监控"><button class="folder-button"><span class="folder-title">监控</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="分布式高并发高性能高可用/监控"><li><a href="../../分布式高并发高性能高可用/监控/服务治理：监控系统如何做？" data-for="分布式高并发高性能高可用/监控/服务治理：监控系统如何做？">服务治理：监控系统如何做？</a></li></ul></div></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="工具和环境"><button class="folder-button"><span class="folder-title">工具和环境</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="工具和环境"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="工具和环境/emacs"><button class="folder-button"><span class="folder-title">emacs</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="工具和环境/emacs"><li><a href="../../工具和环境/emacs/安装" data-for="工具和环境/emacs/安装">安装</a></li><li><a href="../../工具和环境/emacs/快捷键" data-for="工具和环境/emacs/快捷键">快捷键</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="工具和环境/git"><button class="folder-button"><span class="folder-title">git</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="工具和环境/git"><li><a href="../../工具和环境/git/git" data-for="工具和环境/git/git">git</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="工具和环境/msys2"><button class="folder-button"><span class="folder-title">msys2</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="工具和环境/msys2"><li><a href="../../工具和环境/msys2/pacman" data-for="工具和环境/msys2/pacman">pacman</a></li></ul></div></li><li><a href="../../工具和环境/工具" data-for="工具和环境/工具">工具</a></li><li><a href="../../工具和环境/环境搭建" data-for="工具和环境/环境搭建">环境搭建</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="消息队列"><button class="folder-button"><span class="folder-title">消息队列</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="消息队列"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="消息队列/Pulsar"><button class="folder-button"><span class="folder-title">Pulsar</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="消息队列/Pulsar"><li><a href="../../消息队列/Pulsar/1.Pulsar概述" data-for="消息队列/Pulsar/1.Pulsar概述">1.Pulsar概述</a></li><li><a href="../../消息队列/Pulsar/2.doccker-中启动-standalone-Pulsar" data-for="消息队列/Pulsar/2.doccker-中启动-standalone-Pulsar">2.doccker 中启动 standalone Pulsar</a></li></ul></div></li><li><a href="../../消息队列/消息队列对比" data-for="消息队列/消息队列对比">消息队列对比</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="系统设计"><button class="folder-button"><span class="folder-title">系统设计</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="系统设计"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="系统设计/场景题"><button class="folder-button"><span class="folder-title">场景题</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="系统设计/场景题"><li><a href="../../系统设计/场景题/如何" data-for="系统设计/场景题/如何">如何</a></li><li><a href="../../系统设计/场景题/如何设计一个排行榜？" data-for="系统设计/场景题/如何设计一个排行榜？">如何设计一个排行榜？</a></li></ul></div></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="资源"><button class="folder-button"><span class="folder-title">资源</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="资源"><li><a href="../../资源/资源汇总" data-for="资源/资源汇总">资源汇总</a></li></ul></div></li></ul></div></li><li id="explorer-end"></li></ul></div></div></div><div class="center"><div class="page-header"><div class="popover-hint"><nav class="breadcrumb-container" aria-label="breadcrumbs"><div class="breadcrumb-element"><a href="../../">Home</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../../GO/">GO</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../../GO/八股文/">八股文</a><p> ❯ </p></div><div class="breadcrumb-element"><a href>内存管理</a></div></nav><h1 class="article-title">内存管理</h1><p show-comma="true" class="content-meta"><span>Feb 26, 2024</span><span>65 min read</span></p><ul class="tags"><li><a href="../../tags/GO/八股文" class="internal tag-link">GO/八股文</a></li></ul></div></div><article class="popover-hint"><h1 id="内存管理">内存管理<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#内存管理" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<h2 id="golang-的内存模型为什么小对象多了会造成-gc-压力">Golang 的内存模型，为什么小对象多了会造成 gc 压力。<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#golang-的内存模型为什么小对象多了会造成-gc-压力" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>通常小对象过多会导致 GC 三色法消耗过多的 GPU。优化思路是，减少对象分配。</p>
<h2 id="go-语言什么时候垃圾回收写代码的时候如何减少对象分配">Go 语言什么时候垃圾回收，写代码的时候如何减少对象分配<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-语言什么时候垃圾回收写代码的时候如何减少对象分配" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>当 <strong>goroutine 申请新的内存管理单元时触发垃圾回收</strong>。</p>
<p>写代码的时候如何减少对象分配，这是一个关于性能的问题，</p>
<ul>
<li>
<p>例如如果需要把数字转换成字符串，使用 strconv.Itoa () 比 fmt.Sprintf () 要快一倍左右。</p>
</li>
<li>
<p>如果需要把数字转换成字符串，使用 strconv.Itoa () 比 fmt.Sprintf () 要快一倍左右。这里就不一一展开了。</p>
</li>
</ul>
<h2 id="给大家丢脸了用了三年-golang我还是没答对这道内存泄漏题">给大家丢脸了，用了三年 Golang，我还是没答对这道内存泄漏题<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#给大家丢脸了用了三年-golang我还是没答对这道内存泄漏题" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzkxNTU5MjE0MQ==&amp;mid=2247492761&amp;idx=1&amp;sn=7b3660c3da402fa7f4c49b1ca8048f22&amp;source=41#wechat_redirect" class="external">https://mp.weixin.qq.com/s?__biz=MzkxNTU5MjE0MQ==&amp;mid=2247492761&amp;idx=1&amp;sn=7b3660c3da402fa7f4c49b1ca8048f22&amp;source=41#wechat_redirect<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></p>
<h2 id="go-内存泄漏不是那么简单">Go 内存泄漏？不是那么简单<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-内存泄漏不是那么简单" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><a href="https://colobu.com/2019/08/28/go-memory-leak-i-dont-think-so/" class="external">https://colobu.com/2019/08/28/go-memory-leak-i-dont-think-so/<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> </p>
<h2 id="go-内存分配和-tcmalloc-的区别">Go 内存分配，和 tcmalloc 的区别?<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-内存分配和-tcmalloc-的区别" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<h3 id="go-内存分配">GO 内存分配<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-内存分配" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>Go 内存分配核心思想就是把内存分为多级管理，从而降低锁的粒度。</p>
<p>它将可用的堆内存采用二级分配的方式进行管理：<strong>每个线程都会自行维护一个独立的内存池，进行内存分配时优先从该内存池中分配，当内存池不足时才会向全局内存池申请，以避免不同线程对全局内存池的频繁竞争</strong>。</p>
<ul>
<li>Go 在程序启动时，会向操作系统申请一大块内存，之后自行管理。</li>
<li>Go 内存管理的基本单元是 mspan，它由若干个页组成，每种 mspan 可以分配特定大小的 object。</li>
<li>Mcache, mcentral, mheap 是 Go 内存管理的三大组件，层层递进。
<ul>
<li>Mcache 管理线程在本地缓存的 mspan；</li>
<li>mcentral 管理全局的 mspan 供所有线程使用；</li>
<li>mheap 管理 Go 的所有动态分配内存。</li>
</ul>
</li>
<li>分配对象
<ul>
<li>极小的对象 (<span>⇐</span>16B)会分配在一个 object 中，以节省资源，使用 tiny 分配器分配内存；</li>
<li>一般对象(16B-32KB)通过 mspan 分配内存；</li>
<li>大对象(>32 KB)则直接由 mheap 分配内存。</li>
</ul>
</li>
</ul>
<h3 id="tcmalloc"><strong>tcmalloc</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#tcmalloc" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>Tcmalloc 是 google 开发的内存分配算法库，最开始它是作为 google 的一个性能工具库 perftools 的一部分。TCMalloc 是用来替代传统的 malloc 内存分配函数。它有减少内存碎片，适用于多核，更好的并行性支持等特性。<br/>
<strong>TC 就是 Thread Cache 两英文的简写</strong>。它提供了很多优化，如：</p>
<ol>
<li>TCMalloc 用<strong>固定大小的 page (页)来执行内存获取、分配等操作</strong>。这个特性跟 Linux 物理内存页的划分是不是有同样的道理。
<ol>
<li>TCMalloc 用固定大小的对象，比如 8 KB，16 KB 等用于特定大小对象的内存分配，这对于内存获取或释放等操作都带来了简化的作用。</li>
</ol>
</li>
<li>TCMalloc 还<strong>利用缓存常用对象来提高获取内存的速度</strong>。</li>
<li>TCMalloc 还可以<strong>基于每个线程或者每个 CPU 来设置缓存大小</strong>，这是默认设置。
<ol>
<li>TCMalloc 基于每个线程独立设置缓存分配策略，减少了多线程之间锁的竞争。</li>
</ol>
</li>
</ol>
<p>Go 中的内存分类并不像 TCMalloc 那样分成小、中、大对象，但是它的小对象里又细分了一个 Tiny 对象，Tiny 对象指大小在 1 Byte 到 16 Byte 之间并且不包含指针的对象。小对象和大对象只用大小划定，无其他区分。</p>
<p>Go 内存管理与 tcmalloc 最大的不同在于，<strong>它提供了逃逸分析和垃圾回收机制。</strong></p>
<h2 id="go-语言中的堆和栈">Go 语言中的堆和栈<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-语言中的堆和栈" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<ul>
<li>
<p><strong>栈主要用来存储值类型的数据</strong>，如<strong>整数、浮点数、布尔值</strong>等。因为值类型的数据大小是固定的，所以可以直接分配在栈上，访问速度非常快。</p>
</li>
<li>
<p><strong>堆主要用来存储引用类型的数据</strong>，如字<strong>符串、切片、字典</strong>等。因<strong>为引用类型的数据大小是不固定的，所以需要动态分配内存，通常在堆上进行</strong>。同时，由于引用类型的数据通常需要共享和修改，因此使用指针来进行引用和操作，从而避免了复制大量的数据。</p>
</li>
</ul>
<p>可以看出，栈的性能会更好——<strong>不需要额外的垃圾回收机制</strong>（离开该作用域，它们的内存就会被自动回收），<strong>CPU 可以连续缓存</strong>（内存空间是连续的）。堆是通过<strong>GC 回收内存</strong>的。</p>
<h1 id="go-内存分配机制">Go 内存分配机制？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-内存分配机制" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>Go 语言内置运行时（就是 runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。</p>
<h2 id="操作系统的内存管理">操作系统的内存管理<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#操作系统的内存管理" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<h3 id="操作系统存储模型"> 操作系统存储模型<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#操作系统存储模型" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240227194910.png" alt="image.png"/></p>
<p>观察上图，我们可以从中捕捉到的关键词是：</p>
<ul>
<li>
<p>多级模型</p>
</li>
<li>
<p>动态切换</p>
</li>
</ul>
<h3 id="虚拟内存与物理内存">虚拟内存与物理内存<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#虚拟内存与物理内存" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240227194940.png" alt="image.png"/></p>
<p>操作系统内存管理中，另一个重要概念是虚拟内存，其作用如下：</p>
<ul>
<li>
<p>在用户与硬件间添加中间代理层（没有什么是加一个中间层解决不了的）</p>
</li>
<li>
<p> 优化用户体验（进程感知到获得的内存空间是“连续”的）</p>
</li>
<li>
<p> “放大”可用内存（虚拟内存可以由物理内存+磁盘补足，并根据冷热动态置换，用户无感知）</p>
</li>
</ul>
<h3 id="分页管理"> 分页管理<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#分页管理" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>操作系统中通常会将虚拟内存和物理内存切割成固定的尺寸，于虚拟内存而言叫作“页”，于物理内存而言叫作“帧”，原因及要点如下：</p>
<ul>
<li>
<p>提高内存空间利用（以页为粒度后，消灭了不稳定的外部碎片，取而代之的是相对可控的内部碎片）</p>
</li>
<li>
<p> 提高内外存交换效率（更细的粒度带来了更高的灵活度）</p>
</li>
<li>
<p> 与虚拟内存机制呼应，便于建立虚拟地址<span>→</span>物理地址的映射关系（聚合映射关系的数据结构，称为页表）</p>
</li>
<li>
<p> linux 页/帧的大小固定，为 4KB（这实际是由实践推动的经验值，太粗会增加碎片率，太细会增加分配频率影响效率）</p>
</li>
</ul>
<h2 id="go-内存模型设计思想">GO 内存模型设计思想<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-内存模型设计思想" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<ul>
<li>内存分配算法采用 Google 的 <code>TCMalloc算法</code>，<strong>每个线程都会自行维护一个独立的内存池</strong>，进行内存分配时优先从该内存池中分配，当内存池不足时才会向加锁向全局内存池申请，减少系统调用并且避免不同线程对全局内存池的锁竞争</li>
<li>把内存切分的非常的细小，<strong>分为多级管理</strong>，以降低锁的粒度</li>
<li>回收对象内存时，并没有将其真正释放掉，只是放<strong>回预先分配的大块内存中</strong>，以便复用。只有内存闲置过多的时候，才会尝试归还部分内存给操作系统，降低整体开销</li>
</ul>
<p>具体来说</p>
<ol>
<li>以空间换时间，一次缓存，多次复用</li>
</ol>
<p>由于<strong>每次向操作系统申请内存的操作很重，那么不妨一次多申请一些</strong>，以备后用.</p>
<p>Golang 中的堆 mheap 正是基于该思想，产生的数据结构. 我们可以从两个视角来解决 Golang 运行时的堆：</p>
<ul>
<li>
<p>I 对操作系统而言，这是用户进程中缓存的内存</p>
</li>
<li>
<p>II 对于 Go 进程内部，堆是所有对象的内存起源</p>
</li>
</ul>
<ol start="2">
<li> 多级缓存，实现无/细锁化</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZuXibKvib2fj2vlIia93waBCNwL6syk6puNxa0Wx0XfnO48n3o4AM8MNRSicNOcDp3Q9Eicib2j7BIibkqEA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"/></p>
<p>堆是 Go 运行时中最大的临界共享资源，这意味着<strong>每次存取都要加锁</strong>，在性能层面是一件很可怕的事情.</p>
<p>在解决这个问题，Golang 在堆 mheap 之上，依次细化粒度，建立了 mcentral、mcache 的模型，下面对三者作个梳理：</p>
<ul>
<li>
<p>mheap：全局的内存起源，访问要加全局锁</p>
</li>
<li>
<p>mcentral：每种对象大小规格（全局共划分为 68 种）对应的缓存，锁的粒度也仅限于同一种规格以内</p>
</li>
<li>
<p> mcache：每个 P（正是 GMP 中的 P）持有一份的内存缓存，访问时无锁</p>
</li>
</ul>
<p>这些概念，我们在第 2 节中都会再作详细展开，此处可以先不深究，注重于宏观架构即可.</p>
<ul>
<li> 多级规格，提高利用率</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZuXibKvib2fj2vlIia93waBCNwkDibfnBcJn5nOCyDic2gHABzy2TKIKrqN27Nnw3jXrudGb8rcYIjcHCQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"/></p>
<p>首先理下 page 和 mspan 两个概念：</p>
<p>（1）page：最小的存储单元.</p>
<p>Golang 借鉴操作系统分页管理的思想，每个最小的存储单元也称之为页 page，但大小为 8 KB</p>
<p>（2）mspan：最小的管理单元.</p>
<p>mspan 大小为 page 的整数倍，且从 8B 到 80 KB 被划分为 67 种不同的规格，分配对象时，会根据大小映射到不同规格的 mspan，从中获取空间.</p>
<p>于是，我们回头小节多规格 mspan 下产生的特点：</p>
<ul>
<li>
<p>I 根据规格大小，产生了等级的制度</p>
</li>
<li>
<p>II 消除了外部碎片，但不可避免会有内部碎片</p>
</li>
<li>
<p>III 宏观上能提高整体空间利用率</p>
</li>
<li>
<p>IV 正是因为有了规格等级的概念，才支持 mcentral 实现细锁化</p>
</li>
</ul>
<ol start="4">
<li>• 全局总览，留个印象</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZuXibKvib2fj2vlIia93waBCNwkd8rJZ9b0h745aibfNReUePg2bqzT4ibrB6rrxzlzf6fMZnXib87O5o4w/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"/></p>
<p>上图是 Thread-Caching Malloc 的整体架构图，Golang 正是借鉴了该内存模型. 我们先看眼架构，有个整体概念，后续小节中，我们会不断对细节进行补充.</p>
<h2 id="分配组件">分配组件<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#分配组件" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Go 的内存管理组件主要有：<code>mspan</code>、<code>mcache</code>、<code>mcentral</code> 和 <code>mheap</code>
<img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226003340.png" alt="image.png"/></p>
<h2 id="内存管理单元mspan">内存管理单元：mspan<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#内存管理单元mspan" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240227195526.png" alt="image.png"/></p>
<ul>
<li>
<p> mspan 是 Golang 内存管理的最小单元，该结构体中包含 <code>next</code> 和 <code>prev</code> 两个字段，它们分别指向了前一个和后一个 mspan</p>
</li>
<li>
<p>mspan 大小是 page 的整数倍（Go 中的 page 大小为 8KB），且内部的页是连续的（至少在虚拟内存的视角中是这样），这里的页不是操作系统中的内存页，它们是操作系统内存页的整数倍。</p>
</li>
<li>
<p> 每个 mspan 根据空间大小以及面向分配对象的大小，会被划分为不同的等级（2.2小节展开）</p>
</li>
<li>
<p> 同等级的 mspan 会从属同一个 mcentral，最终会被组织成链表，因此带有前后指针（prev、next）</p>
</li>
<li>
<p> 由于同等级的 mspan 内聚于同一个 mcentral，所以会基于同一把互斥锁管理</p>
</li>
<li>
<p> mspan 会基于 <strong>bitMap 辅助快速找到空闲内存块</strong>（块大小为对应等级下的 object 大小），此时需要使用到 <strong>Ctz64 算法</strong>.</p>
</li>
</ul>
<p><code>page</code> 是内存存储的基本单元，“对象”放到 <code>page</code> 中</p>
<pre><code>type mspan struct {
    // 标识前后节点的指针 
    next *mspan     
    prev *mspan    
    // ...
    // 起始地址
    startAddr uintptr 
    // 包含几页，页是连续的
    npages    uintptr 


    // 标识此前的位置都已被占用 
    freeindex uintptr
    // 最多可以存放多少个 object
    nelems uintptr // number of object in the span.


    // bitmap 每个 bit 对应一个 object 块，标识该块是否已被占用
    allocCache uint64
    // ...
    // 标识 mspan 等级，包含 class 和 noscan 两部分信息
    spanclass             spanClass    
    // ...
}
</code></pre>
<h2 id="内存单元等级-spanclass">内存单元等级 spanClass<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#内存单元等级-spanclass" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Go 有 68 种不同大小的 spanClass，用于小对象的分配</p>
<pre><code>const _NumSizeClasses = 68
var class_to_size = [_NumSizeClasses]uint16{0, 8, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536,1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768}
</code></pre>
<p>如果按照序号为 1 的 spanClass（对象规格为 8 B）分配，每个 span 占用堆的字节数：8 k，mspan 可以保存 1024个对象</p>
<p>如果按照序号为 2 的 spanClass（对象规格为 16 B）分配，每个 span 占用堆的字节数：8 k，mspan 可以保存 512个对象</p>
<p>…</p>
<p>如果按照序号为 67 的 spanClass（对象规格为 32 K）分配，每个 span 占用堆的字节数：32 k，mspan 可以保存1个对象</p>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226003424.png" alt="image.png"/></p>
<p>字段含义：</p>
<ul>
<li>Class： class ID，每个 span 结构中都有一个 class ID, 表示该 span 可处理的对象类型</li>
<li>Bytes/obj：该 class 代表对象的字节数</li>
<li>Bytes/span：每个 span 占用堆的字节数，也即页数*页大小</li>
<li>Objects: 每个 span 可分配的对象个数，也即（bytes/spans）/（bytes/obj）</li>
<li>Waste bytes: 每个 span 产生的内存碎片，也即（bytes/spans）%（bytes/obj）</li>
</ul>
<p>大于 32 k 的对象出现时，会直接从 heap 分配一个特殊的 span，这个特殊的 span 的类型 (class)是 0, 只包含了一个大对象</p>
<p>代码位于 runtime/mheap.go</p>
<pre><code>type spanClass uint8


// uint8 左 7 位为 mspan 等级，最右一位标识是否为 noscan
func makeSpanClass(sizeclass uint8, noscan bool) spanClass {
    return spanClass(sizeclass&lt;&lt;1) | spanClass(bool2int(noscan))
}


func (sc spanClass) sizeclass() int8 {
    return int8(sc >> 1)
}


func (sc spanClass) noscan() bool {
    return sc&amp;1 != 0
}
</code></pre>
<h2 id="线程缓存mcache">线程缓存：mcache<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#线程缓存mcache" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240227201105.png" alt="image.png"/></p>
<p>mcache 管理线程在本地缓存的 mspan，每个 goroutine 绑定的 P 都有一个 <code>mcache</code> 字段</p>
<pre><code>type mcache struct {
	 // 微对象分配器相关
    tiny       uintptr
    tinyoffset uintptr
    tinyAllocs uintptr

	 // mcache 中缓存的 mspan，每种 spanClass 各一个
    alloc [numSpanClasses]*mspan
    
}

_NumSizeClasses = 68
numSpanClasses = _NumSizeClasses &lt;&lt; 1
</code></pre>
<ul>
<li>
<p><code>mcache</code> 是每个 P 独有的缓存，因此交互无锁</p>
</li>
<li>
<p><code>mcache</code> 用 <code>Span Classes</code> 作为索引管理多个用于分配的 <code>mspan</code>，它包含所有规格的 <code>mspan</code>。它是 <code>_NumSizeClasses</code> 的 2 倍，也就是 <code>68*2=136</code>，</p>
<ul>
<li>其中* 2 是将 spanClass 分成了有指针和没有指针两种, 方便与垃圾回收。</li>
<li>对于每种规格，有 2 个 mspan，一个 mspan 不包含指针，另一个 mspan 则包含指针。对于无指针对象的 <code>mspan</code> 在进行垃圾回收的时候无需进一步扫描它是否引用了其他活跃的对象。</li>
</ul>
</li>
<li>
<p><code>mcache</code> 在初始化的时候是没有任何 <code>mspan</code> 资源的，在使用过程中会动态地从 <code>mcentral</code> 申请，之后会缓存下来。当对象小于等于 32 KB 大小时，使用 <code>mcache</code> 的相应规格的 <code>mspan</code> 进行分配。</p>
</li>
<li>
<p>mcache 中还有一个为对象分配器 tiny allocator，用于处理小于 16B 对象的内存分配，在 3.3 小节中详细展开.</p>
</li>
</ul>
<h2 id="中心缓存mcentral">中心缓存：mcentral<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#中心缓存mcentral" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240227201114.png" alt="image.png"/></p>
<p>Mcentral 管理全局的 mspan 供所有线程使用，全局 mheap 变量包含 central 字段，每个 mcentral 结构都维护在<strong>mheap</strong>结构内</p>
<pre><code>type mcentral struct {
    spanclass spanClass // 指当前规格大小

    partial [2]spanSet // 有空闲object的mspan列表
    full    [2]spanSet // 没有空闲object的mspan列表
}
</code></pre>
<ul>
<li>每个 mcentral 管理一种 spanClass 的 mspan，</li>
<li>每个 mcentral 下聚合了该 spanClass 下的 mspan</li>
<li>并将有空闲空间和没有空闲空间的 mspan 分开管理。Partial 和 full <code>的数据类型为</code> spanSet，表示 <code>mspans</code> 集，可以通过 pop、push 来获得 mspans</li>
<li>每个 mcentral 一把锁</li>
</ul>
<pre><code>type spanSet struct {
    spineLock mutex
    spine     unsafe.Pointer // 指向[]span的指针
    spineLen  uintptr        // Spine array length, accessed atomically
    spineCap  uintptr        // Spine array cap, accessed under lock

    index headTailIndex  // 前32位是头指针，后32位是尾指针
}
</code></pre>
<p>简单说下 <code>mcache</code> 从 <code>mcentral</code> 获取和归还 <code>mspan</code> 的流程：</p>
<ul>
<li>获取；加锁，从 <code>partial</code> 链表找到一个可用的 <code>mspan</code>；并将其从 <code>partial</code> 链表删除；将取出的 <code>mspan</code> 加入到 <code>full</code> 链表；将 <code>mspan</code> 返回给工作线程，解锁。</li>
<li>归还；加锁，将 <code>mspan</code> 从 <code>full</code> 链表删除；将 <code>mspan</code> 加入到 <code>partial</code> 链表，解锁。</li>
</ul>
<h2 id="页堆mheap">页堆：mheap<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#页堆mheap" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Mheap 管理 Go 的所有动态分配内存，可以认为是 Go 程序持有的整个堆空间，全局唯一</p>
<pre><code>var mheap_ mheap

type mheap struct {
    // 堆的全局锁
    lock mutex


    // 空闲页分配器，底层是多棵基数树组成的索引，每棵树对应 16 GB 内存空间
    pages pageAlloc 


    // 记录了所有的 mspan. 需要知道，所有 mspan 都是经由 mheap，使用连续空闲页组装生成的
    allspans []*mspan


    // heapAreana 数组，64 位系统下，二维数组容量为 [1][2^22]
    // 每个 heapArena 大小 64M，因此理论上，Golang 堆上限为 2^22*64M = 256T
    arenas [1 &lt;&lt; arenaL1Bits]*[1 &lt;&lt; arenaL2Bits]*heapArena


    // ...
    // 多个 mcentral，总个数为 spanClass 的个数
    central [numSpanClasses]struct {
        mcentral mcentral
        // 用于内存地址对齐
        pad      [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral{})%cpu.CacheLinePadSize]byte
    }


    // ...
}
</code></pre>
<ul>
<li>
<p>对于 Golang 上层应用而言，堆是操作系统虚拟内存的抽象</p>
</li>
<li>
<p>所有 <code>mcentral</code> 的集合则是存放于 <code>mheap</code> 中的。<code>mheap</code> 里的 <code>arena</code> 区域是堆内存的抽象，运行时会将 <code>8KB</code> 看做一页，这些内存页中存储了所有在堆上初始化的对象</p>
</li>
<li>
<p>以页（8KB）为单位，作为最小内存存储单元</p>
</li>
<li>
<p>负责将连续页组装成 mspan</p>
</li>
<li>
<p>全局内存基于 <strong>bitMap 标识其使用情况</strong>，每个 bit 对应一页，为 0 则自由，为 1 则已被 mspan 组装</p>
</li>
<li>
<p>通过 <strong>heapArena 聚合页</strong>，记录了页到 mspan 的映射信息（2.7小节展开）</p>
</li>
<li>
<p>建立空闲页基数树索引 radix tree index，辅助快速寻找空闲页（2.6小节展开）</p>
</li>
<li>
<p>是 mcentral 的持有者，持有所有 spanClass 下的 mcentral，作为自身的缓存</p>
</li>
<li>
<p>内存不够时，向操作系统申请，申请单位为 heapArena（64M） 运行时使用二维的 runtime. HeapArena 数组管理所有的内存，每个 runtime. HeapArena 都会管理 64 MB 的内存。</p>
</li>
</ul>
<ul>
<li>当申请内存时，依次经过 <code>mcache</code> 和 <code>mcentral</code> 都没有可用合适规格的大小内存，这时候会向 <code>mheap</code> 申请一块内存。然后按指定规格划分为一些列表，并将其添加到相同规格大小的 <code>mcentral</code> 的 <code>非空闲列表</code> 后面</li>
</ul>
<h2 id="空闲页索引-pagealloc"> 空闲页索引 pageAlloc<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#空闲页索引-pagealloc" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>代码位于 runtime/mpagealloc.go</p>
<pre><code>const summaryLevels = 5


type pageAlloc struct {
    // 共有五层基数树，第一层有 2^14 个节点，因此共用 2^14棵基数树
    // 总空间大小为 2^14*16GB = 256T
    // 接下来每层的节点数为上层的 8 倍
    summary [summaryLevels][]pallocSum
    
    // ...
    // 类似于 tiny offset，小于此值的地址无锁检索，必然没有空间可用
    searchAddr offAddr


    // ...
}
</code></pre>
<p>（1）数据结构背后的含义：</p>
<ul>
<li>
<p>mheap 会基于 bitMap 标识内存中各页的使用情况，bit 位为 0 代表该页是空闲的，为 1 代表该页已被 mspan 占用.</p>
</li>
<li>
<p>每棵基数树聚合了 16 GB 内存空间中各页使用情况的索引信息，用于帮助 mheap 快速找到指定长度的连续空闲页的所在位置</p>
</li>
<li>
<p>mheap 持有 2^14 棵基数树，因此索引全面覆盖到 2^14 * 16 GB = 256 T 的内存空间.</p>
</li>
</ul>
<p>（2）基数树节点设定</p>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240227202838.png" alt="image.png"/></p>
<p>基数树中，每个节点称之为 PallocSum，是一个 <strong>uint64</strong> 类型，体现了索引的聚合信息，包含以下四部分：</p>
<ul>
<li>
<p> start：最右侧 21 个 bit，<strong>标识了当前节点映射的 bitMap 范围中首端有多少个连续的 0 bit（空闲页）</strong>，</p>
</li>
<li>
<p>•max：中间 21 个 bit，<strong>标识了当前节点映射的 bitMap 范围中最多有多少个连续的 0 bit（空闲页）</strong>，称之为 max；</p>
</li>
<li>
<p>• end：左侧 21 个 bit，<strong>标识了当前节点映射的 bitMap 范围中最末端有多少个连续的 0 bit（空闲页）</strong>，称之为 end.</p>
</li>
<li>
<p>• 最左侧一个 bit，弃置不用</p>
</li>
</ul>
<p>（2）基数树节点设定</p>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240227203338.png" alt="image.png"/></p>
<ul>
<li>
<p>每个父 pallocSum 有 8 个子 pallocSum</p>
</li>
<li>
<p>根 pallocSum 总览全局，<strong>映射的 bitMap 范围为全局的 16 GB 空间</strong>（其 max 最大值为 2^21，因此总空间大小为 2^21*8KB=16GB）；</p>
</li>
<li>
<p>从首层向下是一个依次八等分的过程，每一个 pallocSum 映射其父节点 bitMap 范围的八分之一，因此第二层 pallocSum 的 bitMap 范围为 16GB/8 = 2GB，以此类推，第五层节点的范围为 16GB / (8^4) = 4 MB，已经很小</p>
</li>
</ul>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240227203715.png" alt/></p>
<ul>
<li>
<p>•聚合信息时，自底向上. 每个父 pallocSum 聚合 8 个子 pallocSum 的 start、max、end 信息，形成自己的信息，直到根 pallocSum，坐拥全局 16 GB 的 start、max、end 信息</p>
</li>
<li>
<p> mheap 寻页时，自顶向下. 对于遍历到的每个 pallocSum，</p>
<ul>
<li>先看起 start 是否符合，是则寻页成功；</li>
<li>再看 max 是否符合，是则进入其下层孩子 pallocSum 中进一步寻访；</li>
<li>最后看 end 和下一个同辈 pallocSum 的 start 聚合后是否满足，是则寻页成功.</li>
</ul>
<p>基数树节点</p>
</li>
</ul>
<pre><code>const(
    logMaxPackedValue = 21
    maxPackedValue    = 1 &lt;&lt; logMaxPackedValue
)


type pallocSum uint64


// 基于 start、max、end 组装成一个基数树节点 pallocSum
func packPallocSum(start, max, end uint) pallocSum {
    // ...
    return pallocSum((uint64(start) &amp; (maxPackedValue - 1)) |
        ((uint64(max) &amp; (maxPackedValue - 1)) &lt;&lt; logMaxPackedValue) |
        ((uint64(end) &amp; (maxPackedValue - 1)) &lt;&lt; (2 * logMaxPackedValue)))
}


// 当前节点对应区域内，首部连续空闲页的长度
// 通过 uint64 最右侧 21 个 bit 标识
func (p pallocSum) start() uint {
    // ...
    return uint(uint64(p) &amp; (maxPackedValue - 1))
}


// 当前节点对应区域内，连续空闲页的最大长度
// 通过 uint64 左数 23~43 个 bit 标识
func (p pallocSum) max() uint {
    // ...
    return uint((uint64(p) >> logMaxPackedValue) &amp; (maxPackedValue - 1))
}


// 当前节点对应区域内，尾部连续空闲页的长度
// 通过 uint64 左数 2~22 个 bit 标识
func (p pallocSum) end() uint {
    return uint((uint64(p) >> (2 * logMaxPackedValue)) &amp; (maxPackedValue - 1))
}
</code></pre>
<h2 id="记录页到-mspan-的映射heaparena">记录页到 mspan 的映射：heapArena<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#记录页到-mspan-的映射heaparena" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<ul>
<li>
<p>每个 heapArena 包含 8192 个页，大小为 8192 * 8KB = 64 MB</p>
</li>
<li>
<p> heapArena 记录了页到 mspan 的映射. 因为 GC 时，通过地址偏移找到页很方便，但找到其所属的 mspan 不容易. 因此需要通过这个映射信息进行辅助.</p>
</li>
<li>
<p> heapArena 是 mheap 向操作系统申请内存的单位（64MB）</p>
</li>
</ul>
<pre><code>const pagesPerArena = 8192


type heapArena struct {
    // ...
    // 实现 page 到 mspan 的映射
    spans [pagesPerArena]*mspan


    // ...
}
</code></pre>
<h2 id="分配流程">分配流程<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#分配流程" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>下面来串联 Golang 中分配对象的流程，不论是以下哪种方式，最终都会殊途同归步入 mallocgc 方法中，并且根据 3.1 小节中的策略执行分配流程：</p>
<ul>
<li>
<p>new(T)</p>
</li>
<li>
<p> &amp;T{}</p>
</li>
<li>
<p> make(xxxx)</p>
</li>
</ul>
<h3 id="分配对象">分配对象<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#分配对象" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<ul>
<li>微对象 (0, 16 B)：先使用线程缓存上的微型分配器 (tiny allocator)，再依次尝试线程缓存、中心缓存、堆分配内存；</li>
<li>小对象 [16 B, 32 KB]：依次尝试线程缓存、中心缓存、堆分配内存；</li>
<li>大对象 (32 KB, +∞)：直接尝试堆分配内存；</li>
</ul>
<h3 id="分配策略">分配策略<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#分配策略" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>不同类型的对象，会有着不同的分配策略，这些内容在 mallocgc 方法中都有体现.</p>
<p>核心流程类似于读多级缓存的过程，由上而下，每一步只要成功则直接返回. 若失败，则由下层方法兜底.</p>
<p>对于微对象的分配流程：</p>
<p>（1）从 P 专属 mcache 的 tiny 分配器取内存（无锁）</p>
<p>（2）根据所属的 spanClass，从 P 专属 mcache 缓存的 mspan 中取内存（无锁）</p>
<p>（3）根据所属的 spanClass 从对应的 mcentral 中取 mspan 填充到 mcache，然后从 mspan 中取内存（spanClass 粒度锁）</p>
<p>（4）根据所属的 spanClass，从 mheap 的页分配器 pageAlloc 取得足够数量空闲页组装成 mspan 填充到 mcache，然后从 mspan 中取内存（全局锁）</p>
<p>（5）mheap 向操作系统申请内存，更新页分配器的索引信息，然后重复（4）.</p>
<p>对于小对象的分配流程是跳过（1）步，执行上述流程的（2）-（5）步；</p>
<p>对于大对象的分配流程是跳过（1）-（3）步，执行上述流程的（4）-（5）步.</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZuXibKvib2fj2vlIia93waBCNwralF3nEibKSbypbCcrSMDpAEgVJJE1ibaO6QCV2MNjwwibpt8PZiaw686g/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"/></p>
<h1 id="go-内存逃逸机制">Go 内存逃逸机制？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-内存逃逸机制" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<h2 id="概念">概念<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#概念" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>在一段程序中，<strong>每一个函数都会有自己的内存区域存放自己的局部变量、返回地址等</strong>，这些内存会由编译器在栈中进行分配，<strong>每一个函数都会分配一个栈桢</strong>，在函数运行结束后进行销毁，<strong>但是有些变量我们想在函数运行结束后仍然使用它，那么就需要把这个变量在堆上分配</strong>，这种从”栈”上逃逸到”堆”上的现象就成为<strong>内存逃逸</strong>。</p>
<p>在栈上分配的地址，一般由系统申请和释放，不会有额外性能的开销，比如函数的入参、局部变量、返回值等。在堆上分配的内存，如果要回收掉，需要进行 GC，那么 GC 一定会带来额外的性能开销。编程语言不断优化 GC 算法，主要目的都是为了减少 GC 带来的额外性能开销，变量一旦逃逸会导致性能开销变大。</p>
<h2 id="逃逸机制">逃逸机制<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#逃逸机制" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>编译器会根据变量是否被外部引用来决定是否逃逸：</p>
<ol>
<li>如果函数外部没有引用，则优先放到栈中；</li>
<li>如果函数外部存在引用，则必定放到堆中;</li>
<li>如果栈上放不下，则必定放到堆上;</li>
</ol>
<p>逃逸分析也就是由编译器决定哪些变量放在栈，哪些放在堆中，通过编译参数 <code>-gcflag=-m</code> 可以查看编译过程中的逃逸分析，发生逃逸的几种场景如下：</p>
<h3 id="指针逃逸">指针逃逸<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#指针逃逸" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<pre><code>package main

func escape1() *int {
    var a int = 1
    return &amp;a
}

func main() {
    escape1()
}
</code></pre>
<p>通过 <code>go build -gcflags=-m main.go</code> 查看逃逸情况：</p>
<pre><code>./main.go:4:6: moved to heap: a
</code></pre>
<p>函数返回值为局部变量的指针，函数虽然退出了，但是因为指针的存在，指向的内存不能随着函数结束而回收，因此只能分配在堆上。</p>
<h3 id="栈空间不足">栈空间不足<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#栈空间不足" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<pre><code>package main

func escape2() {
    s := make([]int, 0, 10000)
    for index, _ := range s {
        s[index] = index
    }
}

func main() {
    escape2()
}
</code></pre>
<p>通过 <code>go build -gcflags=-m main.go</code> 查看逃逸情况：</p>
<pre><code>./main.go:4:11: make([]int, 10000, 10000) escapes to heap
</code></pre>
<p>当栈空间足够时，不会发生逃逸，但是当变量过大时，已经完全超过栈空间的大小时，将会发生逃逸到堆上分配内存。局部变量 s 占用内存过大，编译器会将其分配到堆上</p>
<h3 id="变量大小不确定">变量大小不确定<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#变量大小不确定" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<pre><code>package main

func escape3() {
    number := 10
    s := make([]int, number) // 编译期间无法确定slice的长度
    for i := 0; i &lt; len(s); i++ {
        s[i] = i
    }
}

func main() {
    escape3()
}
</code></pre>
<p>编译期间无法确定 slice 的长度，这种情况为了保证内存的安全，编译器也会触发逃逸，在堆上进行分配内存。直接 <code>s := make([]int, 10)</code> 不会发生逃逸</p>
<h3 id="动态类型">动态类型<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#动态类型" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>动态类型就是编译期间不确定参数的类型、参数的长度也不确定的情况下就会发生逃逸</p>
<p>空接口 interface{} 可以表示任意的类型，如果函数参数为 interface{}，编译期间很难确定其参数的具体类型，也会发生逃逸。</p>
<pre><code>package main

import &quot;fmt&quot;

func escape4() {
    fmt.Println(1111)
}

func main() {
    escape4()
}
</code></pre>
<p>通过 <code>go build -gcflags=-m main.go</code> 查看逃逸情况：</p>
<pre><code>./main.go:4:6: moved to heap: i
</code></pre>
<p>Fmt.Println (a …interface{})函数参数为 interface，编译器不确定参数的类型，会将变量分配到堆上</p>
<h3 id="闭包引用对象">闭包引用对象<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#闭包引用对象" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<pre><code>package main

func escape5() func() int {
    var i int = 1
    return func() int {
        i++
        return i
    }
}

func main() {
    escape5()
}
</code></pre>
<p>通过 <code>go build -gcflags=-m main.go</code> 查看逃逸情况：</p>
<pre><code>./main.go:4:6: moved to heap: i
</code></pre>
<p>闭包函数中局部变量 i 在后续函数是继续使用的，编译器将其分配到堆上</p>
<h2 id="总结">总结<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#总结" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<ol>
<li>栈上分配内存比在堆中分配内存效率更高</li>
<li>栈上分配的内存不需要 GC 处理，而堆需要</li>
<li>逃逸分析目的是决定内分配地址是栈还是堆</li>
<li>逃逸分析在编译阶段完成</li>
</ol>
<p>因为无论变量的大小，只要是指针变量都会在堆上分配，所以对于小变量我们还是使用传值效率（而不是传指针）更高一点。</p>
<h2 id="怎么避免内存逃逸">怎么避免内存逃逸？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#怎么避免内存逃逸" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<ol>
<li><strong>不要盲目使用变量指针作为参数</strong>，虽然减少了复制，但变量逃逸的开销更大。</li>
<li><strong>预先设定好 slice 长度</strong>，避免频繁超出容量，重新分配。</li>
<li>一个经验是，<strong>指针指向的数据大部分在堆上分配的</strong>，请注意。</li>
</ol>
<p>出现内存逃逸的情况有：</p>
<ol>
<li>
<p>发送指针或带有指针的值到 channel，因为编译时候无法知道那个 goroutine 会在 channel 接受数据，编译器无法知道什么时候释放。</p>
</li>
<li>
<p>在一个切片上存储指针或带指针的值。比如[]*string，导致切片内容逃逸，其引用值一直在堆上。</p>
</li>
<li>
<p>切片的 append 导致超出容量，切片重新分配地址，切片背后的存储基于运行时的数据进行扩充，就会在堆上分配。</p>
</li>
<li>
<p>调用接口类型时，接口类型的方法调用是动态调度，实际使用的具体实现只能在运行时确定，如一个接口类型为 io. Reader 的变量 r，对r.Read (b)的调用将导致 r 的值和字节片 b 的后续转义并因此分配到堆上。</p>
</li>
<li>
<p>在方法内把局部变量指针返回，被外部引用，其生命周期大于栈，导致内存溢出。</p>
</li>
</ol>
<h1 id="go-内存对齐机制">Go 内存对齐机制？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-内存对齐机制" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<h2 id="什么是内存对齐">什么是内存对齐<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#什么是内存对齐" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>为了能让 CPU 可以更快的存取到各个字段，Go 编译器会帮你把 struct 结构体做数据的对齐。<strong>所谓的数据对齐，是指内存地址是所存储数据大小（按字节为单位）的整数倍，以便 CPU 可以一次将该数据从内存中读取出来。</strong> 编译器通过在结构体的各个字段之间填充一些空白已达到对齐的目的。</p>
<h2 id="对齐系数">对齐系数<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#对齐系数" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<ul>
<li>
<p>不同硬件平台占用的大小和对齐值都可能是不一样的 <strong>32 位系统对齐系数是 4，64 位系统对齐系数是 8</strong></p>
</li>
<li>
<p>不同类型的对齐系数也可能不一样，使用 <code>Go</code> 语言中的 <code>unsafe.Alignof</code> 函数可以返回相应类型的对齐系数，<strong>对齐系数都符合 <code>2^n</code> 这个规律</strong>，最大也不会超过8</p>
</li>
</ul>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
)

func main() {
    fmt.Printf(&quot;bool alignof is %d\n&quot;, unsafe.Alignof(bool(true)))
    fmt.Printf(&quot;string alignof is %d\n&quot;, unsafe.Alignof(string(&quot;a&quot;)))
    fmt.Printf(&quot;int alignof is %d\n&quot;, unsafe.Alignof(int(0)))
    fmt.Printf(&quot;float alignof is %d\n&quot;, unsafe.Alignof(float64(0)))
    fmt.Printf(&quot;int32 alignof is %d\n&quot;, unsafe.Alignof(int32(0)))
    fmt.Printf(&quot;float32 alignof is %d\n&quot;, unsafe.Alignof(float32(0)))
}

</code></pre>
<p>可以查看到各种类型在 Mac 64 位上的对齐系数如下：</p>
<pre><code>bool alignof is 1
string alignof is 8
int alignof is 8
int32 alignof is 4
float32 alignof is 4
float alignof is 8
</code></pre>
<h2 id="优点">优点<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#优点" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<ol>
<li>提高可移植性，有些 <code>CPU</code> 可以访问任意地址上的任意数据，而有些 <code>CPU</code> 只能在特定地址访问数据，因此不同硬件平台具有差异性，这样的代码就不具有移植性，如果在编译时，将分配的内存进行对齐，这就具有平台可以移植性了</li>
<li>提高内存的访问效率，32 位 CPU 下一次可以从内存中读取 32 位（4 个字节）的数据，64 位 CPU 下一次可以从内存中读取 64 位（8 个字节）的数据，这个长度也称为 CPU 的字长。CPU 一次可以读取 1 个字长的数据到内存中，如果所需要读取的数据正好跨了 1 个字长，那就得花两个 CPU 周期的时间去读取了。因此在内存中存放数据时进行对齐，可以提高内存访问效率。</li>
</ol>
<h2 id="缺点">缺点<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#缺点" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<ol>
<li>存在内存空间的浪费，实际上是空间换时间</li>
</ol>
<h2 id="结构体对齐">结构体对齐<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#结构体对齐" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>对齐原则：</p>
<ol>
<li><strong>结构体变量中成员的偏移量必须是成员大小的整数倍</strong></li>
<li><strong>整个结构体的地址必须是最大字节的整数倍</strong>（结构体的内存占用是 1/4/8/16 byte…)</li>
</ol>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;runtime&quot;
    &quot;unsafe&quot;
)

type T1 struct {
    i16  int16 // 2 byte
    bool bool  // 1 byte
}

type T2 struct {
    i8  int8  // 1 byte
    i64 int64 // 8 byte
    i32 int32 // 4 byte
}

type T3 struct {
    i8  int8  // 1 byte
    i32 int32 // 4 byte
    i64 int64 // 8 byte
}

func main() {
    fmt.Println(runtime.GOARCH) // amd64

    t1 := T1{}
    fmt.Println(unsafe.Sizeof(t1)) // 4 bytes

    t2 := T2{}
    fmt.Println(unsafe.Sizeof(t2)) // 24 bytes

    t3 := T3{}
    fmt.Println(unsafe.Sizeof(t3)) // 16 bytes
}
</code></pre>
<p>以 T 1 结构体为例，实际存储数据的只有 3 字节，但实际用了 4 字节，浪费了 1 个字节：</p>
<p>I 16 并没有直接放在 bool 的后面，而是在 bool 中填充了一个空白后，放到了偏移量为 2 的位置上。如果 i 16 从偏移量为 1 的位置开始占用 2 个字节，根据对齐原则 2：构体变量中成员的偏移量必须是成员大小的整数倍，套用公式 1 % 2 = 1，就不满足对齐的要求，所以 i 16 从偏移量为2的位置开始
<img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226004114.png" alt="image.png"/></p>
<p>以 T 2 结构体为例，实际存储数据的只有 13 字节，但实际用了 24 字节，浪费了 11 个字节：
<img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226004122.png" alt="image.png"/></p>
<p>以 T 3 结构体为例，实际存储数据的只有 13 字节，但实际用了 16 字节，浪费了 3 个字节：</p>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226004134.png" alt="image.png"/></p>
<h1 id="go-gc-实现原理">Go GC 实现原理？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-gc-实现原理" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<h2 id="什么是-gc">什么是 GC？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#什么是-gc" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>垃圾回收也称为 GC（Garbage Collection），<strong>是一种自动内存管理机制。由垃圾收集器以类似守护协程的方式在后台运作，按照既定的策略为用户回收那些不再被使用的对象，释放对应的内存空间</strong></p>
<p>现代高级编程语言管理内存的方式分为两种：自动和手动，</p>
<ul>
<li>像 C、C++ 等编程语言使用手动管理内存的方式，工程师编写代码过程中需要主动申请或者释放内存；</li>
<li>而 PHP、Java 和 Go 等语言使用自动的内存管理系统，有内存分配器和垃圾收集器来代为分配和回收内存，其中垃圾收集器就是我们常说的 GC。</li>
</ul>
<p>在应用程序中会使用到两种内存，分别为堆（Heap）和栈（Stack），</p>
<ul>
<li>
<p>G<strong>C 负责回收堆内存，而不负责回收栈中的内存</strong>：</p>
</li>
<li>
<p>栈是线程的专用内存，专门为了函数执行而准备的，存储着函数中的局部变量以及调用栈，函数执行完后，编译器可以将栈上分配的内存可以直接释放，不需要通过 GC 来回收。</p>
</li>
</ul>
<p>堆是程序共享的内存，需要 GC 进行回收在堆上分配的内存。</p>
<p>垃圾回收器的执行过程被划分为两个半独立的组件：</p>
<ul>
<li>赋值器（Mutator）：这一名称本质上是在指代用户态的代码。因为对垃圾回收器而言，用户态的代码仅仅只是在修改对象之间的引用关系，也就是在对象图（对象之间引用关系的一个有向图）上进行操作。</li>
<li>回收器（Collector）：负责执行垃圾回收的代码。</li>
</ul>
<h2 id="主流-gc-算法">主流 GC 算法<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#主流-gc-算法" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>目前比较常见的垃圾回收算法有三种：</p>
<ol>
<li>
<p>引用计数：为每个对象维护一个引用计数，当引用该对象的对象销毁时，引用计数 -1，当对象引用计数为 0 时回收该对象。
<img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240227212501.png" alt="image.png"/></p>
<ul>
<li>代表语言：<strong>Python</strong>、<strong>PHP</strong>、<strong>Swift</strong></li>
<li>优点：对象回收快，不会出现内存耗尽或达到某个阈值时才回收。</li>
<li>缺点：不能很好的处理循环引用，而实时维护引用计数也是有损耗的。</li>
</ul>
</li>
<li>
<p>分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。</p>
<ul>
<li>代表语言：<strong>Java</strong></li>
<li>优点：回收性能好</li>
<li>缺点：算法复杂</li>
</ul>
</li>
<li>
<p>标记-清除：从根变量开始遍历所有引用的对象，标记引用的对象，没有被标记的进行回收。</p>
</li>
</ol>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240227213214.png" alt="image.png"/></p>
<pre><code>- 代表语言：**Golang**（三色标记法）
- 优点：解决了引用计数的缺点。
- 缺点：需要 STW，暂时停掉程序运行。 
</code></pre>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226004206.png" alt="image.png"/>
4. 标记-压缩：是在标记清扫算法的基础上做了升级，在第二步”清扫“的同时还会对存活对象进行压缩整合，使得整体空间更为紧凑，从而解决内存碎片问题.
<img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240227213148.png" alt="image.png"/></p>
<ol>
<li>半空间复制:</li>
</ol>
<ul>
<li>分配两片相等大小的空间，称为 fromspace 和 tospace</li>
<li>每轮只使用 fromspace 空间，以GC作为分水岭划分轮次</li>
<li>GC时，将fromspace存活对象转移到tospace中，并以此为契机对空间进行压缩整合</li>
<li> GC后，交换fromspace和tospace，开启新的轮次</li>
</ul>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240227213422.png" alt/></p>
<h2 id="三色标记法"><strong>三色标记法</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#三色标记法" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>此算法是在 Go 1.5 版本开始使用，Go 语言采用的是标记清除算法，并在此基础上使用了三色标记法和混合写屏障技术，GC 过程和其他用户 goroutine 可并发运行，但需要一定时间的 STW</p>
<p>这里的三色，对应了垃圾回收过程中对象的三种状态：</p>
<ul>
<li>灰色：对象还在标记队列中等待</li>
<li>黑色：对象已被标记，<code>gcmarkBits</code> 对应位为 <code>1</code> （该对象不会在本次 GC 中被回收）</li>
<li>白色：对象未被标记，<code>gcmarkBits</code> 对应位为 <code>0</code> （该对象将会在本次 GC 中被清理）</li>
</ul>
<p>简单概括：</p>
<ul>
<li>
<p>标记开始前，将根对象（全局对象、栈上局部变量等）置黑，将其所指向的对象置灰</p>
</li>
<li>
<p>标记规则是，从灰对象出发，将其所指向的对象都置灰. 所有指向对象都置灰后，当前灰对象置黑</p>
</li>
<li>
<p> 标记结束后，白色对象就是不可达的垃圾对象，需要进行清扫.</p>
</li>
</ul>
<p>执行的步骤</p>
<ul>
<li>
<p>Step 1: 创建：白、灰、黑三个集合</p>
</li>
<li>
<p>Step 2: 将所有对象放入白色集合中</p>
</li>
<li>
<p>Step 3: 遍历所有<strong>root 对象</strong>，把遍历到的对象从白色集合放入灰色集合 (这里放入灰色集合的都是根节点的对象)</p>
</li>
<li>
<p>Step 4: 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，自身标记为黑色</p>
</li>
<li>
<p>Step 5: 重复步骤 4，直到灰色中无任何对象，其中用到 2 个机制：</p>
<ul>
<li><strong>写屏障（Write Barrier）</strong>：上面说到的 STW 的目的是防止 GC 扫描时内存变化引起的混乱，而写屏障就是让 goroutine 与 GC 同时运行的手段，虽然不能完全消除 STW，但是可以大大减少 STW 的时间。写屏障在 GC 的特定时间开启，开启后<strong>指针传递时</strong>会把指针标记，即本轮不回收，下次 GC 时再确定。</li>
<li><strong>辅助 GC（Mutator Assist）</strong>：为了防止内存分配过快，在 GC 执行过程中，GC 过程中 mutator 线程会并发运行，而 mutator assist 机制会协助 GC 做一部分的工作。</li>
</ul>
</li>
</ul>
<ul>
<li>Step 6: 收集所有白色对象（垃圾）</li>
</ul>
<h3 id="并发垃圾回收会遇到的问题">并发垃圾回收会遇到的问题<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#并发垃圾回收会遇到的问题" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<h4 id="漏标问题">漏标问题<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#漏标问题" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240227214346.png" alt="image.png"/></p>
<ul>
<li>条件：初始时刻，对象 B 持有对象 C 的引用</li>
<li> moment1：GC协程下，对象A被扫描完成，置黑；此时对象B是灰色，还未完成扫描</li>
<li> momen2：用户协程下，对象A建立指向对象C的引用</li>
<li> moment3：用户协程下，对象B删除指向对象C的引用</li>
<li> moment4：GC 协程下，开始执行对对象 B 的扫描</li>
</ul>
<p>漏标问题是无法接受，其引起的误删现象可能会导致程序出现致命的错误. 针对漏标问题，Golang 给出的解决方案是屏障机制的使用</p>
<h4 id="多标问题">多标问题<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#多标问题" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240227214657.png" alt="image.png"/></p>
<ul>
<li> 条件：初始时刻，对象 A 持有对象 B 的引用</li>
<li>moment1：GC协程下，对象A被扫描完成，置黑；对象B被对象A引用，因此被置灰</li>
<li> momen2：用户协程下，对象 A 删除指向对象 B 的引用</li>
</ul>
<h4 id="内存碎片">内存碎片<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#内存碎片" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>标记清扫算法会存在产生“内存碎片”的缺陷</p>
<p>Golang 采用 TCMalloc 机制，依据对象的大小将其归属为到事先划分好的 spanClass 当中，这样能够消解外部碎片的问题，将问题限制在相对可控的内部碎片当中..</p>
<h4 id="为什么不选择分代垃圾回收机制">为什么不选择分代垃圾回收机制<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#为什么不选择分代垃圾回收机制" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>Golang中存在内存逃逸机制，会在编译过程中将生命周期更长的对象转移到堆中，将生命周期短的对象分配在栈上，并以栈为单位对这部分对象进行回收.</p>
<p>Golang中存在内存逃逸机制，会在编译过程中将生命周期更长的对象转移到堆中，将生命周期短的对象分配在栈上，并以栈为单位对这部分对象进行回收.</p>
<h3 id="root-对象"><strong>root 对象</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#root-对象" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：</p>
<ul>
<li>全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。</li>
<li>执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上指向堆内存的指针。</li>
<li>寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。</li>
</ul>
<h3 id="强弱三色不变式">强弱三色不变式<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#强弱三色不变式" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>漏标问题的本质就是，<strong>一个已经扫描完成的黑对象指向了一个被灰\白对象删除引用的白色对象.</strong></p>
<p>构成这一场景的要素拆分如下：</p>
<p>（1）黑色对象指向了白色对象</p>
<p>（2）灰、白对象删除了白色对象</p>
<p>（3）（1）、（2）步中谈及的白色对象是同一个对象</p>
<p>（4）（1）发生在（2）之前</p>
<p>一套用于解决漏标问题的方法论称之为强弱三色不变式：</p>
<ul>
<li>
<p>• 强三色不变式：白色对象不能被黑色对象直接引用（直接破坏（1））</p>
</li>
<li>
<p>• 弱三色不变式：白色对象可以被黑色对象引用，但要从某个灰对象出发仍然可达该白对象（间接破坏了（1）、（2）的联动）</p>
</li>
</ul>
<h3 id="插入写屏障"><strong>插入写屏障</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#插入写屏障" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240227220514.png" alt="image.png"/></p>
<p><strong>保证当一个黑色对象指向一个白色对象前，会先触发屏障将白色对象置为灰色，再建立引用.</strong></p>
<p>对象被引用时触发的机制（只在堆内存中生效）：赋值器这一行为通知给并发执行的回收器，被引用的对象标记为灰色</p>
<p>缺点：结束时需要 STW 来重新扫描栈，标记栈上引用的白色对象的存活</p>
<h3 id="删除写屏障"><strong>删除写屏障</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#删除写屏障" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240227220546.png" alt="image.png"/></p>
<p><strong>保证当一个白色对象即将被上游删除引用前，会触发屏障将其置灰，之后再删除上游指向其的引用.</strong></p>
<p>对象被删除时触发的机制（只在堆内存中生效）：赋值器将这一行为通知给并发执行的回收器，被删除的对象，如果自身为灰色或者白色，那么标记为灰色</p>
<p>缺点：一个对象的引用被删除后，即使没有其他存活的对象引用它，它仍然会活到下一轮，会产生很大冗余扫描成本，且降低了回收精度</p>
<h3 id="混合写屏障"><strong>混合写屏障</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#混合写屏障" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>插入写屏障、删除写屏障二者择其一，即可解决并发GC的漏标问题，至于错标问题，则采用容忍态度，放到下一轮GC中进行延后处理即可.</p>
<p>GC 没有混合写屏障前，一直是插入写屏障；<strong>混合写屏障是插入写屏障 + 删除写屏障，写屏障只应用在堆上应用，栈上不启用（栈上启用成本很高）</strong></p>
<ul>
<li>
<p>• GC 开始前，以栈为单位分批扫描，将栈中所有对象置黑</p>
</li>
<li>
<p>• GC 期间，栈上新创建对象直接置黑</p>
</li>
<li>
<p>• 堆对象正常启用插入写屏障</p>
</li>
<li>
<p>• 堆对象正常启用删除写屏障</p>
</li>
</ul>
<h3 id="show-case">show case<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#show-case" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>（1）case 1：堆对象删除引用，栈对象建立引用</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZsX03L7kZaOrjpArjV5Tfmib0PFRxUrFryicq6TW7qN5aQibT6aD9aE3Eo0oPibbmKnthQZX21pshcic6Q/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"/></p>
<ul>
<li>背景：存在栈上对象A，黑色（扫描完）；</li>
</ul>
<p>存在堆上对象B，白色（未被扫描）；</p>
<p>存在堆上对象C，被堆上对象B引用，白色（未被扫描）</p>
<ul>
<li>
<p>moment1：A建立对C的引用，由于栈无屏障机制，因此正常建立引用，无额外操作</p>
</li>
<li>
<p>moment2：B尝试删除对C的引用，删除写屏障被触发，C被置灰，因此不会漏标</p>
</li>
</ul>
<p>（2）case 2：一个堆对象删除引用，成为另一个堆对象下游</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZsX03L7kZaOrjpArjV5TfmibxaRBiaBV6h44eqG5fA92WuDGbtXE5XIibyI7QLbmgMLwxkAndaqDWUSw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"/></p>
<ul>
<li>• 背景：存在堆上对象A，白色（未被扫描）；</li>
</ul>
<p>存在堆上对象B，黑色（已完成扫描）；</p>
<p>存在堆上对象C，被堆上对象B引用，白色（未被扫描）</p>
<ul>
<li>
<p>• moment1：B尝试建立对C的引用，插入写屏障被触发，C被置灰</p>
</li>
<li>
<p>• moment2：A删除对C的引用，此时C已置灰，因此不会漏标</p>
</li>
</ul>
<p>（3）case 3：栈对象删除引用，成为堆对象下游</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZsX03L7kZaOrjpArjV5TfmibxHWaKDFs60CDNWs6NvCFaBibqe0PCFoMibUe7Ptc1xAicu5aFwpEP2LYg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"/></p>
<ul>
<li>• 背景：存在栈上对象A，白色（未完成扫描，说明对应的栈未扫描）；</li>
</ul>
<p>存在堆上对象B，黑色（已完成扫描）；</p>
<p>存在堆上对象C，被栈上对象A引用，白色（未被扫描）</p>
<ul>
<li>
<p>• moment1：B尝试建立对C的引用，插入写屏障被触发，C被置灰</p>
</li>
<li>
<p>• moment2：A删除对C的引用，此时C已置灰，因此不会漏标</p>
</li>
</ul>
<p>（4）case 4：一个栈中对象删除引用，另一个栈中对象建立引用</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZsX03L7kZaOrjpArjV5TfmibyjmjfS5mTiaH4EKOuKpDdWToJWfy9iaBvLg9AcicHu8bRqanQk7jCZZ1w/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"/></p>
<ul>
<li>• 背景：存在栈上对象A，白色（未扫描，这是因为对应的栈还未开始扫描）；</li>
</ul>
<p>存在栈上对象B，黑色（已完成扫描，说明对应的栈均已完成扫描）；</p>
<p>存在堆上对象C，被栈上对象A引用，白色（未被扫描）</p>
<ul>
<li>
<p>• moment1：B建立对C的引用；</p>
</li>
<li>
<p>• moment2：A删除对C的引用.</p>
</li>
<li>
<p>• 结论：这种场景下，C要么已然被置灰，要么从某个灰对象触发仍然可达C.</p>
</li>
<li>
<p>• 原因在于，对象的引用不是从天而降，一定要有个来处. 当前 case 中，对象B能建立指向C的引用，至少需要满足如下三个条件之一：</p>
</li>
</ul>
<p>I 栈对象B原先就持有C的引用，如若如此，C就必然已处于置灰状态（因为B已是黑色）</p>
<p>II 栈对象B持有A的引用，通过A间接找到C. 然而这也是不可能的，因为倘若A能同时被另一个栈上的B引用到，那样A必然会升级到堆中，不再满足作为一个栈对象的前提；</p>
<p>III B同栈内存在其他对象X可达C，此时从X出发，必然存在一个灰色对象，从其出发存在可达C的路线.</p>
<p>综上，我们得以证明混合写屏障是能够胜任并发GC场景的解决方案，并且满足栈无须添加屏障的前提.</p>
<h2 id="gc-流程">GC 流程<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#gc-流程" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>一次完整的垃圾回收会分为四个阶段，分别是标记准备、标记开始、标记终止、清理：</p>
<ol>
<li><strong>标记准备（Mark Setup）</strong>：打开写屏障（Write Barrier），需 STW（stop the world)</li>
<li><strong>标记开始（Marking）</strong>：使用三色标记法并发标记，与用户程序并发执行</li>
<li><strong>标记终止（Mark Termination</strong>）：对触发写屏障的对象进行重新扫描标记，关闭写屏障（Write Barrier），需 STW（stop the world)</li>
<li><strong>清理（Sweeping）</strong>：将需要回收的内存归还到堆中，将过多的内存归还给操作系统，与用户程序并发执行
<img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226004354.png" alt="image.png"/></li>
</ol>
<h2 id="gc-触发时机">GC 触发时机<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#gc-触发时机" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><strong>主动触发：</strong></p>
<ul>
<li>调用 runtime.GC () 方法，触发 GC</li>
</ul>
<p><strong>被动触发：</strong></p>
<ul>
<li>定时触发，该触发条件由 <code>runtime.forcegcperiod</code> 变量控制，默认为 2 分钟。当超过两分钟没有产生任何 GC 时，触发 GC</li>
<li>根据内存分配阈值触发，该触发条件由环境变量 GOGC 控制，默认值为 100（100%），当前堆内存占用是上次 GC 结束后占用内存的 2 倍时，触发 GC</li>
</ul>
<h2 id="go-gc-如何调优">Go GC 如何调优？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-gc-如何调优" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<ul>
<li>控制内存分配的速度，限制 Goroutine 的数量，提高赋值器 mutator 的 CPU 利用率（降低 GC 的 CPU 利用率）</li>
<li>少量使用 <code>+</code> 连接 string</li>
<li>Slice 提前分配足够的内存来降低扩容带来的拷贝</li>
<li>避免 map key 对象过多，导致扫描时间增加</li>
<li>变量复用，减少对象分配，例如使用 sync. Pool 来复用需要频繁创建临时对象、使用全局变量等</li>
<li>增大 GOGC 的值，降低 GC 的运行频率</li>
</ul>
<h2 id="go-如何查看-gc-信息">Go 如何查看 GC 信息？<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-如何查看-gc-信息" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<h3 id="1-godebuggctrace1">1. GODEBUG=’gctrace=1’<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#1-godebuggctrace1" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<pre><code>package main
func main() {
    for n := 1; n &lt; 100000; n++ {
        _ = make([]byte, 1&lt;&lt;20)
    }
}
</code></pre>
<pre><code>$ GODEBUG='gctrace=1' go run main.go

gc 1 @0.003s 4%: 0.013+1.7+0.008 ms clock, 0.10+0.67/1.2/0.018+0.064 ms cpu, 4->6->2 MB, 5 MB goal, 8 P
gc 2 @0.006s 2%: 0.006+4.5+0.058 ms clock, 0.048+0.070/0.027/3.6+0.47 ms cpu, 4->5->1 MB, 5 MB goal, 8 P
gc 3 @0.011s 3%: 0.021+1.3+0.009 ms clock, 0.17+0.041/0.41/0.046+0.072 ms cpu, 4->6->2 MB, 5 MB goal, 8 P
gc 4 @0.013s 5%: 0.025+0.38+0.26 ms clock, 0.20+0.054/0.15/0.009+2.1 ms cpu, 4->6->2 MB, 5 MB goal, 8 P
gc 5 @0.014s 5%: 0.021+0.16+0.002 ms clock, 0.17+0.098/0.028/0.001+0.016 ms cpu, 4->5->1 MB, 5 MB goal, 8 P
gc 6 @0.014s 7%: 0.025+1.6+0.003 ms clock, 0.20+0.061/2.9/1.5+0.025 ms cpu, 4->6->2 MB, 5 MB goal, 8 P
gc 7 @0.016s 7%: 0.019+1.0+0.002 ms clock, 0.15+0.053/1.0/0.018+0.017 ms cpu, 4->6->2 MB, 5 MB goal, 8 P
gc 8 @0.017s 7%: 0.029+0.17+0.002 ms clock, 0.23+0.037/0.10/0.063+0.022 ms cpu, 4->4->0 MB, 5 MB goal, 8 P
gc 9 @0.018s 7%: 0.019+0.23+0.002 ms clock, 0.15+0.040/0.16/0.023+0.018 ms cpu, 4->5->1 MB, 5 MB goal, 8 P
gc 10 @0.018s 7%: 0.022+0.23+0.003 ms clock, 0.17+0.061/0.13/0.006+0.024 ms cpu, 4->6->2 MB, 5 MB goal, 8 P
gc 11 @0.018s 7%: 0.019+0.11+0.001 ms clock, 0.15+0.033/0.051/0.013+0.015 ms cpu, 4->5->1 MB, 5 MB goal, 8 P
gc 12 @0.019s 7%: 0.018+0.19+0.001 ms clock, 0.14+0.035/0.10/0.018+0.014 ms cpu, 4->5->1 MB, 5 MB goal, 8 P
gc 13 @0.019s 7%: 0.018+0.35+0.002 ms clock, 0.15+0.21/0.054/0.013+0.016 ms cpu, 4->5->1 MB, 5 MB goal, 8 P
gc 14 @0.019s 8%: 0.024+0.27+0.002 ms clock, 0.19+0.022/0.13/0.014+0.017 ms cpu, 4->5->1 MB, 5 MB goal, 8 P
gc 15 @0.020s 8%: 0.019+0.42+0.038 ms clock, 0.15+0.060/0.28/0.007+0.31 ms cpu, 4->17->13 MB, 5 MB goal, 8 P
gc 16 @0.021s 8%: 0.018+0.53+0.060 ms clock, 0.14+0.045/0.39/0.005+0.48 ms cpu, 21->28->7 MB, 26 MB goal, 8 P
gc 17 @0.021s 10%: 0.020+0.91+0.64 ms clock, 0.16+0.050/0.36/0.027+5.1 ms cpu, 12->16->4 MB, 14 MB goal, 8 P
gc 18 @0.023s 10%: 0.020+0.55+0.002 ms clock, 0.16+0.053/0.50/0.081+0.023 ms cpu, 7->9->2 MB, 8 MB goal, 8 P
</code></pre>
<p>字段含义由下表所示：</p>









































































<div class="table-container"><table><thead><tr><th style="text-align:left;">字段</th><th style="text-align:left;">含义</th></tr></thead><tbody><tr><td style="text-align:left;">gc 2</td><td style="text-align:left;">第二个 GC 周期</td></tr><tr><td style="text-align:left;">0.006</td><td style="text-align:left;">程序开始后的 0.006 秒</td></tr><tr><td style="text-align:left;">2%</td><td style="text-align:left;">该 GC 周期中 CPU 的使用率</td></tr><tr><td style="text-align:left;">0.006</td><td style="text-align:left;">标记开始时， STW 所花费的时间（wall clock）</td></tr><tr><td style="text-align:left;">4.5</td><td style="text-align:left;">标记过程中，并发标记所花费的时间（wall clock）</td></tr><tr><td style="text-align:left;">0.058</td><td style="text-align:left;">标记终止时， STW 所花费的时间（wall clock）</td></tr><tr><td style="text-align:left;">0.048</td><td style="text-align:left;">标记开始时， STW 所花费的时间（cpu time）</td></tr><tr><td style="text-align:left;">0.070</td><td style="text-align:left;">标记过程中，标记辅助所花费的时间（cpu time）</td></tr><tr><td style="text-align:left;">0.027</td><td style="text-align:left;">标记过程中，并发标记所花费的时间（cpu time）</td></tr><tr><td style="text-align:left;">3.6</td><td style="text-align:left;">标记过程中，GC 空闲的时间（cpu time）</td></tr><tr><td style="text-align:left;">0.47</td><td style="text-align:left;">标记终止时， STW 所花费的时间（cpu time）</td></tr><tr><td style="text-align:left;">4</td><td style="text-align:left;">标记开始时，堆的大小的实际值</td></tr><tr><td style="text-align:left;">5</td><td style="text-align:left;">标记结束时，堆的大小的实际值</td></tr><tr><td style="text-align:left;">1</td><td style="text-align:left;">标记结束时，标记为存活的对象大小</td></tr><tr><td style="text-align:left;">5</td><td style="text-align:left;">标记结束时，堆的大小的预测值</td></tr><tr><td style="text-align:left;">8</td><td style="text-align:left;">P 的数量</td></tr></tbody></table></div>
<h3 id="2-go-tool-trace">2. Go tool trace<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#2-go-tool-trace" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<pre><code>package main

import (
    &quot;os&quot;
    &quot;runtime/trace&quot;
)

func main() {
    f, _ := os.Create(&quot;trace.out&quot;)
    defer f.Close()
    trace.Start(f)
    defer trace.Stop()
    for n := 1; n &lt; 100000; n++ {
        _ = make([]byte, 1&lt;&lt;20)
    }
}
</code></pre>
<pre><code>$ go run main.go
$ go tool trace trace.out
</code></pre>
<p>打开浏览器后，可以看到如下统计：
<img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226004606.png" alt="image.png"/></p>
<p>点击 View trace，可以查看当时的 trace 情况
<img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226004617.png" alt="image.png"/></p>
<p>点击 Minimum mutator utilization，可以查看到赋值器 mutator （用户程序）对 CPU 的利用率 74.1%，接近 100%则代表没有针对 GC 的优化空间了
<img src="https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226004625.png" alt="image.png"/></p>
<h3 id="3-debug-readgcstats">3. Debug. ReadGCStats<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#3-debug-readgcstats" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;runtime/debug&quot;
    &quot;time&quot;
)

func printGCStats() {
    t := time.NewTicker(time.Second)
    s := debug.GCStats{}
    for {
        select {
        case &lt;-t.C:
            debug.ReadGCStats(&amp;s)
            fmt.Printf(&quot;gc %d last@%v, PauseTotal %v\n&quot;, s.NumGC, s.LastGC, s.PauseTotal)
        }
    }
}
func main() {
    go printGCStats()
    for n := 1; n &lt; 100000; n++ {
        _ = make([]byte, 1&lt;&lt;20)
    }
}
</code></pre>
<pre><code>$ go run main.go

gc 3392 last@2022-05-04 19:22:52.877293 +0800 CST, PauseTotal 117.524907ms
gc 6591 last@2022-05-04 19:22:53.876837 +0800 CST, PauseTotal 253.254996ms
gc 10028 last@2022-05-04 19:22:54.87674 +0800 CST, PauseTotal 376.981595ms
gc 13447 last@2022-05-04 19:22:55.87689 +0800 CST, PauseTotal 511.420111ms
gc 16938 last@2022-05-04 19:22:56.876955 +0800 CST, PauseTotal 649.293449ms
gc 20350 last@2022-05-04 19:22:57.876756 +0800 CST, PauseTotal 788.003014ms
</code></pre>
<p>字段含义由下表所示：</p>





















<div class="table-container"><table><thead><tr><th style="text-align:left;">字段</th><th style="text-align:left;">含义</th></tr></thead><tbody><tr><td style="text-align:left;">NumGC</td><td style="text-align:left;">GC 总次数</td></tr><tr><td style="text-align:left;">LastGC</td><td style="text-align:left;">上次 GC 时间</td></tr><tr><td style="text-align:left;">PauseTotal</td><td style="text-align:left;">STW 总耗时</td></tr></tbody></table></div>
<h3 id="4-runtime-readmemstats">4. Runtime. ReadMemStats<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#4-runtime-readmemstats" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;runtime&quot;
    &quot;time&quot;
)

func printMemStats() {
    t := time.NewTicker(time.Second)
    s := runtime.MemStats{}
    for {
        select {
        case &lt;-t.C:
            runtime.ReadMemStats(&amp;s)
            fmt.Printf(&quot;gc %d last@%v, heap_object_num: %v, heap_alloc: %vMB, next_heap_size: %vMB\n&quot;,
                s.NumGC, time.Unix(int64(time.Duration(s.LastGC).Seconds()), 0), s.HeapObjects, s.HeapAlloc/(1&lt;&lt;20), s.NextGC/(1&lt;&lt;20))
        }
    }
}
func main() {
    go printMemStats()
    fmt.Println(1 &lt;&lt; 20)
    for n := 1; n &lt; 100000; n++ {
        _ = make([]byte, 1&lt;&lt;20)
    }
}

</code></pre>
<pre><code>$ go run main.go

gc 2978 last@2022-05-04 19:38:04 +0800 CST, heap_object_num: 391, heap_alloc: 20MB, next_heap_size: 28MB
gc 5817 last@2022-05-04 19:38:05 +0800 CST, heap_object_num: 370, heap_alloc: 4MB, next_heap_size: 4MB
gc 9415 last@2022-05-04 19:38:06 +0800 CST, heap_object_num: 392, heap_alloc: 7MB, next_heap_size: 8MB
gc 11429 last@2022-05-04 19:38:07 +0800 CST, heap_object_num: 339, heap_alloc: 4MB, next_heap_size: 5MB
gc 14706 last@2022-05-04 19:38:08 +0800 CST, heap_object_num: 436, heap_alloc: 6MB, next_heap_size: 8MB
gc 18253 last@2022-05-04 19:38:09 +0800 CST, heap_object_num: 375, heap_alloc: 4MB, next_heap_size: 6M
</code></pre>
<p>字段含义由下表所示：</p>





























<div class="table-container"><table><thead><tr><th style="text-align:left;">字段</th><th style="text-align:left;">含义</th></tr></thead><tbody><tr><td style="text-align:left;">NumGC</td><td style="text-align:left;">GC 总次数</td></tr><tr><td style="text-align:left;">LastGC</td><td style="text-align:left;">上次 GC 时间</td></tr><tr><td style="text-align:left;">HeapObjects</td><td style="text-align:left;">堆中已经分配的对象总数，GC 内存回收后 HeapObjects 取值相应减小</td></tr><tr><td style="text-align:left;">HeapAlloc</td><td style="text-align:left;">堆中已经分配给对象的字节数，GC 内存回收后 HeapAlloc 取值相应减小</td></tr><tr><td style="text-align:left;">NextGC</td><td style="text-align:left;">下次 GC 目标堆的大小</td></tr></tbody></table></div></article></div><div class="right sidebar"><div class="graph"><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:false}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xml:space="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:true}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc" class><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#内存管理" data-for="内存管理">内存管理</a></li><li class="depth-1"><a href="#golang-的内存模型为什么小对象多了会造成-gc-压力" data-for="golang-的内存模型为什么小对象多了会造成-gc-压力">Golang 的内存模型，为什么小对象多了会造成 gc 压力。</a></li><li class="depth-1"><a href="#go-语言什么时候垃圾回收写代码的时候如何减少对象分配" data-for="go-语言什么时候垃圾回收写代码的时候如何减少对象分配">Go 语言什么时候垃圾回收，写代码的时候如何减少对象分配</a></li><li class="depth-1"><a href="#给大家丢脸了用了三年-golang我还是没答对这道内存泄漏题" data-for="给大家丢脸了用了三年-golang我还是没答对这道内存泄漏题">给大家丢脸了，用了三年 Golang，我还是没答对这道内存泄漏题</a></li><li class="depth-1"><a href="#go-内存泄漏不是那么简单" data-for="go-内存泄漏不是那么简单">Go 内存泄漏？不是那么简单</a></li><li class="depth-1"><a href="#go-内存分配和-tcmalloc-的区别" data-for="go-内存分配和-tcmalloc-的区别">Go 内存分配，和 tcmalloc 的区别?</a></li><li class="depth-2"><a href="#go-内存分配" data-for="go-内存分配">GO 内存分配</a></li><li class="depth-2"><a href="#tcmalloc" data-for="tcmalloc">tcmalloc</a></li><li class="depth-1"><a href="#go-语言中的堆和栈" data-for="go-语言中的堆和栈">Go 语言中的堆和栈</a></li><li class="depth-0"><a href="#go-内存分配机制" data-for="go-内存分配机制">Go 内存分配机制？</a></li><li class="depth-1"><a href="#操作系统的内存管理" data-for="操作系统的内存管理">操作系统的内存管理</a></li><li class="depth-2"><a href="#操作系统存储模型" data-for="操作系统存储模型"> 操作系统存储模型</a></li><li class="depth-2"><a href="#虚拟内存与物理内存" data-for="虚拟内存与物理内存">虚拟内存与物理内存</a></li><li class="depth-2"><a href="#分页管理" data-for="分页管理"> 分页管理</a></li><li class="depth-1"><a href="#go-内存模型设计思想" data-for="go-内存模型设计思想">GO 内存模型设计思想</a></li><li class="depth-1"><a href="#分配组件" data-for="分配组件">分配组件</a></li><li class="depth-1"><a href="#内存管理单元mspan" data-for="内存管理单元mspan">内存管理单元：mspan</a></li><li class="depth-1"><a href="#内存单元等级-spanclass" data-for="内存单元等级-spanclass">内存单元等级 spanClass</a></li><li class="depth-1"><a href="#线程缓存mcache" data-for="线程缓存mcache">线程缓存：mcache</a></li><li class="depth-1"><a href="#中心缓存mcentral" data-for="中心缓存mcentral">中心缓存：mcentral</a></li><li class="depth-1"><a href="#页堆mheap" data-for="页堆mheap">页堆：mheap</a></li><li class="depth-1"><a href="#空闲页索引-pagealloc" data-for="空闲页索引-pagealloc"> 空闲页索引 pageAlloc</a></li><li class="depth-1"><a href="#记录页到-mspan-的映射heaparena" data-for="记录页到-mspan-的映射heaparena">记录页到 mspan 的映射：heapArena</a></li><li class="depth-1"><a href="#分配流程" data-for="分配流程">分配流程</a></li><li class="depth-2"><a href="#分配对象" data-for="分配对象">分配对象</a></li><li class="depth-2"><a href="#分配策略" data-for="分配策略">分配策略</a></li><li class="depth-0"><a href="#go-内存逃逸机制" data-for="go-内存逃逸机制">Go 内存逃逸机制？</a></li><li class="depth-1"><a href="#概念" data-for="概念">概念</a></li><li class="depth-1"><a href="#逃逸机制" data-for="逃逸机制">逃逸机制</a></li><li class="depth-2"><a href="#指针逃逸" data-for="指针逃逸">指针逃逸</a></li><li class="depth-2"><a href="#栈空间不足" data-for="栈空间不足">栈空间不足</a></li><li class="depth-2"><a href="#变量大小不确定" data-for="变量大小不确定">变量大小不确定</a></li><li class="depth-2"><a href="#动态类型" data-for="动态类型">动态类型</a></li><li class="depth-2"><a href="#闭包引用对象" data-for="闭包引用对象">闭包引用对象</a></li><li class="depth-1"><a href="#总结" data-for="总结">总结</a></li><li class="depth-1"><a href="#怎么避免内存逃逸" data-for="怎么避免内存逃逸">怎么避免内存逃逸？</a></li><li class="depth-0"><a href="#go-内存对齐机制" data-for="go-内存对齐机制">Go 内存对齐机制？</a></li><li class="depth-1"><a href="#什么是内存对齐" data-for="什么是内存对齐">什么是内存对齐</a></li><li class="depth-1"><a href="#对齐系数" data-for="对齐系数">对齐系数</a></li><li class="depth-1"><a href="#优点" data-for="优点">优点</a></li><li class="depth-1"><a href="#缺点" data-for="缺点">缺点</a></li><li class="depth-1"><a href="#结构体对齐" data-for="结构体对齐">结构体对齐</a></li><li class="depth-0"><a href="#go-gc-实现原理" data-for="go-gc-实现原理">Go GC 实现原理？</a></li><li class="depth-1"><a href="#什么是-gc" data-for="什么是-gc">什么是 GC？</a></li><li class="depth-1"><a href="#主流-gc-算法" data-for="主流-gc-算法">主流 GC 算法</a></li><li class="depth-1"><a href="#三色标记法" data-for="三色标记法">三色标记法</a></li><li class="depth-2"><a href="#并发垃圾回收会遇到的问题" data-for="并发垃圾回收会遇到的问题">并发垃圾回收会遇到的问题</a></li><li class="depth-2"><a href="#root-对象" data-for="root-对象">root 对象</a></li><li class="depth-2"><a href="#强弱三色不变式" data-for="强弱三色不变式">强弱三色不变式</a></li><li class="depth-2"><a href="#插入写屏障" data-for="插入写屏障">插入写屏障</a></li><li class="depth-2"><a href="#删除写屏障" data-for="删除写屏障">删除写屏障</a></li><li class="depth-2"><a href="#混合写屏障" data-for="混合写屏障">混合写屏障</a></li><li class="depth-2"><a href="#show-case" data-for="show-case">show case</a></li><li class="depth-1"><a href="#gc-流程" data-for="gc-流程">GC 流程</a></li><li class="depth-1"><a href="#gc-触发时机" data-for="gc-触发时机">GC 触发时机</a></li><li class="depth-1"><a href="#go-gc-如何调优" data-for="go-gc-如何调优">Go GC 如何调优？</a></li><li class="depth-1"><a href="#go-如何查看-gc-信息" data-for="go-如何查看-gc-信息">Go 如何查看 GC 信息？</a></li><li class="depth-2"><a href="#1-godebuggctrace1" data-for="1-godebuggctrace1">1. GODEBUG=’gctrace=1’</a></li><li class="depth-2"><a href="#2-go-tool-trace" data-for="2-go-tool-trace">2. Go tool trace</a></li><li class="depth-2"><a href="#3-debug-readgcstats" data-for="3-debug-readgcstats">3. Debug. ReadGCStats</a></li><li class="depth-2"><a href="#4-runtime-readmemstats" data-for="4-runtime-readmemstats">4. Runtime. ReadMemStats</a></li></ul></div></div><div class="backlinks"><h3>Backlinks</h3><ul class="overflow"><li>No backlinks found</li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.2.3</a> © 2024</p><ul><li><a href="https://github.com/jackyzha0/quartz">GitHub</a></li><li><a href="https://discord.gg/cRFFHYye7t">Discord Community</a></li></ul></footer></div></body><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js" type="application/javascript"></script><script type="application/javascript">function c(){let t=this.parentElement;t.classList.toggle("is-collapsed");let l=t.classList.contains("is-collapsed")?this.scrollHeight:t.scrollHeight;t.style.maxHeight=l+"px";let o=t,e=t.parentElement;for(;e;){if(!e.classList.contains("callout"))return;let n=e.classList.contains("is-collapsed")?e.scrollHeight:e.scrollHeight+o.scrollHeight;e.style.maxHeight=n+"px",o=e,e=e.parentElement}}function i(){let t=document.getElementsByClassName("callout is-collapsible");for(let s of t){let l=s.firstElementChild;if(l){l.addEventListener("click",c),window.addCleanup(()=>l.removeEventListener("click",c));let e=s.classList.contains("is-collapsed")?l.scrollHeight:s.scrollHeight;s.style.maxHeight=e+"px"}}}document.addEventListener("nav",i);window.addEventListener("resize",i);
</script><script type="module">
          let mermaidImport = undefined
          document.addEventListener('nav', async () => {
            if (document.querySelector("code.mermaid")) {
              mermaidImport ||= await import('https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.7.0/mermaid.esm.min.mjs')
              const mermaid = mermaidImport.default
              const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
              mermaid.initialize({
                startOnLoad: false,
                securityLevel: 'loose',
                theme: darkMode ? 'dark' : 'default'
              })

              await mermaid.run({
                querySelector: '.mermaid'
              })
            }
          });
          </script><script src="../../postscript.js" type="module"></script></html>