<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="P 和 M 的数量一定是 1：1 吗？如果一个 G 阻塞了会怎么样？ 不一定，M 必须持有 P 才可以执行代码，跟系统中的其他线程一样，M 也会被系统调用阻塞。P 的个数在启动程序时决定，默认情况下等于 CPU 的核数，可以使用环境变量 GOMAXPROCS 或在程序中使用 runtime.GOMAXPROCS ()方法指定 P 的个数。"><meta property="og:title" content><meta property="og:description" content="P 和 M 的数量一定是 1：1 吗？如果一个 G 阻塞了会怎么样？ 不一定，M 必须持有 P 才可以执行代码，跟系统中的其他线程一样，M 也会被系统调用阻塞。P 的个数在启动程序时决定，默认情况下等于 CPU 的核数，可以使用环境变量 GOMAXPROCS 或在程序中使用 runtime.GOMAXPROCS ()方法指定 P 的个数。"><meta property="og:type" content="website"><meta property="og:image" content="https://googoo-s.github.io/icon.png"><meta property="og:url" content="https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/GMP/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="P 和 M 的数量一定是 1：1 吗？如果一个 G 阻塞了会怎么样？ 不一定，M 必须持有 P 才可以执行代码，跟系统中的其他线程一样，M 也会被系统调用阻塞。P 的个数在启动程序时决定，默认情况下等于 CPU 的核数，可以使用环境变量 GOMAXPROCS 或在程序中使用 runtime.GOMAXPROCS ()方法指定 P 的个数。"><meta name=twitter:image content="https://googoo-s.github.io/icon.png"><title>googoo-s 😄😸😎</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://googoo-s.github.io//icon.png><link href=https://googoo-s.github.io/styles.19109a40042e9f0e72e952fda4442a34.min.css rel=stylesheet><link href=https://googoo-s.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://googoo-s.github.io/js/darkmode.953af745b0f9342644d632fc167f3727.min.js></script>
<script src=https://googoo-s.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://googoo-s.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://googoo-s.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://googoo-s.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://googoo-s.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://googoo-s.github.io/",fetchData=Promise.all([fetch("https://googoo-s.github.io/indices/linkIndex.3bfb24158f5e9d4aff66ae07a3a8bd0d.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://googoo-s.github.io/indices/contentIndex.8972f3e1fb9ffb8fdb949f104473fa8d.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://googoo-s.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://googoo-s.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/googoo-s.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=googoo-s.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://googoo-s.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://googoo-s.github.io/>googoo-s 😄😸😎</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Unknown</p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#p-和-m-的数量一定是-11-吗如果一个-g-阻塞了会怎么样>P 和 M 的数量一定是 1：1 吗？如果一个 G 阻塞了会怎么样？</a></li><li><a href=#golang-gmp-模型全局队列中的-g-会不会饥饿-为什么p-的数量是多少能修改吗m-的数量是多少>Golang GMP 模型，全局队列中的 G 会不会饥饿, 为什么？P 的数量是多少？能修改吗？M 的数量是多少？</a></li><li><a href=#服务器能开多少个-p-由什么决定>服务器能开多少个 P 由什么决定</a></li><li><a href=#服务器能开多少个-m-由什么决定>服务器能开多少个 M 由什么决定</a></li><li><a href=#m-和-p-是怎么样的关系>M 和 P 是怎么样的关系</a></li><li><a href=#gmp-调度过程中存在哪些阻塞>GMP 调度过程中存在哪些阻塞</a></li><li><a href=#gmp-当一个-g-堵塞时gmp-会发生什么>GMP 当一个 G 堵塞时，G、M、P 会发生什么</a></li><li><a href=#sysmon有什么作用><strong>sysmon</strong> <strong>有什么作用</strong></a></li><li><a href=#gmp-模型里为什么要有-p>GMP 模型里为什么要有 P？</a></li><li><a href=#为什么-gmp-模型会更快>为什么 GMP 模型会更快</a></li><li><a href=#同时启动了一万个-g如何调度>同时启动了一万个 G，如何调度？</a></li><li><a href=#go-如何调度假设-4-核的-cpu-应该有几个-m那能有几个-groutinuegroutinue-数量的上限是多少>Go 如何调度，假设 4 核的 cpu 应该有几个 M，那能有几个 groutinue，groutinue 数量的上限是多少？</a></li><li><a href=#gmp-并发模型goroutine-切换的时候上下文环境放在哪里>GMP 并发模型，Goroutine 切换的时候上下文环境放在哪里</a></li><li><a href=#golang-调度能不能不要-p>Golang 调度能不能不要 p</a></li><li><a href=#goroutine-的调度是出现在什么情况下调度时做了什么>Goroutine 的调度是出现在什么情况下，调度时做了什么</a></li><li><a href=#为什么-p-的-local-queue-可无锁访问任务窃取的时候要加锁吗>为什么 P 的 local queue 可无锁访问，任务窃取的时候要加锁吗?</a></li><li><a href=#一个-goroutine-sleep-了操作系统是怎么唤醒的>一个 goroutine sleep 了，操作系统是怎么唤醒的</a></li><li><a href=#go-的协程可以只挂在一个线程上面吗>Go 的协程可以只挂在一个线程上面吗</a></li><li><a href=#go-线程实现模型>Go 线程实现模型？</a><ol><li><a href=#背景>背景</a></li><li><a href=#三种线程模型>三种线程模型</a><ol><li><a href=#内核级线程模型11><strong>内核级线程模型（1：1）</strong></a></li><li><a href=#用户级线程模型n1><strong>用户级线程模型（N：1）</strong></a></li><li><a href=#两级线程模型mn><strong>两级线程模型（M：N)</strong></a></li></ol></li></ol></li><li><a href=#go-gmp-和-gm-模型>Go GMP 和 GM 模型？</a><ol><li><a href=#gmp-模型>GMP 模型</a></li><li><a href=#gm-模型>GM 模型</a></li></ol></li><li><a href=#go-调度原理>Go 调度原理？</a><ol><li><a href=#设计思想>设计思想</a></li><li><a href=#调度对象>调度对象</a></li><li><a href=#被调度对象>被调度对象</a></li><li><a href=#调度流程>调度流程</a></li><li><a href=#调度时机>调度时机</a></li><li><a href=#调度策略>调度策略</a></li></ol></li><li><a href=#go-work-stealing-机制>Go work stealing 机制？</a><ol><li><a href=#概念>概念</a></li><li><a href=#窃取流程>窃取流程</a><ol><li><a href=#选择要窃取的-p><strong>选择要窃取的 P</strong></a></li><li><a href=#从-p-中偷走一半-g><strong>从 P 中偷走一半 G</strong></a></li></ol></li></ol></li><li><a href=#go-hand-off-机制>Go hand off 机制？</a><ol><li><a href=#概念-1>概念</a></li><li><a href=#分离流程>分离流程</a></li></ol></li><li><a href=#go-抢占式调度>Go 抢占式调度？</a><ol><li><a href=#基于协作的抢占式调度>基于协作的抢占式调度</a></li><li><a href=#基于信号的抢占式调度>基于信号的抢占式调度</a></li></ol></li><li><a href=#go-如何查看运行时调度信息>Go 如何查看运行时调度信息？</a><ol><li><ol><li></li></ol></li><li><a href=#godebug>GODEBUG</a></li></ol></li></ol></nav></details></aside><a href=#p-和-m-的数量一定是-11-吗如果一个-g-阻塞了会怎么样><h1 id=p-和-m-的数量一定是-11-吗如果一个-g-阻塞了会怎么样><span class=hanchor arialabel=Anchor># </span>P 和 M 的数量一定是 1：1 吗？如果一个 G 阻塞了会怎么样？</h1></a><p>不一定，M 必须持有 P 才可以执行代码，跟系统中的其他线程一样，M 也会被系统调用阻塞。P 的个数在启动程序时决定，默认情况下等于 CPU 的核数，可以使用环境变量 GOMAXPROCS 或在程序中使用 runtime.GOMAXPROCS ()方法指定 P 的个数。<br>M 的个数通常稍大于 P 的个数，因为除了运行 Go 代码，runtime 包还有其他内置任务需要处理。</p><a href=#golang-gmp-模型全局队列中的-g-会不会饥饿-为什么p-的数量是多少能修改吗m-的数量是多少><h1 id=golang-gmp-模型全局队列中的-g-会不会饥饿-为什么p-的数量是多少能修改吗m-的数量是多少><span class=hanchor arialabel=Anchor># </span>Golang GMP 模型，全局队列中的 G 会不会饥饿, 为什么？P 的数量是多少？能修改吗？M 的数量是多少？</h1></a><ol><li>全局队列中的 G 不会饥饿。因为线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。<br>M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。所以全局队列中的 G 总是能被消费掉.</li><li>P 的数量可以理解为最大为本机可执行的 cpu 的最大数量。<br>通过 runtime.GOMAXPROCS (runtime.NumCPU ())设置。<br>Runtime.NumCPU ()方法返回当前进程可用的逻辑 cpu 数量。</li></ol><a href=#服务器能开多少个-p-由什么决定><h1 id=服务器能开多少个-p-由什么决定><span class=hanchor arialabel=Anchor># </span>服务器能开多少个 P 由什么决定</h1></a><ul><li>P 的个数在程序启动时决定，默认情况下等同于 CPU 的核数</li><li>程序中可以使用 runtime.GOMAXPROCS () 设置 P 的个数，在某些 IO 密集型的场景下可以在一定程度上提高性能。</li><li>一般来讲，程序运行时就将 GOMAXPROCS 大小设置为 CPU 核数，可让 Go 程序充分利用 CPU。在某些 IO 密集型的应用里，这个值可能并不意味着性能最好。理论上当某个 Goroutine 进入系统调用时，会有一个新的 M 被启用或创建，继续占满 CPU。但由于 Go 调度器检测到 M 被阻塞是有一定延迟的，也即旧的 M 被阻塞和新的 M 得到运行之间是有一定间隔的，所以在 IO 密集型应用中不妨把 GOMAXPROCS 设置的大一些，或许会有好的效果。</li></ul><a href=#服务器能开多少个-m-由什么决定><h1 id=服务器能开多少个-m-由什么决定><span class=hanchor arialabel=Anchor># </span>服务器能开多少个 M 由什么决定</h1></a><ul><li>由于 M 必须持有一个 P 才可以运行 Go 代码，所以同时运行的 M 个数，也即线程数一般等同于 CPU 的个数，以达到尽可能的使用 CPU 而又不至于产生过多的线程切换开销。</li><li>P 的个数默认等于 CPU 核数，每个 M 必须持有一个 P 才可以执行 G，一般情况下 M 的个数会略大于 P 的个数，这多出来的 M 将会在 G 产生系统调用时发挥作用。</li><li>Go 语⾔本身是限定 M 的最⼤量是 10000，可以在 runtime/debug 包中的 SetMaxThreads 函数来修改设置</li></ul><a href=#m-和-p-是怎么样的关系><h1 id=m-和-p-是怎么样的关系><span class=hanchor arialabel=Anchor># </span>M 和 P 是怎么样的关系</h1></a><ul><li>M 必须拥有 P 才可以执行 G 中的代码，理想情况下一个 M 对应一个 P，P 含有包含多个 G 的队列，P 会周期性地将 G 调度到 M 种执行。</li></ul><a href=#gmp-调度过程中存在哪些阻塞><h1 id=gmp-调度过程中存在哪些阻塞><span class=hanchor arialabel=Anchor># </span>GMP 调度过程中存在哪些阻塞</h1></a><ul><li>I/O，select</li><li>Block on syscall</li><li>Channel</li><li>等待锁</li><li>Runtime.Gosched ()</li></ul><a href=#gmp-当一个-g-堵塞时gmp-会发生什么><h1 id=gmp-当一个-g-堵塞时gmp-会发生什么><span class=hanchor arialabel=Anchor># </span>GMP 当一个 G 堵塞时，G、M、P 会发生什么</h1></a><p>当 g 阻塞时，p 会和 m 解绑，去寻找下一个可用的 m。<br>G&m 在阻塞结束之后会优先寻找之前的 p，如果此时 p 已绑定其他 m，当前 m 会进入休眠，g 以可运行的状态进入全局队列</p><a href=#sysmon有什么作用><h1 id=sysmon有什么作用><span class=hanchor arialabel=Anchor># </span><strong>sysmon</strong> <strong>有什么作用</strong></h1></a><p>Sysmon 也叫监控线程，变动的周期性检查，好处</p><ul><li>释放闲置超过 5 分钟的 span 物理内存；</li><li>如果超过 2 分钟没有垃圾回收，强制执行；</li><li>将长时间未处理的 netpoll 添加到全局队列；</li><li>向长时间运行的 G 任务发出抢占调度 (超过 10 ms 的 g，会进行 retake)；</li><li>收回因 syscall 长时间阻塞的 P；</li></ul><a href=#gmp-模型里为什么要有-p><h1 id=gmp-模型里为什么要有-p><span class=hanchor arialabel=Anchor># </span>GMP 模型里为什么要有 P？</h1></a><p><a href=https://mp.weixin.qq.com/s/SEE2TUeZQZ7W1BKkmnelAA rel=noopener>https://mp.weixin.qq.com/s/SEE2TUeZQZ7W1BKkmnelAA</a> </p><a href=#为什么-gmp-模型会更快><h1 id=为什么-gmp-模型会更快><span class=hanchor arialabel=Anchor># </span>为什么 GMP 模型会更快</h1></a><p>谈到 Go 语言调度器，绕不开操作系统，进程与线程这些概念。线程是操作系统调度的最小单元，而 Linux 调度器并不区分进程和线程的调度，它们在不同操作系统上的实现也不同，但是在大多数实现中线程属于进程。多个线程可以属于同一个进程并共享内存空间。因为多线程不需要创建新的虚拟内存空间，所以它们也不需要内存管理单元处理上下文的切换，线程之间的通信也正是基于共享内存进行的，与重量级进程相比，线程显得比较轻量。虽然线程比较轻量，但是在调度时也有比较大的额外开销。每个线程会都占用 1 MB 以上的内存空间，在切换线程时不止会消耗较多内存，恢复寄存器中的内存还需要向操作系统申请或者销毁资源。每一个线程上下文的切换都需要消耗 1 us 的时间，而 Go 调度器对 Goroutine 的上下文切换越为 0.2 us，减少了 80% 的额外开销。Go 语言的调度器使用与 CPU 数量相等的线程来减少线程频繁切换带来的内存开销，同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。</p><a href=#同时启动了一万个-g如何调度><h1 id=同时启动了一万个-g如何调度><span class=hanchor arialabel=Anchor># </span>同时启动了一万个 G，如何调度？</h1></a><p>首先一万个 G 会按照 P 的设定个数，尽量平均地分配到每个 P 的本地队列中。如果所有本地队列都满了，那么剩余的 G 则会分配到 GMP 的全局队列上。接下来便开始执行 GMP 模型的调度策略：</p><ul><li><strong>本地队列轮转</strong>：每个 P 维护着一个包含 G 的队列，不考虑 G 进入系统调用或 IO 操作的情况下，P 周期性的将 G 调度到 M 中执行，执行一小段时间，将上下文保存下来，然后将 G 放到队列尾部，然后从队首中重新取出一个 G 进行调度。</li><li><strong>系统调用</strong>：上面说到 P 的个数默认等于 CPU 核数，每个 M 必须持有一个 P 才可以执行 G，一般情况下 M 的个数会略大于 P 的个数，这多出来的 M 将会在 G 产生系统调用时发挥作用。当该 G 即将进入系统调用时，对应的 M 由于陷入系统调用而进被阻塞，将释放 P，进而某个空闲的 M1获取 P，继续执行 P 队列中剩下的 G。</li><li><strong>工作量窃取</strong>：多个 P 中维护的 G 队列有可能是不均衡的，当某个 P 已经将 G 全部执行完，然后去查询全局队列，全局队列中也没有新的 G，而另一个 M 中队列中还有 3 很多 G 待运行。此时，空闲的 P 会将其他 P 中的 G 偷取一部分过来，一般每次偷取一半。</li></ul><a href=#go-如何调度假设-4-核的-cpu-应该有几个-m那能有几个-groutinuegroutinue-数量的上限是多少><h1 id=go-如何调度假设-4-核的-cpu-应该有几个-m那能有几个-groutinuegroutinue-数量的上限是多少><span class=hanchor arialabel=Anchor># </span>Go 如何调度，假设 4 核的 cpu 应该有几个 M，那能有几个 groutinue，groutinue 数量的上限是多少？</h1></a><p>协程的数量, 理论上没有上限<br>M 的最大数量一万<br>4 核的 cpu 默认最大并发的 M=4</p><a href=#gmp-并发模型goroutine-切换的时候上下文环境放在哪里><h1 id=gmp-并发模型goroutine-切换的时候上下文环境放在哪里><span class=hanchor arialabel=Anchor># </span>GMP 并发模型，Goroutine 切换的时候上下文环境放在哪里</h1></a><p>协程切换时候的上下文存储在处理器中</p><a href=#golang-调度能不能不要-p><h1 id=golang-调度能不能不要-p><span class=hanchor arialabel=Anchor># </span>Golang 调度能不能不要 p</h1></a><p><strong>1. 介绍 golang 调度器中 P 是什么？</strong></p><p>Processor 的简称，处理器，上下文。</p><p><strong>2. 简述 p 的功能与为什么必须要 P</strong></p><p>它的主要用途就是用来执行 goroutine 的，它维护了一个 goroutine 队列，即 runqueue。Processor 是让咱们从 N: 1 调度到 M: N 调度的重要部分。</p><a href=#goroutine-的调度是出现在什么情况下调度时做了什么><h1 id=goroutine-的调度是出现在什么情况下调度时做了什么><span class=hanchor arialabel=Anchor># </span>Goroutine 的调度是出现在什么情况下，调度时做了什么</h1></a><p>Go 调度器会在以下三种情况对 goroutine 进行调度：</p><ol><li>Goroutine 执行某个操作因条件不满足需要等待而发生的调度。</li><li>Goroutine 主动调用 Gosched ()让出 CPU 而发生的调度。</li><li>Goroutine 运行时间太长或长时间处于系统调用中，被调度器剥夺运行权而发生的调度。</li></ol><p>调度器一般做以下事：</p><ul><li>协程调度。因为系统内核不能再决定协程的切换，那么协程的切换时间点则是由程序内部的调度器决定的。</li><li>垃圾回收。垃圾回收的必要条件是内存位于一致状态，这就需要暂停所有的线程，如果交给系统去做，那么会暂停所有的线程使其一致。程序自身的调度器知道什么时候内存位于一致状态，那么就没有必要暂停所有运行的协程。</li></ul><a href=#为什么-p-的-local-queue-可无锁访问任务窃取的时候要加锁吗><h1 id=为什么-p-的-local-queue-可无锁访问任务窃取的时候要加锁吗><span class=hanchor arialabel=Anchor># </span>为什么 P 的 local queue 可无锁访问，任务窃取的时候要加锁吗?</h1></a><p>绑定在 P 上的 local queue 是顺序执行的，不存在执行状态的 G 协程抢占，所以可以无锁访问。</p><p>任务窃取也是窃取其他 P 上等待状态的 G 协程，所以也可以不用加锁。</p><a href=#一个-goroutine-sleep-了操作系统是怎么唤醒的><h1 id=一个-goroutine-sleep-了操作系统是怎么唤醒的><span class=hanchor arialabel=Anchor># </span>一个 goroutine sleep 了，操作系统是怎么唤醒的</h1></a><ol><li><strong>goroutine 唤醒</strong><br>Goroutine 的唤醒涉及到一个很重要的函数 (goready), 它的作用就是唤醒 waiting 状态的 goroutine.<br>通过 systemstack 切到 g 0 栈，在 g 0 栈上发起调度.<br>获取 goroutine 的状态.<br>将 waiting 状态的 goroutine 切换到 runable 状态<br>尝试唤起一个 p 来执行当前 goroutine</li><li>注释: go 程序中，每个 M 都会绑定一个叫 g 0 的初代 goroutine，它在 M 的创建的时候创建，g 0 的主要工作就是 goroutine 的调度、垃圾回收等.</li></ol><a href=#go-的协程可以只挂在一个线程上面吗><h1 id=go-的协程可以只挂在一个线程上面吗><span class=hanchor arialabel=Anchor># </span>Go 的协程可以只挂在一个线程上面吗</h1></a><p>不能。可以保证一个 P，用 runtime.GOMAXPROCS (1)设置处理器 P 只启动一个，但程序初始化的线程 M 一般不会只有一个。</p><a href=#go-线程实现模型><h1 id=go-线程实现模型><span class=hanchor arialabel=Anchor># </span>Go 线程实现模型？</h1></a><p>Go 实现的是两级线程模型（M：N)，准确的说是 GMP 模型，是对两级线程模型的改进实现，使它能够更加灵活地进行线程之间的调度。</p><a href=#背景><h2 id=背景><span class=hanchor arialabel=Anchor># </span>背景</h2></a><table><thead><tr><th>含义</th><th>缺点</th><th></th></tr></thead><tbody><tr><td>单进程时代</td><td>每个程序就是一个进程，直到一个程序运行完，才能进行下一个进程</td><td>1. 无法并发，只能串行 2. 进程阻塞所带来的 CPU 时间浪费</td></tr><tr><td>多进程/线程时代</td><td>一个线程阻塞， cpu 可以立刻切换到其他线程中去执行</td><td>1. 进程/线程占用内存高 2. 进程/线程上下文切换成本高</td></tr><tr><td>协程时代</td><td>协程（用户态线程）绑定线程（内核态线程），cpu 调度线程执行</td><td>1. 实现起来较复杂，协程和线程的绑定依赖调度器算法</td></tr></tbody></table><p>线程 -> CPU 由操作系统调度，协程 -> 线程由 Go 调度器来调度，协程与线程的映射关系有三种线程模型</p><a href=#三种线程模型><h2 id=三种线程模型><span class=hanchor arialabel=Anchor># </span>三种线程模型</h2></a><p>线程实现模型主要分为：<code>内核级线程模型</code>、<code>用户级线程模型</code>、<code>两级线程模型</code>，他们的区别在于用户线程与内核线程之间的对应关系。</p><a href=#内核级线程模型11><h3 id=内核级线程模型11><span class=hanchor arialabel=Anchor># </span><strong>内核级线程模型（1：1）</strong></h3></a><p>1 个用户线程对应 1 个内核线程，这种最容易实现，协程的调度都由 CPU 完成了</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226001710.png width=auto alt=image.png></p><p>优点：</p><ul><li>实现起来最简单</li><li>能够利用多核</li><li>如果进程中的一个线程被阻塞，不会阻塞其他线程，是能够切换同一进程内的其他线程继续执行</li></ul><p>缺点：</p><ul><li>上下文切换成本高，创建、删除和切换都由 CPU 完成</li></ul><a href=#用户级线程模型n1><h3 id=用户级线程模型n1><span class=hanchor arialabel=Anchor># </span><strong>用户级线程模型（N：1）</strong></h3></a><p>1 个进程中的所有线程对应 1 个内核线程</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226001725.png width=auto alt=image.png></p><p>优点：</p><ul><li>上下文切换成本低，在用户态即可完成协程切换</li></ul><p>缺点：</p><ul><li>无法利用多核</li><li>一旦协程阻塞，造成线程阻塞，本线程的其它协程无法执行</li></ul><a href=#两级线程模型mn><h3 id=两级线程模型mn><span class=hanchor arialabel=Anchor># </span><strong>两级线程模型（M：N)</strong></h3></a><p>M 个线程对应 N 个内核线程</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226001737.png width=auto alt=image.png></p><p>优点：</p><ul><li>能够利用多核</li><li>上下文切换成本低</li><li>如果进程中的一个线程被阻塞，不会阻塞其他线程，是能够切换同一进程内的其他线程继续执行</li></ul><p>缺点：</p><ul><li>实现起来最复杂</li></ul><a href=#go-gmp-和-gm-模型><h1 id=go-gmp-和-gm-模型><span class=hanchor arialabel=Anchor># </span>Go GMP 和 GM 模型？</h1></a><p>什么才是一个好的调度器？</p><p>能在适当的时机将合适的协程分配到合适的位置，保证公平和效率。</p><p>Go 采用了 GMP 模型（对两级线程模型的改进实现），使它能够更加灵活地进行线程之间的调度。</p><a href=#gmp-模型><h2 id=gmp-模型><span class=hanchor arialabel=Anchor># </span>GMP 模型</h2></a><p>GMP 是 Go 运行时调度层面的实现，包含 4 个重要结构，分别是 G、M、P、Sched
<img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226001847.png width=auto alt=image.png></p><ul><li><p><strong>G（Goroutine）</strong>：代表 Go 协程 Goroutine，存储了 Goroutine 的执行栈信息、Goroutine 状态以及 Goroutine 的任务函数等。<strong>G 的数量无限制，理论上只受内存的影响</strong>，创建一个 G 的初始栈大小为 2-4 K，配置一般的机器也能简简单单开启数十万个 Goroutine ，而且 Go 语言在 G 退出的时候还会把 G 清理之后放到 P 本地或者全局的闲置列表 gFree 中以便复用。</p></li><li><p><strong>M（Machine）</strong>： Go 对操作系统线程（OS thread）的封装，可以看作操作系统内核线程，想要在 CPU 上执行代码必须有线程，通过系统调用 clone 创建。M 在绑定有效的 P 后，进入一个调度循环，而调度循环的机制大致是从 P 的本地运行队列以及全局队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作并回到 M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础。<strong>M 的数量有限制，默认数量限制是 10000</strong>，可以通过 debug.SetMaxThreads () 方法进行设置，如果有 M 空闲，那么就会回收或者睡眠。</p></li><li><p>**P（Processor）：虚拟处理器，M 执行 G 所需要的资源和上下文，只有将 P 和 M 绑定，才能让 P 的 runq 中的 G 真正运行起来。P 的数量决定了系统内最大可并行的 G 的数量，**P 的数量受本机的 CPU 核数影响，可通过环境变量$GOMAXPROCS 或在 runtime.GOMAXPROCS ()来设置，默认为 CPU 核心数。</p></li><li><p><strong>Sched：调度器结构</strong>，它维护有存储 M 和 G 的全局队列，以及调度器的一些状态信息</p></li></ul><table><thead><tr><th></th><th>G</th><th>M</th><th>P</th></tr></thead><tbody><tr><td>数量限制</td><td>无限制，受机器内存影响</td><td>有限制，默认最多 10000</td><td>有限制，最多 GOMAXPROCS 个</td></tr><tr><td>创建时机</td><td>go func</td><td>当没有足够的 M 来关联 P 并运行其中的可运行的 G 时会请求创建新的 M</td><td>在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建个 P</td></tr></tbody></table><p><strong>核心数据结构:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>//src/runtime/runtime2.go
</span></span><span class=line><span class=cl>type g struct {
</span></span><span class=line><span class=cl>    goid    int64 // 唯一的goroutine的ID
</span></span><span class=line><span class=cl>    sched gobuf // goroutine切换时，用于保存g的上下文
</span></span><span class=line><span class=cl>    stack stack // 栈
</span></span><span class=line><span class=cl>  gopc        // pc of go statement that created this goroutine
</span></span><span class=line><span class=cl>    startpc    uintptr // pc of goroutine function
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>type p struct {
</span></span><span class=line><span class=cl>    lock mutex
</span></span><span class=line><span class=cl>    id          int32
</span></span><span class=line><span class=cl>    status      uint32 // one of pidle/prunning/...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // Queue of runnable goroutines. Accessed without lock.
</span></span><span class=line><span class=cl>    runqhead uint32 // 本地队列队头
</span></span><span class=line><span class=cl>    runqtail uint32 // 本地队列队尾
</span></span><span class=line><span class=cl>    runq     [256]guintptr // 本地队列，大小256的数组，数组往往会被都读入到缓存中，对缓存友好，效率较高
</span></span><span class=line><span class=cl>    runnext guintptr // 下一个优先执行的goroutine（一定是最后生产出来的)，为了实现局部性原理，runnext中的G永远会被最先调度执行
</span></span><span class=line><span class=cl>    ... 
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>type m struct {
</span></span><span class=line><span class=cl>    g0            *g     
</span></span><span class=line><span class=cl>    // 每个M都有一个自己的G0，不指向任何可执行的函数，在调度或系统调用时，M会切换到G0，使用G0的栈空间来调度
</span></span><span class=line><span class=cl>    curg          *g    
</span></span><span class=line><span class=cl>    // 当前正在执行的G
</span></span><span class=line><span class=cl>    ... 
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>type schedt struct {
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    runq     gQueue // 全局队列，链表（长度无限制）
</span></span><span class=line><span class=cl>    runqsize int32  // 全局队列长度
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>GMP 模型的实现算是 Go 调度器的一大进步，但调度器仍然有一个令人头疼的问题，那就是不支持抢占式调度，这导致一旦某个 G 中出现死循环的代码逻辑，那么 G 将永久占用分配给它的 P 和 M，而位于同一个 P 中的其他 G 将得不到调度，出现“饿死”的情况。</p><p>当只有一个 P（GOMAXPROCS=1）时，整个 Go 程序中的其他 G 都将“饿死”。于是在 Go 1.2 版本中实现了基于协作的“抢占式”调度，在 Go 1.14 版本中实现了基于信号的“抢占式”调度。</p><a href=#gm-模型><h2 id=gm-模型><span class=hanchor arialabel=Anchor># </span>GM 模型</h2></a><p>Go 早期是 GM 模型，没有 P 组件
<img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226002031.png width=auto alt=image.png></p><p>**GM 调度存在的问题： **</p><ol><li><strong>全局队列的锁竞争</strong>，当 M 从全局队列中添加或者获取 G 的时候，都需要获取队列锁，导致激烈的锁竞争</li><li><strong>M 转移 G 增加额外开销</strong>，当 M 1 在执行 G 1 的时候， M 1 创建了 G 2，为了继续执行 G 1，需要把 G 2 保存到全局队列中，无法保证 G 2 是被 M 1 处理。因为 M 1 原本就保存了 G 2 的信息，所以 G 2 最好是在 M 1 上执行，这样的话也不需要转移 G 到全局队列和线程上下文切换</li><li><strong>线程使用效率不能最大化</strong>，没有<strong>work-stealing</strong> 和<strong>hand-off</strong> 机制</li></ol><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，为了解决这一的问题 go 从 1.1 版本引入 P，在运行时系统的时候加入 P 对象，让 P 去管理这个 G 对象，M 想要运行 G，必须绑定 P，才能运行 P 所管理的 G</p><a href=#go-调度原理><h1 id=go-调度原理><span class=hanchor arialabel=Anchor># </span>Go 调度原理？</h1></a><p>Goroutine 调度的本质就是将 **Goroutine (G）**按照一定算法放到 CPU 上去执行。</p><p>CPU 感知不到 Goroutine，只知道内核线程，所以需要<strong>Go 调度器</strong>将协程调度到内核线程上面去，然后<strong>操作系统调度器</strong>将内核线程放到 CPU 上去执行</p><p>M 是对内核级线程的封装，<strong>所以 Go 调度器的工作就是将 G 分配到 M</strong></p><p>Go 调度器的实现不是一蹴而就的，它的调度模型与算法也是几经演化，从最初的 GM 模型、到 GMP 模型，从<strong>不支持抢占</strong>，到<strong>支持协作式抢占</strong>，再到<strong>支持基于信号的异步抢占</strong>，经历了不断地优化与打磨。</p><a href=#设计思想><h2 id=设计思想><span class=hanchor arialabel=Anchor># </span>设计思想</h2></a><ul><li>线程复用（<strong>work stealing 机制</strong>和<strong>hand off 机制</strong>）</li><li>利用并行（利用多核 CPU）</li><li>抢占调度（解决公平性问题）</li></ul><a href=#调度对象><h2 id=调度对象><span class=hanchor arialabel=Anchor># </span>调度对象</h2></a><p>Go 调度器</p><blockquote><p>Go 调度器是属于 Go runtime 中的一部分，Go runtime 负责实现 Go 的<strong>并发调度</strong>、<strong>垃圾回收</strong>、<strong>内存堆栈管理</strong>等关键功能</p></blockquote><a href=#被调度对象><h2 id=被调度对象><span class=hanchor arialabel=Anchor># </span>被调度对象</h2></a><p>G 的来源</p><ul><li>P 的 runnext（只有 1 个 G，局部性原理，永远会被最先调度执行）</li><li>P 的本地队列（数组，最多 256 个 G）</li><li>全局 G 队列（链表，无限制）</li><li>网络轮询器_network poller_（存放网络调用被阻塞的 G）</li></ul><p>P 的来源</p><ul><li>全局 P 队列（数组，GOMAXPROCS 个 P）</li></ul><p>M 的来源</p><ul><li>休眠线程队列（未绑定 P，长时间休眠会等待 GC 回收销毁）</li><li>运行线程（绑定 P，指向 P 中的 G）</li><li>自旋线程（绑定 P，指向 M 的 G0）</li></ul><p>其中运行线程数 + 自旋线程数 &lt;= P的数量（GOMAXPROCS），M个数 >= P 个数</p><a href=#调度流程><h2 id=调度流程><span class=hanchor arialabel=Anchor># </span>调度流程</h2></a><p>协程的调度采用了生产者-消费者模型，实现了用户任务与调度器的解耦
<img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226002132.png width=auto alt=image.png></p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226002138.png width=auto alt=image.png></p><p>生产端我们开启的每个协程都是一个计算任务，这些任务会被提交给 go 的 runtime。如果计算任务非常多，有成千上万个，那么这些任务是不可能同时被立刻执行的，所以这个计算任务一定会被先暂存起来，一般的做法是放到内存的队列中等待被执行。</p><p>G 的生命周期：G 从创建、保存、被获取、调度和执行、阻塞、销毁，步骤如下：</p><ul><li><p><strong>步骤 1：创建 G</strong>，关键字 <code>go func()</code> 创建 G <strong>步骤 2：保存 G</strong>，创建的 G 优先保存到本地队列 P，如果 P 满了，则会平衡部分 P 到全局队列中</p></li><li><p><strong>步骤 3</strong>：<strong>唤醒或者新建 M</strong>执行任务，进入调度循环（步骤 4,5,6)</p></li><li><p><strong>步骤 4：M 获取 G</strong>，M 首先从 P 的本地队列获取 G，如果 P 为空，则从全局队列获取 G，如果全局队列也为空，则从另一个本地队列偷取一半数量的 G（负载均衡），这种从其它 P 偷的方式称之为 work stealing</p></li><li><p><strong>步骤 5：M 调度和执行 G</strong>，M 调用 <code>G.func()</code> 函数执行 G</p><ul><li>如果 M 在执行 G 的过程发生<strong>系统调用阻塞</strong>（同步），会阻塞 G 和 M（操作系统限制），此时 P 会和当前 M 解绑，并寻找新的 M，如果没有空闲的 M 就会新建一个 M ，接管正在阻塞 G 所属的 P，接着继续执行 P 中其余的 G，这种阻塞后释放 P 的方式称之为 hand off。当<strong>系统调用结束</strong>后，这个 G 会尝试获取一个空闲的 P 执行，优先获取之前绑定的 P，并放入到这个 P 的本地队列，如果获取不到 P，那么这个线程 M 变成休眠状态，加入到空闲线程中，然后这个 G 会被放入到全局队列中。</li><li>如果 M 在执行 G 的过程发生网络 IO 等操作阻塞时（异步），阻塞 G，<strong>不会阻塞 M</strong>。M 会寻找 P 中其它可执行的 G 继续执行，G 会被网络轮询器 network poller 接手，当阻塞的 G 恢复后，G 1 从 network poller 被移回到 P 的 LRQ 中，重新进入可执行状态。异步情况下，通过调度，Go scheduler 成功地将 I/O 的任务转变成了 CPU 任务，或者说将内核级别的线程切换转变成了用户级别的 goroutine 切换，大大提高了效率。</li></ul></li><li><p><strong>步骤 6：M 执行完 G 后清理现场</strong>，重新进入调度循环（将 M 上运⾏的 goroutine 切换为 G 0，G 0 负责调度时协程的切换）。其中步骤 2 中保存 G 的详细流程如下：</p><ul><li>执行 go func 的时候，主线程 M 0 会调用 newproc ()生成一个 G 结构体，这里会先选定当前 M 0 上的 P 结构</li><li>每个协程 G 都会被尝试先放到 P 中的 runnext，若 runnext 为空则放到 runnext 中，生产结束</li><li>若 runnext 满，则将原来 runnext 中的 G 踢到本地队列中，将当前 G 放到 runnext 中，生产结束</li><li>若本地队列也满了，则将本地队列中的 G 拿出一半，放到全局队列中，生产结束。
<img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226002235.png width=auto alt=image.png></li></ul></li></ul><a href=#调度时机><h2 id=调度时机><span class=hanchor arialabel=Anchor># </span>调度时机</h2></a><p><strong>什么时候进行调度（执行/切换）？</strong></p><p>在以下情形下，会切换正在执行的 goroutine</p><ul><li>抢占式调度<ul><li>Sysmon 检测到协程运行过久（比如 sleep，死循环）<ul><li>切换到 g 0，进入调度循环</li></ul></li></ul></li><li>主动调度<ul><li>新起一个协程和协程执行完毕<ul><li>触发调度循环</li></ul></li><li>主动调用 runtime.Gosched ()<ul><li>切换到 g 0，进入调度循环</li></ul></li><li>垃圾回收之后<ul><li>Stw 之后，会重新选择 g 开始执行</li></ul></li></ul></li><li>被动调度<ul><li>系统调用（比如文件 IO）阻塞（同步）<ul><li>阻塞 G 和 M，P 与 M 分离，将 P 交给其它 M 绑定，其它 M 执行 P 的剩余 G</li></ul></li><li>网络 IO 调用阻塞（异步）<ul><li>阻塞 G，G 移动到 NetPoller，M 执行 P 的剩余 G</li></ul></li><li>Atomic/mutex/channel 等阻塞（异步）<ul><li>阻塞 G，G 移动到 channel 的等待队列中，M 执行 P 的剩余 G</li></ul></li></ul></li></ul><a href=#调度策略><h2 id=调度策略><span class=hanchor arialabel=Anchor># </span>调度策略</h2></a><p><strong>使用什么策略来挑选下一个 goroutine 执行？</strong></p><p>由于 P 中的 G 分布在 runnext、本地队列、全局队列、网络轮询器中，则需要挨个判断是否有可执行的 G，大体逻辑如下：</p><ul><li>每执行 61 次调度循环，从全局队列获取 G，若有则直接返回</li><li>从 P 上的 runnext 看一下是否有 G，若有则直接返回</li><li>从 P 上的本地队列看一下是否有 G，若有则直接返回</li><li>上面都没查找到时，则去全局队列、网络轮询器查找或者从其他 P 中窃取，<strong>一直阻塞</strong>直到获取到一个可用的 G 为止</li></ul><p>源码实现如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func schedule() {
</span></span><span class=line><span class=cl>    _g_ := getg()
</span></span><span class=line><span class=cl>    var gp *g
</span></span><span class=line><span class=cl>    var inheritTime bool
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    if gp == nil {
</span></span><span class=line><span class=cl>        // 每执行61次调度循环会看一下全局队列。为了保证公平，避免全局队列一直无法得到执行的情况，当全局运行队列中有待执行的G时，通过schedtick保证有一定几率会从全局的运行队列中查找对应的Goroutine；
</span></span><span class=line><span class=cl>        if _g_.m.p.ptr().schedtick%61 == 0 &amp;&amp; sched.runqsize &gt; 0 {
</span></span><span class=line><span class=cl>            lock(&amp;sched.lock)
</span></span><span class=line><span class=cl>            gp = globrunqget(_g_.m.p.ptr(), 1)
</span></span><span class=line><span class=cl>            unlock(&amp;sched.lock)
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    if gp == nil {
</span></span><span class=line><span class=cl>        // 先尝试从P的runnext和本地队列查找G
</span></span><span class=line><span class=cl>        gp, inheritTime = runqget(_g_.m.p.ptr())
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    if gp == nil {
</span></span><span class=line><span class=cl>        // 仍找不到，去全局队列中查找。还找不到，要去网络轮询器中查找是否有G等待运行；仍找不到，则尝试从其他P中窃取G来执行。
</span></span><span class=line><span class=cl>        gp, inheritTime = findrunnable() // blocks until work is available
</span></span><span class=line><span class=cl>        // 这个函数是阻塞的，执行到这里一定会获取到一个可执行的G
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    // 调用execute，继续调度循环
</span></span><span class=line><span class=cl>    execute(gp, inheritTime)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>从全局队列查找时，如果要所有 P 平分全局队列中的 G，每个 P 要分得多少个，这里假设会分得 n 个。然后把这 n 个 G，转移到当前 G 所在 P 的本地队列中去。但是最多不能超过 P 本地队列长度的一半（即 128）。这样做的目的是，如果下次调度循环到来的时候，就不必去加锁到全局队列中在获取一次 G 了，性能得到了很好的保障。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func globrunqget(_p_ *p, max int32) *g {
</span></span><span class=line><span class=cl>   ...
</span></span><span class=line><span class=cl>   // gomaxprocs = p的数量
</span></span><span class=line><span class=cl>   // sched.runqsize是全局队列长度
</span></span><span class=line><span class=cl>   // 这里n = 全局队列的G平分到每个P本地队列上的数量 + 1
</span></span><span class=line><span class=cl>   n := sched.runqsize/gomaxprocs + 1
</span></span><span class=line><span class=cl>   if n &gt; sched.runqsize {
</span></span><span class=line><span class=cl>      n = sched.runqsize
</span></span><span class=line><span class=cl>   }
</span></span><span class=line><span class=cl>   if max &gt; 0 &amp;&amp; n &gt; max {
</span></span><span class=line><span class=cl>      n = max
</span></span><span class=line><span class=cl>   }
</span></span><span class=line><span class=cl>   // 平分后的数量n不能超过本地队列长度的一半，也就是128
</span></span><span class=line><span class=cl>   if n &gt; int32(len(_p_.runq))/2 {
</span></span><span class=line><span class=cl>      n = int32(len(_p_.runq)) / 2
</span></span><span class=line><span class=cl>   }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   // 执行将G从全局队列中取n个分到当前P本地队列的操作
</span></span><span class=line><span class=cl>   sched.runqsize -= n
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   gp := sched.runq.pop()
</span></span><span class=line><span class=cl>   n--
</span></span><span class=line><span class=cl>   for ; n &gt; 0; n-- {
</span></span><span class=line><span class=cl>      gp1 := sched.runq.pop()
</span></span><span class=line><span class=cl>      runqput(_p_, gp1, false)
</span></span><span class=line><span class=cl>   }
</span></span><span class=line><span class=cl>   return gp
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>从其它 P 查找时，会偷一半的 G 过来放到当前 P 的本地队列</p><a href=#go-work-stealing-机制><h1 id=go-work-stealing-机制><span class=hanchor arialabel=Anchor># </span>Go work stealing 机制？</h1></a><a href=#概念><h2 id=概念><span class=hanchor arialabel=Anchor># </span>概念</h2></a><p>当线程 M⽆可运⾏的 G 时，尝试从其他 M 绑定的 P 偷取 G，减少空转，提高了线程利用率（避免闲着不干活）。</p><p>当从本线程绑定 P 本地队列、全局 G 队列、netpoller 都找不到可执行的 g，会从别的 P 里窃取 G 并放到当前 P 上面。</p><p>从_netpoller_ 中拿到的 G 是_Gwaiting 状态（ 存放的是因为网络 IO 被阻塞的 G），从其它地方拿到的 G 是_Grunnable 状态</p><p>从全局队列取的 G 数量：N = min (len (GRQ)/GOMAXPROCS + 1, len (GRQ/2)) （根据 GOMAXPROCS 负载均衡）</p><p>从其它 P 本地队列<strong>窃取</strong>的 G 数量：N = len (LRQ)/2（平分）</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226002437.png width=auto alt=image.png></p><a href=#窃取流程><h2 id=窃取流程><span class=hanchor arialabel=Anchor># </span>窃取流程</h2></a><p>源码见 runtime/proc. Go stealWork 函数，窃取流程如下，如果经过多次努力一直找不到需要运行的 goroutine 则调用 stopm 进入睡眠状态，等待被其它工作线程唤醒。</p><ol><li>选择要窃取的 P</li><li>从 P 中偷走一半 G</li></ol><a href=#选择要窃取的-p><h3 id=选择要窃取的-p><span class=hanchor arialabel=Anchor># </span><strong>选择要窃取的 P</strong></h3></a><p>窃取的实质就是遍历 allp 中的所有 p，查看其运行队列是否有 goroutine，如果有，则取其一半到当前工作线程的运行队列</p><p>为了保证公平性，遍历 allp 时并不是固定的从 allp[0]即第一个 p 开始，而是从随机位置上的 p 开始，而且遍历的顺序也随机化了，并不是现在访问了第 i 个 p 下一次就访问第 i+1 个 p，而是使用了一种伪随机的方式遍历 allp 中的每个 p，防止每次遍历时使用同样的顺序访问 allp 中的元素</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>offset := uint32(random()) % nprocs
</span></span><span class=line><span class=cl>coprime := 随机选取一个小于nprocs且与nprocs互质的数
</span></span><span class=line><span class=cl>const stealTries = 4 // 最多重试4次
</span></span><span class=line><span class=cl>for i := 0; i &lt; stealTries; i++ {
</span></span><span class=line><span class=cl>    for i := 0; i &lt; nprocs; i++ {
</span></span><span class=line><span class=cl>      p := allp[offset]
</span></span><span class=line><span class=cl>        从p的运行队列偷取goroutine
</span></span><span class=line><span class=cl>        if 偷取成功 {
</span></span><span class=line><span class=cl>        break
</span></span><span class=line><span class=cl>     }
</span></span><span class=line><span class=cl>        offset += coprime
</span></span><span class=line><span class=cl>        offset = offset % nprocs
</span></span><span class=line><span class=cl>     }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>可以看到只要随机数不一样，偷取 p 的顺序也不一样，但可以保证经过 nprocs 次循环，每个 p 都会被访问到。</p><a href=#从-p-中偷走一半-g><h3 id=从-p-中偷走一半-g><span class=hanchor arialabel=Anchor># </span><strong>从 P 中偷走一半 G</strong></h3></a><p>源码见 runtime/proc. Go runqsteal 函数：</p><p>挑选出盗取的对象 p 之后，则调用 runqsteal 盗取 p 的运行队列中的 goroutine，runqsteal 函数再调用 runqgrap 从 p 的本地队列尾部批量偷走一半的 g</p><p>为啥是偷一半的 g，可以理解为负载均衡</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func runqgrab(_p_ *p, batch *[256]guintptr, batchHead uint32, stealRunNextG bool) uint32 {
</span></span><span class=line><span class=cl>    for {
</span></span><span class=line><span class=cl>        h := atomic.LoadAcq(&amp;_p_.runqhead) // load-acquire, synchronize with other consumers
</span></span><span class=line><span class=cl>        t := atomic.LoadAcq(&amp;_p_.runqtail) // load-acquire, synchronize with the producer
</span></span><span class=line><span class=cl>        n := t - h        //计算队列中有多少个goroutine
</span></span><span class=line><span class=cl>        n = n - n/2     //取队列中goroutine个数的一半
</span></span><span class=line><span class=cl>        if n == 0 {
</span></span><span class=line><span class=cl>            ......
</span></span><span class=line><span class=cl>            return ......
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return n
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#go-hand-off-机制><h1 id=go-hand-off-机制><span class=hanchor arialabel=Anchor># </span>Go hand off 机制？</h1></a><a href=#概念-1><h2 id=概念-1><span class=hanchor arialabel=Anchor># </span>概念</h2></a><p>也称为 P 分离机制，当本线程 M 因为 G 进行的系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的 M 执行，也提高了线程利用率（避免站着茅坑不拉 shi）。</p><a href=#分离流程><h2 id=分离流程><span class=hanchor arialabel=Anchor># </span>分离流程</h2></a><p>当前线程 M 阻塞时，释放 P，给其它空闲的 M 处理
<img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226002549.png width=auto alt=image.png></p><a href=#go-抢占式调度><h1 id=go-抢占式调度><span class=hanchor arialabel=Anchor># </span>Go 抢占式调度？</h1></a><p>在 1.2 版本之前，Go 的调度器仍然不支持抢占式调度，程序只能依靠 Goroutine 主动让出 CPU 资源才能触发调度，这会引发一些问题，比如：</p><ul><li>某些 Goroutine 可以长时间占用线程，造成其它 Goroutine 的饥饿</li><li>垃圾回收器是需要 stop the world 的，如果垃圾回收器想要运行了，那么它必须先通知其它的 goroutine 停下来，这会造成较长时间的等待时间</li></ul><p>为解决这个问题：</p><ul><li>Go 1.2 中实现了基于协作的“抢占式”调度</li><li>Go 1.14 中实现了基于信号的“抢占式”调度</li></ul><a href=#基于协作的抢占式调度><h2 id=基于协作的抢占式调度><span class=hanchor arialabel=Anchor># </span>基于协作的抢占式调度</h2></a><p>协作式：大家都按事先定义好的规则来，比如：一个 goroutine 执行完后，退出，让出 p，然后下一个 goroutine 被调度到 p 上运行。这样做的缺点就在于是否让出 p 的决定权在 groutine 自身。一旦某个 g 不主动让出 p 或执行时间较长，那么后面的 goroutine 只能等着，没有方法让前者让出 p，导致延迟甚至饿死。</p><p>非协作式: 就是由 runtime 来决定一个 goroutine 运行多长时间，如果你不主动让出，对不起，我有手段可以抢占你，把你踢出去，让后面的 goroutine 进来运行。</p><p>基于协作的抢占式调度流程：</p><ul><li>编译器会在调用函数前插入 runtime. Morestack，让运行时有机会在这段代码中检查是否需要执行抢占调度</li><li>Go 语言运行时会在垃圾回收暂停程序、系统监控发现 Goroutine 运行超过 10 ms，那么会在这个协程设置一个抢占标记</li><li>当发生函数调用时，可能会执行编译器插入的 runtime. Morestack，它调用的 runtime. Newstack 会检查抢占标记，如果有抢占标记就会触发抢占让出 cpu，切到调度主协程里</li></ul><p>这种解决方案只能说局部解决了“饿死”问题，只在有函数调用的地方才能插入“抢占”代码（埋点），对于没有函数调用而是纯算法循环计算的 G，Go 调度器依然无法抢占。</p><p>比如，死循环等并没有给编译器插入抢占代码的机会，以下程序在 go 1.14 之前的 go 版本中，运行后会一直卡住，而不会打印 <code>I got scheduled!</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;runtime&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>runtime</span><span class=p>.</span><span class=nf>GOMAXPROCS</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;I got scheduled!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>为了解决这些问题，<strong>Go 在 1.14 版本中增加了对非协作的抢占式调度的支持</strong>，这种<strong>抢占式调度是基于系统信号的，也就是通过向线程发送信号的方式来抢占正在运行的 Goroutine</strong></p><a href=#基于信号的抢占式调度><h2 id=基于信号的抢占式调度><span class=hanchor arialabel=Anchor># </span>基于信号的抢占式调度</h2></a><p>真正的抢占式调度是基于信号完成的，所以也称为“异步抢占”。不管协程有没有意愿主动让出 cpu 运行权，只要某个协程执行时间过长，就会发送信号强行夺取 cpu 运行权。</p><ul><li>M 注册一个 SIGURG 信号的处理函数：sighandler</li><li>Sysmon 启动后会间隔性的进行监控，最长间隔 10 ms，最短间隔 20 us。如果发现某协程独占 P 超过 10 ms，会给 M 发送抢占信号</li><li>M 收到信号后，内核执行 sighandler 函数把当前协程的状态从_Grunning 正在执行改成 _Grunnable 可执行，把抢占的协程放到全局队列里，M 继续寻找其他 goroutine 来运行</li><li>被抢占的 G 再次调度过来执行时，会继续原来的执行流</li></ul><p>抢占分为 <code>_Prunning</code> 和 <code>_Psyscall</code>，<code>_Psyscall</code> 抢占通常是由于阻塞性系统调用引起的，比如磁盘 io、cgo。<code>_Prunning</code> 抢占通常是由于一些类似死循环的计算逻辑引起的。</p><a href=#go-如何查看运行时调度信息><h1 id=go-如何查看运行时调度信息><span class=hanchor arialabel=Anchor># </span>Go 如何查看运行时调度信息？</h1></a><p>有 2 种方式可以查看一个程序的调度 GMP 信息，分别是 go tool trace 和 GODEBUG</p><p>Trace. Go</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;os&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;runtime/trace&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//创建trace文件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>f</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Create</span><span class=p>(</span><span class=s>&#34;trace.out&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//启动trace goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>err</span> <span class=p>=</span> <span class=nx>trace</span><span class=p>.</span><span class=nf>Start</span><span class=p>(</span><span class=nx>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>trace</span><span class=p>.</span><span class=nf>Stop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//main
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Hello World&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=-httpsyouandgentlenesscn20230828goe8afade8a880e99da2e8af95e9a298e7b2bee8aeb2go-tool-trace-go-tool-trace-go-tool-trace><a href=https://youandgentleness.cn/2023/08/28/Go%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E8%AE%B2/#go-tool-trace rel=noopener></a> go tool trace</h4><p>启动可视化界面</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>go run trace.go
</span></span><span class=line><span class=cl>go tool trace trace.out
</span></span><span class=line><span class=cl>2022/04/22 10:44:11 Parsing trace...
</span></span><span class=line><span class=cl>2022/04/22 10:44:11 Splitting trace...
</span></span><span class=line><span class=cl>2022/04/22 10:44:11 Opening browser. Trace viewer is listening on http://127.0.0.1:35488
</span></span></code></pre></td></tr></table></div></div><p><strong>1. 打开 <code> http://127.0.0.1:35488</code> 查看可视化界面：</strong>
<img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226002735.png width=auto alt=image.png></p><p>点击 <code>view trace</code> 能够看见可视化的调度流程：</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226002746.png width=auto alt=image.png></p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226002842.png width=auto alt=image.png></p><p>一共有 2 个 G 在程序中，一个是特殊的 G 0，是每个 M 必须有的一个初始化的 G，另外一个是 G 1 main goroutine (执行 main 函数的协程)，在一段时间内处于可运行和运行的状态。</p><p><strong>2. 点击 Threads 那一行可视化的数据条，我们会看到 M 详细的信息</strong>
<img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226002855.png width=auto alt=image.png></p><p>一共有 2 个 M 在程序中，一个是特殊的 M 0，用于初始化使用，另外一个是用于执行 G 1 的 M1</p><p><strong>3. 点击 Proc 那一行可视化的数据条，我们会看到 P 上正在运行 goroutine 详细的信息</strong></p><p>一共有 3 个 P 在程序中，分别是 P 0、P 1、P2</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226002905.png width=auto alt=image.png></p><p>点击具体的 Goroutine 行为后可以看到其相关联的详细信息:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Start：开始时间
</span></span><span class=line><span class=cl>Wall Duration：持续时间
</span></span><span class=line><span class=cl>Self Time：执行时间
</span></span><span class=line><span class=cl>Start Stack Trace：开始时的堆栈信息
</span></span><span class=line><span class=cl>End Stack Trace：结束时的堆栈信息
</span></span><span class=line><span class=cl>Incoming flow：输入流
</span></span><span class=line><span class=cl>Outgoing flow：输出流
</span></span><span class=line><span class=cl>Preceding events：之前的事件
</span></span><span class=line><span class=cl>Following events：之后的事件
</span></span><span class=line><span class=cl>All connected：所有连接的事件
</span></span></code></pre></td></tr></table></div></div><a href=#godebug><h2 id=godebug><span class=hanchor arialabel=Anchor># </span>GODEBUG</h2></a><p>GODEBUG 变量可以控制运行时内的调试变量。查看调度器信息，将会使用如下两个参数：</p><ul><li>Schedtrace：设置 <code>schedtrace=X</code> 参数可以使运行时在每 X 毫秒发出一行调度器的摘要信息到标准 err 输出中。</li><li>Scheddetail：设置 <code>schedtrace=X</code> 和 <code>scheddetail=1</code> 可以使运行时在每 X 毫秒发出一次详细的多行信息，信息内容主要包括调度程序、处理器、OS 线程和 Goroutine 的状态。</li></ul><p><strong>查看基本信息</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>go build trace.go
</span></span><span class=line><span class=cl>GODEBUG=schedtrace=1000 ./trace
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>SCHED 0ms: gomaxprocs=8 idleprocs=6 threads=4 spinningthreads=1 idlethreads=0 runqueue=0 [1 0 0 0 0 0 0 0]
</span></span><span class=line><span class=cl>Hello World
</span></span><span class=line><span class=cl>SCHED 1010ms: gomaxprocs=8 idleprocs=8 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0 0 0 0 0 0 0]
</span></span><span class=line><span class=cl>Hello World
</span></span><span class=line><span class=cl>SCHED 2014ms: gomaxprocs=8 idleprocs=8 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0 0 0 0 0 0 0]
</span></span><span class=line><span class=cl>Hello World
</span></span><span class=line><span class=cl>SCHED 3024ms: gomaxprocs=8 idleprocs=8 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0 0 0 0 0 0 0]
</span></span><span class=line><span class=cl>Hello World
</span></span><span class=line><span class=cl>SCHED 4027ms: gomaxprocs=8 idleprocs=8 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0 0 0 0 0 0 0]
</span></span><span class=line><span class=cl>Hello World
</span></span><span class=line><span class=cl>SCHED 5029ms: gomaxprocs=8 idleprocs=7 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0 0 0 0 0 0 0]
</span></span></code></pre></td></tr></table></div></div><p>Sched：每一行都代表调度器的调试信息，后面提示的毫秒数表示启动到现在的运行时间，输出的时间间隔受 <code>schedtrace</code> 的值影响。</p><p>Gomaxprocs：当前的 CPU 核心数（GOMAXPROCS 的当前值）。</p><p>Idleprocs：空闲的处理器数量，后面的数字表示当前的空闲数量。</p><p>Threads：OS 线程数量，后面的数字表示当前正在运行的线程数量。</p><p>Spinningthreads：自旋状态的 OS 线程数量。</p><p>Idlethreads：空闲的线程数量。</p><p>Runqueue：全局队列中中的 Goroutine 数量，而后面的[0 0 0 0 0 0 0 0] 则分别代表这 8 个 P 的本地队列正在运行的 Goroutine 数量。</p><p><strong>查看详细信息</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>go build trace.go
</span></span><span class=line><span class=cl>GODEBUG=scheddetail=1,schedtrace=1000 ./trace
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>SCHED 0ms: gomaxprocs=8 idleprocs=6 threads=4 spinningthreads=1 idlethreads=0 runqueue=0 gcwaiting=0 nmidlelocked=0 stopwait=0 sysmonwait=0
</span></span><span class=line><span class=cl>  P0: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=1 gfreecnt=0 timerslen=0
</span></span><span class=line><span class=cl>  P1: status=1 schedtick=0 syscalltick=0 m=2 runqsize=0 gfreecnt=0 timerslen=0
</span></span><span class=line><span class=cl>  P2: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0
</span></span><span class=line><span class=cl>  P3: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0
</span></span><span class=line><span class=cl>  P4: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0
</span></span><span class=line><span class=cl>  P5: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0
</span></span><span class=line><span class=cl>  P6: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0
</span></span><span class=line><span class=cl>  P7: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0
</span></span><span class=line><span class=cl>  M3: p=0 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 spinning=false blocked=false lockedg=-1
</span></span><span class=line><span class=cl>  M2: p=1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=2 dying=0 spinning=false blocked=false lockedg=-1
</span></span><span class=line><span class=cl>  M1: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=2 dying=0 spinning=false blocked=false lockedg=-1
</span></span><span class=line><span class=cl>  M0: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 spinning=false blocked=false lockedg=1
</span></span><span class=line><span class=cl>  G1: status=1(chan receive) m=-1 lockedm=0
</span></span><span class=line><span class=cl>  G2: status=1() m=-1 lockedm=-1
</span></span><span class=line><span class=cl>  G3: status=1() m=-1 lockedm=-1
</span></span><span class=line><span class=cl>  G4: status=4(GC scavenge wait) m=-1 lockedm=-1
</span></span></code></pre></td></tr></table></div></div><p>G</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>status：G 的运行状态。
</span></span><span class=line><span class=cl>m：隶属哪一个 M。
</span></span><span class=line><span class=cl>lockedm：是否有锁定 M。
</span></span></code></pre></td></tr></table></div></div><p>G 的运行状态共涉及如下 9 种状态：</p><table><thead><tr><th>状态</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>_Gidle</td><td>0</td><td>刚刚被分配，还没有进行初始化。</td></tr><tr><td>_Grunnable</td><td>1</td><td>已经在运行队列中，还没有执行用户代码。</td></tr><tr><td>_Grunning</td><td>2</td><td>不在运行队列里中，已经可以执行用户代码，此时已经分配了 M 和 P。</td></tr><tr><td>_Gsyscall</td><td>3</td><td>正在执行系统调用，此时分配了 M。</td></tr><tr><td>_Gwaiting</td><td>4</td><td>在运行时被阻止，没有执行用户代码，也不在运行队列中，此时它正在某处阻塞等待中。</td></tr><tr><td>_Gmoribund_unused</td><td>5</td><td>尚未使用，但是在 gdb 中进行了硬编码。</td></tr><tr><td>_Gdead</td><td>6</td><td>尚未使用，这个状态可能是刚退出或是刚被初始化，此时它并没有执行用户代码，有可能有也有可能没有分配堆栈。</td></tr><tr><td>_Genqueue_unused</td><td>7</td><td>尚未使用。</td></tr><tr><td>_Gcopystack</td><td>8</td><td>正在复制堆栈，并没有执行用户代码，也不在运行队列中。</td></tr></tbody></table><p>M</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>p：隶属哪一个 P。
</span></span><span class=line><span class=cl>curg：当前正在使用哪个 G。
</span></span><span class=line><span class=cl>runqsize：运行队列中的 G 数量。
</span></span><span class=line><span class=cl>gfreecnt：可用的G（状态为 Gdead）。
</span></span><span class=line><span class=cl>mallocing：是否正在分配内存。
</span></span><span class=line><span class=cl>throwing：是否抛出异常。
</span></span><span class=line><span class=cl>preemptoff：不等于空字符串的话，保持 curg 在这个 m 上运行。
</span></span></code></pre></td></tr></table></div></div><p>P</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>status：P 的运行状态。
</span></span><span class=line><span class=cl>schedtick：P 的调度次数。
</span></span><span class=line><span class=cl>syscalltick：P 的系统调用次数。
</span></span><span class=line><span class=cl>m：隶属哪一个 M。
</span></span><span class=line><span class=cl>runqsize：运行队列中的 G 数量。
</span></span><span class=line><span class=cl>gfreecnt：可用的G（状态为 Gdead）
</span></span></code></pre></td></tr></table></div></div><table><thead><tr><th>状态</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>_Pidle</td><td>0</td><td>刚刚被分配，还没有进行进行初始化。</td></tr><tr><td>_Prunning</td><td>1</td><td>当 M 与 P 绑定调用 acquirep 时，P 的状态会改变为 _Prunning。</td></tr><tr><td>_Psyscall</td><td>2</td><td>正在执行系统调用。</td></tr><tr><td>_Pgcstop</td><td>3</td><td>暂停运行，此时系统正在进行 GC，直至 GC 结束后才会转变到下一个状态阶段。</td></tr><tr><td>_Pdead</td><td>4</td><td>废弃，不再使用。</td></tr></tbody></table></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://googoo-s.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by googoo-s using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2024</p><ul><li><a href=https://googoo-s.github.io/>Home</a></li><li><a href=https://github.com/googoo-s>GitHub</a></li></ul></footer></div></div></body></html>