<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="参考  你真的了解go语言中的切片吗
基本介绍 go 语言中的切片对标于其他编程语言中通俗意义上的“数组”. 切片中的元素存放在一块内存地址连续的区域，使用索引可以快速检索到指定位置的元素；切片长度和容量是可变的，在使用过程中可以根据需要进行扩容.
Go slice 的底层实现原理? 切片是基于数组实现的，它的底层是数组，可以理解为对底层数组的抽象。
源码包中 src/runtime/slice. Go 定义了 slice 的数据结构：
 1 2 3 4 5 6 7 8  type slice struct { // 指向起点的地址 array unsafe."><meta property="og:title" content="Slice"><meta property="og:description" content="参考  你真的了解go语言中的切片吗
基本介绍 go 语言中的切片对标于其他编程语言中通俗意义上的“数组”. 切片中的元素存放在一块内存地址连续的区域，使用索引可以快速检索到指定位置的元素；切片长度和容量是可变的，在使用过程中可以根据需要进行扩容.
Go slice 的底层实现原理? 切片是基于数组实现的，它的底层是数组，可以理解为对底层数组的抽象。
源码包中 src/runtime/slice. Go 定义了 slice 的数据结构：
 1 2 3 4 5 6 7 8  type slice struct { // 指向起点的地址 array unsafe."><meta property="og:type" content="website"><meta property="og:image" content="https://googoo-s.github.io/icon.png"><meta property="og:url" content="https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/Slice/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content="Slice"><meta name=twitter:description content="参考  你真的了解go语言中的切片吗
基本介绍 go 语言中的切片对标于其他编程语言中通俗意义上的“数组”. 切片中的元素存放在一块内存地址连续的区域，使用索引可以快速检索到指定位置的元素；切片长度和容量是可变的，在使用过程中可以根据需要进行扩容.
Go slice 的底层实现原理? 切片是基于数组实现的，它的底层是数组，可以理解为对底层数组的抽象。
源码包中 src/runtime/slice. Go 定义了 slice 的数据结构：
 1 2 3 4 5 6 7 8  type slice struct { // 指向起点的地址 array unsafe."><meta name=twitter:image content="https://googoo-s.github.io/icon.png"><title>Slice</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://googoo-s.github.io//icon.png><link href=https://googoo-s.github.io/styles.19109a40042e9f0e72e952fda4442a34.min.css rel=stylesheet><link href=https://googoo-s.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://googoo-s.github.io/js/darkmode.953af745b0f9342644d632fc167f3727.min.js></script>
<script src=https://googoo-s.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://googoo-s.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://googoo-s.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://googoo-s.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://googoo-s.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://googoo-s.github.io/",fetchData=Promise.all([fetch("https://googoo-s.github.io/indices/linkIndex.3bfb24158f5e9d4aff66ae07a3a8bd0d.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://googoo-s.github.io/indices/contentIndex.5773b7fc9ef1749b93b1b7daaee162c3.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://googoo-s.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://googoo-s.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/googoo-s.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=googoo-s.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://googoo-s.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://googoo-s.github.io/>googoo-s 😄😸😎</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Slice</h1><p class=meta>Last updated
Feb 25, 2024</p><ul class=tags><li><a href=https://googoo-s.github.io/tags/GO/%E5%85%AB%E8%82%A1%E6%96%87/>Go 八股文</a></li></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#参考>参考</a></li><li><a href=#基本介绍>基本介绍</a></li><li><a href=#go-slice-的底层实现原理>Go slice 的底层实现原理?</a></li><li><a href=#slice-切片的截取>Slice 切片的截取</a></li><li><a href=#slice-元素追加>Slice 元素追加</a></li><li><a href=#slice-扩容>Slice 扩容</a></li><li><a href=#slice-元素删除>Slice 元素删除</a></li><li><a href=#slice-切片拷贝>Slice 切片拷贝</a></li><li><a href=#go-array-和-slice-的区别>Go array 和 slice 的区别？</a></li><li><a href=#go-slice-深拷贝和浅拷贝>Go slice 深拷贝和浅拷贝</a></li><li><a href=#go-slice-为什么不是线程安全的>Go slice 为什么不是线程安全的？</a></li><li><a href=#nil-切片和空切片指向的地址一样>nil 切片和空切片指向的地址一样？</a></li><li><a href=#拷贝大切片一定比小切片代价大吗>拷贝大切片一定比小切片代价大吗？</a></li><li><a href=#json-库对-nil-slice-和空-slice-的处理是一致的吗>json 库对 nil slice 和空 slice 的处理是一致的吗？</a></li><li><a href=#扩容前后的-slice-是否相同>扩容前后的 Slice 是否相同?</a></li><li><a href=#使用值为-nil-的-slicemap-会发生啥>使用值为 nil 的 slice、map 会发生啥</a></li><li><a href=#slice-分配在堆上还是栈上>slice 分配在堆上还是栈上</a></li><li><a href=#go-中如果-new-一个切片会怎么样>Go 中如果 new 一个切片会怎么样</a></li><li><a href=#整型切片如何初始化>整型切片如何初始化？</a></li><li><a href=#数组怎么转集合->数组怎么转集合 ?</a></li><li><a href=#数组是如何实现根据下标随机访问数组元素的吗>数组是如何实现根据下标随机访问数组元素的吗？</a></li><li><a href=#一个函数传参一个-slice先-append-再赋值和另一个函数先赋值再-append哪个会发生变化>一个函数传参一个 slice，先 append 再赋值和另一个函数先赋值再 append，哪个会发生变化？</a></li></ol></nav></details></aside><a href=#参考><h1 id=参考><span class=hanchor arialabel=Anchor># </span>参考</h1></a><p><a href="https://mp.weixin.qq.com/s?__biz=MzkxMjQzMjA0OQ==&mid=2247484378&idx=1&sn=3d2d4a0055a96c8c76e620371bfec7f7&chksm=c10c4d04f67bc412295034c5ad5a28bb11ffcd4d8fd2d8846e3bdb48d4137ecf6637557d9be4&scene=178&cur_album_id=2709593649634033668#rd" rel=noopener>你真的了解go语言中的切片吗</a></p><a href=#基本介绍><h1 id=基本介绍><span class=hanchor arialabel=Anchor># </span>基本介绍</h1></a><p>go 语言中的切片对标于其他编程语言中通俗意义上的“数组”. <strong>切片中的元素存放在一块内存地址连续的区域</strong>，使用索引可以快速检索到指定位置的元素；切片长度和容量是可变的，在使用过程中可以根据需要进行扩容.</p><a href=#go-slice-的底层实现原理><h1 id=go-slice-的底层实现原理><span class=hanchor arialabel=Anchor># </span>Go slice 的底层实现原理?</h1></a><p>切片是基于数组实现的，它的底层是数组，可以理解为对底层数组的抽象。</p><p>源码包中 src/runtime/slice. Go 定义了 slice 的数据结构：</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226175632.png width=auto alt=image.png></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type slice struct {
</span></span><span class=line><span class=cl>	// 指向起点的地址
</span></span><span class=line><span class=cl>    array unsafe.Pointer
</span></span><span class=line><span class=cl>    // 切片长度
</span></span><span class=line><span class=cl>    len   int
</span></span><span class=line><span class=cl>    // 切片容量
</span></span><span class=line><span class=cl>    cap   int
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Slice 占用 24 个字节</p><ul><li><p>Array: 指向底层数组的指针，占用 8 个字节</p></li><li><p>Len: 切片的长度，占用 8 个字节</p></li><li><p>Cap: 切片的容量，cap 总是大于等于 len 的，占用 8 个字节</p></li></ul><p>Slice 有 4 种初始化方式</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// 初始化方式1：直接声明
</span></span><span class=line><span class=cl>var slice1 []int
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 初始化方式2：使用字面量
</span></span><span class=line><span class=cl>slice2 := []int{1, 2, 3, 4}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 初始化方式3：使用make创建slice
</span></span><span class=line><span class=cl>slice3 := make([]int, 3, 5)         
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 初始化方式4: 从切片或数组“截取”
</span></span><span class=line><span class=cl>slcie4 := arr[1:3]
</span></span></code></pre></td></tr></table></div></div><p>通过一个简单程序，看下 slice 初始化调用的底层函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>slice</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>slice</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>slice</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>slice</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>slice</span><span class=p>),</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>slice</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>通过 <code>go tool compile -S test.go | grep CALL</code> 得到汇编代码</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0x0042 00066 (test.go:6)        CALL    runtime.makeslice(SB)
</span></span><span class=line><span class=cl>0x006d 00109 (test.go:7)        CALL    runtime.growslice(SB)
</span></span><span class=line><span class=cl>0x00a4 00164 (test.go:8)        CALL    runtime.convTslice(SB)
</span></span><span class=line><span class=cl>0x00c0 00192 (test.go:8)        CALL    runtime.convT64(SB)
</span></span><span class=line><span class=cl>0x00d8 00216 (test.go:8)        CALL    runtime.convT64(SB)
</span></span><span class=line><span class=cl>0x0166 00358 ($GOROOT/src/fmt/print.go:274)     CALL    fmt.Fprintln(SB)
</span></span><span class=line><span class=cl>0x0180 00384 (test.go:5)        CALL    runtime.morestack_noctxt(SB)
</span></span><span class=line><span class=cl>0x0079 00121 (&lt;autogenerated&gt;:1)        CALL    runtime.efaceeq(SB)
</span></span><span class=line><span class=cl>0x00a0 00160 (&lt;autogenerated&gt;:1)        CALL    runtime.morestack_noctxt(SB)
</span></span></code></pre></td></tr></table></div></div><p>初始化 slice 调用的是 <strong>runtime. Makeslice，makeslice 函数的工作主要就是计算 slice 所需内存大小，然后调用 mallocgc 进行内存的分配</strong></p><p>所需内存大小 = 切片中元素大小 * 切片的容量</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func makeslice(et *_type, len, cap int) unsafe.Pointer {
</span></span><span class=line><span class=cl>    // 根据 cap 结合每个元素的大小，计算出消耗的总容量
</span></span><span class=line><span class=cl>    mem, overflow := math.MulUintptr(et.size, uintptr(cap))
</span></span><span class=line><span class=cl>    if overflow || mem &gt; maxAlloc || len &lt; 0 || len &gt; cap {
</span></span><span class=line><span class=cl>        // 倘若容量超限，len 取负值或者 len 超过 cap，直接 panic
</span></span><span class=line><span class=cl>        mem, overflow := math.MulUintptr(et.size, uintptr(len))
</span></span><span class=line><span class=cl>        if overflow || mem &gt; maxAlloc || len &lt; 0 {
</span></span><span class=line><span class=cl>            panicmakeslicelen()
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        panicmakeslicecap()
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    // 走 mallocgc 进行内存分配以及切片初始化
</span></span><span class=line><span class=cl>    return mallocgc(mem, et, true)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#slice-切片的截取><h1 id=slice-切片的截取><span class=hanchor arialabel=Anchor># </span>Slice 切片的截取</h1></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> x := make([]int, 2, 10)
</span></span><span class=line><span class=cl> _ = x[6:10]
</span></span><span class=line><span class=cl> _ = x[6:]
</span></span><span class=line><span class=cl> _ = x[2:]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//_ = x[6:] 这⼀⾏会发⽣panic, 截取符号 [i:j]，
</span></span><span class=line><span class=cl>//如果 j 省略，默认是原切⽚或者数组的⻓度，x 的⻓度是 2，⼩于起始下标 6 ，所以 panic
</span></span></code></pre></td></tr></table></div></div><p>可以修改 slice 下标的方式，进行 slice 内容的截取，形如 s[a: b] 的格式，其中 a b 代表切片的索引 index，左闭右开，比如 s[a: b] 对应的范围是 [a,b)，代表的是取切片 slice index = a ~ index = b-1 范围的内容.</p><p>此外，这里我聊到的 a 和 b 是可以缺省的：</p><ul><li><p>如果 a 缺省不填则默认取 0 ，则代表从切片起始位置开始截取. 比如 s[:b] 等价于 s[0:b]</p></li><li><p> 如果 b 缺省不填，则默认取 len(s)，则代表末尾截取到切片长度 len 的终点，比如 s[a:] 等价于 s[a:len(s)]</p></li><li><p>•a 和 b 均缺省也是可以的，则代表截取整个切片长度的范围，比如 s[:] 等价于 s[0:len(s)</p></li></ul><p>对切片 slice 执行截取操作时，本质上是一次引用传递操作，因为不论如何截取，<strong>底层复用的都是同一块内存空间中的数据</strong>，只不过，截取动作会创建出一个新的 slice header 实例</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226180202.png width=auto alt=image.png></p><a href=#slice-元素追加><h1 id=slice-元素追加><span class=hanchor arialabel=Anchor># </span>Slice 元素追加</h1></a><p>通过 append 操作，可以在 slice 末尾，额外新增一个元素. 需要注意，这里的末尾指的是针对 slice 的长度 len 而言. <strong>这个过程中倘若发现 slice 的剩余容量已经不足了，则会对 slice 进行扩容</strong>.</p><a href=#slice-扩容><h1 id=slice-扩容><span class=hanchor arialabel=Anchor># </span>Slice 扩容</h1></a><p><strong>版本 1.18 之前</strong>
扩容会发生在 slice append 的时候，当 slice 的 cap 不足以容纳新元素，就会进行扩容，扩容规则如下</p><ul><li>如果原有 slice 长度小于 1024，那么每次就扩容为原来的 2 倍</li><li>如果原 slice 长度大于等于 1024，那么每次扩容就扩为原来的 1.25 倍</li></ul><p><strong>1.18 +</strong></p><p>切片的扩容流程源码位于 runtime/slice.go 文件的 growslice 方法当中，其中核心步骤如下：</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statistic20240226204620.png width=auto alt=image.png></p><ul><li><p>倘若扩容后预期的新容量小于原切片的容量，则 panic</p></li><li><p>倘若切片元素大小为 0（元素类型为 struct{}），则直接复用一个全局的 zerobase 实例，直接返回</p></li><li><p>倘若预期的新容量超过老容量的两倍，则直接采用预期的新容量</p></li><li><p>倘若老容量小于 256，则直接采用老容量的2倍作为新容量</p></li><li><p>倘若老容量已经大于等于 256，则在老容量的基础上扩容 1/4 的比例并且累加上 192 的数值，持续这样处理，直到得到的新容量已经大于等于预期的新容量为止</p></li><li><p> 结合 mallocgc 流程中，对内存分配单元 mspan 的等级制度，推算得到实际需要申请的内存空间大小</p></li><li><p>调用 mallocgc，对新切片进行内存初始化</p></li><li><p>调用 memmove 方法，将老切片中的内容拷贝到新切片中</p></li><li><p> 返回扩容后的新切片</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func growslice(et *_type, old slice, cap int) slice {
</span></span><span class=line><span class=cl>    //... 
</span></span><span class=line><span class=cl>    if cap &lt; old.cap {
</span></span><span class=line><span class=cl>        panic(errorString(&#34;growslice: cap out of range&#34;))
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if et.size == 0 {
</span></span><span class=line><span class=cl>        // 倘若元素大小为 0，则无需分配空间直接返回
</span></span><span class=line><span class=cl>        return slice{unsafe.Pointer(&amp;zerobase), old.len, cap}
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // 计算扩容后数组的容量
</span></span><span class=line><span class=cl>    newcap := old.cap
</span></span><span class=line><span class=cl>    // 取原容量两倍的容量数值
</span></span><span class=line><span class=cl>    doublecap := newcap + newcap
</span></span><span class=line><span class=cl>    // 倘若新的容量大于原容量的两倍，直接取新容量作为数组扩容后的容量
</span></span><span class=line><span class=cl>    if cap &gt; doublecap {
</span></span><span class=line><span class=cl>        newcap = cap
</span></span><span class=line><span class=cl>    } else {
</span></span><span class=line><span class=cl>        const threshold = 256
</span></span><span class=line><span class=cl>        // 倘若原容量小于 256，则扩容后新容量为原容量的两倍
</span></span><span class=line><span class=cl>        if old.cap &lt; threshold {
</span></span><span class=line><span class=cl>            newcap = doublecap
</span></span><span class=line><span class=cl>        } else {
</span></span><span class=line><span class=cl>            // 在原容量的基础上，对原容量 * 5/4 并且加上 192
</span></span><span class=line><span class=cl>            // 循环执行上述操作，直到扩容后的容量已经大于等于预期的新容量为止
</span></span><span class=line><span class=cl>            for 0 &lt; newcap &amp;&amp; newcap &lt; cap {             
</span></span><span class=line><span class=cl>                newcap += (newcap + 3*threshold) / 4
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            // 倘若数值越界了，则取预期的新容量 cap 封顶
</span></span><span class=line><span class=cl>            if newcap &lt;= 0 {
</span></span><span class=line><span class=cl>                newcap = cap
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    var overflow bool
</span></span><span class=line><span class=cl>    var lenmem, newlenmem, capmem uintptr
</span></span><span class=line><span class=cl>    // 基于容量，确定新数组容器所需要的内存空间大小 capmem
</span></span><span class=line><span class=cl>    switch {
</span></span><span class=line><span class=cl>    // 倘若数组元素的大小为 1，则新容量大小为 1 * newcap.
</span></span><span class=line><span class=cl>    // 同时会针对 span class 进行取整
</span></span><span class=line><span class=cl>    case et.size == 1:
</span></span><span class=line><span class=cl>        lenmem = uintptr(old.len)
</span></span><span class=line><span class=cl>        newlenmem = uintptr(cap)
</span></span><span class=line><span class=cl>        capmem = roundupsize(uintptr(newcap))
</span></span><span class=line><span class=cl>        overflow = uintptr(newcap) &gt; maxAlloc
</span></span><span class=line><span class=cl>        newcap = int(capmem)
</span></span><span class=line><span class=cl>    // 倘若数组元素为指针类型，则根据指针占用空间结合元素个数计算空间大小
</span></span><span class=line><span class=cl>    // 并会针对 span class 进行取整
</span></span><span class=line><span class=cl>    case et.size == goarch.PtrSize:
</span></span><span class=line><span class=cl>        lenmem = uintptr(old.len) * goarch.PtrSize
</span></span><span class=line><span class=cl>        newlenmem = uintptr(cap) * goarch.PtrSize
</span></span><span class=line><span class=cl>        capmem = roundupsize(uintptr(newcap) * goarch.PtrSize)
</span></span><span class=line><span class=cl>        overflow = uintptr(newcap) &gt; maxAlloc/goarch.PtrSize
</span></span><span class=line><span class=cl>        newcap = int(capmem / goarch.PtrSize)
</span></span><span class=line><span class=cl>    // 倘若元素大小为 2 的指数，则直接通过位运算进行空间大小的计算   
</span></span><span class=line><span class=cl>    case isPowerOfTwo(et.size):
</span></span><span class=line><span class=cl>        var shift uintptr
</span></span><span class=line><span class=cl>        if goarch.PtrSize == 8 {
</span></span><span class=line><span class=cl>            // Mask shift for better code generation.
</span></span><span class=line><span class=cl>            shift = uintptr(sys.Ctz64(uint64(et.size))) &amp; 63
</span></span><span class=line><span class=cl>        } else {
</span></span><span class=line><span class=cl>            shift = uintptr(sys.Ctz32(uint32(et.size))) &amp; 31
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        lenmem = uintptr(old.len) &lt;&lt; shift
</span></span><span class=line><span class=cl>        newlenmem = uintptr(cap) &lt;&lt; shift
</span></span><span class=line><span class=cl>        capmem = roundupsize(uintptr(newcap) &lt;&lt; shift)
</span></span><span class=line><span class=cl>        overflow = uintptr(newcap) &gt; (maxAlloc &gt;&gt; shift)
</span></span><span class=line><span class=cl>        newcap = int(capmem &gt;&gt; shift)
</span></span><span class=line><span class=cl>    // 兜底分支：根据元素大小乘以元素个数
</span></span><span class=line><span class=cl>    // 再针对 span class 进行取整     
</span></span><span class=line><span class=cl>    default:
</span></span><span class=line><span class=cl>        lenmem = uintptr(old.len) * et.size
</span></span><span class=line><span class=cl>        newlenmem = uintptr(cap) * et.size
</span></span><span class=line><span class=cl>        capmem, overflow = math.MulUintptr(et.size, uintptr(newcap))
</span></span><span class=line><span class=cl>        capmem = roundupsize(capmem)
</span></span><span class=line><span class=cl>        newcap = int(capmem / et.size)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // 进行实际的切片初始化操作
</span></span><span class=line><span class=cl>    var p unsafe.Pointer
</span></span><span class=line><span class=cl>    // 非指针类型
</span></span><span class=line><span class=cl>    if et.ptrdata == 0 {
</span></span><span class=line><span class=cl>        p = mallocgc(capmem, nil, false)
</span></span><span class=line><span class=cl>        // ...
</span></span><span class=line><span class=cl>    } else {
</span></span><span class=line><span class=cl>        // 指针类型
</span></span><span class=line><span class=cl>        p = mallocgc(capmem, et, true)
</span></span><span class=line><span class=cl>        // ...
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    // 将切片的内容拷贝到扩容后的位置 p 
</span></span><span class=line><span class=cl>    memmove(p, old.array, lenmem)
</span></span><span class=line><span class=cl>    return slice{p, old.len, newcap}
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#slice-元素删除><h1 id=slice-元素删除><span class=hanchor arialabel=Anchor># </span>Slice 元素删除</h1></a><p>从切片中删除元素的实现思路，本质上和切片内容截取的思路是一致的.</p><p>需要删除 slice 中间的某个元素，<strong>操作思路则是采用内容截取加上元素追加的复合操作</strong>，可以先截取待删除元素的左侧部分内容，然后在此基础上追加上待删除元素后侧部分的内容：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>    s := []int{0,1,2,3,4}
</span></span><span class=line><span class=cl>    // 删除 index = 2 的元素
</span></span><span class=line><span class=cl>    s = append(s[:2],s[3:]...)
</span></span><span class=line><span class=cl>    // s: [0,1,3,4], len: 4, cap: 5
</span></span><span class=line><span class=cl>    t.Logf(&#34;s: %v, len: %d, cap: %d&#34;, s, len(s), cap(s))
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Go 语言删除切片元素的方法：<br>1、指定删除位置，如【index := 1】;<br>2、查看删除位置之前的元素和之后的元素;<br>3、将删除点前后的元素连接起来即可。<br>Go 语言并没有对删除切片元素提供专用的语法或者接口，需要使用切片本身的特性来删除元素。<br>示例代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>str := []string{&#34;a&#34;,&#34;b&#34;,&#34;c&#34;}
</span></span><span class=line><span class=cl>// step 1
</span></span><span class=line><span class=cl>index := 1
</span></span><span class=line><span class=cl>// step 2
</span></span><span class=line><span class=cl>fmt.Println(str[:index], str[index+1])
</span></span><span class=line><span class=cl>// step 3
</span></span><span class=line><span class=cl>str = append(str[:index], str[index+1]...)
</span></span><span class=line><span class=cl>// res
</span></span><span class=line><span class=cl>fmt.Println(str)
</span></span></code></pre></td></tr></table></div></div><a href=#slice-切片拷贝><h1 id=slice-切片拷贝><span class=hanchor arialabel=Anchor># </span>Slice 切片拷贝</h1></a><p>slice 的拷贝可以分为简单拷贝和完整拷贝两种类型.</p><ul><li>简单拷贝，只需要对切片的字面量进行赋值传递即可，这样相当于创建出了一个新的 slice header 实例，但是其中的指针 array、容量 cap 和长度 len 仍和老的 slice header 实例相同.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func Test_slice(t *testing.T) {
</span></span><span class=line><span class=cl>    s := []int{0, 1, 2, 3, 4}
</span></span><span class=line><span class=cl>    s1 := s
</span></span><span class=line><span class=cl>    t.Logf(&#34;address of s: %p, address of s1: %p&#34;, s, s1)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><ul><li>slice 的完整复制，指的是会创建出一个和 slice 容量大小相等的独立的内存区域，并将原 slice 中的元素一一拷贝到新空间中.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func Test_slice(t *testing.T) {
</span></span><span class=line><span class=cl>    s := []int{0, 1, 2, 3, 4}
</span></span><span class=line><span class=cl>    s1 := make([]int, len(s))
</span></span><span class=line><span class=cl>    copy(s1, s)
</span></span><span class=line><span class=cl>    t.Logf(&#34;s: %v, s1: %v&#34;, s, s1)
</span></span><span class=line><span class=cl>    t.Logf(&#34;address of s: %p, address of s1: %p&#34;, s, s1)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#go-array-和-slice-的区别><h1 id=go-array-和-slice-的区别><span class=hanchor arialabel=Anchor># </span>Go array 和 slice 的区别？</h1></a><p><strong>1）数组长度不同</strong></p><p>数组初始化必须指定长度，并且长度就是固定的</p><p>切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大</p><p><strong>2）函数传参不同</strong></p><p>数组是值类型，将一个数组赋值给另一个数组时，传递的是一份深拷贝，函数传参操作都会复制整个数组数据，会占用额外的内存，函数内对数组元素值的<strong>修改</strong>，不会修改原数组内容。</p><p>切片是引用类型，将一个切片赋值给另一个切片时，传递的是一份浅拷贝，函数传参操作不会拷贝整个切片，只会复制 len 和 cap，底层共用同一个数组，不会占用额外的内存，函数内对数组元素值的<strong>修改</strong>，会修改原数组内容。</p><p><strong>3）计算数组长度方式不同</strong></p><p>数组需要遍历计算数组长度，时间复杂度为 O (n)</p><p>切片底层包含 len 字段，可以通过 len ()计算切片长度，时间复杂度为 O (1)</p><a href=#go-slice-深拷贝和浅拷贝><h1 id=go-slice-深拷贝和浅拷贝><span class=hanchor arialabel=Anchor># </span>Go slice 深拷贝和浅拷贝</h1></a><p>深拷贝：拷贝的是数据本身，创造一个新对象，新创建的对象与原对象不共享内存，新创建的对象在内存中开辟一个新的内存地址，新对象值修改时不会影响原对象值</p><p>实现深拷贝的方式：</p><ol><li>Copy (slice 2, slice 1)</li><li>遍历 append 赋值</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func main() {
</span></span><span class=line><span class=cl>    slice1 := []int{1, 2, 3, 4, 5}
</span></span><span class=line><span class=cl>    slice2 := make([]int, 5, 5)
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;slice1: %v, %p\n&#34;, slice1, slice1)
</span></span><span class=line><span class=cl>    copy(slice2, slice1)
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;slice2: %v, %p\n&#34;, slice2, slice2)
</span></span><span class=line><span class=cl>    slice3 := make([]int, 0, 5)
</span></span><span class=line><span class=cl>    for _, v := range slice1 {
</span></span><span class=line><span class=cl>        slice3 = append(slice3, v)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;slice3: %v, %p\n&#34;, slice3, slice3)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>slice1: [1 2 3 4 5], 0xc0000b0030
</span></span><span class=line><span class=cl>slice2: [1 2 3 4 5], 0xc0000b0060
</span></span><span class=line><span class=cl>slice3: [1 2 3 4 5], 0xc0000b0090
</span></span></code></pre></td></tr></table></div></div><p>浅拷贝：拷贝的是数据地址，只复制指向的对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会变化</p><p>实现浅拷贝的方式：</p><p>引用类型的变量，<strong>默认赋值操作就是浅拷贝</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func main() {
</span></span><span class=line><span class=cl>    slice1 := []int{1, 2, 3, 4, 5}
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;slice1: %v, %p\n&#34;, slice1, slice1)
</span></span><span class=line><span class=cl>    slice2 := slice1
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;slice2: %v, %p\n&#34;, slice2, slice2)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>slice1: [1 2 3 4 5], 0xc00001a120
</span></span><span class=line><span class=cl>slice2: [1 2 3 4 5], 0xc00001a120
</span></span></code></pre></td></tr></table></div></div><a href=#go-slice-为什么不是线程安全的><h1 id=go-slice-为什么不是线程安全的><span class=hanchor arialabel=Anchor># </span>Go slice 为什么不是线程安全的？</h1></a><p><strong>先看下线程安全的定义</strong>：</p><p>多个线程访问同一个对象时，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。</p><p>若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p><p><strong>再看 Go 语言实现线程安全常用的几种方式</strong>：</p><ol><li>互斥锁</li><li>读写锁</li><li>原子操作</li><li>Sync. Once</li><li>Sync. Atomic</li><li>Channel</li></ol><p>Slice 底层结构并没有使用加锁等方式，不支持并发读写，所以并不是线程安全的，使用多个 goroutine 对类型为 slice 的变量进行操作，每次输出的值大概率都不会一样，与预期值不一致; <strong>slice 在并发执行中不会报错，但是数据会丢失</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/**
</span></span><span class=line><span class=cl>* 切片非并发安全
</span></span><span class=line><span class=cl>* 多次执行，每次得到的结果都不一样
</span></span><span class=line><span class=cl>* 可以考虑使用 channel 本身的特性 (阻塞) 来实现安全的并发读写
</span></span><span class=line><span class=cl> */
</span></span><span class=line><span class=cl>func TestSliceConcurrencySafe(t *testing.T) {
</span></span><span class=line><span class=cl> a := make([]int, 0)
</span></span><span class=line><span class=cl> var wg sync.WaitGroup
</span></span><span class=line><span class=cl> for i := 0; i &lt; 10000; i++ {
</span></span><span class=line><span class=cl>  wg.Add(1)
</span></span><span class=line><span class=cl>  go func(i int) {
</span></span><span class=line><span class=cl>   a = append(a, i)
</span></span><span class=line><span class=cl>   wg.Done()
</span></span><span class=line><span class=cl>  }(i)
</span></span><span class=line><span class=cl> }
</span></span><span class=line><span class=cl> wg.Wait()
</span></span><span class=line><span class=cl> t.Log(len(a)) 
</span></span><span class=line><span class=cl> // not equal 10000
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#nil-切片和空切片指向的地址一样><h1 id=nil-切片和空切片指向的地址一样><span class=hanchor arialabel=Anchor># </span>nil 切片和空切片指向的地址一样？</h1></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func main() {
</span></span><span class=line><span class=cl>    var s1 []int
</span></span><span class=line><span class=cl>    s2 := make([]int, 0)
</span></span><span class=line><span class=cl>    s3 := make([]int, 0)
</span></span><span class=line><span class=cl>    data1 := (*reflect.SliceHeader)(unsafe.Pointer(&amp;s1)).Data
</span></span><span class=line><span class=cl>    data2 := (*reflect.SliceHeader)(unsafe.Pointer(&amp;s2)).Data
</span></span><span class=line><span class=cl>    data3 := (*reflect.SliceHeader)(unsafe.Pointer(&amp;s3)).Data
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;s1 data:%+v\n&#34;, data1)
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;s2 data:%+v\n&#34;, data2)
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;s3 data:%+v\n&#34;, data3)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;s1:s2=&gt;%t\n&#34;, data1 == data2)
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;s2:s3=&gt;%t\n&#34;, data2 == data3)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//输出
</span></span><span class=line><span class=cl>s1 data:0
</span></span><span class=line><span class=cl>s2 data:824634859200
</span></span><span class=line><span class=cl>s3 data:824634859200
</span></span><span class=line><span class=cl>s1:s2=&gt;false
</span></span><span class=line><span class=cl>s2:s3=&gt;true
</span></span></code></pre></td></tr></table></div></div><p><strong>Nil 切片和空切片指向的地址不一样</strong>。</p><p><strong>Nil 切片引用数组指针地址为 0（无指向任何实际地址）</strong></p><p><strong>空切片的引用数组指针地址是有的，且固定为一个值。</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>//切片的数据结构
</span></span><span class=line><span class=cl>type SliceHeader struct {
</span></span><span class=line><span class=cl>    Data uintptr //引用数组指针地址
</span></span><span class=line><span class=cl>    Len  int
</span></span><span class=line><span class=cl>    Cap  int
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><strong>Nil 切片和空切片最大的区别在于指向的数组引用地址是不一样的</strong></p><a href=#拷贝大切片一定比小切片代价大吗><h1 id=拷贝大切片一定比小切片代价大吗><span class=hanchor arialabel=Anchor># </span>拷贝大切片一定比小切片代价大吗？</h1></a><p>并不是，所有切片的大小相同；三个字段（一个 uintptr，两个 int）。切片中的第一个字段是指向切片底层数组的指针，这是切片的存储空间，第二个字段是切片的长度，第三个字段是容量。将一个 slice 变量分配给另一个变量只会复制三个机器字。所<strong>以拷贝大切片跟小切片的代价应该是一样的</strong>。</p><p>SliceHeader 是切片在 go 的底层结构。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type SliceHeader struct {
</span></span><span class=line><span class=cl>    Data uintptr
</span></span><span class=line><span class=cl>    Len  int
</span></span><span class=line><span class=cl>    Cap  int
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>大切片跟小切片的区别无非就是 Len 和 Cap 的值比小切片的这两个值大一些，如果发生拷贝，本质上就是拷贝上面的三个字段。</p><a href=#json-库对-nil-slice-和空-slice-的处理是一致的吗><h1 id=json-库对-nil-slice-和空-slice-的处理是一致的吗><span class=hanchor arialabel=Anchor># </span>json 库对 nil slice 和空 slice 的处理是一致的吗？</h1></a><p>Json 库对 nil slice 和空 slice 的处理是不一致的，</p><p>因为 nil slice 只是声明了 slice，却没有给实例化的对象。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>	var f1 []string
</span></span><span class=line><span class=cl>    f2 := make([]string, 0)
</span></span><span class=line><span class=cl>    json1, _ := json.Marshal(Person{f1})
</span></span><span class=line><span class=cl>    json2, _ := json.Marshal(Person{f2})
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;%s\n&#34;, string(json1))
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;%s\n&#34;, string(json2))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//输出
</span></span><span class=line><span class=cl>{&#34;Friends&#34;:null}
</span></span><span class=line><span class=cl>{&#34;Friends&#34;:[]}
</span></span></code></pre></td></tr></table></div></div><p><strong>Json 库对 nil slice 编码为 null, json 库对空 slice 编码为[]。</strong></p><a href=#扩容前后的-slice-是否相同><h1 id=扩容前后的-slice-是否相同><span class=hanchor arialabel=Anchor># </span>扩容前后的 Slice 是否相同?</h1></a><p>情况一：<strong>原数组还有容量可以扩容（实际容量没有填充完），这种情况下，扩容以后的数组还是指向原来的数组</strong>，对一个切片的操作可能影响多个指针指向相同地址的 slice。</p><p>情况二：<strong>原来数组的容量已经达到了最大值，再想扩容，go 默认会先开一片内存区域，把原来的值拷贝过来，然后再执行 append ()操作</strong>。这种情况丝毫不影响原数组。要复制一个 slice，最好使用 copy 函数。</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statisticimage-20230906170544338.png width=auto alt=image-20230906170544338></p><p><strong>输出：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>函数内s=[1,2]
</span></span><span class=line><span class=cl>主函数内s=[1]
</span></span></code></pre></td></tr></table></div></div><a href=#使用值为-nil-的-slicemap-会发生啥><h1 id=使用值为-nil-的-slicemap-会发生啥><span class=hanchor arialabel=Anchor># </span>使用值为 nil 的 slice、map 会发生啥</h1></a><p><strong>允许对值为 nil 的 slice 添加元素，但对值为 nil 的 map 添加元素，则会造成运行时 panic</strong>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// map 错误示例  
</span></span><span class=line><span class=cl>func main () {  
</span></span><span class=line><span class=cl>    var m map[string]int  
</span></span><span class=line><span class=cl>    m[&#34;one&#34;] = 1  // error: panic: assignment to entry in nil map  
</span></span><span class=line><span class=cl>    // m := make (map[string]int)// map 的正确声明，分配了实际的内存  
</span></span><span class=line><span class=cl>}      
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>// slice 正确示例  
</span></span><span class=line><span class=cl>func main () {  
</span></span><span class=line><span class=cl> var s []int  
</span></span><span class=line><span class=cl> s = append (s, 1)  
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>如果先使用 <code>make()</code>,那么可以使用 <code>m["one"]=1</code>,因为分配了内存。</p><a href=#slice-分配在堆上还是栈上><h1 id=slice-分配在堆上还是栈上><span class=hanchor arialabel=Anchor># </span>slice 分配在堆上还是栈上</h1></a><p><strong>有可能分配到栈上，也有可能分配到栈上。当开辟切片空间较大时，会逃逸到堆上</strong>。</p><p>通过命令 <code>go build -gcflags "-m -l" xxx.go</code> 观察 golang 是如何进行逃逸分析的</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// map 错误示例
</span></span><span class=line><span class=cl>func main() {
</span></span><span class=line><span class=cl>    var m map[string]int
</span></span><span class=line><span class=cl>    m[&#34;one&#34;] = 1  // error: panic: assignment to entry in nil map
</span></span><span class=line><span class=cl>    // m := make(map[string]int)// map 的正确声明，分配了实际的内存
</span></span><span class=line><span class=cl>}    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// slice 正确示例
</span></span><span class=line><span class=cl>func main() {
</span></span><span class=line><span class=cl> var s []int
</span></span><span class=line><span class=cl> s = append(s, 1)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#go-中如果-new-一个切片会怎么样><h1 id=go-中如果-new-一个切片会怎么样><span class=hanchor arialabel=Anchor># </span>Go 中如果 new 一个切片会怎么样</h1></a><p><strong>new ([]int) 之后的 list 是⼀个未设置⻓度的 * []int 类型的指针不能对未设置⻓度的指针执⾏ append 操作。</strong></p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statisticimage-20230724165822059.png width=auto alt=image-20230724165822059></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>list</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>([]</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 编译错误
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// new([]int) 之后的 list 是⼀个未设置⻓度的 *[]int 类型的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 不能对未设置⻓度的指针执⾏ append 操作。
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>*</span><span class=nx>list</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=o>*</span><span class=nx>list</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=o>*</span><span class=nx>list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>s1</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>s2</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 编译错误，s2需要展开
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>s1</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s1</span><span class=p>,</span> <span class=nx>s2</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>s1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=c1>//正确写法
</span></span></span></code></pre></td></tr></table></div></div><a href=#整型切片如何初始化><h1 id=整型切片如何初始化><span class=hanchor arialabel=Anchor># </span>整型切片如何初始化？</h1></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>//数组初始化
</span></span><span class=line><span class=cl>arr1 := [3]int{1, 2, 3}
</span></span><span class=line><span class=cl>arr2 := [...]int{1, 2, 3}
</span></span><span class=line><span class=cl>arr3 := [3]int{0:3,1:4}
</span></span></code></pre></td></tr></table></div></div><a href=#数组怎么转集合-><h1 id=数组怎么转集合-><span class=hanchor arialabel=Anchor># </span>数组怎么转集合 ?</h1></a><p>可以使用数组的索引作为 map 的 key，数组的值作为 map 的值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>//数组初始化
</span></span><span class=line><span class=cl>arr1 := [3]int{1, 2, 3}
</span></span><span class=line><span class=cl>arr2 := [...]int{1, 2, 3}
</span></span><span class=line><span class=cl>arr3 := [3]int{0:3,1:4}
</span></span></code></pre></td></tr></table></div></div><a href=#数组是如何实现根据下标随机访问数组元素的吗><h1 id=数组是如何实现根据下标随机访问数组元素的吗><span class=hanchor arialabel=Anchor># </span>数组是如何实现根据下标随机访问数组元素的吗？</h1></a><p>例如： a := [10]int{0}</p><ul><li>计算机给数组 a，分配了一组连续的内存空间。</li><li>比如内存块的首地址为 base_address=1000。</li><li>当计算给每个内存单元分配一个地址，计算机通过地址来访问数据。当计算机需要访问数组的某个元素的时候，会通过一个寻址公式来计算存储的内存地址。</li></ul><a href=#一个函数传参一个-slice先-append-再赋值和另一个函数先赋值再-append哪个会发生变化><h1 id=一个函数传参一个-slice先-append-再赋值和另一个函数先赋值再-append哪个会发生变化><span class=hanchor arialabel=Anchor># </span>一个函数传参一个 slice，先 append 再赋值和另一个函数先赋值再 append，哪个会发生变化？</h1></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BeforeAppend</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>s</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>AfterAppend</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>s</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>BeforeAppend</span><span class=p>(</span><span class=nx>s</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>AfterAppend</span><span class=p>(</span><span class=nx>s</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://googoo-s.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by googoo-s using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2024</p><ul><li><a href=https://googoo-s.github.io/>Home</a></li><li><a href=https://github.com/googoo-s>GitHub</a></li></ul></footer></div></div></body></html>