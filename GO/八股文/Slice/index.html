<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="nil 切片和空切片指向的地址一样？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  func main() { var s1 []int s2 := make([]int, 0) s3 := make([]int, 0) data1 := (*reflect."><meta property="og:title" content="Slice"><meta property="og:description" content="nil 切片和空切片指向的地址一样？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  func main() { var s1 []int s2 := make([]int, 0) s3 := make([]int, 0) data1 := (*reflect."><meta property="og:type" content="website"><meta property="og:image" content="https://googoo-s.github.io/icon.png"><meta property="og:url" content="https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/Slice/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content="Slice"><meta name=twitter:description content="nil 切片和空切片指向的地址一样？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  func main() { var s1 []int s2 := make([]int, 0) s3 := make([]int, 0) data1 := (*reflect."><meta name=twitter:image content="https://googoo-s.github.io/icon.png"><title>Slice</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://googoo-s.github.io//icon.png><link href=https://googoo-s.github.io/styles.19109a40042e9f0e72e952fda4442a34.min.css rel=stylesheet><link href=https://googoo-s.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://googoo-s.github.io/js/darkmode.953af745b0f9342644d632fc167f3727.min.js></script>
<script src=https://googoo-s.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://googoo-s.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://googoo-s.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://googoo-s.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://googoo-s.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://googoo-s.github.io/",fetchData=Promise.all([fetch("https://googoo-s.github.io/indices/linkIndex.3bfb24158f5e9d4aff66ae07a3a8bd0d.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://googoo-s.github.io/indices/contentIndex.7e7b176f3dc5e31fceeff574620ae38a.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://googoo-s.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://googoo-s.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/googoo-s.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=googoo-s.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://googoo-s.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://googoo-s.github.io/>googoo-s 😄😸😎</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Slice</h1><p class=meta>Last updated
Feb 25, 2024</p><ul class=tags><li><a href=https://googoo-s.github.io/tags/GO/%E5%85%AB%E8%82%A1%E6%96%87/>Go 八股文</a></li></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#nil-切片和空切片指向的地址一样>nil 切片和空切片指向的地址一样？</a></li><li><a href=#拷贝大切片一定比小切片代价大吗>拷贝大切片一定比小切片代价大吗？</a></li><li><a href=#json-库对-nil-slice-和空-slice-的处理是一致的吗>json 库对 nil slice 和空 slice 的处理是一致的吗？</a></li><li><a href=#golang-切片如何删除数据>Golang 切片如何删除数据</a></li><li><a href=#扩容前后的-slice-是否相同>扩容前后的 Slice 是否相同?</a></li><li><a href=#使用值为-nil-的-slicemap-会发生啥>使用值为 nil 的 slice、map 会发生啥</a></li><li><a href=#slice-分配在堆上还是栈上>slice 分配在堆上还是栈上</a></li><li><a href=#slice-切片的截取>slice 切片的截取</a></li><li><a href=#go-中如果-new-一个切片会怎么样>Go 中如果 new 一个切片会怎么样</a></li><li><a href=#整型切片如何初始化>整型切片如何初始化？</a></li><li><a href=#数组怎么转集合->数组怎么转集合 ?</a></li><li><a href=#数组是如何实现根据下标随机访问数组元素的吗>数组是如何实现根据下标随机访问数组元素的吗？</a></li><li><a href=#一个函数传参一个-slice先-append-再赋值和另一个函数先赋值再-append哪个会发生变化>一个函数传参一个 slice，先 append 再赋值和另一个函数先赋值再 append，哪个会发生变化？</a></li><li><a href=#一个对象数组不用-delete-使用-delete-有什么影响>一个对象数组，不用 delete[] 使用 delete 有什么影响</a></li><li><a href=#go-slice-的底层实现原理>Go slice 的底层实现原理?</a></li><li><a href=#go-array-和-slice-的区别>Go array 和 slice 的区别？</a></li><li><a href=#go-slice-深拷贝和浅拷贝>Go slice 深拷贝和浅拷贝</a></li><li><a href=#go-slice-扩容机制>Go slice 扩容机制？</a></li><li><a href=#go-slice-为什么不是线程安全的>Go slice 为什么不是线程安全的？</a></li></ol></nav></details></aside><a href=#nil-切片和空切片指向的地址一样><h1 id=nil-切片和空切片指向的地址一样><span class=hanchor arialabel=Anchor># </span>nil 切片和空切片指向的地址一样？</h1></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func main() {
</span></span><span class=line><span class=cl>    var s1 []int
</span></span><span class=line><span class=cl>    s2 := make([]int, 0)
</span></span><span class=line><span class=cl>    s3 := make([]int, 0)
</span></span><span class=line><span class=cl>    data1 := (*reflect.SliceHeader)(unsafe.Pointer(&amp;s1)).Data
</span></span><span class=line><span class=cl>    data2 := (*reflect.SliceHeader)(unsafe.Pointer(&amp;s2)).Data
</span></span><span class=line><span class=cl>    data3 := (*reflect.SliceHeader)(unsafe.Pointer(&amp;s3)).Data
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;s1 data:%+v\n&#34;, data1)
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;s2 data:%+v\n&#34;, data2)
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;s3 data:%+v\n&#34;, data3)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;s1:s2=&gt;%t\n&#34;, data1 == data2)
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;s2:s3=&gt;%t\n&#34;, data2 == data3)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//输出
</span></span><span class=line><span class=cl>s1 data:0
</span></span><span class=line><span class=cl>s2 data:824634859200
</span></span><span class=line><span class=cl>s3 data:824634859200
</span></span><span class=line><span class=cl>s1:s2=&gt;false
</span></span><span class=line><span class=cl>s2:s3=&gt;true
</span></span></code></pre></td></tr></table></div></div><p>Nil 切片和空切片指向的地址不一样。</p><p>Nil 切片引用数组指针地址为 0（无指向任何实际地址）</p><p>空切片的引用数组指针地址是有的，且固定为一个值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>//切片的数据结构
</span></span><span class=line><span class=cl>type SliceHeader struct {
</span></span><span class=line><span class=cl>    Data uintptr //引用数组指针地址
</span></span><span class=line><span class=cl>    Len  int
</span></span><span class=line><span class=cl>    Cap  int
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Nil 切片和空切片最大的区别在于指向的数组引用地址是不一样的</p><a href=#拷贝大切片一定比小切片代价大吗><h1 id=拷贝大切片一定比小切片代价大吗><span class=hanchor arialabel=Anchor># </span>拷贝大切片一定比小切片代价大吗？</h1></a><p>并不是，所有切片的大小相同；三个字段（一个 uintptr，两个 int）。切片中的第一个字段是指向切片底层数组的指针，这是切片的存储空间，第二个字段是切片的长度，第三个字段是容量。将一个 slice 变量分配给另一个变量只会复制三个机器字。所以拷贝大切片跟小切片的代价应该是一样的。</p><p>SliceHeader 是切片在 go 的底层结构。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type SliceHeader struct {
</span></span><span class=line><span class=cl>    Data uintptr
</span></span><span class=line><span class=cl>    Len  int
</span></span><span class=line><span class=cl>    Cap  int
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>大切片跟小切片的区别无非就是 Len 和 Cap 的值比小切片的这两个值大一些，如果发生拷贝，本质上就是拷贝上面的三个字段。</p><a href=#json-库对-nil-slice-和空-slice-的处理是一致的吗><h1 id=json-库对-nil-slice-和空-slice-的处理是一致的吗><span class=hanchor arialabel=Anchor># </span>json 库对 nil slice 和空 slice 的处理是一致的吗？</h1></a><p>Json 库对 nil slice 和空 slice 的处理是不一致的，</p><p>因为 nil slice 只是声明了 slice，却没有给实例化的对象。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>	var f1 []string
</span></span><span class=line><span class=cl>    f2 := make([]string, 0)
</span></span><span class=line><span class=cl>    json1, _ := json.Marshal(Person{f1})
</span></span><span class=line><span class=cl>    json2, _ := json.Marshal(Person{f2})
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;%s\n&#34;, string(json1))
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;%s\n&#34;, string(json2))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//输出
</span></span><span class=line><span class=cl>{&#34;Friends&#34;:null}
</span></span><span class=line><span class=cl>{&#34;Friends&#34;:[]}
</span></span></code></pre></td></tr></table></div></div><p>Json 库对 nil slice 编码为 null, json 库对空 slice 编码为[]。</p><a href=#golang-切片如何删除数据><h1 id=golang-切片如何删除数据><span class=hanchor arialabel=Anchor># </span>Golang 切片如何删除数据</h1></a><p>Go 语言删除切片元素的方法：<br>1、指定删除位置，如【index := 1】;<br>2、查看删除位置之前的元素和之后的元素;<br>3、将删除点前后的元素连接起来即可。<br>Go 语言并没有对删除切片元素提供专用的语法或者接口，需要使用切片本身的特性来删除元素。<br>示例代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>str := []string{&#34;a&#34;,&#34;b&#34;,&#34;c&#34;}
</span></span><span class=line><span class=cl>   // step 1
</span></span><span class=line><span class=cl>   index := 1
</span></span><span class=line><span class=cl>   // step 2
</span></span><span class=line><span class=cl>   fmt.Println(str[:index], str[index+1])
</span></span><span class=line><span class=cl>   // step 3
</span></span><span class=line><span class=cl>   str = append(str[:index], str[index+1]...)
</span></span><span class=line><span class=cl>   // res
</span></span><span class=line><span class=cl>   fmt.Println(str)
</span></span></code></pre></td></tr></table></div></div><a href=#扩容前后的-slice-是否相同><h1 id=扩容前后的-slice-是否相同><span class=hanchor arialabel=Anchor># </span>扩容前后的 Slice 是否相同?</h1></a><p>情况一：原数组还有容量可以扩容（实际容量没有填充完），这种情况下，扩容以后的数组还是指向原来的数组，对一个切片的操作可能影响多个指针指向相同地址的 slice。</p><p>情况二：原来数组的容量已经达到了最大值，再想扩容，go 默认会先开一片内存区域，把原来的值拷贝过来，然后再执行 append ()操作。这种情况丝毫不影响原数组。要复制一个 slice，最好使用 copy 函数。</p><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statisticimage-20230906170544338.png width=auto alt=image-20230906170544338></p><p><strong>输出：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>函数内s=[1,2]
</span></span><span class=line><span class=cl>主函数内s=[1]
</span></span></code></pre></td></tr></table></div></div><a href=#使用值为-nil-的-slicemap-会发生啥><h1 id=使用值为-nil-的-slicemap-会发生啥><span class=hanchor arialabel=Anchor># </span>使用值为 nil 的 slice、map 会发生啥</h1></a><p>允许对值为 nil 的 slice 添加元素，但对值为 nil 的 map 添加元素，则会造成运行时 panic。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12</td><td>// map 错误示例<br>func main () {<br>var m map[string]int<br>m[&ldquo;one&rdquo;] = 1 // error: panic: assignment to entry in nil map<br>// m := make (map[string]int)// map 的正确声明，分配了实际的内存<br>}<br><br>// slice 正确示例<br>func main () {<br>var s []int<br>s = append (s, 1)<br>}</td></tr></tbody></table><p>如果先使用 <code>make()</code>,那么可以使用 <code>m["one"]=1</code>,因为分配了内存。</p><a href=#slice-分配在堆上还是栈上><h1 id=slice-分配在堆上还是栈上><span class=hanchor arialabel=Anchor># </span>slice 分配在堆上还是栈上</h1></a><p>有可能分配到栈上，也有可能分配到栈上。当开辟切片空间较大时，会逃逸到堆上。</p><p>通过命令 <code>go build -gcflags "-m -l" xxx.go</code> 观察 golang 是如何进行逃逸分析的</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// map 错误示例
</span></span><span class=line><span class=cl>func main() {
</span></span><span class=line><span class=cl>    var m map[string]int
</span></span><span class=line><span class=cl>    m[&#34;one&#34;] = 1  // error: panic: assignment to entry in nil map
</span></span><span class=line><span class=cl>    // m := make(map[string]int)// map 的正确声明，分配了实际的内存
</span></span><span class=line><span class=cl>}    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// slice 正确示例
</span></span><span class=line><span class=cl>func main() {
</span></span><span class=line><span class=cl> var s []int
</span></span><span class=line><span class=cl> s = append(s, 1)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#slice-切片的截取><h1 id=slice-切片的截取><span class=hanchor arialabel=Anchor># </span>slice 切片的截取</h1></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> x := make([]int, 2, 10)
</span></span><span class=line><span class=cl> _ = x[6:10]
</span></span><span class=line><span class=cl> _ = x[6:]
</span></span><span class=line><span class=cl> _ = x[2:]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//_ = x[6:] 这⼀⾏会发⽣panic, 截取符号 [i:j]，
</span></span><span class=line><span class=cl>//如果 j 省略，默认是原切⽚或者数组的⻓度，x 的⻓度是 2，⼩于起始下标 6 ，所以 panic
</span></span></code></pre></td></tr></table></div></div><a href=#go-中如果-new-一个切片会怎么样><h1 id=go-中如果-new-一个切片会怎么样><span class=hanchor arialabel=Anchor># </span>Go 中如果 new 一个切片会怎么样</h1></a><p><img src=https://googoo-s.oss-cn-chengdu.aliyuncs.com/statisticimage-20230724165822059.png width=auto alt=image-20230724165822059></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>list</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>([]</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 编译错误
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// new([]int) 之后的 list 是⼀个未设置⻓度的 *[]int 类型的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 不能对未设置⻓度的指针执⾏ append 操作。
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>*</span><span class=nx>list</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=o>*</span><span class=nx>list</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=o>*</span><span class=nx>list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>s1</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>s2</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 编译错误，s2需要展开
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>s1</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s1</span><span class=p>,</span> <span class=nx>s2</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>s1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=c1>//正确写法
</span></span></span></code></pre></td></tr></table></div></div><a href=#整型切片如何初始化><h1 id=整型切片如何初始化><span class=hanchor arialabel=Anchor># </span>整型切片如何初始化？</h1></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>//数组初始化
</span></span><span class=line><span class=cl>arr1 := [3]int{1, 2, 3}
</span></span><span class=line><span class=cl>arr2 := [...]int{1, 2, 3}
</span></span><span class=line><span class=cl>arr3 := [3]int{0:3,1:4}
</span></span></code></pre></td></tr></table></div></div><a href=#数组怎么转集合-><h1 id=数组怎么转集合-><span class=hanchor arialabel=Anchor># </span>数组怎么转集合 ?</h1></a><p>可以使用数组的索引作为 map 的 key，数组的值作为 map 的值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>//数组初始化
</span></span><span class=line><span class=cl>arr1 := [3]int{1, 2, 3}
</span></span><span class=line><span class=cl>arr2 := [...]int{1, 2, 3}
</span></span><span class=line><span class=cl>arr3 := [3]int{0:3,1:4}
</span></span></code></pre></td></tr></table></div></div><a href=#数组是如何实现根据下标随机访问数组元素的吗><h1 id=数组是如何实现根据下标随机访问数组元素的吗><span class=hanchor arialabel=Anchor># </span>数组是如何实现根据下标随机访问数组元素的吗？</h1></a><p>例如： a := [10]int{0}</p><ul><li>计算机给数组 a，分配了一组连续的内存空间。</li><li>比如内存块的首地址为 base_address=1000。</li><li>当计算给每个内存单元分配一个地址，计算机通过地址来访问数据。当计算机需要访问数组的某个元素的时候，会通过一个寻址公式来计算存储的内存地址。</li></ul><a href=#一个函数传参一个-slice先-append-再赋值和另一个函数先赋值再-append哪个会发生变化><h1 id=一个函数传参一个-slice先-append-再赋值和另一个函数先赋值再-append哪个会发生变化><span class=hanchor arialabel=Anchor># </span>一个函数传参一个 slice，先 append 再赋值和另一个函数先赋值再 append，哪个会发生变化？</h1></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BeforeAppend</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>s</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>AfterAppend</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>s</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>BeforeAppend</span><span class=p>(</span><span class=nx>s</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>AfterAppend</span><span class=p>(</span><span class=nx>s</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#一个对象数组不用-delete-使用-delete-有什么影响><h1 id=一个对象数组不用-delete-使用-delete-有什么影响><span class=hanchor arialabel=Anchor># </span>一个对象数组，不用 delete[] 使用 delete 有什么影响</h1></a><p>1、针对简单类型使用 new 分配后的不管是数组还是非数组形式内存空间用两种方式均可如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>int *a = new int[10];   
</span></span><span class=line><span class=cl>delete a;   
</span></span><span class=line><span class=cl>delete [] a; 
</span></span></code></pre></td></tr></table></div></div><p>此种情况中的释放效果相同，原因在于：分配简单类型内存时，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统并不会调用析构函数，它直接通过指针可以获取实际分配的内存空间，哪怕是一个数组内存空间 (在分配过程中系统会记录分配内存的大小等信息，此信息保存在结构体_CrtMemBlockHeader 中，具体情况可参看 VC 安装目录下 CRTSRCDBGDEL. Cpp)</p><p>2、针对类 Class，两种方式体现出具体差异</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class A
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    private:
</span></span><span class=line><span class=cl>        char *m_cBuffer;
</span></span><span class=line><span class=cl>        int m_nLen;
</span></span><span class=line><span class=cl>    public:
</span></span><span class=line><span class=cl>        A(){ m_cBuffer = new char[m_nLen]; }
</span></span><span class=line><span class=cl>        ~A() { delete [] m_cBuffer; }
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>A *a = new A[10];
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 仅释放了a指针指向的全部内存空间 但是只调用了a[0]对象的析构函数 剩下的从a[1]到a[9]这9个用户自行分配的m_cBuffer对应内存空间将不能释放 从而造成内存泄漏
</span></span><span class=line><span class=cl>delete a;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 调用使用类对象的析构函数释放用户自己分配内存空间并且   释放了a指针指向的全部内存空间
</span></span><span class=line><span class=cl>delete [] a;
</span></span></code></pre></td></tr></table></div></div><p>所以总结下就是，如果 ptr 代表一个用 new 申请的内存返回的内存空间地址，即所谓的指针，那么：</p><p>Delete ptr – 代表用来释放内存，且只用来释放 ptr 指向的内存。<br>Delete[] rg – 用来释放 rg 指向的内存，！！还逐一调用数组中每个对象的 destructor！！<br>对于像 int/char/long/int*/struct 等等简单数据类型，由于对象没有 destructor，所以用 delete 和 delete [] 是一样的！但是如果是 C++ 对象数组就不同了！</p><a href=#go-slice-的底层实现原理><h1 id=go-slice-的底层实现原理><span class=hanchor arialabel=Anchor># </span>Go slice 的底层实现原理?</h1></a><p>切片是基于数组实现的，它的底层是数组，可以理解为对底层数组的抽象。</p><p>源码包中 src/runtime/slice. Go 定义了 slice 的数据结构：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type slice struct {
</span></span><span class=line><span class=cl>    array unsafe.Pointer
</span></span><span class=line><span class=cl>    len   int
</span></span><span class=line><span class=cl>    cap   int
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>Slice 占用 24 个字节</p><ul><li><p>Array: 指向底层数组的指针，占用 8 个字节</p></li><li><p>Len: 切片的长度，占用 8 个字节</p></li><li><p>Cap: 切片的容量，cap 总是大于等于 len 的，占用 8 个字节</p></li></ul><p>Slice 有 4 种初始化方式</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// 初始化方式1：直接声明
</span></span><span class=line><span class=cl>var slice1 []int
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 初始化方式2：使用字面量
</span></span><span class=line><span class=cl>slice2 := []int{1, 2, 3, 4}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 初始化方式3：使用make创建slice
</span></span><span class=line><span class=cl>slice3 := make([]int, 3, 5)         
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 初始化方式4: 从切片或数组“截取”
</span></span><span class=line><span class=cl>slcie4 := arr[1:3]
</span></span></code></pre></td></tr></table></div></div><p>通过一个简单程序，看下 slice 初始化调用的底层函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>slice</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>slice</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>slice</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>slice</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>slice</span><span class=p>),</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>slice</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>通过 <code>go tool compile -S test.go | grep CALL</code> 得到汇编代码</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0x0042 00066 (test.go:6)        CALL    runtime.makeslice(SB)
</span></span><span class=line><span class=cl>0x006d 00109 (test.go:7)        CALL    runtime.growslice(SB)
</span></span><span class=line><span class=cl>0x00a4 00164 (test.go:8)        CALL    runtime.convTslice(SB)
</span></span><span class=line><span class=cl>0x00c0 00192 (test.go:8)        CALL    runtime.convT64(SB)
</span></span><span class=line><span class=cl>0x00d8 00216 (test.go:8)        CALL    runtime.convT64(SB)
</span></span><span class=line><span class=cl>0x0166 00358 ($GOROOT/src/fmt/print.go:274)     CALL    fmt.Fprintln(SB)
</span></span><span class=line><span class=cl>0x0180 00384 (test.go:5)        CALL    runtime.morestack_noctxt(SB)
</span></span><span class=line><span class=cl>0x0079 00121 (&lt;autogenerated&gt;:1)        CALL    runtime.efaceeq(SB)
</span></span><span class=line><span class=cl>0x00a0 00160 (&lt;autogenerated&gt;:1)        CALL    runtime.morestack_noctxt(SB)
</span></span></code></pre></td></tr></table></div></div><p>初始化 slice 调用的是 runtime. Makeslice，makeslice 函数的工作主要就是计算 slice 所需内存大小，然后调用 mallocgc 进行内存的分配</p><p>所需内存大小 = 切片中元素大小 * 切片的容量</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func makeslice(et *_type, len, cap int) unsafe.Pointer {
</span></span><span class=line><span class=cl>    mem, overflow := math.MulUintptr(et.size, uintptr(cap))
</span></span><span class=line><span class=cl>    if overflow || mem &gt; maxAlloc || len &lt; 0 || len &gt; cap {
</span></span><span class=line><span class=cl>        // NOTE: Produce a &#39;len out of range&#39; error instead of a
</span></span><span class=line><span class=cl>        // &#39;cap out of range&#39; error when someone does make([]T, bignumber).
</span></span><span class=line><span class=cl>        // &#39;cap out of range&#39; is true too, but since the cap is only being
</span></span><span class=line><span class=cl>        // supplied implicitly, saying len is clearer.
</span></span><span class=line><span class=cl>        // See golang.org/issue/4085.
</span></span><span class=line><span class=cl>        mem, overflow := math.MulUintptr(et.size, uintptr(len))
</span></span><span class=line><span class=cl>        if overflow || mem &gt; maxAlloc || len &lt; 0 {
</span></span><span class=line><span class=cl>            panicmakeslicelen()
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        panicmakeslicecap()
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return mallocgc(mem, et, true)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#go-array-和-slice-的区别><h1 id=go-array-和-slice-的区别><span class=hanchor arialabel=Anchor># </span>Go array 和 slice 的区别？</h1></a><p><strong>1）数组长度不同</strong></p><p>数组初始化必须指定长度，并且长度就是固定的</p><p>切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大</p><p><strong>2）函数传参不同</strong></p><p>数组是值类型，将一个数组赋值给另一个数组时，传递的是一份深拷贝，函数传参操作都会复制整个数组数据，会占用额外的内存，函数内对数组元素值的<strong>修改</strong>，不会修改原数组内容。</p><p>切片是引用类型，将一个切片赋值给另一个切片时，传递的是一份浅拷贝，函数传参操作不会拷贝整个切片，只会复制 len 和 cap，底层共用同一个数组，不会占用额外的内存，函数内对数组元素值的<strong>修改</strong>，会修改原数组内容。</p><p><strong>3）计算数组长度方式不同</strong></p><p>数组需要遍历计算数组长度，时间复杂度为 O (n)</p><p>切片底层包含 len 字段，可以通过 len ()计算切片长度，时间复杂度为 O(1)</p><a href=#go-slice-深拷贝和浅拷贝><h1 id=go-slice-深拷贝和浅拷贝><span class=hanchor arialabel=Anchor># </span>Go slice 深拷贝和浅拷贝</h1></a><p>深拷贝：拷贝的是数据本身，创造一个新对象，新创建的对象与原对象不共享内存，新创建的对象在内存中开辟一个新的内存地址，新对象值修改时不会影响原对象值</p><p>实现深拷贝的方式：</p><ol><li>Copy (slice 2, slice 1)</li><li>遍历 append 赋值</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func main() {
</span></span><span class=line><span class=cl>    slice1 := []int{1, 2, 3, 4, 5}
</span></span><span class=line><span class=cl>    slice2 := make([]int, 5, 5)
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;slice1: %v, %p\n&#34;, slice1, slice1)
</span></span><span class=line><span class=cl>    copy(slice2, slice1)
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;slice2: %v, %p\n&#34;, slice2, slice2)
</span></span><span class=line><span class=cl>    slice3 := make([]int, 0, 5)
</span></span><span class=line><span class=cl>    for _, v := range slice1 {
</span></span><span class=line><span class=cl>        slice3 = append(slice3, v)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;slice3: %v, %p\n&#34;, slice3, slice3)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>slice1: [1 2 3 4 5], 0xc0000b0030
</span></span><span class=line><span class=cl>slice2: [1 2 3 4 5], 0xc0000b0060
</span></span><span class=line><span class=cl>slice3: [1 2 3 4 5], 0xc0000b0090
</span></span></code></pre></td></tr></table></div></div><p>浅拷贝：拷贝的是数据地址，只复制指向的对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会变化</p><p>实现浅拷贝的方式：</p><p>引用类型的变量，默认赋值操作就是浅拷贝</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func main() {
</span></span><span class=line><span class=cl>    slice1 := []int{1, 2, 3, 4, 5}
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;slice1: %v, %p\n&#34;, slice1, slice1)
</span></span><span class=line><span class=cl>    slice2 := slice1
</span></span><span class=line><span class=cl>    fmt.Printf(&#34;slice2: %v, %p\n&#34;, slice2, slice2)
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>slice1: [1 2 3 4 5], 0xc00001a120
</span></span><span class=line><span class=cl>slice2: [1 2 3 4 5], 0xc00001a120
</span></span></code></pre></td></tr></table></div></div><a href=#go-slice-扩容机制><h1 id=go-slice-扩容机制><span class=hanchor arialabel=Anchor># </span>Go slice 扩容机制？</h1></a><p>扩容会发生在 slice append 的时候，当 slice 的 cap 不足以容纳新元素，就会进行扩容，扩容规则如下</p><ul><li>如果原有 slice 长度小于 1024，那么每次就扩容为原来的 2 倍</li><li>如果原 slice 长度大于等于 1024，那么每次扩容就扩为原来的 1.25 倍</li></ul><p><strong>补充</strong></p><p>如果 go 1.18+，原来的 slice 容量 oldcap 小于 256 的时候，新 slice 的容量 newcap 是 oldcap 的 2 倍；当 oldcap 容量大于等于 256 的时候，newcap 会有个计算公式：newcap += (newcap +3 threshold) / 4 再对 newcap 作了一个内存对齐，这个和内存分配策略相关。进行内存对齐之后，新 slice 的容量是要大于等于按照前半部分生成的 newcap。</p><a href=#go-slice-为什么不是线程安全的><h1 id=go-slice-为什么不是线程安全的><span class=hanchor arialabel=Anchor># </span>Go slice 为什么不是线程安全的？</h1></a><p><strong>先看下线程安全的定义</strong>：</p><p>多个线程访问同一个对象时，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。</p><p>若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p><p><strong>再看 Go 语言实现线程安全常用的几种方式</strong>：</p><ol><li>互斥锁</li><li>读写锁</li><li>原子操作</li><li>Sync. Once</li><li>Sync. Atomic</li><li>Channel</li></ol><p>Slice 底层结构并没有使用加锁等方式，不支持并发读写，所以并不是线程安全的，使用多个 goroutine 对类型为 slice 的变量进行操作，每次输出的值大概率都不会一样，与预期值不一致; slice 在并发执行中不会报错，但是数据会丢失</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/**
</span></span><span class=line><span class=cl>* 切片非并发安全
</span></span><span class=line><span class=cl>* 多次执行，每次得到的结果都不一样
</span></span><span class=line><span class=cl>* 可以考虑使用 channel 本身的特性 (阻塞) 来实现安全的并发读写
</span></span><span class=line><span class=cl> */
</span></span><span class=line><span class=cl>func TestSliceConcurrencySafe(t *testing.T) {
</span></span><span class=line><span class=cl> a := make([]int, 0)
</span></span><span class=line><span class=cl> var wg sync.WaitGroup
</span></span><span class=line><span class=cl> for i := 0; i &lt; 10000; i++ {
</span></span><span class=line><span class=cl>  wg.Add(1)
</span></span><span class=line><span class=cl>  go func(i int) {
</span></span><span class=line><span class=cl>   a = append(a, i)
</span></span><span class=line><span class=cl>   wg.Done()
</span></span><span class=line><span class=cl>  }(i)
</span></span><span class=line><span class=cl> }
</span></span><span class=line><span class=cl> wg.Wait()
</span></span><span class=line><span class=cl> t.Log(len(a)) 
</span></span><span class=line><span class=cl> // not equal 10000
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://googoo-s.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by googoo-s using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2024</p><ul><li><a href=https://googoo-s.github.io/>Home</a></li><li><a href=https://github.com/googoo-s>GitHub</a></li></ul></footer></div></div></body></html>