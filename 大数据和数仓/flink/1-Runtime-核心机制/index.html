<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Runtime 整体架构 执行环境 Flink 是可以运行在多种不同的环境中的
 可以通过单进程多线程的方式直接运行，从而提供调试的能力。 它也可以运行在 Yarn 或者 K 8 S 这种资源管理系统上面， 也可以在各种云环境中执行   Flink 提供了一套统一的分布式作业执行引擎，也就是 Flink Runtime 这层。Flink 在 Runtime 层之上提供了 DataStream 和 DataSet 两"><meta property="og:title" content><meta property="og:description" content="Runtime 整体架构 执行环境 Flink 是可以运行在多种不同的环境中的
 可以通过单进程多线程的方式直接运行，从而提供调试的能力。 它也可以运行在 Yarn 或者 K 8 S 这种资源管理系统上面， 也可以在各种云环境中执行   Flink 提供了一套统一的分布式作业执行引擎，也就是 Flink Runtime 这层。Flink 在 Runtime 层之上提供了 DataStream 和 DataSet 两"><meta property="og:type" content="website"><meta property="og:image" content="https://googoo-s.github.io/icon.png"><meta property="og:url" content="https://googoo-s.github.io/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%B0%E4%BB%93/flink/1-Runtime-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Runtime 整体架构 执行环境 Flink 是可以运行在多种不同的环境中的
 可以通过单进程多线程的方式直接运行，从而提供调试的能力。 它也可以运行在 Yarn 或者 K 8 S 这种资源管理系统上面， 也可以在各种云环境中执行   Flink 提供了一套统一的分布式作业执行引擎，也就是 Flink Runtime 这层。Flink 在 Runtime 层之上提供了 DataStream 和 DataSet 两"><meta name=twitter:image content="https://googoo-s.github.io/icon.png"><title>googoo-s 😄😸😎</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://googoo-s.github.io//icon.png><link href=https://googoo-s.github.io/styles.19109a40042e9f0e72e952fda4442a34.min.css rel=stylesheet><link href=https://googoo-s.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://googoo-s.github.io/js/darkmode.953af745b0f9342644d632fc167f3727.min.js></script>
<script src=https://googoo-s.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://googoo-s.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://googoo-s.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://googoo-s.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://googoo-s.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://googoo-s.github.io/",fetchData=Promise.all([fetch("https://googoo-s.github.io/indices/linkIndex.f65387078bd3afa8657e01f74a9355e6.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://googoo-s.github.io/indices/contentIndex.1fabdda7cc971358f790157164bee7be.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://googoo-s.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://googoo-s.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/googoo-s.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=googoo-s.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://googoo-s.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://googoo-s.github.io/>googoo-s 😄😸😎</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Unknown</p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#runtime-整体架构>Runtime 整体架构</a><ol><li><a href=#执行环境>执行环境</a></li><li><a href=#架构>架构</a></li><li><a href=#作业提交执行流程>作业提交执行流程</a></li></ol></li><li><a href=#资源管理和作业调度>资源管理和作业调度</a><ol><li><a href=#资源管理>资源管理</a><ol><li><a href=#share-slot>Share Slot</a></li></ol></li><li><a href=#作业调度>作业调度</a></li></ol></li><li><a href=#错误恢复>错误恢复</a><ol><li><a href=#task-执行出现错误>Task 执行出现错误</a></li><li><a href=#master-发生异常>Master 发生异常</a></li></ol></li></ol></nav></details></aside><a href=#runtime-整体架构><h1 id=runtime-整体架构><span class=hanchor arialabel=Anchor># </span>Runtime 整体架构</h1></a><a href=#执行环境><h2 id=执行环境><span class=hanchor arialabel=Anchor># </span>执行环境</h2></a><p>Flink 是可以运行在多种不同的环境中的</p><ul><li>可以通过单进程多线程的方式直接运行，从而提供调试的能力。</li><li>它也可以运行在 Yarn 或者 K 8 S 这种资源管理系统上面，</li><li>也可以在各种云环境中执行
<img src=https://googoo-s.github.io//statistic/Pasted%20image%2020230810152528.png width=auto alt></li></ul><p>Flink 提供了一套统一的分布式作业执行引擎，也就是 Flink Runtime 这层。Flink 在 Runtime 层之上提供了 DataStream 和 DataSet 两<br>套 API，分别用来编写流作业与批作业</p><a href=#架构><h2 id=架构><span class=hanchor arialabel=Anchor># </span>架构</h2></a><p><img src=https://googoo-s.github.io//statistic/Pasted%20image%2020230810152852.png width=auto alt></p><p>它采用了标准 master-slave 的结构，</p><ul><li>其中左侧白色圈中的部分即是 master，它负责管理整个集群中的资源和作业；<ul><li>Dispatcher 负责接收用户提供的作业，并且负责为这个新提交的作业拉起一个新的 JobManager 组件</li><li>ResourceManager 负责资源的管理，在整个 Flink 集群中只有一个 ResourceManager</li><li>JobManager 负责管理作业的执行，在一个 Flink 集群中可能有多个作业同时执行，每个作业都有自己的 JobManager 组件</li></ul></li><li>而右侧的两个 TaskExecutor 则是 Slave</li></ul><a href=#作业提交执行流程><h2 id=作业提交执行流程><span class=hanchor arialabel=Anchor># </span>作业提交执行流程</h2></a><p>提交脚本会</p><ul><li>首先启动一个 Client 进程负责作业的编译与提交。<ul><li>它首先将用户编写的代码编译为一个 JobGraph，在这个过程，它还会进行一些检查或优化等工作。</li><li>Client 将产生的 JobGraph 提交到集群中执行，此时有两种情 况<ul><li>一种是类似于 Standalone 这种 Session 模式，AM 会预先启动，此时 Client 直接与 Dispatcher 建立连接并提交作业即可</li><li>AM 不会预先启动，此时 Client 将首先向资源管理系统 （如 Yarn、K 8 S）申请资源来启动 AM，然后再向 AM 中的 Dispatcher 提交作业</li></ul></li></ul></li><li>作业到 Dispatcher 后，Dispatcher 会首先启动一个 JobManager 组件</li><li>然后 JobManager 会向 ResourceManager 申请资源来启动作业中具体的任务<ul><li>session 模式，此时 ResourceManager 中已有记录了 TaskExecutor 注册的资源，可以直接选取空闲资源进行分配。</li><li>Per-Job 模式，ResourceManager 也需要首先向外部资源管理系统申请资源来启动 TaskExecutor，然后等待 TaskExecutor 注册相应资源后再继续选择空闲资源进程分配。</li></ul></li></ul><blockquote><p>目前 Flink 中 TaskExecutor 的资源是通过 Slot 来描述的，一个 Slot 一般可以执行一个具体的 Task，但在一些情况下也可以执行多个相关联的 Task</p></blockquote><ul><li>TaskExecutor 收到 JobManager 提交的 Task 之后，会启动一个新的线程来执行该 Task<ul><li>Task 启动后就会开始进行预先指定的计算，并通过数据 Shuffle 模块互相交换数据</li></ul></li></ul><p>总之</p><ol><li><p>Per-job 模式下 AppMaster 和 TaskExecutor 都是按需申请的。因此，Per-job 模式更适合运行执行时间较长的大作业，这些作业对稳定性要求较高，并且对申请资源的时间不敏感。与之对应，</p></li><li><p>在 Session 模式下，Flink 预先启动 AppMaster 以及一组 TaskExecutor，然后在整个集群的生命周期中会执行多个作业。可以看出，Session 模式更适合规模小，执行时间短的作业</p></li><li></li></ol><p><img src=https://googoo-s.github.io//statistic/Pasted%20image%2020230810154008.png width=auto alt></p><a href=#资源管理和作业调度><h1 id=资源管理和作业调度><span class=hanchor arialabel=Anchor># </span>资源管理和作业调度</h1></a><p>作业调度可以看做是对资源和任务进行匹配的过程。</p><ul><li>资源是通过 Slot 来表示的，每个 Slot 可以用来执行不同的 Task</li><li>任务即 Job 中实际的 Task，它包含了待执行的用户逻辑</li></ul><p>调度的主要目的就是为了给 Task 找到匹配的 Slot，</p><p>逻辑上来说，每个 Slot 都应该有一个向量来描述它所能提供的各种资源的量，每个 Task 也需要相应的说明它所需要的各种资源的量。</p><ul><li>但是实际上在 1.9 之前，Flink 是不支持细粒度的资源描述的，而是统一的认为每个 Slot 提供的资源和 Task 需要的资源都是相同的。</li><li>从 1.9 开始，Flink 开始增加对细粒度的资源匹配的支持的实现，但这部分功能目前仍在完善中</li></ul><a href=#资源管理><h2 id=资源管理><span class=hanchor arialabel=Anchor># </span>资源管理</h2></a><p>作业调度的基础是首先提供对资源的管理，Flink 中的资源是由 TaskExecutor 上的 Slot 来表示 的</p><p><img src=https://googoo-s.github.io//statistic/Pasted%20image%2020230810154620.png width=auto alt></p><ul><li>在 ResourceManager 中，有一个子组件叫做 SlotManager，它维护了当前集群中所有 TaskExecutor 上的 Slot 的信息与状态，如该 Slot 在哪个 TaskExecutor 中，该 Slot 当前是否空闲等</li><li>JobManager 会首先将相应的 Slot 缓存到 SlotPool 中，但不会立即释放。</li><li>当 SlotPool 中缓存的 Slot 超过指定的时间仍未使用时，SlotPool 就会发起释放该 Slot 的过程。</li><li>SlotPool 会首先通知 TaskManager 来释放该 Slot，然后 TaskExecutor 通知 ResourceManager 该 Slot 已经被释放，从而最终完成释放的逻辑</li></ul><a href=#share-slot><h3 id=share-slot><span class=hanchor arialabel=Anchor># </span>Share Slot</h3></a><p>默认情况下，每个 Slot 可以分配给一个 Task。但是，这种方式在某些情况下会导致资源利用率不高</p><p>如 A、B、C 依次执行计算逻辑，那么给 A、B、C 分配分配单独的 Slot 就会导致资源利用 率不高。</p><p><img src=https://googoo-s.github.io//statistic/Pasted%20image%2020230810160851.png width=auto alt></p><p>Flink 提供了 Share Slot 的机制</p><ul><li>每个 Slot 中可以部署来自不同 JobVertex 的多个任务，但是不能部署来自同一个 JobVertex 的 Task</li><li>每个 Slot 中最多可以部署同一个 AB 或 C 的 Task，但是可以同时部署 A、B 和 C 的各一个 Task</li><li>当单个 Task 占用资源较少时，Share Slot 可以提高资源利用率。</li><li>Share Slot 也提供了一种简 单的保持负载均衡的方式。</li></ul><a href=#作业调度><h2 id=作业调度><span class=hanchor arialabel=Anchor># </span>作业调度</h2></a><p>JobManager 负责维护作业中 Task 执行的状态。</p><p>Client 端会向 JobManager 提交一个 JobGraph，它代表了作业的逻辑结构。</p><p>JobManager 会根据 JobGraph 按并发展开，从而得到 JobManager 中关键的 ExecutionGraph</p><p><img src=https://googoo-s.github.io//statistic/Pasted%20image%2020230810161346.png width=auto alt></p><p>与 JobGraph 相比，ExecutionGraph 中对于每个 Task 与中间结果等均创建了对应的对象，从而可以维护这些实体的信息与状态</p><p>一个 Flink Job 中是包含多个 Task 的，因此另一个关键的问题是在 Flink 中，按什么顺序来调度 Task</p><ul><li>Eager 调度：它会在作业启动时申请资源将所有的 Task 调度起来。这种调度算法主要用来调度可能没有终止的流作 业</li><li>Lazy From Source：从 Source 开始，按拓扑顺序来进行调度<ul><li>先调度没有上游任务的 Source 任务，当这些任务执行完成时，它会将输出数据缓存到内存或者写入到磁盘中。</li><li>对于后续的任务，当它的前驱任务全部执行完成后，Flink 就会将这些任务调度起来。这些任务会从读取上游缓存的输出数据进行自己的计算</li></ul></li></ul><p><img src=https://googoo-s.github.io//statistic/Pasted%20image%2020230810161835.png width=auto alt></p><a href=#错误恢复><h1 id=错误恢复><span class=hanchor arialabel=Anchor># </span>错误恢复</h1></a><p>错误可能分为两大类：</p><ul><li>Task 执行出现错误</li><li>Flink 集群的 Master 出现错误</li></ul><a href=#task-执行出现错误><h2 id=task-执行出现错误><span class=hanchor arialabel=Anchor># </span>Task 执行出现错误</h2></a><p>第一类 Task 执行错误，Flink 提供了多种不同的错误恢复策略。</p><ul><li><p>第一种策略是 Restart-all，即直接重启所有的 Task。由于 Checkpoint 机制，因此当任务重启后可以直接从上次的<br>Checkpoint 开始继续执行</p></li><li><p>第二类错误恢复策略是 Restart-individual，它只适用于 Task 之间没有数据传输的情况。这种情况下，我们可以直接重启出错的任务</p></li></ul><blockquote><p>由于 Flink 的批作业没有 Checkpoint 机制，因此对于需要数据传输的作业，直接重启所有 Task 会导致作业从头计算，从而导致一定的性能问题</p></blockquote><ul><li>第三种，Region-Based 的 Failover 策略<ul><li>两种不同的数据传输方式<ul><li>一种是 Pipeline 类型的方式，这种方式上下游 Task 之间直接通过网络传输数据，因此需要上下游同时运行</li><li>Blocking 类型的试，如上节所述，这种方式下，上游的 Task 会首先将数据进行缓存，因此上下游的 Task 可以单独执行</li></ul></li><li>基于这两种类型的传输，Flink 将 ExecutionGraph 中使用 Pipeline 方式传输数据的 Task 的子图叫做 <strong>Region</strong>，将整个 ExecutionGraph 划分为多个子图，<ul><li>Region 内的 Task 必须同时重启，</li><li>而不同 Region 的 Task 由于在 Region 边界存在 Blocking 的边，因此，可以单独重启下游 Region 中的 Task</li></ul></li><li>分两种情况进行考虑<ul><li>如果是由于 Task 本身的问题发生错误，那么可以只重启该 Task 所属的 Region 中的 Task，这些 Task 重启之后，可以直接拉取上游 Region 缓存的输出结果继续进行计算<ul><li><img src=https://googoo-s.github.io//statistic/Pasted%20image%2020230810163059.png width=auto alt></li></ul></li><li>如果错误是由于读取上游结果出现问题，那么还需要重启上游 Region 来重新产生相应的数据，还需要同时重启上游 Region 所有的下游 Region<ul><li><img src=https://googoo-s.github.io//statistic/Pasted%20image%2020230810163045.png width=auto alt></li></ul></li></ul></li></ul></li></ul><a href=#master-发生异常><h2 id=master-发生异常><span class=hanchor arialabel=Anchor># </span>Master 发生异常</h2></a><p>Flink 支持启动多个 Master 作为备份，这些 Master 可以通过 ZK 来进行选主，从而保证某一时刻只有一个 Master 在运行。当前活路的 Master 发生异常时 , 某个备份的 Master 可以接管协调的工作。</p><p>为了保证 Master 可以准确维护作业的状态，Flink 目前采用了一种最简单的实现方式，即直接重启整个作业</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://googoo-s.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by googoo-s using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://googoo-s.github.io/>Home</a></li><li><a href=https://github.com/googoo-s>GitHub</a></li></ul></footer></div></div></body></html>