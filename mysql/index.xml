<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MySQLs on</title><link>https://quartz.jzhao.xyz/mysql/</link><description>Recent content in MySQLs on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://quartz.jzhao.xyz/mysql/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</guid><description>MySQL 的基本架构图 MySQL 可以分为 Server 层和存储引擎层两部分
连接器 连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令为
1 mysql -h$ip -P$port -u$user -p 连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E4%BA%8B%E5%8A%A1-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8CMVCC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E4%BA%8B%E5%8A%A1-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8CMVCC/</guid><description>已知的矛盾
只查询。可重复读隔离级别，事务 T 启动的时候会创建一个视图 read-view，之后事务 T 执行期间，即使有其他事务修改了数据，事务 T 看到的仍然跟在启动时看到的一样。
更新后查询。在写方面 一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，它又不能这么超然了，会被锁住，进入等待状态。问题是，既然进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值是啥。
1 2 3 4 5 6 mysql&amp;gt; CREATE TABLE `t` ( `id` int(11) NOT NULL, `k` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB; insert into t(id, k) values(1,1),(2,2); 对于，上述的表格采用一下操作</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E4%BA%8B%E5%8A%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E4%BA%8B%E5%8A%A1/</guid><description>事务的特性 原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成
一致性（Consistency）：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E4%BA%8B%E5%8A%A1%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E4%BA%86%E5%90%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E4%BA%8B%E5%8A%A1%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E4%BA%86%E5%90%97/</guid><description>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：
**针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，**因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
**针对当前读（select &amp;hellip; for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，**因为当执行 select &amp;hellip; for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8-%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8-%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/</guid><description>这点没错，但是大家知道 B+ 树里的节点里存放的是什么呢？查询数据的过程又是怎样的？
这次，我们从数据页的角度看 B+ 树，看看每个节点长啥样。
InnoDB 是如何存储数据的？ 记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。
InnoDB 的数据是按「数据页」为单位来读写的
InnoDB 数据页的默认大小是 16KB</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</guid><description>解锁这些面试题：
MySQL 的 NULL 值会占用空间吗？
MySQL 怎么知道 varchar(n) 实际占用数据的大小？
varchar(n) 中 n 最大取值为多少？</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8_Change-buffer-%E5%92%8C-buffer-pool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8_Change-buffer-%E5%92%8C-buffer-pool/</guid><description>Change Buffer change buffer 当需要更新一个数据页时，如果数据页在内存中就直接更新，
而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下**，InnoDB 会将这些更新操作缓存在 change buffer 中**，
在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8_%E8%A1%8C%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8_%E8%A1%8C%E7%BB%93%E6%9E%84/</guid><description>InnoDB 行格式有哪些？ 行格式（row_format），就是一条记录的存储结构。
InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。
Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。
由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E6%97%A5%E5%BF%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E6%97%A5%E5%BF%97/</guid><description>Update 的执行过程
1 UPDATEt_userSETname=&amp;#39;xiaolin&amp;#39;WHEREid=1; 客户端先通过连接器建立连接，连接器自会判断用户身份；
因为这是一条 update 语句，所以不需要经过查询缓存，但是表上有更新语句，是会把整个表的查询缓存清空的，所以说查询缓存很鸡肋，在 MySQL 8.0 就被移除这个功能了；
解析器会通过词法分析识别出关键字 update，表名等等，构建出语法树，接着还会做语法分析，判断输入的语句是否符合 MySQL 语法；</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95-Count%E6%95%88%E7%8E%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95-Count%E6%95%88%E7%8E%87/</guid><description>Count(*)的实现方式 在不同的 MySQL 引擎中，count(*) 有不同的实现方式:
MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；
而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。
什么 InnoDB 不跟 MyISAM 一样，也把数字存起来呢?</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95-MySQL-%E4%BD%BF%E7%94%A8-like-x%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%A4%B1%E6%95%88%E5%90%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95-MySQL-%E4%BD%BF%E7%94%A8-like-x%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%A4%B1%E6%95%88%E5%90%97/</guid><description>谁还没碰过索引失效呢
使用左模糊匹配（like &amp;ldquo;%xx&amp;rdquo;）并不一定会走全表扫描，关键还是看数据表中的字段。
如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，也不会走全表扫描（type=all），而是走全扫描二级索引树(type=index)。
题目一 数据库表如下，id 是主键索引，name 是二级索引，其他字段都是非索引字段
这四条模糊匹配的查询语句，第一条和第二条都会走索引扫描，而且都是选择扫描二级索引（index_name），我贴个第二条查询语句的执行计划结果图：
而第三和第四条会发生索引失效，执行计划的结果 type= ALL，代表了全表扫描。
题目二 数据库表特别之处在于，只有两个字段，一个是主键索引 id，另外一个是二级索引 name。</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95-MySQL-%E5%8D%95%E8%A1%A8%E4%B8%8D%E8%A6%81%E8%B6%85%E8%BF%87-2000W-%E8%A1%8C%E9%9D%A0%E8%B0%B1%E5%90%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95-MySQL-%E5%8D%95%E8%A1%A8%E4%B8%8D%E8%A6%81%E8%B6%85%E8%BF%87-2000W-%E8%A1%8C%E9%9D%A0%E8%B0%B1%E5%90%97/</guid><description>mysql 最大建议行数2000w,靠谱吗? - 京东云开发者的个人空间 - OSCHINA - 中文开源技术交流社区
总结 MySQL 的表数据是以页的形式存放的，页在磁盘中不一定是连续的。
页的空间是 16K, 并不是所有的空间都是用来存放数据的，会有一些固定的信息，如，页头，页尾，页码，校验码等等。</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>什么是索引 那换到数据库中，索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。
索引的分类。 我们可以按照四个角度来分类索引。
按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。
按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。
按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。
按「字段个数」分类：单列索引、联合索引。
接下来，按照这些角度来说说各类索引的特点
按数据结构分类 每一种存储引擎支持的索引类型不一定相同，我在表中总结了 MySQL 常见的存储引擎 InnoDB、MyISAM 和 Memory 分别支持的索引类型。</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95-%E7%90%86%E8%A7%A3-B-%E6%A0%91B+-%E6%A0%91%E7%89%B9%E7%82%B9%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95-%E7%90%86%E8%A7%A3-B-%E6%A0%91B+-%E6%A0%91%E7%89%B9%E7%82%B9%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</guid><description>为什么 MySQL 采用 B+ 树作为索引？
B 树 B 树就是常说的“B 减树（B- 树）”，又名平衡多路（即不止两个子树）查找树，它和平衡二叉树的不同有这么几点：
平衡二叉树节点最多有两个子树，而 B 树每个节点可以有多个子树，M 阶 B 树表示该树每个节点最多有 M 个子树</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95/</guid><description>索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。
常见的索引模型 索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同
InnoDB的索引模型 在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。
InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。
B+树的结构 B+树是B树的变体，具有比B树更高的查询性能
回顾一个m阶的B树具有如下几个特征：
根结点至少有两个子女</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E9%94%81-MySQL-%E5%8F%AF%E4%BB%A5%E9%98%B2%E6%AD%A2%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B9%BB%E8%AF%BB%E5%90%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E9%94%81-MySQL-%E5%8F%AF%E4%BB%A5%E9%98%B2%E6%AD%A2%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B9%BB%E8%AF%BB%E5%90%97/</guid><description>昨天有位读者在美团二面的时候，被问到关于幻读的问题：
面试官反问的大概意思是，MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？
答案是可以的。
接下来，通过几个小实验来证明这个结论吧，顺便再帮大家复习一下记录锁+间隙锁。
#什么是幻读？ 首先来看看 MySQL 文档是怎么定义幻读（Phantom Read）的:
The so-called phantom problem occurs within a transaction when the same query produces different sets of rows at different times.</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E9%94%81-MySQL-%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E9%94%81%E7%9A%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E9%94%81-MySQL-%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E9%94%81%E7%9A%84/</guid><description>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁，所以后面的内容都是基于 InnoDB 引擎的。
什么 SQL 语句会加行级锁？ 普通的 select 语句是不会对记录加锁的（除了串行化隔离级别），因为它属于快照读，是通过 MVCC（多版本并发控制）实现的。
如果要在查询时对记录加行级锁，可以使用下面这两个方式，这两种查询会加锁的语句称为锁定读。
1 2 3 4 //对读取的记录加共享锁(S型锁) select .</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E9%94%81-MySQL%E6%AD%BB%E9%94%81%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E9%94%81-MySQL%E6%AD%BB%E9%94%81%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/</guid><description>死锁的发生 我建了一张订单表，其中 id 字段为主键索引，order_no 字段普通索引，也就是非唯一索引：
1 2 3 4 5 6 7 8 CREATETABLE`t_order`(`id`intNOTNULLAUTO_INCREMENT,`order_no`intDEFAULTNULL,`create_date`datetimeDEFAULTNULL,PRIMARYKEY(`id`),KEY`index_order`(`order_no`)USINGBTREE)ENGINE=InnoDB; 假设这时有两事务，一个事务要插入订单 1007 ，另外一个事务要插入订单 1008，因为需要对订单做幂等性校验，所以两个事务先要查询该订单是否存在，不存在才插入记录，过程如下：</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E9%94%81-Update%E6%B2%A1%E5%8A%A0%E7%B4%A2%E5%BC%95%E4%BC%9A%E9%94%81%E5%85%A8%E8%A1%A8%E5%90%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E9%94%81-Update%E6%B2%A1%E5%8A%A0%E7%B4%A2%E5%BC%95%E4%BC%9A%E9%94%81%E5%85%A8%E8%A1%A8%E5%90%97/</guid><description>大家好，我是小林。
昨晚在群划水的时候，看到有位读者说了这么一件事。
大概就是，在线上执行一条 update 语句修改数据库数据的时候，where 条件没有带上索引，导致业务直接崩了，被老板教训了一波
这次我们就来看看：
为什么会发生这种的事故？
又该如何避免这种事故的发生？
说个前提，接下来说的案例都是基于 InnoDB 存储引擎，且事务的隔离级别是可重复读。
为什么会发生这种的事故？ InnoDB 存储引擎的默认事务隔离级别是「可重复读」，但是在这个隔离级别下，在多个事务并发的时候，会出现幻读的问题，所谓的幻读是指在同一事务下，连续执行两次同样的查询语句，第二次的查询语句可能会返回之前不存在的行。</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%9F%BA%E7%A1%80/%E9%94%81/</guid><description>根据加锁的范围可以分为全局锁，表级锁，行锁。
![[Pasted image 20230727224159.png]]
全局锁 全局锁就是对整个数据库实例加锁。
全局锁的用法 全局读锁：MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)
FTWRL
FTWRL 前有读写的话 ,FTWRL 都会等待 读写执行完毕后才执行</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/1.%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/1.%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95/</guid><description>查询过程 select id from T where k=5
这个查询语句在索引树上查找的过程，先是通过 B+ 树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认为数据页内部通过二分法来定位记录。
对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一个不满足 k=5 条件的记录。
对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/10.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%9F%A5%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E4%B9%9F%E6%89%A7%E8%A1%8C%E8%BF%99%E4%B9%88%E6%85%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/10.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%9F%A5%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E4%B9%9F%E6%89%A7%E8%A1%8C%E8%BF%99%E4%B9%88%E6%85%A2/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 mysql&amp;gt; CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB; delimiter ;; create procedure idata() begin declare i int; set i=1; while(i&amp;lt;=100000) do insert into t values(i,i); set i=i+1; end while; end;; delimiter ; call idata(); 第一类：查询长时间不返回 1 2 mysql&amp;gt; select * from t where id=1; 大概率是表 t 被锁住了。接下来分析原因的时候，一般都是首先执行一下 show processlist 命令，看看当前语句处于什么状态</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/11.%E5%B9%BB%E8%AF%BB%E6%98%AF%E4%BB%80%E4%B9%88%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/11.%E5%B9%BB%E8%AF%BB%E6%98%AF%E4%BB%80%E4%B9%88%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</guid><description>1 2 3 4 5 6 7 8 9 10 11 CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`) ) ENGINE=InnoDB; insert into t values(0,0,0),(5,5,5), (10,10,10),(15,15,15),(20,20,20),(25,25,25); 1 2 3 4 begin; select * from t where d=5 for update; commit; 比较好理解的是，这个语句会命中 d=5 的这一行，对应的主键 id=5，**因此在 select 语句执行完成后，id=5 这一行会加一个写锁，而且由于两阶段锁协议，这个写锁会在执行 commit 语句的时候释放。**由于字段 d 上没有索引，因此这条查询语句会做全表扫描。那么，其他被扫描到的，但是不满足条件的 5 行记录上，会不会被加锁呢？</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/12.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%94%B9%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E9%94%81%E8%BF%99%E4%B9%88%E5%A4%9A/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/12.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%94%B9%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E9%94%81%E8%BF%99%E4%B9%88%E5%A4%9A/</guid><description>加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。
原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。
原则 2：查找过程中访问到的对象才会加锁。
优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。
优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/13.MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A5%AE%E9%B8%A9%E6%AD%A2%E6%B8%B4%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/13.MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A5%AE%E9%B8%A9%E6%AD%A2%E6%B8%B4%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/</guid><description/></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/14.MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E7%9A%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/14.MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E7%9A%84/</guid><description>得到的结论是：只要 redo log 和 binlog 保证持久化到磁盘，就能确保 MySQL 异常重启后，数据可以恢复。
redo log 的写入流程是怎么样的，如何保证 redo log 真实地写入了磁盘。那么今天，我们就再一起看看 MySQL 写入 binlog 和 redo log 的流程</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/15.MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E7%9A%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/15.MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E7%9A%84/</guid><description>我不止一次地和你提到了 binlog，大家知道 binlog 可以用来归档，也可以用来做主备同步，但它的内容是什么样的呢？为什么备库执行了 binlog 就可以跟主库保持一致了呢？
MySQL 主备的基本原理 上图就是基本的主备切换流程：（M-S结构）
在状态 1 中，客户端的读写都直接访问节点 A，而节点 B 是 A 的备库，只是将 A 的更新都同步过来，到本地执行。这样可以保持节点 B 和 A 的数据是相同的。</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/16.MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/16.MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84/</guid><description>正常情况下，只要主库执行更新生成的所有 binlog，都可以传到备库并被正确地执行，备库就能达到跟主库一致的状态，这就是最终一致性
MySQL 要提供高可用能力，只有最终一致性是不够的。
我再放一次上一篇文章中讲到的双 M 结构的主备切换流程图
主备延迟 在介绍主动切换流程的详细步骤之前，我要先跟你说明一个概念，即**“同步延迟”。与数据同步有关的时间点主要包括以下三个：**
主库 A 执行完成一个事务，写入 binlog，我们把这个时刻记为 T1;
之后传给备库 B，我们把备库 B 接收完这个 binlog 的时刻记为 T2;</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/17.%E5%A4%87%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BB%B6%E8%BF%9F%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%B0%8F%E6%97%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/17.%E5%A4%87%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BB%B6%E8%BF%9F%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%B0%8F%E6%97%B6/</guid><description>你会发现，这些场景里，不论是偶发性的查询压力，还是备份，对备库延迟的影响一般是分钟级的，而且在备库恢复正常以后都能够追上来。但是，如果备库执行日志的速度持续低于主库生成日志的速度，那这个延迟就有可能成了小时级别。
备库并行复制能力
谈到主备的并行复制能力，我们要关注的是图中黑色的两个箭头。
一个箭头代表了客户端写入主库（更重要）
另一箭头代表的是备库上 sql_thread 执行中转日志（relay log）
在主库上，影响并发度的原因就是各种锁了。
而日志在备库上的执行，就是图中备库上 sql_thread 更新数据 (DATA) 的逻辑。如果是用单线程的话，就会导致备库应用日志不够快，造成主备延迟</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/18.%E4%B8%BB%E5%BA%93%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86%E4%BB%8E%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/18.%E4%B8%BB%E5%BA%93%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86%E4%BB%8E%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E/</guid><description>大多数的互联网应用场景都是读多写少，因此你负责的业务，在发展过程中很可能先会遇到读性能的问题。而在数据库层解决读性能问题，所以需要一主多从。
图中，虚线箭头表示的是主备关系，也就是 A 和 A’互为主备， 从库 B、C、D 指向的是主库 A。一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。
在一主多从架构下，主库故障后的主备切换问题。
下图就是主库发生故障，主备切换后的结果。相比于一主一备的切换流程，一主多从结构在切换完成后**，A’会成为新的主库，从库 B、C、D 也要改接到 A’。正是由于多了从库 B、C、D 重新指向的这个过程**，所以主备切换的复杂性也相应增加了。
基于位点的主备切换 当我们把节点 B 设置成节点 A’的从库的时候，需要执行一条 change master 命令</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/19.%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E7%9A%84%E5%9D%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/19.%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E7%9A%84%E5%9D%91/</guid><description/></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/2.%E5%A6%82%E4%BD%95%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E5%8A%A0%E7%B4%A2%E5%BC%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/2.%E5%A6%82%E4%BD%95%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E5%8A%A0%E7%B4%A2%E5%BC%95/</guid><description>乎所有的系统都支持邮箱登录，如何在邮箱这样的字段上建立合理的索引
1 2 3 4 5 mysql&amp;gt; create table SUser( ID bigint unsigned primary key, email varchar(64), ... )engine=innodb; MySQL 是支持前缀索引的，也就是说，你可以定义字符串的一部分作为索引。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/20.%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E5%90%A6%E5%87%BA%E9%97%AE%E9%A2%98-%E4%BA%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/20.%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E5%90%A6%E5%87%BA%E9%97%AE%E9%A2%98-%E4%BA%86/</guid><description/></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/21.%E8%BF%98%E6%9C%89kill%E4%B8%8D%E6%8E%89%E7%9A%84%E8%AF%AD%E5%8F%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/21.%E8%BF%98%E6%9C%89kill%E4%B8%8D%E6%8E%89%E7%9A%84%E8%AF%AD%E5%8F%A5/</guid><description/></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/22.%E6%88%91%E6%9F%A5%E8%BF%99%E4%B9%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AD%98%E6%89%93%E7%88%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/22.%E6%88%91%E6%9F%A5%E8%BF%99%E4%B9%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AD%98%E6%89%93%E7%88%86/</guid><description/></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/23.%E5%88%B0%E5%BA%95%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E7%94%A8join/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/23.%E5%88%B0%E5%BA%95%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E7%94%A8join/</guid><description/></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/24.join%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/24.join%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96/</guid><description>介绍了 join 语句的两种算法，分别是 Index Nested-Loop Join(NLJ) 和 Block Nested-Loop Join(BNL)。
这两个算法都还有继续优化的空间，我们今天就来聊聊这个话题。
我还是创建两个表 t1、t2 来和你展开今天的问题
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 create table t1(id int primary key, a int, b int, index(a)); create table t2 like t1; drop procedure idata; delimiter ;; create procedure idata() begin declare i int; set i=1; while(i&amp;lt;=1000)do insert into t1 values(i, 1001-i, i); set i=i+1; end while; set i=1; while(i&amp;lt;=1000000)do insert into t2 values(i, i, i); set i=i+1; end while; end;; delimiter ; call idata(); Multi-Range Read 优化 这个优化的主要目的是尽量使用顺序读盘。</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/25.%E4%B8%BA%E5%95%A5%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/25.%E4%B8%BA%E5%95%A5%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%8D/</guid><description>我们在优化 join 查询的时候使用到了临时表。当时，我们是这么用的：
create temporary table temp_t like t1; alter table temp_t add index(b); insert into temp_t select * from t2 where b&amp;gt;=1 and b&amp;lt;=2000; select * from t1 join temp_t on (t1.</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/26.%E8%BF%98%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8Memory%E5%BC%95%E6%93%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/26.%E8%BF%98%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8Memory%E5%BC%95%E6%93%8E/</guid><description>内存表的数据组织结构
create table t1(id int primary key, c int) engine=Memory; create table t2(id int primary key, c int) engine=innodb; insert into t1 values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(0,0); insert into t2 values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(0,0);</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/27.%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%BA%E5%95%A5%E4%B8%8D%E8%BF%9E%E7%BB%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/27.%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%BA%E5%95%A5%E4%B8%8D%E8%BF%9E%E7%BB%AD/</guid><description>由于自增主键可以让主键索引尽量地保持递增顺序插入，避免了页分裂，因此索引更紧凑。
自增主键不能保证连续递增
CREATE TABLE t ( id int(11) NOT NULL AUTO_INCREMENT, c int(11) DEFAULT NULL, d int(11) DEFAULT NULL, PRIMARY KEY (id), UNIQUE KEY c (c) ) ENGINE=InnoDB;</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/28.insert%E4%B8%BA%E5%95%A5%E9%94%81%E9%82%A3%E4%B9%88%E5%A4%9A/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/28.insert%E4%B8%BA%E5%95%A5%E9%94%81%E9%82%A3%E4%B9%88%E5%A4%9A/</guid><description>MySQL 对自增主键锁做了优化，尽量在申请到自增 id 以后，就释放自增锁。
insert 语句是一个很轻量的操作。不过，这个结论对于“普通的 insert 语句”才有效。也就是说，还有些 insert 语句是属于“特殊情况”的，在执行过程中需要给其他资源加锁，或者无法在申请到自增 id 以后就立马释放自增锁
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 CREATE TABLE t ( id int(11) NOT NULL AUTO_INCREMENT, c int(11) DEFAULT NULL, d int(11) DEFAULT NULL, PRIMARY KEY (id), UNIQUE KEY c (c) ) ENGINE=InnoDB; insert into t values(null, 1,1); insert into t values(null, 2,2); insert into t values(null, 3,3); insert into t values(null, 4,4); create table t2 like t insert … select 语句 在可重复读隔离级别下，binlog_format=statement 时执行：</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/29%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/29%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8/</guid><description>如果可以控制对源表的扫描行数和加锁范围很小的话，我们简单地使用 insert … select 语句即可实现
更稳妥的方案是先将数据写到外部文本文件，然后再写回目标表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 create database db1; use db1; create table t(id int primary key, a int, b int, index(a))engine=innodb; delimiter ;; create procedure idata() begin declare i int; set i=1; while(i&amp;lt;=1000)do insert into t values(i,i,i); set i=i+1; end while; end;; delimiter ; call idata(); create database db2; create table db2.</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/3.MySQL-%E9%94%99%E9%80%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/3.MySQL-%E9%94%99%E9%80%89/</guid><description>MySQL 中一张表其实是可以支持多个索引的。使用哪个索引是由 MySQL 来确定的。
一条本来可以执行得很快的语句，却由于 MySQL 选错了索引，而导致执行速度变得很慢
1 2 3 4 5 6 7 8 9 CREATE TABLE `t` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `a` (`a`), KEY `b` (`b`) ) ENGINE=InnoDB； 使用存储过程来插入数据</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/30.grant%E4%B9%8B%E5%90%8E%E8%A6%81%E8%B7%9F%E7%9D%80flush-privileges%E5%90%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/30.grant%E4%B9%8B%E5%90%8E%E8%A6%81%E8%B7%9F%E7%9D%80flush-privileges%E5%90%97/</guid><description>grant 语句是用来给用户赋权的。不知道你有没有见过一些操作文档里面提到，grant 之后要马上跟着执行一个 flush privileges 命令，才能使赋权语句生效
下来，我就先和你介绍一下 grant 语句和 flush privileges 语句分别做了什么事情
create user &amp;lsquo;ua&amp;rsquo;@&amp;rsquo;%&amp;rsquo; identified by &amp;lsquo;pa&amp;rsquo;;
这条语句的逻辑是创建一个用户’ua’@’%’，密码是 pa。在 MySQL 里面，用户名 (user)+ 地址 (host) 才表示一个用户，因此 ua@ip1 和 ua@ip2 代表的是两个不同的用户。</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/31-%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/31-%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8/</guid><description>分区表有什么问题，为什么公司规范不让使用分区表呢?
分区表是什么? 1 2 3 4 5 6 7 8 9 10 11 CREATE TABLE t ( ftime datetime NOT NULL, c int(11) DEFAULT NULL, KEY (ftime) ) ENGINE=InnoDB DEFAULT CHARSET=latin1 PARTITION BY RANGE (YEAR(ftime)) (PARTITION p_2017 VALUES LESS THAN (2017) ENGINE = InnoDB, PARTITION p_2018 VALUES LESS THAN (2018) ENGINE = InnoDB, PARTITION p_2019 VALUES LESS THAN (2019) ENGINE = InnoDB, PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE = InnoDB); insert into t values(&amp;#39;2017-4-1&amp;#39;,1),(&amp;#39;2018-4-1&amp;#39;,1); 我在表 t 中初始化插入了两行记录，按照定义的分区规则**，这两行记录分别落在 p_2018 和 p_2019 这两个分区**上。</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/32.%E8%87%AA%E5%A2%9Eid%E7%94%A8%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/32.%E8%87%AA%E5%A2%9Eid%E7%94%A8%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E/</guid><description>既然自增 id 有上限，就有可能被用完。但是，自增 id 用完了会怎么样呢？今天这篇文章，我们就来看看 MySQL 里面的几种自增 id，一起分析一下它们的值达到上限以后，会出现什么情况。
表定义自增值 id 表定义的自增值达到上限后的逻辑是：再申请下一个 id 时，得到的值保持不变
1 2 3 4 5 6 7 8 9 10 11 12 create table t(id int unsigned auto_increment primary key) auto_increment=4294967295; insert into t values(null); //成功插入一行 4294967295 show create table t; /* CREATE TABLE t ( id int(10) unsigned NOT NULL AUTO_INCREMENT, PRIMARY KEY (id) ) ENGINE=InnoDB AUTO_INCREMENT=4294967295; */ insert into t values(null); //Duplicate entry &amp;#39;4294967295&amp;#39; for key &amp;#39;PRIMARY&amp;#39; 以看到，第一个 insert 语句插入数据成功后，这个表的 AUTO_INCREMENT 没有改变（还是 4294967295），就导致了第二个 insert 语句又拿到相同的自增 id 值，再试图执行插入语句，报主键冲突错误</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/4.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84MySQL%E4%BC%9A%E6%8A%96%E4%B8%80%E4%B8%8B--Flush/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/4.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84MySQL%E4%BC%9A%E6%8A%96%E4%B8%80%E4%B8%8B--Flush/</guid><description>一条 SQL 语句，正常执行的时候特别快，但是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持续时间还很短。
不知道你有没有遇到过这样的场景，一条 SQL 语句，正常执行的时候特别快，但是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持续时间还很短。
你的 SQL 语句为什么变“慢”了 我为你介绍了 WAL 机制。现在你知道了，InnoDB 在处理更新语句的时候，只做了写日志这一个磁盘操作。这个日志叫作 redo log（重做日志）
当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。
做下类比的话，掌柜记账的账本是数据文件，记账用的粉板是日志文件（redo log），掌柜的记忆就是内存。
掌柜总要找时间把账本更新一下，这对应的就是把内存里的数据写入磁盘的过程，术语就是 flush</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/5.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%88%A0%E6%8E%89%E4%B8%80%E5%8D%8A%E8%A1%A8%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%8F%98---%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E7%A9%BA%E9%97%B4%E5%9B%9E%E6%94%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/5.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%88%A0%E6%8E%89%E4%B8%80%E5%8D%8A%E8%A1%A8%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%8F%98---%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E7%A9%BA%E9%97%B4%E5%9B%9E%E6%94%B6/</guid><description>一个 InnoDB 表包含两部分，即：表结构定义和数据
在 MySQL 8.0 版本以前，表结构是存在以.frm 为后缀的文件里。
而 MySQL 8.0 版本，则已经允许把表结构定义放在系统数据表中了。因为表结构定义占用的空间很小，
先和你说明为什么简单地删除表数据达不到表空间回收的效果，然后再和你介绍正确回收空间的方法。
参数 innodb_file_per_table 表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 innodb_file_per_table 控制的</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/7.-order-by-%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/7.-order-by-%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</guid><description>1 2 3 4 5 6 7 8 9 10 CREATE TABLE `t` ( `id` int(11) NOT NULL, `city` varchar(16) NOT NULL, `name` varchar(16) NOT NULL, `age` int(11) NOT NULL, `addr` varchar(128) DEFAULT NULL, PRIMARY KEY (`id`), KEY `city` (`city`) ) ENGINE=InnoDB; 1 2 select city,name,age from t where city=&amp;#39;杭州&amp;#39; order by name limit 1000 ; 全字段排序 为避免全表扫描，我们需要在 city 字段加上索引。</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/8.%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E6%98%BE%E7%A4%BA%E9%9A%8F%E6%9C%BA%E6%B6%88%E6%81%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/8.%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E6%98%BE%E7%A4%BA%E9%9A%8F%E6%9C%BA%E6%B6%88%E6%81%AF/</guid><description>英语学习 App 首页有一个随机显示单词的功能，也就是根据每个用户的级别有一个单词表，然后这个用户每次访问首页的时候，都会随机滚动显示三个单词。他们发现随着单词表变大，选单词这个逻辑变得越来越慢，甚至影响到了首页的打开速度。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 mysql&amp;gt; CREATE TABLE `words` ( `id` int(11) NOT NULL AUTO_INCREMENT, `word` varchar(64) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB; delimiter ;; create procedure idata() begin declare i int; set i=0; while i&amp;lt;10000 do insert into words(word) values(concat(char(97+(i div 1000)), char(97+(i % 1000 div 100)), char(97+(i % 100 div 10)), char(97+(i % 10)))); set i=i+1; end while; end;; delimiter ; call idata(); 接下来，我们就一起看看要随机选择 3 个单词，有什么方法实现，存在什么问题以及如何改进</description></item><item><title/><link>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/9.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%BA%9BSQL%E8%AF%AD%E5%8F%A5%E9%80%BB%E8%BE%91%E7%9B%B8%E5%90%8C%E6%80%A7%E8%83%BD%E5%8D%B4%E5%B7%AE%E5%BC%82%E5%B7%A8%E5%A4%A7%E6%A1%88%E4%BE%8B%E4%B8%80%E6%9D%A1%E4%BB%B6%E5%AD%97%E6%AE%B5%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/MySQL/%E5%AE%9E%E8%B7%B5/9.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%BA%9BSQL%E8%AF%AD%E5%8F%A5%E9%80%BB%E8%BE%91%E7%9B%B8%E5%90%8C%E6%80%A7%E8%83%BD%E5%8D%B4%E5%B7%AE%E5%BC%82%E5%B7%A8%E5%A4%A7%E6%A1%88%E4%BE%8B%E4%B8%80%E6%9D%A1%E4%BB%B6%E5%AD%97%E6%AE%B5%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C/</guid><description>案例一：条件字段函数操作 假设你现在维护了一个交易系统，其中交易记录表 tradelog 包含交易流水号（tradeid）、交易员 id（operator）、交易时间（t_modified）等字段。为了便于描述，我们先忽略其他字段。这个表的建表语句如下：
1 2 3 4 5 6 7 8 9 mysql&amp;gt; CREATE TABLE tradelog ( id int(11) NOT NULL, tradeid varchar(32) DEFAULT NULL, operator int(11) DEFAULT NULL, t_modified datetime DEFAULT NULL, PRIMARY KEY (id), KEY tradeid (tradeid), KEY t_modified (t_modified) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 现在已经记录了从 2016 年初到 2018 年底的所有数据，运营部门有一个需求是，要统计发生在所有年份中 7 月份的交易记录总数。</description></item></channel></rss>