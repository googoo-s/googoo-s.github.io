<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://googoo-s.github.io/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 31 Jul 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://googoo-s.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>dataview</title><link>https://googoo-s.github.io/Obsidian/dataview/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/dataview/</guid><description>官方地址 代码仓库 文档地址 其他教程 Obsidian DataView 入门保姆级引导手册 元数据 元数据是一系列的键值对,可以给笔记，可以给note,list item ,task 添加元数据
如何添加元数据 Frontmatter frontmatter 是markdown的一种扩展，可以使用yaml 来添加元数据 1 2 3 4 5 6 7 --- alias: &amp;#34;document&amp;#34; last-reviewed: 2021-08-17 thoughts: rating: 8 reviewable: false --- inline fields 使用方法为在文件的任意位置添加 1 2 3 4 Basic Field:: Some random Value **Bold Field**:: Nice!</description></item><item><title>excalidraw</title><link>https://googoo-s.github.io/Obsidian/excalidraw/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/excalidraw/</guid><description> 代码仓库 note 中插入excalidraw 语法 1 ![[excalidraw]]</description></item><item><title>Front Matter</title><link>https://googoo-s.github.io/Obsidian/Front-Matter/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/Front-Matter/</guid><description>使用 Front Matter 可以保存 note 待元数据，推荐使用 Hugo 的配置 Front matter | Hugo (gohugo.io)</description></item><item><title>lua基础</title><link>https://googoo-s.github.io/lua/lua%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/lua/lua%E5%9F%BA%E7%A1%80/</guid><description>Lua 简介 Lua 是一个小巧的脚本语言。是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组并于 1993 年开发。其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。Lua 由标准 C 编写而成，几乎在所有操作系统和平台上都可以编译、运行。Lua 并没有提供强大的库，这是由它的定位决定的。所以 Lua 不适合作为开发独立应用程序的语言。Lua 有一个同时进行的 JIT 项目，提供在特定平台上的即时编译功能。</description></item><item><title>Lua高级</title><link>https://googoo-s.github.io/lua/Lua%E9%AB%98%E7%BA%A7/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/lua/Lua%E9%AB%98%E7%BA%A7/</guid><description>元表 元表 (metatable) 的表现行为类似于 C++ 语言中的操作符重载，例如我们可以重载 &amp;ldquo;__add&amp;rdquo; 元方法 (metamethod)，来计算两个 Lua 数组的并集；或者重载 &amp;ldquo;__index&amp;rdquo; 方法，来定义我们自己的 Hash 函数。Lua 提供了两个十分重要的用来处理元表的方法
setmetatable(table, metatable)：此方法用于为一个表设置元表。</description></item><item><title>obsidian overview</title><link>https://googoo-s.github.io/Obsidian/obsidian-overview/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/obsidian-overview/</guid><description>主页内容 obsidian 相关内容，包括插件
结构</description></item><item><title>Obsidian-plugin</title><link>https://googoo-s.github.io/Obsidian/Obsidian-plugin/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/Obsidian-plugin/</guid><description> advanced-table banners calendar commander dataview emoji-shortcodes emoji-toolbar excel-to-markdown-table homepage hover-editor icon-folder) icons image-toolkit minimal-settings obsidian-git recent-files settings-search style-settings tag-wrangler excalidraw</description></item><item><title>publish</title><link>https://googoo-s.github.io/Obsidian/publish/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/publish/</guid><description>obsidian 目前最完美的免费发布方案 渐进式教程 by oldwinter</description></item><item><title>template</title><link>https://googoo-s.github.io/Obsidian/template/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/template/</guid><description> * 模板的使用方法 默认存放的文件夹 /template</description></item><item><title/><link>https://googoo-s.github.io/Dobbo/Dubbo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Dobbo/Dubbo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</guid><description>这篇文章是我根据官方文档以及自己平时的使用情况，对 Dubbo 所做的一个总结。欢迎补充！
# Dubbo 基础 # 什么是 Dubbo? Dubbo 官网
Apache Dubboopen in new window |ˈdʌbəʊ| 是一款高性能、轻量级的开源 WEB 和 RPC 框架。</description></item><item><title/><link>https://googoo-s.github.io/elastic/KQL/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/elastic/KQL/</guid><description>Kibana Query Language
https://juejin.cn/post/7003201901382598686
https://www.elastic.co/guide/en/kibana/7.14/kuery-query.html#kuery-query</description></item><item><title/><link>https://googoo-s.github.io/netty/BootStrap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/netty/BootStrap/</guid><description>简单来说，引导一个应用程序是指对它进行配置，并使它运行起来的过程—尽管该过程的具体细节可能并不如它的定义那样简单，尤其是对于一个网络应用程序来说
Netty处理引导的方式使你的应用程序和网络层相隔离，无论它是客户端还是服务器
BootStrap类 引导类的层次结构包括一个抽象的父类和两个具体的引导子类
相对于将具体的引导类分别看作用于服务器和客户端的引导来说，记住它们的本意是用来支撑不同的应用程序的功能的将有所裨益。
服务器致力于使用一个父 Channel 来接受来自客户端的连接，并创建子 Channel 以用于它们之间的通信
而客户端将最可能只需要一个单独的、没有父 Channel 的 Channel 来用于所有的网络交互</description></item><item><title/><link>https://googoo-s.github.io/netty/ByteBuf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/netty/ByteBuf/</guid><description>网络数据的基本单位总是字节。Java NIO 提供了 ByteBuffer 作为它的字节容器，但是这个类使用起来过于复杂，而且也有些繁琐。
Netty 的 ByteBuffer 替代品是 ByteBuf，一个强大的实现，既解决了 JDK API 的局限性，又为网络应用程序的开发者提供了更好的 API。
ByteBuf 的优点 Netty 的数据处理 API 通过两个组件暴露——abstract class ByteBuf 和 interface ByteBufHolder。</description></item><item><title/><link>https://googoo-s.github.io/netty/ChannelHandlerChannelPipelineChannelContext/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/netty/ChannelHandlerChannelPipelineChannelContext/</guid><description>当我们在本章中探讨 Netty 的数据流以及处理组件
在 ChannelPipeline 中将 ChannelHandler 链接在一起以组织处理逻辑。我们将会研究涉及这些类的各种用例，以及一个重要的关系—ChannelHandlerContext
ChannelHandler Channel 的生命周期 ChannelHandler的生命周期
Netty定义了两个重要的ChannelHandler
 ChannelInboundHandler——处理入站数据以及各种状态变化；</description></item><item><title/><link>https://googoo-s.github.io/netty/EventLoop-%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/netty/EventLoop-%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</guid><description>常见的线程模型 基本的线程池化模式
从池的空闲线程列表中选择一个 Thread，并且指派它去运行一个已提交的任务（一个 Runnable 的实现）；
当任务完成时，将该 Thread 返回给该列表，使其可被重用
虽然池化和重用线程相对于简单地为每个任务都创建和销毁线程是一种进步，但是它并不能消除由上下文切换所带来的开销
EventLoop 运行任务来处理在连接的生命周期内发生的事件是任何网络框架的基本功能。与之相应的编程上的构造通常被称为事件循环—一个 Netty 使用了 interface io.</description></item><item><title/><link>https://googoo-s.github.io/netty/%E4%BC%A0%E8%BE%93%E5%92%8CChannel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/netty/%E4%BC%A0%E8%BE%93%E5%92%8CChannel/</guid><description>在某些时候，你需要支撑比预期多很多的并发连接。如果你随后尝试从阻塞传输切换到非阻塞传输，那么你可能会因为这两种网络 API 的截然不同而遇到问题。
Netty 为它所有的传输实现提供了一个通用 API，这使得这种转换比你直接使用 JDK 所能够达到的简单得多。
传输方式 OIO
NIO
AIO
Channel 传输 API 的核心是 interface Channel，它被用于所有的 I/O 操作</description></item><item><title/><link>https://googoo-s.github.io/netty/%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/netty/%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</guid><description>IO 模型 IO模型详解
Java 网络编程 最早期的 Java API（java.net）只支持由本地系统套接字库提供的所谓的阻塞函数
1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 创建一个新的 ServerSocket，用以 监听指定端口上的连接请求 ServerSocket serverSocket = new ServerSocket(portNumber); // 对accept 阻塞，知道创建一个 Socket clientSocket = serverSocket.</description></item><item><title/><link>https://googoo-s.github.io/netty/%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/netty/%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/</guid><description>每个网络应用程序都必须定义如何解析在
两个节点之间来回传输的原始字节
其和 目标应用程序的数据格式做相互转换
编码器是将消息转换为适合于传输的格式（最有可能的就是字节流）；
而对应的解码器则是将网络字节流转换回应用程序的消息格式
解码器 因为解码器是负责将入站数据从一种格式转换到另一种格式的，所以知道 Netty 的解码器实现了 ChannelInboundHandler 也不会让你感到意外。</description></item><item><title/><link>https://googoo-s.github.io/spring/spring-framework/spring-%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/spring/spring-framework/spring-%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description>“JDK 中用到了哪些设计模式? Spring 中用到了哪些设计模式? ”这两个问题，在面试中比较常见。
我在网上搜索了一下关于 Spring 中设计模式的讲解几乎都是千篇一律，而且大部分都年代久远。所以，花了几天时间自己总结了一下。
由于我的个人能力有限，文中如有任何错误各位都可以指出。另外，文章篇幅有限，对于设计模式以及一些源码的解读我只是一笔带过，这篇文章的主要目的是回顾一下 Spring 中的设计模式。
# 控制反转(IoC)和依赖注入(DI) IoC(Inversion of Control,控制反转) 是 Spring 中一个非常非常重要的概念，它不是什么技术，而是一种解耦的设计思想。IoC 的主要目的是借助于“第三方”(Spring 中的 IoC 容器) 实现具有依赖关系的对象之间的解耦(IOC 容器管理对象，你只管使用即可)，从而降低代码之间的耦合度。</description></item><item><title/><link>https://googoo-s.github.io/spring/spring-MVC/J2EE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/spring/spring-MVC/J2EE/</guid><description>Servlet 总结 在 Java Web 程序中，Servlet主要负责接收用户请求 HttpServletRequest,在 doGet(), doPost() 中做相应的处理，并将回应 HttpServletResponse 反馈给用户。Servlet 可以设置初始化参数，供 Servlet 内部使用。一个 Servlet 类只会有一个实例，在它初始化时调用 init() 方法，销毁时调用 destroy() 方法**。**Servlet 需要在 web.</description></item><item><title/><link>https://googoo-s.github.io/statistic/%E5%BA%94%E7%94%A8%E5%B1%82.png/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/statistic/%E5%BA%94%E7%94%A8%E5%B1%82.png/</guid><description/></item><item><title/><link>https://googoo-s.github.io/statistic/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82.png/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/statistic/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82.png/</guid><description/></item><item><title/><link>https://googoo-s.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AE%BE%E8%AE%A1/%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AE%BE%E8%AE%A1/%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95%E8%AF%A6%E8%A7%A3/</guid><description>由于网络问题、系统或者服务内部的 Bug、服务器宕机、操作系统崩溃等问题的不确定性，我们的系统或者服务永远不可能保证时刻都是可用的状态。
为了最大限度的减小系统或者服务出现故障之后带来的影响，我们需要用到的 超时（Timeout） 和 重试（Retry） 机制。
想要把超时和重试机制讲清楚其实很简单，因为它俩本身就不是什么高深的概念。
虽然超时和重试机制的思想很简单，但是它俩是真的非常实用。你平时接触到的绝大部分涉及到远程调用的系统或者服务都会应用超时和重试机制。尤其是对于微服务系统来说，正确设置超时和重试非常重要。单体服务通常只涉及数据库、缓存、第三方 API、中间件等的网络调用，而微服务系统内部各个服务之间还存在着网络调用。
# 超时机制 # 什么是超时机制？ 超时机制说的是当一个请求超过指定的时间（比如 1s）还没有被处理的话，这个请求就会直接被取消并抛出指定的异常或者错误（比如 504 Gateway Timeout）。
我们平时接触到的超时可以简单分为下面 2 种：</description></item><item><title/><link>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/Untitled/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/Untitled/</guid><description>Kafka 是什么？主要应用场景有哪些？ Kafka 是一个分布式流式处理平台。这到底是什么意思呢？
流平台具有三个关键功能：
消息队列：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。 容错的持久方式存储记录消息流：Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。 流式处理平台： 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。 Kafka 主要有两大应用场景：
消息队列：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。 数据处理： 构建实时的流数据处理程序来转换或处理数据流。 # 和其他消息队列相比,Kafka 的优势在哪里？ 我们现在经常提到 Kafka 的时候就已经默认它是一个非常优秀的消息队列了，我们也会经常拿它跟 RocketMQ、RabbitMQ 对比。我觉得 Kafka 相比其他消息队列主要的优势如下：</description></item><item><title/><link>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/RocketMQ%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/RocketMQ%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</guid><description>消息队列扫盲 消息队列顾名思义就是存放消息的队列，队列我就不解释了，别告诉我你连队列都不知道是啥吧？
所以问题并不是消息队列是什么，而是 消息队列为什么会出现？消息队列能用来干什么？用它来干这些事会带来什么好处？消息队列会带来副作用吗？
# 消息队列为什么会出现？ 消息队列算是作为后端程序员的一个必备技能吧，因为分布式应用必定涉及到各个系统之间的通信问题，这个时候消息队列也应运而生了。可以说分布式的产生是消息队列的基础，而分布式怕是一个很古老的概念了吧，所以消息队列也是一个很古老的中间件了。
# 消息队列能用来干什么？ # 异步 你可能会反驳我，应用之间的通信又不是只能由消息队列解决，好好的通信为什么中间非要插一个消息队列呢？我不能直接进行通信吗？
很好 👍，你又提出了一个概念，同步通信。就比如现在业界使用比较多的 Dubbo 就是一个适用于各个系统之间同步通信的 RPC 框架。
我来举个 🌰 吧，比如我们有一个购票系统，需求是用户在购买完之后能接收到购买完成的短信。</description></item><item><title/><link>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/JWT-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/JWT-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3/</guid><description>什么是 JWT? JWT （JSON Web Token） 是目前最流行的跨域认证解决方案，是一种基于 Token 的认证授权机制。 从 JWT 的全称可以看出，JWT 本身也是 Token，一种规范化之后的 JSON 结构的 Token。
JWT 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 Session 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。</description></item><item><title/><link>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/JWT-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/JWT-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90/</guid><description>在 JWT 基本概念详解open in new window 这篇文章中，我介绍了：
什么是 JWT? JWT 由哪些部分组成？ 如何基于 JWT 进行身份验证？ JWT 如何防止 Token 被篡改？ 如何加强 JWT 的安全性？ 这篇文章，我们一起探讨一下 JWT 身份认证的优缺点以及常见问题的解决办法。</description></item><item><title/><link>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/SSO-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/SSO-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E8%AF%A6%E8%A7%A3/</guid><description>SO 介绍 # 什么是 SSO？ SSO 英文全称 Single Sign On，单点登录。SSO 是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。
例如你登录网易账号中心（https://reg.163.com/ ）之后访问以下站点都是登录状态。
网易直播 https://v.163.comopen in new window 网易博客 https://blog.</description></item><item><title/><link>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid><description>加密算法是一种用数学方法对数据进行变换的技术，目的是保护数据的安全，防止被未经授权的人读取或修改。加密算法可以分为三大类：对称加密算法、非对称加密算法和哈希算法（也叫摘要算法）。
日常开发中常见的需要用到的加密算法的场景：
保存在数据库中的密码需要加盐之后使用哈希算法（比如 BCrypt）进行加密。 保存在数据库中的银行卡号、身份号这类敏感数据需要使用对称加密算法（比如 AES）保存。 网络传输的敏感数据比如银行卡号、身份号需要用 HTTPS + 非对称加密算法（如 RSA）来保证传输数据的安全性。 &amp;hellip;&amp;hellip; # 哈希算法 哈希算法也叫哈希函数、散列函数或摘要算法，它的作用是对任意长度的数据生成一个固定长度的唯一标识，也叫哈希值、散列值或消息摘要（后文统称为哈希值）。
哈希算法效果演示
哈希值的作用是可以用来验证数据的完整性和一致性。</description></item><item><title/><link>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/</guid><description>系统需要对用户输入的文本进行敏感词过滤如色情、政治、暴力相关的词汇。
敏感词过滤用的使用比较多的 Trie 树算法 和 DFA 算法。
# 算法实现 # Trie 树 Trie 树 也称为字典树、单词查找树，哈系树的一种变种，通常被用于字符串匹配，用来解决在一组字符串集合中快速查找某个字符串的问题。像浏览器搜索的关键词提示一般就是基于 Trie 树来做的。
浏览器 Trie 树效果展示</description></item><item><title/><link>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/</guid><description>数据脱敏说的就是我们根据特定的规则对敏感信息数据进行变形，比如我们把手机号、身份证号某些位数使用 * 来代替。</description></item><item><title/><link>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%AF%A6%E8%A7%A3/</guid><description>老权限系统的问题与现状 转转公司在过去并没有一个统一的权限管理系统，权限管理由各业务自行研发或是使用其他业务的权限系统，权限管理的不统一带来了不少问题：
各业务重复造轮子，维护成本高 各系统只解决部分场景问题，方案不够通用，新项目选型时没有可靠的权限管理方案 缺乏统一的日志管理与审批流程，在授权信息追溯上十分困难 基于上述问题，去年底公司启动建设转转统一权限系统，目标是开发一套灵活、易用、安全的权限管理系统，供各业务使用。
# 业界权限系统的设计方式 目前业界主流的权限模型有两种，下面分别介绍下：
基于角色的访问控制（RBAC） 基于属性的访问控制（ABAC） # RBAC 模型 基于角色的访问控制（Role-Based Access Control，简称 RBAC） 指的是通过用户的角色（Role）授权其相关权限，实现了灵活的访问控制，相比直接授予用户权限，要更加简单、高效、可扩展。</description></item><item><title/><link>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3/</guid><description>认证 (Authentication) 和授权 (Authorization)的区别是什么？ 这是一个绝大多数人都会混淆的问题。首先先从读音上来认识这两个名词，很多人都会把它俩的读音搞混，所以我建议你先先去查一查这两个单词到底该怎么读，他们的具体含义是什么。
说简单点就是：
认证 (Authentication)： 你是谁。 授权 (Authorization)： 你有权限干什么。 稍微正式点（啰嗦点）的说法就是：
Authentication（认证） 是验证您的身份的凭据（例如用户名/用户 ID 和密码），通过这个凭据，系统得以知道你就是你，也就是说系统存在你这个用户。所以，Authentication 被称为身份/用户验证。 Authorization（授权） 发生在 Authentication（认证） 之后。授权嘛，光看意思大家应该就明白，它主要掌管我们访问系统的权限。比如有些特定资源只能具有特定权限的人才能访问比如 admin，有些对系统资源操作比如删除、添加、更新只能特定人才具有。 认证：</description></item><item><title/><link>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/Java-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/Java-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%AF%A6%E8%A7%A3/</guid><description>为什么需要定时任务？ 我们来看一下几个非常常见的业务场景：
某系统凌晨要进行数据备份。 某电商平台，用户下单半个小时未支付的情况下需要自动取消订单。 某媒体聚合平台，每 10 分钟动态抓取某某网站的数据为自己所用。 某博客平台，支持定时发送文章。 某基金平台，每晚定时计算用户当日收益情况并推送给用户最新的数据。 &amp;hellip;&amp;hellip; 这些场景往往都要求我们在某个特定的时间去做某个事情。
# 单机定时任务技术选型 # Timer java.util.Timer是 JDK 1.3 开始就已经支持的一种定时任务的实现方式。</description></item><item><title/><link>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5/Web-%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5/Web-%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E8%AF%A6%E8%A7%A3/</guid><description>原文地址： https://juejin.cn/post/7122014462181113887，JavaGuideopen in new window 对本文进行了完善总结。
我有一个朋友做了一个小破站，现在要实现一个站内信 Web 消息推送的功能，对，就是下图这个小红点，一个很常用的功能。
站内信 Web 消息推送
不过他还没想好用什么方式做，这里我帮他整理了一下几种方案，并简单做了实现。
# 什么是消息推送？ 推送的场景比较多，比如有人关注我的公众号，这时我就会收到一条推送消息，以此来吸引我点击打开应用。
消息推送通常是指网站的运营工作等人员，通过某种工具对用户当前网页或移动设备 APP 进行的主动消息推送。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/HTTP/7-HTTP3-%E5%BC%BA%E5%8A%BF%E6%9D%A5%E8%A2%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/HTTP/7-HTTP3-%E5%BC%BA%E5%8A%BF%E6%9D%A5%E8%A2%AD/</guid><description>HTTP/3 现在（2022 年 5 月）还没正式推出，不过自 2017 年起，HTTP/3 已经更新到 34 个草案了，基本的特性已经确定下来了，对于包格式可能后续会有变化。
所以，这次 HTTP/3 介绍不会涉及到包格式，只说它的特性。
美中不足的 HTTP/2 HTTP/2 通过头部压缩、二进制编码、多路复用、服务器推送等新特性大幅度提升了 HTTP/1.1 的性能，而美中不足的是 HTTP/2 协议是基于 TCP 实现的，于是存在的缺陷有三个。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/HTTP/9-%E6%97%A2%E7%84%B6%E6%9C%89-HTTP-%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89-WebSocket/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/HTTP/9-%E6%97%A2%E7%84%B6%E6%9C%89-HTTP-%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89-WebSocket/</guid><description>来源：公众号@小白debug
原文地址： 既然有 HTTP 协议，为什么还要有 WebSocket？
平时我们打开网页，比如购物网站某宝。都是点一下「列表商品」，跳转一下网页就到了「商品详情」。
从 HTTP 协议的角度来看，就是点一下网页上的某个按钮，前端发一次 HTTP 请求，网站返回一次 HTTP 响应。这种由客户端主动请求，服务器响应的方式也满足大部分网页的功能场景。
但有没有发现，这种情况下，服务器从来就「不会主动」给客户端发一次消息。就像你喜欢的女生从来不会主动找你一样。
但如果现在，你在刷网页的时候「右下角」突然弹出一个小广告，提示你【一个人在家偷偷才能玩哦】。
求知，好学，勤奋，这些刻在你 DNA 里的东西都动起来了。</description></item><item><title>Git 核心概念总结</title><link>https://googoo-s.github.io/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/git/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/git/</guid><description>版本控制 什么是版本控制 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。除了项目源代码，你可以对任何类型的文件进行版本控制。
为什么要版本控制 有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。
本地版本控制系统 许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单，但是特别容易犯错。有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。
为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。
集中化的版本控制系统 接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。
集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。
这么做虽然解决了本地版本控制系统无法让在不同系统上的开发者协同工作的诟病，但也还是存在下面的问题：
单点故障： 中央服务器宕机，则其他人无法使用；如果中心数据库磁盘损坏又没有进行备份，你将丢失所有数据。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。 必须联网才能工作： 受网络状况、带宽影响。 分布式版本控制系统 于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 Git 就是一个典型的分布式版本控制系统。</description></item></channel></rss>