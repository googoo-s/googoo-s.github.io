<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://googoo-s.github.io/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 31 Jul 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://googoo-s.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>dataview</title><link>https://googoo-s.github.io/Obsidian/dataview/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/dataview/</guid><description>官方地址 代码仓库 文档地址 其他教程 Obsidian DataView 入门保姆级引导手册 元数据 元数据是一系列的键值对,可以给笔记，可以给note,list item ,task 添加元数据
如何添加元数据 Frontmatter frontmatter 是markdown的一种扩展，可以使用yaml 来添加元数据 1 2 3 4 5 6 7 --- alias: &amp;#34;document&amp;#34; last-reviewed: 2021-08-17 thoughts: rating: 8 reviewable: false --- inline fields 使用方法为在文件的任意位置添加 1 2 3 4 Basic Field:: Some random Value **Bold Field**:: Nice!</description></item><item><title>excalidraw</title><link>https://googoo-s.github.io/Obsidian/excalidraw/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/excalidraw/</guid><description> 代码仓库 note 中插入excalidraw 语法 1 ![[excalidraw]]</description></item><item><title>Front Matter</title><link>https://googoo-s.github.io/Obsidian/Front-Matter/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/Front-Matter/</guid><description>使用 Front Matter 可以保存 note 待元数据，推荐使用 Hugo 的配置 Front matter | Hugo (gohugo.io)</description></item><item><title>lua基础</title><link>https://googoo-s.github.io/lua/lua%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/lua/lua%E5%9F%BA%E7%A1%80/</guid><description>Lua 简介 Lua 是一个小巧的脚本语言。是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组并于 1993 年开发。其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。Lua 由标准 C 编写而成，几乎在所有操作系统和平台上都可以编译、运行。Lua 并没有提供强大的库，这是由它的定位决定的。所以 Lua 不适合作为开发独立应用程序的语言。Lua 有一个同时进行的 JIT 项目，提供在特定平台上的即时编译功能。</description></item><item><title>Lua高级</title><link>https://googoo-s.github.io/lua/Lua%E9%AB%98%E7%BA%A7/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/lua/Lua%E9%AB%98%E7%BA%A7/</guid><description>元表 元表 (metatable) 的表现行为类似于 C++ 语言中的操作符重载，例如我们可以重载 &amp;ldquo;__add&amp;rdquo; 元方法 (metamethod)，来计算两个 Lua 数组的并集；或者重载 &amp;ldquo;__index&amp;rdquo; 方法，来定义我们自己的 Hash 函数。Lua 提供了两个十分重要的用来处理元表的方法
setmetatable(table, metatable)：此方法用于为一个表设置元表。</description></item><item><title>obsidian overview</title><link>https://googoo-s.github.io/Obsidian/obsidian-overview/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/obsidian-overview/</guid><description>主页内容 obsidian 相关内容，包括插件
结构</description></item><item><title>Obsidian-plugin</title><link>https://googoo-s.github.io/Obsidian/Obsidian-plugin/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/Obsidian-plugin/</guid><description> advanced-table banners calendar commander dataview emoji-shortcodes emoji-toolbar excel-to-markdown-table homepage hover-editor icon-folder) icons image-toolkit minimal-settings obsidian-git recent-files settings-search style-settings tag-wrangler excalidraw</description></item><item><title>publish</title><link>https://googoo-s.github.io/Obsidian/publish/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/publish/</guid><description>obsidian 目前最完美的免费发布方案 渐进式教程 by oldwinter</description></item><item><title>template</title><link>https://googoo-s.github.io/Obsidian/template/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/template/</guid><description> * 模板的使用方法 默认存放的文件夹 /template</description></item><item><title/><link>https://googoo-s.github.io/awesome/JavaGuide-%E7%9F%A5%E8%AF%86%E6%98%9F%E7%90%83%E4%BC%98%E8%B4%A8%E4%B8%BB%E9%A2%98%E6%B1%87%E6%80%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/awesome/JavaGuide-%E7%9F%A5%E8%AF%86%E6%98%9F%E7%90%83%E4%BC%98%E8%B4%A8%E4%B8%BB%E9%A2%98%E6%B1%87%E6%80%BB/</guid><description>为了避免这里成为知识杂货铺，我会对严格筛选入选的优质主题。
更新日期：2023-06-11
面试
● Java面试常见问题总结（2023最新版）
● 一位 HR 分享的求职建议
● 面试和简历上的一些大忌
●项目：
○ 如何回答项目遇到什么困难，如何解决这类问题
○ 项目太简单怎么办?
○ 商城项目到底能不能做？
安抚心态
如果你陷入精神内耗或者自我怀疑，不然看看下面这些内容：</description></item><item><title/><link>https://googoo-s.github.io/elastic/KQL/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/elastic/KQL/</guid><description>Kibana Query Language
https://juejin.cn/post/7003201901382598686
https://www.elastic.co/guide/en/kibana/7.14/kuery-query.html#kuery-query</description></item><item><title/><link>https://googoo-s.github.io/lua/%E7%94%A8Go%E5%AE%9E%E7%8E%B0Lua/1.%E4%BA%8C%E8%BF%9B%E5%88%B6Chunk/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/lua/%E7%94%A8Go%E5%AE%9E%E7%8E%B0Lua/1.%E4%BA%8C%E8%BF%9B%E5%88%B6Chunk/</guid><description>什么是二进制 chunk Lua 脚本并.不是直接被 Lua 解释器解释执行，而是类似 Java 语言那样，先由 Lua 编译器编译为字节码，然后再交给 Lua 虚拟机去执行
Lua 字节码需要一个载体，这个载体就是二进制 chunk，对 Java 虚拟机比较熟悉的读者可以把二进制 chunk 看作 Lua 版的 class 文件</description></item><item><title/><link>https://googoo-s.github.io/lua/%E7%94%A8Go%E5%AE%9E%E7%8E%B0Lua/2.%E6%8C%87%E4%BB%A4%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/lua/%E7%94%A8Go%E5%AE%9E%E7%8E%B0Lua/2.%E6%8C%87%E4%BB%A4%E9%9B%86/</guid><description>指令集介绍 按照实现方式，虚拟机大致可以分为两类：
基于栈（Stack Based）。 Java 虚拟机、. NET CLR、Python 虚拟机，以及在第 2 章中提到过的 Ruby YARV 虚拟机都是基于栈的虚拟机； 基于寄存器（Register Based）。 以及本书讨论的 Lua 虚拟机则是基于寄存器的虚拟机 如同真实机器有一套指令集（Instruction Set）一样，虚拟机也有自己的指令集：</description></item><item><title/><link>https://googoo-s.github.io/lua/%E7%94%A8Go%E5%AE%9E%E7%8E%B0Lua/3.lua-API/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/lua/%E7%94%A8Go%E5%AE%9E%E7%8E%B0Lua/3.lua-API/</guid><description>Lua 核心是以库（Library）的形式被实现的，其他应用程序只需要链接 Lua 库就可以使用 Lua 提供的 API 轻松获得脚本执行能力
Lua 发布版包含的两个命令行程序，也就是我们已经很熟悉的 lua 和 luac，实际上就是 Lua 库的两个特殊的宿主程序。
Lua API 介绍 官方 Lua 使用 Clean C（其语法是 C 和 C++语言的子集）编写，Lua API 主要是指一系列以“lua_”开头的 C 语言函数（也可能是宏定义，后文统称为函数）。</description></item><item><title/><link>https://googoo-s.github.io/lua/%E7%94%A8Go%E5%AE%9E%E7%8E%B0Lua/%E5%89%8D%E8%A8%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/lua/%E7%94%A8Go%E5%AE%9E%E7%8E%B0Lua/%E5%89%8D%E8%A8%80/</guid><description>参考资料 * 自己动手实现Lua:虚拟机、编译器和标准库 《Programming in Lua, Fourth Edition》 《Lua 5.3 Reference Manual》 《The Evolution of Lua》 《The Implementation of Lua 5.</description></item><item><title/><link>https://googoo-s.github.io/netty/1.-%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/netty/1.-%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</guid><description>IO 模型 IO模型详解
Java 网络编程 最早期的 Java API（java.net）只支持由本地系统套接字库提供的所谓的阻塞函数
1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 创建一个新的 ServerSocket，用以 监听指定端口上的连接请求 ServerSocket serverSocket = new ServerSocket(portNumber); // 对accept 阻塞，知道创建一个 Socket clientSocket = serverSocket.</description></item><item><title/><link>https://googoo-s.github.io/netty/BootStrap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/netty/BootStrap/</guid><description>简单来说，引导一个应用程序是指对它进行配置，并使它运行起来的过程—尽管该过程的具体细节可能并不如它的定义那样简单，尤其是对于一个网络应用程序来说
Netty处理引导的方式使你的应用程序和网络层相隔离，无论它是客户端还是服务器
BootStrap类 引导类的层次结构包括一个抽象的父类和两个具体的引导子类
相对于将具体的引导类分别看作用于服务器和客户端的引导来说，记住它们的本意是用来支撑不同的应用程序的功能的将有所裨益。
服务器致力于使用一个父 Channel 来接受来自客户端的连接，并创建子 Channel 以用于它们之间的通信
而客户端将最可能只需要一个单独的、没有父 Channel 的 Channel 来用于所有的网络交互</description></item><item><title/><link>https://googoo-s.github.io/netty/ByteBuf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/netty/ByteBuf/</guid><description>网络数据的基本单位总是字节。Java NIO 提供了 ByteBuffer 作为它的字节容器，但是这个类使用起来过于复杂，而且也有些繁琐。
Netty 的 ByteBuffer 替代品是 ByteBuf，一个强大的实现，既解决了 JDK API 的局限性，又为网络应用程序的开发者提供了更好的 API。
ByteBuf 的优点 Netty 的数据处理 API 通过两个组件暴露——abstract class ByteBuf 和 interface ByteBufHolder。</description></item><item><title/><link>https://googoo-s.github.io/netty/ChannelHandlerChannelPipelineChannelContext/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/netty/ChannelHandlerChannelPipelineChannelContext/</guid><description>当我们在本章中探讨 Netty 的数据流以及处理组件
在 ChannelPipeline 中将 ChannelHandler 链接在一起以组织处理逻辑。我们将会研究涉及这些类的各种用例，以及一个重要的关系—ChannelHandlerContext
ChannelHandler Channel 的生命周期 ChannelHandler的生命周期
Netty定义了两个重要的ChannelHandler
 ChannelInboundHandler——处理入站数据以及各种状态变化；</description></item><item><title/><link>https://googoo-s.github.io/netty/EventLoop-%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/netty/EventLoop-%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</guid><description>常见的线程模型 基本的线程池化模式
从池的空闲线程列表中选择一个 Thread，并且指派它去运行一个已提交的任务（一个 Runnable 的实现）；
当任务完成时，将该 Thread 返回给该列表，使其可被重用
虽然池化和重用线程相对于简单地为每个任务都创建和销毁线程是一种进步，但是它并不能消除由上下文切换所带来的开销
EventLoop 运行任务来处理在连接的生命周期内发生的事件是任何网络框架的基本功能。与之相应的编程上的构造通常被称为事件循环—一个 Netty 使用了 interface io.</description></item><item><title/><link>https://googoo-s.github.io/netty/%E4%BC%A0%E8%BE%93%E5%92%8CChannel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/netty/%E4%BC%A0%E8%BE%93%E5%92%8CChannel/</guid><description>在某些时候，你需要支撑比预期多很多的并发连接。如果你随后尝试从阻塞传输切换到非阻塞传输，那么你可能会因为这两种网络 API 的截然不同而遇到问题。
Netty 为它所有的传输实现提供了一个通用 API，这使得这种转换比你直接使用 JDK 所能够达到的简单得多。
传输方式 OIO
NIO
AIO
Channel 传输 API 的核心是 interface Channel，它被用于所有的 I/O 操作</description></item><item><title/><link>https://googoo-s.github.io/netty/%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/netty/%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/</guid><description>每个网络应用程序都必须定义如何解析在
两个节点之间来回传输的原始字节
其和目标应用程序的数据格式做相互转换
编码器是将消息转换为适合于传输的格式（最有可能的就是字节流）；
而对应的解码器则是将网络字节流转换回应用程序的消息格式
解码器 因为解码器是负责将入站数据从一种格式转换到另一种格式的，所以知道 Netty 的解码器实现了 ChannelInboundHandler 也不会让你感到意外。</description></item><item><title/><link>https://googoo-s.github.io/Obsidian/%E4%BD%BF%E7%94%A8quartz%E5%8F%91%E5%B8%83obsidian-vault/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/%E4%BD%BF%E7%94%A8quartz%E5%8F%91%E5%B8%83obsidian-vault/</guid><description/></item><item><title/><link>https://googoo-s.github.io/spring/Spring-cloud/spring-cloud-alibaba/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/spring/Spring-cloud/spring-cloud-alibaba/</guid><description> 官网 spring cloud alibaba</description></item><item><title/><link>https://googoo-s.github.io/statistic/%E5%BA%94%E7%94%A8%E5%B1%82.png/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/statistic/%E5%BA%94%E7%94%A8%E5%B1%82.png/</guid><description/></item><item><title/><link>https://googoo-s.github.io/statistic/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82.png/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/statistic/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82.png/</guid><description/></item><item><title/><link>https://googoo-s.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%8F%AF%E7%94%A8/%E6%97%A5%E5%BF%97/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8B%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%8F%AF%E7%94%A8/%E6%97%A5%E5%BF%97/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8B%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/</guid><description/></item><item><title/><link>https://googoo-s.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%8F%AF%E7%94%A8/%E7%9B%91%E6%8E%A7/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%81%9A/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%8F%AF%E7%94%A8/%E7%9B%91%E6%8E%A7/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%81%9A/</guid><description/></item><item><title/><link>https://googoo-s.github.io/%E5%B7%A5%E5%85%B7%E5%92%8C%E7%8E%AF%E5%A2%83/emacs/%E5%AE%89%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E5%B7%A5%E5%85%B7%E5%92%8C%E7%8E%AF%E5%A2%83/emacs/%E5%AE%89%E8%A3%85/</guid><description>https://github.com/kiennq/emacs-build
添加到菜单栏 需要打开 server-mode 1 (server-mode 1) 新建文件 emacs.reg 注意修改路径
1 2 3 4 5 6 7 8 9 10 11 Windows Registry Editor Version 5.</description></item><item><title/><link>https://googoo-s.github.io/%E5%B7%A5%E5%85%B7%E5%92%8C%E7%8E%AF%E5%A2%83/emacs/%E5%BF%AB%E6%8D%B7%E9%94%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E5%B7%A5%E5%85%B7%E5%92%8C%E7%8E%AF%E5%A2%83/emacs/%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid><description>Emacs 这个东东听说功能很强大。不过感觉有些难学，还好网络上的资源还是比较丰富的。目前基于最基本的文本编辑来学习。而且它的快捷键很多，所以要在使用过程中学习会比较容易记住。这个是从网上搜索来的，总结的比较好的，贴在自己这里当做摘录了，方便查询。
C = Control
M = Meta = Alt S = Super = APPs Del = Backspace
RET = Enter</description></item><item><title/><link>https://googoo-s.github.io/%E5%B7%A5%E5%85%B7%E5%92%8C%E7%8E%AF%E5%A2%83/msys2/pacman/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E5%B7%A5%E5%85%B7%E5%92%8C%E7%8E%AF%E5%A2%83/msys2/pacman/</guid><description>安装软件 pacman -S (软件名)：安装软件，若有多个软件包，空格分隔 pacman -S --needed （软件名）：安装软件，若存在，不重新安装最新的软件 pacman -Sy (软件名)：安装软件前，先从远程仓库下载软件包数据库 pacman -Sv (软件名)：输出操作信息后安装 pacman -Sw (软件名)：只下载软件包，而不安装 pacman -U (软件名.</description></item><item><title/><link>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pulsar/1.Pulsar%E6%A6%82%E8%BF%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pulsar/1.Pulsar%E6%A6%82%E8%BF%B0/</guid><description>Pulsar 是一个分布式发布、订阅 (pub-sub)消息的平台，具有非常灵活的消息传递模型以及跨语言的客户端 API。Pulsar 也是一个集消息传递、消息存储、轻量化函数式计算于一体的流数据平台。Pulsar 采用了计算与存储分离的架构，支持云原生、多租户、持久化存储、多机房跨区域数据复制等，具有高一致性、高吞吐、低延时及高可扩展性等流数据存储系统特性
Pular 不只是消息队列 Pulsar 是一个分布式消息平台，可以同时处理流式数据和异构系统数据对接这两类问题 1Pulsar 是一个分布式消息平台，可以同时处理流式数据和异构系统数据对接这两类问题 Pulsar 是一个集消息传递、消息存储、轻量化函数式计算于一体的流数据平台 Pulsar 是一个分布式可扩展的流式存储系统，并在数据存储的基础上构建了消息队列和流服务的统一模型 存储计算分离 存储计算结合 在 Kafka 中，每个分区的管理与存储职能都依赖其中一个服务端节点（承担分区 Leader 角色的 Broker 节点）。 该节点在处理数据写入请求的同时，会将数据写到本机的存储路径下，并负责向其他副本写入数据。 在数据的读取过程中，该节点负责读取磁盘数据并发送回客户端。 存储与计算功能都由一个 Kafka Broker 节点负责，这样可简化服务端处理流程，增大单机的处理吞吐量。RabbitMQ 和 RocketMQ 与 Kafka 类似，采用的也是存储与计算相结合的设计方式。</description></item><item><title/><link>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pulsar/2.doccker-%E4%B8%AD%E5%90%AF%E5%8A%A8-standalone-Pulsar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pulsar/2.doccker-%E4%B8%AD%E5%90%AF%E5%8A%A8-standalone-Pulsar/</guid><description>1 2 $ docker run -it -p 6650:6650 -p 8080:8080 --mount source=pulsardata,target=/pulsar/data --mount source=pulsarconf,target=/pulsar/conf apachepulsar/pulsar:@pulsar:version@ bin/pulsar standalone</description></item><item><title/><link>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AF%B9%E6%AF%94/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AF%B9%E6%AF%94/</guid><description>性能和可靠性 副本与存储结构 Pulsar通过BookKeeper实现了数据的高可靠。在BookKeeper中Ledger是基本的持久化存储单元。Pulsar的每个主题的数据都会在逻辑上映射为多个Ledger。每个Ledger在服务端会存储多个副本。为了灵活地控制存储时的一致性，BookKeeper在存储时提供了3个关键的参数—数据存储的副本数（Ensemble Size，直译为集合数量）、最大写入副本数（Write Quorum Size，直译为法定写入数量）、最小写入副本数（Ack Quorum Size，直译为法定确认数量） 集群的高可用一般通过多副本机制来保障。Pulsar、Kafka、RabbitMQ 与 RocketMQ 都依赖副本或备份来保障高可用。
Kafka 以分区维度进行高可用保障，每个分区的数据会保存多个副本。在多个副本中会有一个被选为主副本并负责数据的读取与写入。与此同时，主副本还负责将数据同步至其他副本。在集群视角下，各个主副本会分布在不同的节点上，从全局来看，每个服务端的负载是相对均衡的 RocketMQ 依赖主从复制机制来实现数据的多副本，从而保证服务的可靠性。不同于 Kafka 采用物理分区方式（每个分区对应一个真实的日志文件），RocketMQ 采用逻辑分区的方式。RocketMQ 消息的存储由逻辑队列和物理日志一同实现，其中物理日志负责将消息存储在物理存储介质中，而消息的逻辑队列里存储对应消息的物理存储地址。在物理存储部分，RabbitMQ 也采用类似的主从复制机制来保障高可用。 Pulsar 通过 BookKeeper 实现了数据的高可靠。在 BookKeeper 中 Ledger 是基本的持久化存储单元。Pulsar 的每个主题的数据都会在逻辑上映射为多个 Ledger。每个 Ledger 在服务端会存储多个副本。为了灵活地控制存储时的一致性，BookKeeper 在存储时提供了 3 个关键的参数—数据存储的副本数（Ensemble Size，直译为集合数量）、最大写入副本数（Write Quorum Size，直译为法定写入数量）、最小写入副本数（Ack Quorum Size，直译为法定确认数量） 语义支持与一致性级别 根据 CAP 定理，在一个分布式系统中，一致性 (Consistency)、可用性 (Availability)、分区容错性 (Partition tolerance)三者不能同时满足。</description></item><item><title/><link>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%9C%BA%E6%99%AF%E9%A2%98/%E5%A6%82%E4%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%9C%BA%E6%99%AF%E9%A2%98/%E5%A6%82%E4%BD%95/</guid><description/></item><item><title/><link>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%9C%BA%E6%99%AF%E9%A2%98/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%8E%92%E8%A1%8C%E6%A6%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%9C%BA%E6%99%AF%E9%A2%98/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%8E%92%E8%A1%8C%E6%A6%9C/</guid><description/></item><item><title>Git 核心概念总结</title><link>https://googoo-s.github.io/%E5%B7%A5%E5%85%B7%E5%92%8C%E7%8E%AF%E5%A2%83/git/git/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E5%B7%A5%E5%85%B7%E5%92%8C%E7%8E%AF%E5%A2%83/git/git/</guid><description>版本控制 什么是版本控制 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。除了项目源代码，你可以对任何类型的文件进行版本控制。
为什么要版本控制 有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。
本地版本控制系统 许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单，但是特别容易犯错。有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。
为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。
集中化的版本控制系统 接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。
集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。
这么做虽然解决了本地版本控制系统无法让在不同系统上的开发者协同工作的诟病，但也还是存在下面的问题：
单点故障： 中央服务器宕机，则其他人无法使用；如果中心数据库磁盘损坏又没有进行备份，你将丢失所有数据。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。 必须联网才能工作： 受网络状况、带宽影响。 分布式版本控制系统 于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 Git 就是一个典型的分布式版本控制系统。</description></item></channel></rss>