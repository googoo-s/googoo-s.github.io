<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://googoo-s.github.io/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://googoo-s.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://googoo-s.github.io/docker/docker-compose/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/docker/docker-compose/</guid><description>docker compose 文档
Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。
Compose 使用的三个步骤：
使用 Dockerfile 定义应用程序的环境。</description></item><item><title/><link>https://googoo-s.github.io/docker/Docker-%E5%88%9D%E5%AD%A6%E8%80%85%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/docker/Docker-%E5%88%9D%E5%AD%A6%E8%80%85%E5%91%BD%E4%BB%A4/</guid><description>https://docs.docker.com/reference/
一、基础命令 帮助命令 1 2 3 docker --version # 显示docker的版本信息 docker info # 显示docker的系统信息 docker 命令 --help # 显示帮助命令 镜像命令 搜索镜像 1 2 3 4 # 搜索镜像 docker search mysql # 条件过滤搜索结果 docker search --filter=STARS=5000 「列表解释」</description></item><item><title/><link>https://googoo-s.github.io/docker/Docker-%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/docker/Docker-%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/</guid><description>什么是镜像仓库（Registry） 右边的区域就是镜像仓库，术语叫 Registry，直译就是“注册中心”，意思是所有镜像的 Repository 都在这里登记保管，就像是一个巨大的档案馆。
然后我们再来看左边的“docker pull”，虚线显示了它的工作流程，先到“Docker daemon”，再到 Registry，只有当 Registry 里存有镜像才能真正把它下载到本地。
什么是 Docker Hub 什么是 Docker Hub
“Docker Hub”（https://hub.docker.com/）。</description></item><item><title/><link>https://googoo-s.github.io/docker/dockerfile/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/docker/dockerfile/</guid><description>Dockerfile 是用来描述文件的构成的文本文档，其中包含了用户可以在使用行调用以组合 Image 的所有命令，用户还可以使用 Docker build 实现连续执行多个命令行的自动构建。
通过编写Dockerfile生磁镜像，可以为开发、测试团队提供基本一致的环境，从而提升开发、测试团队的效率，不用再为环境不统一而发愁，同时运维也能更加方便地管理我们的镜像。
镜像的内部机制是什么 镜像就是一个打包文件，里面包含了应用程序还有它运行所依赖的环境，例如文件系统、环境变量、配置参数等等
环境变量、配置参数这些东西还是比较简单的，随便用一个 manifest 清单就可以管理，真正麻烦的是文件系统。
容器镜像的一个重大创新点：分层，术语叫“Layer”
容器镜像内部并不是一个平坦的结构，而是由许多的镜像层组成的，每层都是只读不可修改的一组文件，相同的层可以在镜像之间共享，然后多个层像搭积木一样堆叠起来，再使用一种叫**“Union FS 联合文件系统**”
可以用命令 docker inspect 来查看镜像的分层信息，比如 nginx:alpine</description></item><item><title/><link>https://googoo-s.github.io/docker/%E4%B8%8E%E5%A4%96%E7%95%8C%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B1%E4%BA%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/docker/%E4%B8%8E%E5%A4%96%E7%95%8C%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B1%E4%BA%AB/</guid><description>如何拷贝容器内的数据 cp 命令，它可以在宿主机和容器之间拷贝文件，是最基本的一种数据交换功能。
docker cp 的用法很简单，很类似 Linux 的“cp”“scp”，指定源路径（src path）和目标路径（dest path）就可以了。如果源路径是宿主机那么就是把文件拷贝进容器，如果源路径是容器那么就是把文件拷贝出容器，注意需要用容器名或者容器 ID 来指明是哪个容器的路径。
1 2 docker cp a.txt 062:/tmp 如何共享主机上的文件 只需要在 docker run 命令启动容器的时候使用 -v 参数就行，具体的格式是“宿主机路径: 容器内路径”。</description></item><item><title/><link>https://googoo-s.github.io/docker/%E5%A6%82%E4%BD%95%E5%AE%B9%E5%99%A8%E5%8C%96%E5%BA%94%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/docker/%E5%A6%82%E4%BD%95%E5%AE%B9%E5%99%A8%E5%8C%96%E5%BA%94%E7%94%A8/</guid><description>镜像是容器的静态形式，它打包了应用程序的所有运行依赖项，方便保存和传输。使用容器技术运行镜像，就形成了动态的容器，由于镜像只读不可修改，所以应用程序的运行环境总是一致的。
容器化的应用就是指以镜像的形式打包应用程序，然后在容器环境里从镜像启动容器。
我这里就对今天的镜像操作和容器操作做个小结：
常用的镜像操作有 docker pull、docker images、docker rmi，分别是拉取镜像、查看镜像和删除镜像。
用来启动容器的 docker run 是最常用的命令，它有很多参数用来调整容器的运行状态，对于后台服务来说应该使用 -d。
docker exec 命令可以在容器内部执行任意程序，对于调试排错特别有用。</description></item><item><title/><link>https://googoo-s.github.io/ElasticSearch/%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/ElasticSearch/%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>![[精选7道Elastic Search面试题！.pdf]]</description></item><item><title/><link>https://googoo-s.github.io/HOME/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/HOME/</guid><description>所有的文章 1 list from &amp;#34;/&amp;#34;</description></item><item><title/><link>https://googoo-s.github.io/Java/IO/AIO/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/IO/AIO/</guid><description/></item><item><title/><link>https://googoo-s.github.io/Java/IO/BIO/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/IO/BIO/</guid><description>字节流 InputStream（字节输入流） InputStream用于从源头（通常是文件）读取数据（字节信息）到内存中，java.io.InputStream抽象类是所有字节输入流的父类。
InputStream 常用方法 ：
read() ：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 -1 ，表示文件结束。
read(byte b[ ]) : 从输入流中读取一些字节存储到数组 b 中。如果数组 b 的长度为零，则不读取。如果没有可用字节读取，返回 -1。如果有可用字节读取，则最多读取的字节数最多等于 b.</description></item><item><title/><link>https://googoo-s.github.io/Java/IO/IO%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/IO/IO%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</guid><description>何为 I/O? I/O（Input/Outpu） 即输入／输出 。
我们先从计算机结构的角度来解读一下 I/O。
根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。
从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。
我们再先从应用程序的角度来解读一下 I/O。
为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 用户空间（User space） 和 内核空间（Kernel space ） 。</description></item><item><title/><link>https://googoo-s.github.io/Java/IO/Java-IO-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/IO/Java-IO-overview/</guid><description>Java 中的 IO 流分为几种？ 流按照不同的特点，有很多种划分方式
按照流的流向分，可以分为 输入流 和 输出流 ；
按照操作单元划分，可以划分为 字节流 和 字符流 ；
按照流的角色划分为 节点流 和 处理流</description></item><item><title/><link>https://googoo-s.github.io/Java/IO/NIO/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/IO/NIO/</guid><description>NIO 与 IO 主要区别 ![[Pasted image 20230727001911.png]]
- 面向流与面向缓冲 io Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方 它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区 nio NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动 - 阻塞与非阻塞IO nio 使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel） io 当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了 - 选择器 NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道 这种选择机制，使得一个单独的线程很容易来管理多个通道。 - NIO和IO如何影响应用程序的设计 对NIO或IO类的API调用 使用NIO的API调用时看起来与使用IO时有所不同，但这并不意外，因为并不是仅从一个InputStream逐字节读取，而是数据必须先读入缓冲区再处理 数据处理 用来处理数据的线程数 NIO可让您只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂 如果你有少量的连接使用非常高的带宽，一次发送大量的数据，也许典型的IO服务器实现可能非常契合 NIO Path java.</description></item><item><title/><link>https://googoo-s.github.io/Java/JVM/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/JVM/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</guid><description>运行时数据区域 Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK 1.8 和之前的版本略有不同，下面会介绍到。
JDK 1.8 之前 ：
JDK 1.8 之后 ：
线程私有的：
程序计数器</description></item><item><title/><link>https://googoo-s.github.io/Java/JVM/JVM-%E8%B0%83%E4%BC%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/JVM/JVM-%E8%B0%83%E4%BC%98/</guid><description>有哪些常用的命令行性能监控和故障处理工具？ 操作系统工具
top：显示系统整体资源使用情况
vmstat：监控内存和CPU
iostat：监控IO使用
netstat：监控网络使用JDK性能监控工具
JDK性能监控工具</description></item><item><title/><link>https://googoo-s.github.io/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid><description>堆空间的基本结构 Java 自动内存管理最核心的功能是 堆 内存中对象的分配与回收。
Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。
在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：
新生代内存(Young Generation)</description></item><item><title/><link>https://googoo-s.github.io/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</guid><description>回顾下类加载过程 加载
连接
验证
准备
解析
初始化</description></item><item><title/><link>https://googoo-s.github.io/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</guid><description>类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：
加载（Loading）
连接
验证（Verification）
准备（Preparation）
解析（Resolution）
初始化（Initialization）</description></item><item><title/><link>https://googoo-s.github.io/Java/JVM/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/JVM/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</guid><description>回顾一下字节码 在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），只面向虚拟机
Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，
同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，
下图展示了不同的语言被不同的编译器编译成.class文件最终运行在 Java 虚拟机之上。.</description></item><item><title/><link>https://googoo-s.github.io/Java/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/overview/</guid><description/></item><item><title/><link>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-overview/</guid><description>什么是 Java Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里 难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。 Java语言作为静态面向对象编程语言的优秀代表，极好地实现了面向对象理论，允许 程序员以优雅的思维方式进行复杂的编程 Java 语言有哪些特点?
简单易学； 面向对象（封装，继承，多态）； 平台无关性（ Java 虚拟机实现平台无关性）； 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）； 可靠性； 安全性； 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）； 编译与解释并存； 🐛 修正（参见： issue#544open in new window） ：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用std::thread和std::async来创建线程。参考链接：http://www.</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-SPI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-SPI/</guid><description>何谓 SPI? SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。
SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。
很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。
SPI 和 API 有什么区别？ 那 SPI 和 API 有啥区别？</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-%E5%8F%8D%E5%B0%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-%E5%8F%8D%E5%B0%84/</guid><description>关于反射的详细解读，请看这篇文章 Java 反射机制详解。
何谓反射？ 主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。
反射的优缺点？ 优点：反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。
缺点：反射让我们在运行时有了分析操作类的能力的同时，也增加了安全题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。
相关阅读： Java Reflection: Why is it so slow?open in new window 。</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid><description>注释有哪几种形式？ Java 中的注释有三种：
单行注释 ：通常用于解释方法内某单行代码的作用。
多行注释 ：通常用于解释一段代码的作用。
文档注释 ：通常用于生成 Java 开发文档。
用的比较多的还是单行注释和文档注释，多行注释在实际开发中使用的相对较少。</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-%E5%B8%B8%E7%94%A8%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-%E5%B8%B8%E7%94%A8%E7%B1%BB/</guid><description>Object Object 类的常见方法有哪些？ Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。 */public final native Class&amp;lt;?</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</guid><description>什么是序列化?什么是反序列化? 如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。
简单来说：
序列化： 将数据结构或对象转换成二进制字节流的过程
反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程
对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-%E5%BC%82%E5%B8%B8/</guid><description>Java 异常类层次结构图概览 ：
Exception 和 Error 有什么区别？ 在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类:
Exception :程序本身可以处理的异常，可以通过 catch 来进行捕获。</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-%E6%B3%9B%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-%E6%B3%9B%E5%9E%8B/</guid><description>什么是泛型？有什么作用？ Java 泛型（Generics） 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。
编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 ArrayList&amp;lt;Person&amp;gt; persons = new ArrayList&amp;lt;Person&amp;gt;() 这行代码就指明了该 ArrayList 对象只能传入 Person 对象，如果传入其他类型的对象就会报错。
1 ArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt; 并且，原生 List 返回类型是 Object ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-%E6%B3%A8%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-%E6%B3%A8%E8%A7%A3/</guid><description>注解 何谓注解？ Annotation （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。
注解本质是一个继承了Annotation 的特殊接口：
1 2 3 4 5 6 7 8 9 @Target(ElementType.METHOD) @Retention(RetentionPolicy.</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>Java 的数据类型 定义：Java 语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。 Java 语言数据类型分为两种：基本数据类型和引用数据类型 ![[Pasted image 20230726230002.png]]
基本数据类型 Ava 中有 8 种基本数据类型，分别为：
6 种数字类型： 4 种整数型：byte、short、int、long 2 种浮点型：float、double 1 种字符类型：char 1 种布尔型：boolean 这 8 种基本数据类型的默认值以及所占空间的大小如下： 基本类型 位数 字节 默认值 取值范围 byte 8 1 0 -128 ~ 127 short 16 2 0 -32768 ~ 32767 int 32 4 0 -2147483648 ~ 2147483647 long 64 8 0 L -9223372036854775808 ~ 9223372036854775807 char 16 2 &amp;lsquo;u 0000&amp;rsquo; 0 ~ 65535 float 32 4 0 f 1.</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid><description>面向对象和面向过程的区别 两者的主要区别在于解决问题的方式不同：
面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。
面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。
另外，面向对象开发的程序一般更易维护、易复用、易扩展。
相关 issue : 面向过程 ：面向过程性能比面向对象高？？open in new window
创建一个对象用什么运算符?对象实体与对象引用有何不同? new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>![[Java面试题、面经.pdf]]
![[Java 面试知识点总结.pdf]]
![[Java 面试知识点总结(1).pdf]]
![[Java面试题、面经(1).pdf]]
![[阿里大佬总结的Java面试资料.pdf]]</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid><description>要想理解透彻 JMM（Java 内存模型），我们先要从 CPU 缓存模型和指令重排序 说起！
从 CPU 缓存模型说起 CPU Cache CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。
为了更好地理解，我画了一个简单的 CPU Cache 示意图如下所示。</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98/</guid><description>Java 内存模型 导致可见性的原因是缓存，导致有序性的原因是编译优化，那解决可见性、有序性最直接的办法就是禁用缓存和编译优化，但是这样性能堪忧，应该按需禁用缓存以及编译优化。
如何做到“按需禁用”呢？对于并发程序，何时禁用缓存以及编译优化只有程序员知道，那所谓“按需禁用”其实就是指按照程序员的要求来禁用。
本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 volatile、synchronized 和 final 三个关键字，以及六项 Happens-Before 规则。
volatile volatile 关键字并不是 Java 语言的特产，古老的 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B/</guid><description>Java 线程的生命周期 对于有生命周期的事物，要学好它，思路非常简单，只要能搞懂生命周期中各个节点的状态转换机制就可以了
通用的生命周期 &amp;mdash; &amp;mdash; 初始状态 初始状态，指的是线程已经被创建，但是还不允许分配 CPU 执行。这个状态属于编程语言特有的，不过这里所谓的被创建，仅仅是在编程语言层面被创建，而在操作系统层面，真正的线程还没有创建。 可运行状态 可运行状态，指的是线程可以分配 CPU 执行。在这种状态下，真正的操作系统线程已经被成功创建了，所以可以分配 CPU 执行。 运行状态 当有空闲的 CPU 时，操作系统会将其分配给一个处于可运行状态的线程，被分配到 CPU 的线程的状态就转换成了运行状态。 休眠状态 运行状态的线程如果调用一个阻塞的 API（例如以阻塞方式读文件）或者等待某个事件（例如条件变量），那么线程的状态就会转换到休眠状态，同时释放 CPU 使用权，休眠状态的线程永远没有机会获得 CPU 使用权。当等待的事件出现了，线程就会从休眠状态转换到可运行状态。 终止状态 线程执行完或者出现异常就会进入终止状态，终止状态的线程不会切换到其他任何状态，进入终止状态也就意味着线程的生命周期结束了。 java 中的生命周期 NEW（初始化状态）</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/ThreadLocal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/ThreadLocal/</guid><description>ThreadLocal 有什么用？ **ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal**类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。
如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。
如何使用 ThreadLocal？ 相信看了上面的解释，大家已经搞懂 ThreadLocal 类是个什么东西了。下面简单演示一下如何在项目中实际使用 ThreadLocal 。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import java.</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BA%92%E6%96%A5%E9%94%81%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BA%92%E6%96%A5%E9%94%81%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98/</guid><description>一个或者多个操作在 CPU 执行的过程中不被中断的特性，称为“原子性”。
如何解决原子性问题 原子性问题的源头是线程切换，如果能够禁用线程切换那不就能解决这个问题了吗？而操作系统做线程切换是依赖 CPU 中断的，所以禁止 CPU 发生中断就能够禁止线程切换。&amp;mdash;&amp;mdash;早期单核可行，现在不可行
在单核 CPU 场景下，同一时刻只有一个线程执行，禁止 CPU 中断，意味着操作系统不会重新调度线程，也就是禁止了线程切换，获得 CPU 使用权的线程就可以不间断地执行，所以两次写操作一定是：要么都被执行，要么都没有被执行，具有原子性
在多核场景下，同一时刻，有可能有两个线程同时在执行，一个线程执行在 CPU-1 上，一个线程执行在 CPU-2 上，此时禁止 CPU 中断，只能保证 CPU 上的线程连续执行，并不能保证同一时刻只有一个线程执行</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8BBug%E7%9A%84%E6%BA%90%E5%A4%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8BBug%E7%9A%84%E6%BA%90%E5%A4%B4/</guid><description>我们的 CPU、内存、I/O 设备都在不断迭代，不断朝着更快的方向努力。但是，在这个快速发展的过程中，有一个核心矛盾一直存在，就是这三者的速度差异
为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为：
cpu增加缓存，以均衡与内存的速度差异
操作系统增加了进程、线程，以分时复用CPU,进而均衡 CPU 与 I/O 设备的速度差异
编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。
这些优化导致了一些问题。</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</guid><description>并行、并发的区别 从操作系统的角度来看，线程是CPU分配的最小单位
并发：两个及两个以上的作业在同一 时间段 内执行。
并行：两个及两个以上的作业在同一 时刻 执行。
同步和异步的区别 同步 ： 发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%AE%89%E5%85%A8%E6%80%A7%E6%B4%BB%E8%B7%83%E6%80%A7%E4%BB%A5%E5%8F%8A%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%AE%89%E5%85%A8%E6%80%A7%E6%B4%BB%E8%B7%83%E6%80%A7%E4%BB%A5%E5%8F%8A%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/</guid><description>存在共享数据并且该数据会发生变化，通俗地讲就是有多个线程会同时读写同一数据,需要分析安全性、活跃性以及性能问题。
那如果能够做到不共享数据或者数据状态不发生变化，不就能够保证线程的安全性了嘛。有不少技术方案都是基于这个理论的，例如线程本地存储（Thread Local Storage，TLS）、不变模式等等，后面我会详细介绍相关的技术方案是如何在 Java 语言中实现的。
安全性问题 当多个线程同时访问同一数据，并且至少有一个线程会写这个数据的时候，如果我们不采取防护措施，那么就会导致并发 Bug，对此还有一个专业的术语，叫做数据竞争（Data Race）
程序的执行结果依赖线程执行的顺序，叫做竟态条件（Race Condition）
那面对数据竞争和竞态条件问题，又该如何保证线程的安全性呢？其实这两类问题，都可以用互斥这个技术方案，而实现互斥的方案有很多，CPU 提供了相关的互斥指令，操作系统、编程语言也会提供相关的 API。从逻辑上来看，我们可以统一归为：锁。
活跃性问题 指的是某个操作无法执行下去。我们常见的**“死锁”**就是一种典型的活跃性问题，当然除了死锁外，还有两种情况，分别是“活锁”和“饥饿
活跃性问题</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/CompletableFuture%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/CompletableFuture%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid><description>前面我们不止一次提到，用多线程优化性能，其实不过就是将串行操作变成并行操作
异步化，是并行方案得以实施的基础，更深入地讲其实就是**：利用多线程优化性能这个核心方案得以实施的基础**
CompletableFuture 的核心优势 这里我们用 CompletableFuture 重新实现前面曾提及的烧水泡茶程序
我们分了 3 个任务：
任务 1 负责洗水壶、烧开水，
任务 2 负责洗茶壶、洗茶杯和拿茶叶，</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/CompletionService%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/CompletionService%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/</guid><description>有一个询价应用，这个应用需要从三个电商询价，然后保存在自己的数据库里。核心示例代码如下所示，由于是串行的，所以性能很慢，你来试着优化一下吧
1 2 3 4 5 6 7 8 9 10 // 向电商S1询价，并保存 r1 = getPriceByS1(); save(r1); // 向电商S2询价，并保存 r2 = getPriceByS2(); save(r2); // 向电商S3询价，并保存 r3 = getPriceByS3(); save(r3); 使用“ThreadPoolExecutor+Future”的方案，化结果很可能是下面示例代码这样：用三个线程异步执行询价，通过三次调用 Future 的 get() 方法获取询价结果，之后将询价结果保存在数据库中</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/CountDownLatch%E5%92%8CCyclicBarrier%E8%AE%A9%E7%BA%BF%E7%A8%8B%E6%AD%A5%E8%B0%83%E4%B8%80%E8%87%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/CountDownLatch%E5%92%8CCyclicBarrier%E8%AE%A9%E7%BA%BF%E7%A8%8B%E6%AD%A5%E8%B0%83%E4%B8%80%E8%87%B4/</guid><description>目前对账系统的处理逻辑是首先查询订单，然后查询派送单，之后对比订单和派送单，将差异写入差异库。
对账系统的代码抽象之后，也很简单，核心代码如下，就是在一个单线程里面循环查询订单、派送单，然后执行对账，最后将写入差异库。
1 2 3 4 5 6 7 8 9 10 11 while(存在未对账订单){ // 查询未对账订单 pos = getPOrders(); // 查询派送单 dos = getDOrders(); // 执行对账操作 diff = check(pos, dos); // 差异写入差异库 save(diff); } 利用并行优化对账系统 目前对账系统是单线程执行的，图形化后是下图这个样子。</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/Executor-%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/Executor-%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid><description>线程是一个重量级的对象，应该避免频繁创建和销毁，可以使用线程池
一般意义上的池化资源，都是下面这样，当你需要资源的时候就调用 acquire() 方法来申请资源，用完之后就调用 release() 释放资源。
1 2 3 4 5 6 7 8 9 class XXXPool{ // 获取池化资源 XXX acquire() { } // 释放池化资源 void release(XXX x){ } } 若你带着这个固有模型来看并发包里线程池相关的工具类时，会很遗憾地发现它们完全匹配不上，Java 提供的线程池里面压根就没有申请线程和释放线程的方法.</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/Fork-Join%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84MapReduce/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/Fork-Join%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84MapReduce/</guid><description>对于简单的并行任务，你可以通过“线程池 +Future”的方案来解决；如果任务之间有聚合关系，无论是 AND 聚合还是 OR 聚合，都可以通过 CompletableFuture 来解决；而批量的并行任务，则可以通过 CompletionService 来解决。
我们一直讲，并发编程可以分为三个层面的问题，分别是分工、协作和互斥当你关注于任务的时候，你会发现你的视角已经从并发编程的细节中跳出来了，你应用的更多的是现实世界的思维模式，类比的往往是现实世界里的分工，所以我把线程池、Future、CompletableFuture 和 CompletionService 都列到了分工里面
上面提到的简单并行、聚合、批量并行这三种任务模型，基本上能够覆盖日常工作中的并发场景了，但还是不够全面，因为还有一种“分治”的任务模型没有覆盖到.
分治，顾名思义，即分而治之，是一种解决复杂问题的思维方法和模式；具体来讲，指的是把一个复杂的问题分解成多个相似的子问题，然后再把子问题分解成更小的子问题，直到子问题简单到可以直接求解。
分治任务模型 分治任务模型可分为两个阶段：
一个阶段是任务分解，也就是将任务迭代地分解为子任务，直至子任务可以直接计算出结果；</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/Future/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/Future/</guid><description>使用 ThreadPoolExecutor 的时候，如何获取任务执行结果
如何获取任务执行结果 Java 通过 ThreadPoolExecutor 提供的 3 个 submit() 方法和 1 个 FutureTask 工具类来支持获得任务执行结果的需求
submit() 1 2 3 4 5 6 7 // 提交Runnable任务 Future&amp;lt;?</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/Lock%E5%92%8CCondition/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/Lock%E5%92%8CCondition/</guid><description>ava SDK 并发包通过 Lock 和 Condition 两个接口来实现管程，其中 Lock 用于解决互斥问题，Condition 用于解决同步问题。
Java 语言本身提供的 synchronized 也是管程的一种实现，既然 Java 从语言层面已经实现了管程了，那为什么还要在 SDK 里提供另外一种实现呢？
再造管程的理由 例如在 Java 的 1.</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore/</guid><description>信号量模型 号量模型还是很简单的，可以简单概括为：一个计数器，一个等待队列，三个方法，
信号量模型里，计数器和等待队列对外是透明的，所以只能通过信号量模型提供的三个方法来访问它们，这三个方法分别是：init()、down() 和 up()。你可以结合下图来形象化地理解。
init()：设置计数器的初始值。
down()：计数器的值减 1；如果此时计数器的值小于 0，则当前线程将被阻塞，否则当前线程可以继续执行。
up()：计数器的值加 1；如果此时计数器的值小于或者等于 0，则唤醒等待队列中的一个线程，并将其从等待队列中移除。
对应的代码解释</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/%E5%8D%B0%E7%AB%A0%E9%94%81StampedLock%E6%AF%94%E8%AF%BB%E5%86%99%E9%94%81%E6%9B%B4%E5%BF%AB%E7%9A%84%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/%E5%8D%B0%E7%AB%A0%E9%94%81StampedLock%E6%AF%94%E8%AF%BB%E5%86%99%E9%94%81%E6%9B%B4%E5%BF%AB%E7%9A%84%E9%94%81/</guid><description>StampedLock 支持的三种锁模式 ReadWriteLock 支持两种模式：一种是读锁，一种是写锁。
StampedLock 支持三种模式，分别是：写锁、悲观读锁和乐观读。
其中，写锁、悲观读锁的语义和 ReadWriteLock 的写锁、读锁的语义非常类似，允许多个线程同时获取悲观读锁，但是只允许一个线程获取写锁，写锁和悲观读锁是互斥的。
StampedLock 里的写锁和悲观读锁加锁成功之后，都会返回一个 stamp；然后解锁的时候，需要传入这个 stamp
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 final StampedLock sl = new StampedLock(); // 获取/释放悲观读锁示意代码 long stamp = sl.</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%97%A0%E9%94%81%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E5%85%B8%E8%8C%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%97%A0%E9%94%81%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E5%85%B8%E8%8C%83/</guid><description>1 2 3 4 5 6 7 8 9 10 11 public class Test { AtomicLong count = new AtomicLong(0); void add10K() { int idx = 0; while(idx++ &amp;lt; 10000) { count.</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</guid><description>同步容器及其注意事项 都是基于 synchronized 这个同步关键字实现的，所以也被称为同步容器。
Java 中的容器主要可以分为四个大类，分别是 List、Map、Set 和 Queue，但并不是所有的 Java 容器都是线程安全的。
如何将非线程安全的容器变成线程安全的容器？
只要把非线程安全的容器封装在对象内部，然后控制好访问路径就可以了
以 ArrayList 为例，看看如何将它变成线程安全的在下面的代码中，SafeArrayList 内部持有一个 ArrayList 的实例 c，所有访问 c 的方法我们都增加了 synchronized 关键字，需要注意的是我们还增加了一个 addIfNotExist() 方法，这个方法也是用 synchronized 来保证原子性的。</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/%E8%AF%BB%E5%86%99%E9%94%81ReadWriteLock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E7%B1%BB/%E8%AF%BB%E5%86%99%E9%94%81ReadWriteLock/</guid><description>一种非常普遍的并发场景：读多写少场景。实际工作中，为了优化性能，我们经常会使用缓存，例如缓存元数据、缓存基础数据等，这就是一种典型的读多写少应用场景。缓存之所以能提升性能，一个重要的条件就是缓存的数据一定是读多写少的，例如元数据和基础数据基本上不会发生变化（写少），但是使用它们的地方却很多（读多）。针对读多写少这种并发场景，Java SDK 并发包提供了读写锁——ReadWriteLock，非常容易使用，并且性能很好。
什么是读写锁 而是一个广为使用的通用技术，所有的读写锁都遵守以下三条基本原则： 1允许多个线程同时读共享变量； 2只允许一个线程写共享变量； 3如果一个写线程正在执行写操作，此时禁止读线程读共享变量。读写锁与互斥锁的一个重要区别就是读写锁允许多个线程同时读共享变量，而互斥锁是不允许的，这是读写锁在读多写少场景下性能优于互斥锁的关键。但读写锁的写操作是互斥的
实现一个缓存 在下面的代码中，我们声明了一个 Cache 类，其中类型参数 K 代表缓存里 key 的类型，V 代表缓存里 value 的类型，缓存的数据保存在 Cache 类内部的 HashMap 里面，HashMap 不是线程安全的，这里我们使用读写锁 ReadWriteLock 来保证其线程安全。ReadWriteLock 是一个接口，它的实现类是 ReentrantReadWriteLock，通过名字你应该就能判断出来，它是支持可重入的。下面我们通过 rwl 创建了一把读锁和一把写锁</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%AD%BB%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%AD%BB%E9%94%81/</guid><description>在上一篇文章中，我们用 Account.class 作为互斥锁，来解决银行业务里面的转账问题，虽然这个方案不存在并发问题，但是所有账户的转账操作都是串行的。
账户 A 转账户 B、账户 C 转账户 D 这两个转账操作现实世界里是可以并行的；
具体操作为：
文件架上恰好有转出账本和转入账本，那就同时拿走；
如果文件架上只有转出账本和转入账本之一，那这个柜员就先把文件架上有的账本拿到手，同时等着其他柜员把另外一个账本送回来；
转出账本和转入账本都没有，那这个柜员就等着两个账本都被送回来。</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E4%BC%98%E5%8C%96%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E4%BC%98%E5%8C%96%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85/</guid><description>等待通知机制优化循环等待
在破坏占用且等待条件的时候，如果转出账本和转入账本不满足同时在文件架上这个条件，就用死循环的方式来循环等待
1 2 3 4 // 一次性申请转出账户和转入账户，直到成功 while(!actr.apply(this, target)) ； 如果 apply() 操作耗时长，或者并发冲突量大的时候，循环等待这种方案就不适用了，因为在这种场景下，可能要循环上万次才能获取到锁，太消耗 CPU 了。</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%AE%A1%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%AE%A1%E7%A8%8B/</guid><description>什么是管程 Java 采用的是管程技术，synchronized 关键字及 wait()、notify()、notifyAll() 这三个方法都是管程的组成部分。而管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程
所谓管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发
MESA 模型 管程的发展历史上有三种管程模型
管程模型
Hasen 模型
Hoare 模型</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid><description>线程池
什么是线程池? 顾名思义，线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。
为什么要用线程池？ 池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。
线程池提供了一种限制和管理资源（包括执行一个任务）的方式。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。
这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：
降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
如何创建线程池？ 方式一：通过**ThreadPoolExecutor**构造函数来创建（推荐）。</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Copy-on-Write/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Copy-on-Write/</guid><description>每次 RPC 调用都需要通过负载均衡器来计算目标服务的 IP 和端口号，而负载均衡器需要通过路由表获取接口的所有路由信息，也就是说，每次 RPC 调用都需要访问路由表，所以访问路由表这个操作的性能要求是很高的**。不过路由表对数据的一致性要求并不高，一个服务提供方从上线到反馈到客户端的路由表里，即便有 5 秒钟，很多时候也都是能接受的**（5 秒钟，对于以纳秒作为时钟周期的 CPU 来说，那何止是一万年，所以路由表对一致性的要求并不高）。
对读的性能要求很高，读多写少，弱一致性。它们综合在一起，你会想到什么呢？CopyOnWriteArrayList 和 CopyOnWriteArraySet 天生就适用这种场景啊。
RouteTable 这个类内部我们通过ConcurrentHashMap&amp;gt;这个数据结构来描述路由表，ConcurrentHashMap 的 Key 是接口名，Value 是路由集合，这个路由集合我们用是 CopyOnWriteArraySet</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Immutability%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E4%B8%8D%E5%8F%98%E6%80%A7%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Immutability%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E4%B8%8D%E5%8F%98%E6%80%A7%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</guid><description>Immutability 模式：如何利用不变性解决并发问题
解决并发问题，其实最简单的办法就是让共享变量只有读操作，而没有写操作
不变性（Immutability）模式。所谓不变性，简单来讲，就是对象一旦被创建之后，状态就不再发生变化
快速实现具备不可变性的类 将一个类所有的属性都设置成 final 的，并且只允许存在只读方法，那么这个类基本上就具备不可变性了，更严格的做法是这个类本身也是 final 的，也就是不允许继承。
Java SDK 里很多类都具备不可变性，如经常用到的 String 和 Long、Integer、Double 等基础类型的包装类都具备不可变性，
如果你仔细翻看这些类的声明、属性和方法，你会发现它们都严格遵守不可变类的三点要求：类和属性都是 final 的，所有方法均是只读的。</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F-ThreadLocal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F-ThreadLocal/</guid><description>已经知道通过局部变量可以做到避免共享，那还有没有其他方法可以做到呢？
有的，Java 语言提供的**线程本地存储（ThreadLocal）**就能够做到
ThreadLocal 的使用方法 下面这个静态类 ThreadId 会为每个线程分配一个唯一的线程 Id，如果一个线程前后两次调用 ThreadId 的 get() 方法，两次 get() 方法的返回值是相同的。但如果是两个线程分别调用 ThreadId 的 get() 方法，那么两个线程看到的 get() 方法的返回值是不同的。</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81/</guid><description>乐观锁和悲观锁 悲观锁：悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放
共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程
Java 中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现
悲观锁通常多用于写多比较多的情况下（多写场景），避免频繁失败和重试影响性能
乐观锁：总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）</description></item><item><title/><link>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid><description>Semaphore Semaphore的作用 synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，而Semaphore(信号量)可以用来控制同时访问特定资源的线程数量。
Semaphore 有两种模式：。
公平模式： 调用 acquire() 方法的顺序就是获取许可证的顺序，遵循 FIFO；
非公平模式： 抢占式的。
1 2 3 4 5 6 7 public Semaphore(int permits) { sync = new NonfairSync(permits); } public Semaphore(int permits, boolean fair) { sync = fair ?</description></item><item><title/><link>https://googoo-s.github.io/Java/%E9%9B%86%E5%90%88/Java-%E9%9B%86%E5%90%88-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E9%9B%86%E5%90%88/Java-%E9%9B%86%E5%90%88-overview/</guid><description>常见的集合 Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 Collection接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。对于Collection 接口，下面又有三个主要的子接口：List、Set 和 Queue。
Java 集合框架如下图所示
其中 Collection 是集合 List 、 Set 、Queue的父接口，它主要有两个子接口：</description></item><item><title/><link>https://googoo-s.github.io/Java/%E9%9B%86%E5%90%88/List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E9%9B%86%E5%90%88/List/</guid><description>ArrayList 和 Vector 的区别 ArrayList 是 List 的主要实现类，底层使用 Object[]存储，适用于频繁的查找工作，线程不安全 ；
Vector 是 List 的古老实现类，底层使用Object[] 存储，线程安全的。
ArrayList和LinkedList有什么区别？ 是否线程安全</description></item><item><title/><link>https://googoo-s.github.io/Java/%E9%9B%86%E5%90%88/Map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E9%9B%86%E5%90%88/Map/</guid><description>HashMap 和 HashTable 的区别 线程是否安全： HashMap 是非线程安全的，****Hashtable 是线程安全的,因为 Hashtable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；
效率： 因为线程安全的问题，HashMap 要比 Hashtable 效率高一点。另外，Hashtable 基本被淘汰，不要在代码中使用它；</description></item><item><title/><link>https://googoo-s.github.io/Java/%E9%9B%86%E5%90%88/Queue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E9%9B%86%E5%90%88/Queue/</guid><description>Queue 与 Deque 的区别 Queue
Queue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO） 规
Queue 扩展了 Collection 的接口，根据 因为容量问题而导致操作失败后处理方式的不同 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</description></item><item><title/><link>https://googoo-s.github.io/Java/%E9%9B%86%E5%90%88/Set/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E9%9B%86%E5%90%88/Set/</guid><description>comparable 和 Comparator 的区别 comparable 接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序
comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序
一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo()方法和使用自制的Comparator方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 Collections.</description></item><item><title/><link>https://googoo-s.github.io/Java/%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>![[Java集合框架常见面试题.pdf]]
![[集合框架.pdf]]</description></item><item><title/><link>https://googoo-s.github.io/Java/%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>![[《面渣逆袭手册》V1.1.pdf]]</description></item><item><title/><link>https://googoo-s.github.io/journal/2023-07-25/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/journal/2023-07-25/</guid><description/></item><item><title/><link>https://googoo-s.github.io/journal/2023-07-26/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/journal/2023-07-26/</guid><description> 02:19 asdfa 02:19 asdfa 02:19 asdfasd 02:19 adsfad 02:19 adfsasd 02:19 asdfads</description></item><item><title/><link>https://googoo-s.github.io/journal/2023-07-27/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/journal/2023-07-27/</guid><description>1 table</description></item><item><title/><link>https://googoo-s.github.io/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-DaemonSet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-DaemonSet/</guid><description>另外一类代表在线业务 API 对象：DaemonSet，它会在 Kubernetes 集群的每个节点上都运行一个 Pod，就好像是 Linux 系统里的“守护进程”（Daemon）。
为什么要有 DaemonSet Deployment 并不关心这些 Pod 会在集群的哪些节点上运行，在它看来，Pod 的运行环境与功能是无关的，只要 Pod 的数量足够，应用程序应该会正常工作。
有一些业务比较特殊**，它们不是完全独立于系统运行的，而是与主机存在“绑定”关系，必须要依附于节点才能产生价值**，比如说：
网络应用（如 kube-proxy），必须每个节点都运行一个 Pod，否则节点就无法加入 Kubernetes 网络</description></item><item><title/><link>https://googoo-s.github.io/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-Deployment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-Deployment/</guid><description>Deployment”，顾名思义，它是专门用来部署应用程序的，能够让应用永不宕机，多用来发布无状态的应用，是 Kubernetes 里最常用也是最有用的一个对象
为什么要有Delplyment 除了“离线业务”，另一大类业务——也就是“在线业务”，在 Kubernetes 里应该如何处理呢？
我们先看看用 Pod 是否就足够了。因为它在 YAML 里使用“containers”就可以任意编排容器，而且还有一个**“restartPolicy”字段，默认值就是 Always**，可以监控 Pod 里容器的状态，一旦发生异常，就会自动重启容器。
“restartPolicy”只能保证容器正常工作。不知你有没有想到，如果容器之外的 Pod 出错了该怎么办呢？比如说，有人不小心用 kubectl delete 误删了 Pod，或者 Pod 运行的节点发生了断电故障，那么 Pod 就会在集群里彻底消失，对容器的控制也就无从谈起了</description></item><item><title/><link>https://googoo-s.github.io/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-Job-%E4%B8%8E-CronJob/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-Job-%E4%B8%8E-CronJob/</guid><description>Pod 已经是一个相对完善的对象，专门负责管理容器，那么我们就不应该再“画蛇添足”地盲目为它扩充功能，而是要保持它的独立性，**容器之外的功能就需要定义其他的对象，把 Pod 作为它的一个成员“组合”**进去。
为什么要有 Job/CronJob Nginx 和 busybox，它们分别代表了 Kubernetes 里的两大类业务。一类是像 Nginx 这样长时间运行的**“在线业务”，另一类是像 busybox 这样短时间运行的“离线业务**”
在线业务”类型的应用有很多，比如 Nginx、Node.js、MySQL、Redis 等等，一旦运行起来基本上不会停，也就是永远在线。</description></item><item><title/><link>https://googoo-s.github.io/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-Pod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-Pod/</guid><description>为什么要有 Pod Namespace 做隔离，Cgroups 做限制，rootfs 做文件系统”这样的“三句箴言”可以朗朗上口了，为什么 Kubernetes 项目又突然搞出一个 Pod 来呢？
为了解决这样多应用联合运行的问题，同时还要不破坏容器的隔离，就需要在容器外面再建立一个“收纳舱”，让多个容器既保持相对独立，又能够小范围共享网络、存储等资源，而且永远是“绑在一起”的状态。
Kubernetes 项目所做的，其实就是将“进程组”的概念映射到了容器技术中，这就是Pod
为什么Pod 是Kubernetes 的核心对象 Kubernetes 让 Pod 去编排处理容器，然后把 Pod 作为应用调度部署的最小单位，</description></item><item><title/><link>https://googoo-s.github.io/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-StatefulSet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-StatefulSet/</guid><description>eployment 和 DaemonSet 两种 API 对象，它们是在 Kubernetes 集群里部署应用的重要工具，不过它们也有一个缺点，只能管理“无状态应用”（Stateless Application），不能管理“有状态应用”（Stateful Application）。
有状态应用”的处理比较复杂，要考虑的事情很多，但是这些问题我们其实可以通过组合Deployment、Service、PersistentVolume 等对象来解决。
什么是有状态的应用 状态”，应用保存的数据，实际上就是它某个时刻的“运行状态”。
只是有的应用的状态信息不是很重要，即使不恢复状态也能够正常运行，这就是我们常说的“无状态应用”。
还有一些应用，运行状态信息就很重要了，如果因为重启而丢失了状态是绝对无法接受的，这样的应用就是“有状态应用”。</description></item><item><title/><link>https://googoo-s.github.io/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-YAML/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-YAML/</guid><description>声明式与命令式是怎么回事 “声明式”，在 Kubernetes 出现之前比较少见，它与“命令式”完全相反，不关心具体的过程，更注重结果。我们不需要“教”计算机该怎么做，只要告诉它一个目标状态，它自己就会想办法去完成任务，相比起来自动化、智能化程度更高。
什么是 YAML YAML 的官网（https://yaml.org/）有对语言规范的完整介绍，所以我就不在这里列举语言的细节了，只讲一些与 Kubernetes 相关的要点，帮助你快速掌握。
YAML 是 JSON 的超集，支持整数、浮点数、布尔、字符串、数组和对象等数据类型
但和 JSON 比起来，YAML 的语法更简单，形式也更清晰紧凑，比如：
使用空白与缩进表示层次（有点类似 Python），可以不使用花括号和方括号。</description></item><item><title/><link>https://googoo-s.github.io/Kubernetes/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Kubernetes/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</guid><description>为啥要有命名空间 Kubernetes 的名字空间并不是一个实体对象，只是一个逻辑上的概念。
它可以把集群切分成一个个彼此独立的区域，然后我们把对象放到这些区域里，就实现了类似容器技术里 namespace 的隔离效果，应用只能在自己的名字空间里分配资源和运行，不会干扰到其他名字空间里的应用。
Kubernetes面对大规模集群、海量节点时的一种现实考虑。）
可能会有大量的 Pod，这就使得资源争抢和命名冲突的概率大大增加了。
多团队、多项目共用 Kubernetes 的时候，我们就需要把集群给适当地“局部化”，为每一类用户创建出只属于它自己的“工作空间”
区分测试，生产环境
如何使用名字空间 创建</description></item><item><title/><link>https://googoo-s.github.io/Kubernetes/%E5%AD%98%E5%82%A8-PersistentVolume/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Kubernetes/%E5%AD%98%E5%82%A8-PersistentVolume/</guid><description>一起来了解 Volume 的高级用法，看看 Kubernetes 管理存储资源的 API 对象 PersistentVolume、PersistentVolumeClaim、StorageClass，然后使用本地磁盘来创建实际可用的存储卷。
什么是 PersistentVolume PersistentVolume专门用来表示持久存储设备，但隐藏了存储的底层实现，我们只需要知道它能安全可靠地保管数据就可以了（由于 PersistentVolume 这个词很长，一般都把它简称为 PV）。
作为存储的抽象，PV 实际上就是一些存储设备、文件系统，比如 Ceph、GlusterFS、NFS，甚至是本地磁盘，管理它们已经超出了 Kubernetes 的能力范围，所以，一般会由系统管理员单独维护，然后再在 Kubernetes 里创建对应的 PV</description></item><item><title/><link>https://googoo-s.github.io/Kubernetes/%E5%AE%B9%E5%99%A8-docker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Kubernetes/%E5%AE%B9%E5%99%A8-docker/</guid><description>Docker 相关内容 [[如何容器化应用]]
[[dockerfile]]
[[与外界资源的共享]]
什么是 CRI NCF 已经成立一年了，而 Kubernetes 也已经发布了 1.0 版，可以正式用于生产环境，这些都标志着 Kubernetes 已经成长起来了，不再需要“看脸色吃饭”。于是它就宣布加入了 CNCF，成为了第一个 CNCF 托管项目，想要借助基金会的力量联合其他厂商，一起来“扳倒”Docker。
Kubernetes 引入了一个新的接口标准：CRI ，Container Runtime Interface。</description></item><item><title/><link>https://googoo-s.github.io/Kubernetes/%E5%AE%B9%E5%99%A8-%E5%AE%B9%E5%99%A8%E7%9A%84%E6%9C%AC%E8%B4%A8%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%9B%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Kubernetes/%E5%AE%B9%E5%99%A8-%E5%AE%B9%E5%99%A8%E7%9A%84%E6%9C%AC%E8%B4%A8%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%9B%E7%A8%8B/</guid><description>容器就是操作系统里一个特殊的“沙盒”环境，里面运行的进程只能看到受限的信息，与外部系统实现了隔离。
容器隔离的目的是为了系统安全，限制了进程能够访问的各种资源。
相比虚拟机技术，容器更加轻巧、更加高效，消耗的系统资源非常少，在云计算时代极具优势。
容器的基本实现技术是 Linux 系统里的 namespace、cgroup、chroot。
广义上来说，容器技术是动态的容器、静态的镜像和远端的仓库这三者的组合。</description></item><item><title/><link>https://googoo-s.github.io/Kubernetes/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E4%B8%8EKubernetes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Kubernetes/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E4%B8%8EKubernetes/</guid><description>容器技术的核心概念是容器、镜像、仓库，使用这三大基本要素我们就可以轻松地完成应用的打包、分发工作，实现“一次开发，到处运行”的梦想。
现实生产环境的复杂程度实在是太高了，除了最基本的安装，还会有各式各样的需求，
服务发现
负载均衡
状态监控
健康检查
扩容缩容
应用迁移</description></item><item><title/><link>https://googoo-s.github.io/Kubernetes/%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Kubernetes/%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0/</guid><description>在 Kubernetes 里，使用命令 kubectl scale，我们就可以轻松调整 Deployment,StatefulSet 下属的 Pod 数量。
除了“应用伸缩”，其他的运维操作比如应用更新、版本回退等工作
滚动更新，使用 kubectl rollout 实现用户无感知的应用升级和降级
Kubernetes 如何定义应用版本 在 Kubernetes 里，版本更新使用的不是 API 对象，而是两个命令：kubectl apply 和 kubectl rollout，当然它们也要搭配部署应用所需要的 Deployment、DaemonSet 等 YAML 文件。</description></item><item><title/><link>https://googoo-s.github.io/Kubernetes/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7Metrics-Server%E5%92%8CPrometheus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Kubernetes/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7Metrics-Server%E5%92%8CPrometheus/</guid><description>观测集群是不能用“探针”这种简单的方式的，所以今天我就带你一起来看看 Kubernetes 为集群提供的两种系统级别的监控项目：**Metrics Server 和 Prometheus，**以及基于它们的水平自动伸缩对象 HorizontalPodAutoscaler。
Metrics Server https://github.com/kubernetes-sigs/metrics-server
top 能够实时显示当前系统的 CPU 和内存利用率，它是性能分析和调优的基本工具，非常有用。Kubernetes 也提供了类似的命令，就是 kubectl top，不过默认情况下这个命令不会生效，必须要安装一个插件 Metrics Server 才可以</description></item><item><title/><link>https://googoo-s.github.io/Kubernetes/%E7%BD%91%E7%BB%9C-CNI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Kubernetes/%E7%BD%91%E7%BB%9C-CNI/</guid><description>讲讲 Kubernetes 的网络接口标准 CNI，以及 Calico、Cilium 等性能更好的网络插件。
Kubernetes 的网络模型 Docker 的 null、host 和 bridge 三种网络模式还有印象吗？这里我重新画了一张图，描述了 Docker 里最常用的 bridge 网络模式：
Docker 会创建一个名字叫“docker0”的网桥，默认是私有网段“172.</description></item><item><title/><link>https://googoo-s.github.io/Kubernetes/%E7%BD%91%E7%BB%9C-Ingress/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Kubernetes/%E7%BD%91%E7%BB%9C-Ingress/</guid><description>集群进出流量的总管
对网络流量的管理方案还是太简单，离复杂的现代应用架构需求还有很大的差距，所以 Kubernetes 就在 Service 之上又提出了一个新的概念：Ingress。
为什么要有 Ingress Service 的功能和运行机制，它本质上就是一个由 kube-proxy 控制的四层负载均衡，在 TCP/IP 协议栈上转发流量
但在四层上的负载均衡功能还是太有限了，只能够依据 IP 地址和端口号做一些简单的判断和组合，而我们现在的绝大多数应用都是跑在七层的 HTTP/HTTPS 协议上的，有更多的高级路由条件，比如主机名、URI、请求头、证书等等，而这些在 TCP/IP 网络栈里是根本看不见的。</description></item><item><title/><link>https://googoo-s.github.io/Kubernetes/%E7%BD%91%E7%BB%9C-Service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Kubernetes/%E7%BD%91%E7%BB%9C-Service/</guid><description>而在云原生时代，微服务无疑是应用的主流形态。为了更好地支持微服务以及服务网格这样的应用架构，Kubernetes 又专门定义了一个新的对象：Service，它是集群内部的负载均衡机制，用来解决服务发现的关键问题
为什么要有 Service 解决服务发现的问题，实现负载均衡，它们在前端与后端之间加入了一个“中间层”，屏蔽后端的变化，为前端提供一个稳定的服务。
LVS、Nginx 毕竟不是云原生技术，所以 Kubernetes 就按照这个思路，定义了新的 API 对象**：Service。**
Service 的工作原理和 LVS、Nginx 差不多，Kubernetes 会给Service 分配一个静态 IP 地址，然后它再去自动管理、维护后面动态变化的 Pod 集合，当客户端访问 Service，它就根据某种策略，把流量转发给后面的某个 Pod。</description></item><item><title/><link>https://googoo-s.github.io/Kubernetes/%E8%B5%84%E6%BA%90%E5%92%8C%E6%8E%A2%E9%92%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Kubernetes/%E8%B5%84%E6%BA%90%E5%92%8C%E6%8E%A2%E9%92%88/</guid><description>容器资源配额 cgroup、chroot。其中的 namespace 实现了独立的进程空间，chroot 实现了独立的文件系统，但唯独没有看到 cgroup 的具体应用。cgroup 的作用是管控 CPU、内存，保证容器不会无节制地占用基础资源，进而影响到系统里的其他应用。
CPU、内存直接“内置”在系统里的，不像硬盘那样需要“外挂”，所以申请和管理的过程也就会简单很多。具体的申请方法很简单，只要在 Pod 容器的描述部分添加一个新字段 resources 就可以了，
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 apiVersion: v1 kind: Pod metadata: name: ngx-pod-resources spec: containers: - image: nginx:alpine name: ngx resources: requests: cpu: 10m memory: 100Mi limits: cpu: 20m memory: 200Mi containers.</description></item><item><title/><link>https://googoo-s.github.io/Kubernetes/%E9%85%8D%E7%BD%AE-ConfigMap-Secret/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Kubernetes/%E9%85%8D%E7%BD%AE-ConfigMap-Secret/</guid><description>配置方式
第一种是编写 Dockerfile，用 COPY 指令把配置文件打包到镜像里；
第二种是在运行时使用 docker cp 或者 docker run -v，把本机的文件拷贝进容器。
。第一种方法相当于是在镜像里固定了配置文件，不好修改，不灵活，第二种方法则显得有点“笨拙”，不适合在集群中自动化运维管理。
ConfigMap/Secret 首先你要知道，应用程序有很多类别的配置信息，但从数据安全的角度来看可以分成两类：</description></item><item><title/><link>https://googoo-s.github.io/lua/lua-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/lua/lua-overview/</guid><description>Lua 简介 Lua 是一个小巧的脚本语言。是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组并于 1993 年开发。其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。Lua 由标准 C 编写而成，几乎在所有操作系统和平台上都可以编译、运行。Lua 并没有提供强大的库，这是由它的定位决定的。所以 Lua 不适合作为开发独立应用程序的语言。Lua 有一个同时进行的 JIT 项目，提供在特定平台上的即时编译功能。</description></item><item><title/><link>https://googoo-s.github.io/lua/Lua%E9%AB%98%E7%BA%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/lua/Lua%E9%AB%98%E7%BA%A7/</guid><description>元表 元表 (metatable) 的表现行为类似于 C++ 语言中的操作符重载，例如我们可以重载 &amp;ldquo;__add&amp;rdquo; 元方法 (metamethod)，来计算两个 Lua 数组的并集；或者重载 &amp;ldquo;__index&amp;rdquo; 方法，来定义我们自己的 Hash 函数。Lua 提供了两个十分重要的用来处理元表的方法
setmetatable(table, metatable)：此方法用于为一个表设置元表。</description></item><item><title/><link>https://googoo-s.github.io/maven/maven-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/maven/maven-overview/</guid><description>什么是 Maven Maven 是一种用来管理 Java 项目的工具，但不是那种用来管理资源规划和调度的工具。 相反，它处理的是管理一个具体的项目所涉及的各种任务，如编译、测试、打包、文档以及分发。
Maven 包括以下的几个部分。
一组用于处理依赖管理、目录结构以及构建工作流的约定。
基于这些约定实现的标准化 ，可以极大地简化开发过程。例如，一个常用的目录结构使得开发者可以更加容易地跟上不熟悉的项目的节奏。 一个用于项目配置的XML Schema：项目对象模型（Project Object Model），简称POM①。</description></item><item><title/><link>https://googoo-s.github.io/MongoDB/%E4%B9%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MongoDB/%E4%B9%A6/</guid><description>![[mongo权威指南(第三版).pdf]]</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</guid><description>MySQL 的基本架构图 MySQL 可以分为 Server 层和存储引擎层两部分
连接器 连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令为
1 mysql -h$ip -P$port -u$user -p 连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E4%BA%8B%E5%8A%A1-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8CMVCC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E4%BA%8B%E5%8A%A1-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8CMVCC/</guid><description>已知的矛盾
只查询。可重复读隔离级别，事务 T 启动的时候会创建一个视图 read-view，之后事务 T 执行期间，即使有其他事务修改了数据，事务 T 看到的仍然跟在启动时看到的一样。
更新后查询。在写方面 一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，它又不能这么超然了，会被锁住，进入等待状态。问题是，既然进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值是啥。
1 2 3 4 5 6 mysql&amp;gt; CREATE TABLE `t` ( `id` int(11) NOT NULL, `k` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB; insert into t(id, k) values(1,1),(2,2); 对于，上述的表格采用一下操作</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E4%BA%8B%E5%8A%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E4%BA%8B%E5%8A%A1/</guid><description>事务的特性 原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成
一致性（Consistency）：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E4%BA%8B%E5%8A%A1%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E4%BA%86%E5%90%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E4%BA%8B%E5%8A%A1%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E4%BA%86%E5%90%97/</guid><description>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：
**针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，**因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
**针对当前读（select &amp;hellip; for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，**因为当执行 select &amp;hellip; for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8-%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8-%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/</guid><description>这点没错，但是大家知道 B+ 树里的节点里存放的是什么呢？查询数据的过程又是怎样的？
这次，我们从数据页的角度看 B+ 树，看看每个节点长啥样。
InnoDB 是如何存储数据的？ 记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。
InnoDB 的数据是按「数据页」为单位来读写的
InnoDB 数据页的默认大小是 16KB</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</guid><description>解锁这些面试题：
MySQL 的 NULL 值会占用空间吗？
MySQL 怎么知道 varchar(n) 实际占用数据的大小？
varchar(n) 中 n 最大取值为多少？</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8_Change-buffer-%E5%92%8C-buffer-pool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8_Change-buffer-%E5%92%8C-buffer-pool/</guid><description>Change Buffer change buffer 当需要更新一个数据页时，如果数据页在内存中就直接更新，
而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下**，InnoDB 会将这些更新操作缓存在 change buffer 中**，
在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8_%E8%A1%8C%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8_%E8%A1%8C%E7%BB%93%E6%9E%84/</guid><description>InnoDB 行格式有哪些？ 行格式（row_format），就是一条记录的存储结构。
InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。
Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。
由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E6%97%A5%E5%BF%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E6%97%A5%E5%BF%97/</guid><description>Update 的执行过程
1 UPDATEt_userSETname=&amp;#39;xiaolin&amp;#39;WHEREid=1; 客户端先通过连接器建立连接，连接器自会判断用户身份；
因为这是一条 update 语句，所以不需要经过查询缓存，但是表上有更新语句，是会把整个表的查询缓存清空的，所以说查询缓存很鸡肋，在 MySQL 8.0 就被移除这个功能了；
解析器会通过词法分析识别出关键字 update，表名等等，构建出语法树，接着还会做语法分析，判断输入的语句是否符合 MySQL 语法；</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95-Count%E6%95%88%E7%8E%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95-Count%E6%95%88%E7%8E%87/</guid><description>Count(*)的实现方式 在不同的 MySQL 引擎中，count(*) 有不同的实现方式:
MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；
而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。
什么 InnoDB 不跟 MyISAM 一样，也把数字存起来呢?</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95-MySQL-%E4%BD%BF%E7%94%A8-like-x%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%A4%B1%E6%95%88%E5%90%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95-MySQL-%E4%BD%BF%E7%94%A8-like-x%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%A4%B1%E6%95%88%E5%90%97/</guid><description>谁还没碰过索引失效呢
使用左模糊匹配（like &amp;ldquo;%xx&amp;rdquo;）并不一定会走全表扫描，关键还是看数据表中的字段。
如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，也不会走全表扫描（type=all），而是走全扫描二级索引树(type=index)。
题目一 数据库表如下，id 是主键索引，name 是二级索引，其他字段都是非索引字段
这四条模糊匹配的查询语句，第一条和第二条都会走索引扫描，而且都是选择扫描二级索引（index_name），我贴个第二条查询语句的执行计划结果图：
而第三和第四条会发生索引失效，执行计划的结果 type= ALL，代表了全表扫描。
题目二 数据库表特别之处在于，只有两个字段，一个是主键索引 id，另外一个是二级索引 name。</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95-MySQL-%E5%8D%95%E8%A1%A8%E4%B8%8D%E8%A6%81%E8%B6%85%E8%BF%87-2000W-%E8%A1%8C%E9%9D%A0%E8%B0%B1%E5%90%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95-MySQL-%E5%8D%95%E8%A1%A8%E4%B8%8D%E8%A6%81%E8%B6%85%E8%BF%87-2000W-%E8%A1%8C%E9%9D%A0%E8%B0%B1%E5%90%97/</guid><description>mysql 最大建议行数2000w,靠谱吗? - 京东云开发者的个人空间 - OSCHINA - 中文开源技术交流社区
总结 MySQL 的表数据是以页的形式存放的，页在磁盘中不一定是连续的。
页的空间是 16K, 并不是所有的空间都是用来存放数据的，会有一些固定的信息，如，页头，页尾，页码，校验码等等。</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>什么是索引 那换到数据库中，索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。
索引的分类。 我们可以按照四个角度来分类索引。
按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。
按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。
按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。
按「字段个数」分类：单列索引、联合索引。
接下来，按照这些角度来说说各类索引的特点
按数据结构分类 每一种存储引擎支持的索引类型不一定相同，我在表中总结了 MySQL 常见的存储引擎 InnoDB、MyISAM 和 Memory 分别支持的索引类型。</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95-%E7%90%86%E8%A7%A3-B-%E6%A0%91B+-%E6%A0%91%E7%89%B9%E7%82%B9%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95-%E7%90%86%E8%A7%A3-B-%E6%A0%91B+-%E6%A0%91%E7%89%B9%E7%82%B9%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</guid><description>为什么 MySQL 采用 B+ 树作为索引？
B 树 B 树就是常说的“B 减树（B- 树）”，又名平衡多路（即不止两个子树）查找树，它和平衡二叉树的不同有这么几点：
平衡二叉树节点最多有两个子树，而 B 树每个节点可以有多个子树，M 阶 B 树表示该树每个节点最多有 M 个子树</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95/</guid><description>索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。
常见的索引模型 索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同
InnoDB的索引模型 在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。
InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。
B+树的结构 B+树是B树的变体，具有比B树更高的查询性能
回顾一个m阶的B树具有如下几个特征：
根结点至少有两个子女</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E9%94%81-MySQL-%E5%8F%AF%E4%BB%A5%E9%98%B2%E6%AD%A2%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B9%BB%E8%AF%BB%E5%90%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E9%94%81-MySQL-%E5%8F%AF%E4%BB%A5%E9%98%B2%E6%AD%A2%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B9%BB%E8%AF%BB%E5%90%97/</guid><description>昨天有位读者在美团二面的时候，被问到关于幻读的问题：
面试官反问的大概意思是，MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？
答案是可以的。
接下来，通过几个小实验来证明这个结论吧，顺便再帮大家复习一下记录锁+间隙锁。
#什么是幻读？ 首先来看看 MySQL 文档是怎么定义幻读（Phantom Read）的:
The so-called phantom problem occurs within a transaction when the same query produces different sets of rows at different times.</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E9%94%81-MySQL-%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E9%94%81%E7%9A%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E9%94%81-MySQL-%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E9%94%81%E7%9A%84/</guid><description>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁，所以后面的内容都是基于 InnoDB 引擎的。
什么 SQL 语句会加行级锁？ 普通的 select 语句是不会对记录加锁的（除了串行化隔离级别），因为它属于快照读，是通过 MVCC（多版本并发控制）实现的。
如果要在查询时对记录加行级锁，可以使用下面这两个方式，这两种查询会加锁的语句称为锁定读。
1 2 3 4 //对读取的记录加共享锁(S型锁) select .</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E9%94%81-MySQL%E6%AD%BB%E9%94%81%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E9%94%81-MySQL%E6%AD%BB%E9%94%81%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/</guid><description>死锁的发生 我建了一张订单表，其中 id 字段为主键索引，order_no 字段普通索引，也就是非唯一索引：
1 2 3 4 5 6 7 8 CREATETABLE`t_order`(`id`intNOTNULLAUTO_INCREMENT,`order_no`intDEFAULTNULL,`create_date`datetimeDEFAULTNULL,PRIMARYKEY(`id`),KEY`index_order`(`order_no`)USINGBTREE)ENGINE=InnoDB; 假设这时有两事务，一个事务要插入订单 1007 ，另外一个事务要插入订单 1008，因为需要对订单做幂等性校验，所以两个事务先要查询该订单是否存在，不存在才插入记录，过程如下：</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E9%94%81-Update%E6%B2%A1%E5%8A%A0%E7%B4%A2%E5%BC%95%E4%BC%9A%E9%94%81%E5%85%A8%E8%A1%A8%E5%90%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E9%94%81-Update%E6%B2%A1%E5%8A%A0%E7%B4%A2%E5%BC%95%E4%BC%9A%E9%94%81%E5%85%A8%E8%A1%A8%E5%90%97/</guid><description>大家好，我是小林。
昨晚在群划水的时候，看到有位读者说了这么一件事。
大概就是，在线上执行一条 update 语句修改数据库数据的时候，where 条件没有带上索引，导致业务直接崩了，被老板教训了一波
这次我们就来看看：
为什么会发生这种的事故？
又该如何避免这种事故的发生？
说个前提，接下来说的案例都是基于 InnoDB 存储引擎，且事务的隔离级别是可重复读。
为什么会发生这种的事故？ InnoDB 存储引擎的默认事务隔离级别是「可重复读」，但是在这个隔离级别下，在多个事务并发的时候，会出现幻读的问题，所谓的幻读是指在同一事务下，连续执行两次同样的查询语句，第二次的查询语句可能会返回之前不存在的行。</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E9%94%81/</guid><description>根据加锁的范围可以分为全局锁，表级锁，行锁。
![[Pasted image 20230727224159.png]]
全局锁 全局锁就是对整个数据库实例加锁。
全局锁的用法 全局读锁：MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)
FTWRL
FTWRL 前有读写的话 ,FTWRL 都会等待 读写执行完毕后才执行</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/1.%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/1.%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95/</guid><description>查询过程 select id from T where k=5
这个查询语句在索引树上查找的过程，先是通过 B+ 树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认为数据页内部通过二分法来定位记录。
对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一个不满足 k=5 条件的记录。
对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/10.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%9F%A5%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E4%B9%9F%E6%89%A7%E8%A1%8C%E8%BF%99%E4%B9%88%E6%85%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/10.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%9F%A5%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E4%B9%9F%E6%89%A7%E8%A1%8C%E8%BF%99%E4%B9%88%E6%85%A2/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 mysql&amp;gt; CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB; delimiter ;; create procedure idata() begin declare i int; set i=1; while(i&amp;lt;=100000) do insert into t values(i,i); set i=i+1; end while; end;; delimiter ; call idata(); 第一类：查询长时间不返回 1 2 mysql&amp;gt; select * from t where id=1; 大概率是表 t 被锁住了。接下来分析原因的时候，一般都是首先执行一下 show processlist 命令，看看当前语句处于什么状态</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/11.%E5%B9%BB%E8%AF%BB%E6%98%AF%E4%BB%80%E4%B9%88%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/11.%E5%B9%BB%E8%AF%BB%E6%98%AF%E4%BB%80%E4%B9%88%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</guid><description>1 2 3 4 5 6 7 8 9 10 11 CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`) ) ENGINE=InnoDB; insert into t values(0,0,0),(5,5,5), (10,10,10),(15,15,15),(20,20,20),(25,25,25); 1 2 3 4 begin; select * from t where d=5 for update; commit; 比较好理解的是，这个语句会命中 d=5 的这一行，对应的主键 id=5，**因此在 select 语句执行完成后，id=5 这一行会加一个写锁，而且由于两阶段锁协议，这个写锁会在执行 commit 语句的时候释放。**由于字段 d 上没有索引，因此这条查询语句会做全表扫描。那么，其他被扫描到的，但是不满足条件的 5 行记录上，会不会被加锁呢？</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/12.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%94%B9%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E9%94%81%E8%BF%99%E4%B9%88%E5%A4%9A/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/12.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%94%B9%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%E9%94%81%E8%BF%99%E4%B9%88%E5%A4%9A/</guid><description>加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。
原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。
原则 2：查找过程中访问到的对象才会加锁。
优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。
优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/13.MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A5%AE%E9%B8%A9%E6%AD%A2%E6%B8%B4%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/13.MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A5%AE%E9%B8%A9%E6%AD%A2%E6%B8%B4%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/</guid><description/></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/14.MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E7%9A%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/14.MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E7%9A%84/</guid><description>得到的结论是：只要 redo log 和 binlog 保证持久化到磁盘，就能确保 MySQL 异常重启后，数据可以恢复。
redo log 的写入流程是怎么样的，如何保证 redo log 真实地写入了磁盘。那么今天，我们就再一起看看 MySQL 写入 binlog 和 redo log 的流程</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/15.MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E7%9A%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/15.MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E7%9A%84/</guid><description>我不止一次地和你提到了 binlog，大家知道 binlog 可以用来归档，也可以用来做主备同步，但它的内容是什么样的呢？为什么备库执行了 binlog 就可以跟主库保持一致了呢？
MySQL 主备的基本原理 上图就是基本的主备切换流程：（M-S结构）
在状态 1 中，客户端的读写都直接访问节点 A，而节点 B 是 A 的备库，只是将 A 的更新都同步过来，到本地执行。这样可以保持节点 B 和 A 的数据是相同的。</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/16.MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/16.MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84/</guid><description>正常情况下，只要主库执行更新生成的所有 binlog，都可以传到备库并被正确地执行，备库就能达到跟主库一致的状态，这就是最终一致性
MySQL 要提供高可用能力，只有最终一致性是不够的。
我再放一次上一篇文章中讲到的双 M 结构的主备切换流程图
主备延迟 在介绍主动切换流程的详细步骤之前，我要先跟你说明一个概念，即**“同步延迟”。与数据同步有关的时间点主要包括以下三个：**
主库 A 执行完成一个事务，写入 binlog，我们把这个时刻记为 T1;
之后传给备库 B，我们把备库 B 接收完这个 binlog 的时刻记为 T2;</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/17.%E5%A4%87%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BB%B6%E8%BF%9F%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%B0%8F%E6%97%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/17.%E5%A4%87%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BB%B6%E8%BF%9F%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%B0%8F%E6%97%B6/</guid><description>你会发现，这些场景里，不论是偶发性的查询压力，还是备份，对备库延迟的影响一般是分钟级的，而且在备库恢复正常以后都能够追上来。但是，如果备库执行日志的速度持续低于主库生成日志的速度，那这个延迟就有可能成了小时级别。
备库并行复制能力
谈到主备的并行复制能力，我们要关注的是图中黑色的两个箭头。
一个箭头代表了客户端写入主库（更重要）
另一箭头代表的是备库上 sql_thread 执行中转日志（relay log）
在主库上，影响并发度的原因就是各种锁了。
而日志在备库上的执行，就是图中备库上 sql_thread 更新数据 (DATA) 的逻辑。如果是用单线程的话，就会导致备库应用日志不够快，造成主备延迟</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/18.%E4%B8%BB%E5%BA%93%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86%E4%BB%8E%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/18.%E4%B8%BB%E5%BA%93%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86%E4%BB%8E%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E/</guid><description>大多数的互联网应用场景都是读多写少，因此你负责的业务，在发展过程中很可能先会遇到读性能的问题。而在数据库层解决读性能问题，所以需要一主多从。
图中，虚线箭头表示的是主备关系，也就是 A 和 A’互为主备， 从库 B、C、D 指向的是主库 A。一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。
在一主多从架构下，主库故障后的主备切换问题。
下图就是主库发生故障，主备切换后的结果。相比于一主一备的切换流程，一主多从结构在切换完成后**，A’会成为新的主库，从库 B、C、D 也要改接到 A’。正是由于多了从库 B、C、D 重新指向的这个过程**，所以主备切换的复杂性也相应增加了。
基于位点的主备切换 当我们把节点 B 设置成节点 A’的从库的时候，需要执行一条 change master 命令</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/19.%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E7%9A%84%E5%9D%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/19.%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E7%9A%84%E5%9D%91/</guid><description/></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/2.%E5%A6%82%E4%BD%95%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E5%8A%A0%E7%B4%A2%E5%BC%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/2.%E5%A6%82%E4%BD%95%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E5%8A%A0%E7%B4%A2%E5%BC%95/</guid><description>乎所有的系统都支持邮箱登录，如何在邮箱这样的字段上建立合理的索引
1 2 3 4 5 mysql&amp;gt; create table SUser( ID bigint unsigned primary key, email varchar(64), ... )engine=innodb; MySQL 是支持前缀索引的，也就是说，你可以定义字符串的一部分作为索引。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/20.%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E5%90%A6%E5%87%BA%E9%97%AE%E9%A2%98-%E4%BA%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/20.%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E5%90%A6%E5%87%BA%E9%97%AE%E9%A2%98-%E4%BA%86/</guid><description/></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/21.%E8%BF%98%E6%9C%89kill%E4%B8%8D%E6%8E%89%E7%9A%84%E8%AF%AD%E5%8F%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/21.%E8%BF%98%E6%9C%89kill%E4%B8%8D%E6%8E%89%E7%9A%84%E8%AF%AD%E5%8F%A5/</guid><description/></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/22.%E6%88%91%E6%9F%A5%E8%BF%99%E4%B9%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AD%98%E6%89%93%E7%88%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/22.%E6%88%91%E6%9F%A5%E8%BF%99%E4%B9%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AD%98%E6%89%93%E7%88%86/</guid><description/></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/23.%E5%88%B0%E5%BA%95%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E7%94%A8join/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/23.%E5%88%B0%E5%BA%95%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E7%94%A8join/</guid><description/></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/24.join%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/24.join%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96/</guid><description>介绍了 join 语句的两种算法，分别是 Index Nested-Loop Join(NLJ) 和 Block Nested-Loop Join(BNL)。
这两个算法都还有继续优化的空间，我们今天就来聊聊这个话题。
我还是创建两个表 t1、t2 来和你展开今天的问题
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 create table t1(id int primary key, a int, b int, index(a)); create table t2 like t1; drop procedure idata; delimiter ;; create procedure idata() begin declare i int; set i=1; while(i&amp;lt;=1000)do insert into t1 values(i, 1001-i, i); set i=i+1; end while; set i=1; while(i&amp;lt;=1000000)do insert into t2 values(i, i, i); set i=i+1; end while; end;; delimiter ; call idata(); Multi-Range Read 优化 这个优化的主要目的是尽量使用顺序读盘。</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/25.%E4%B8%BA%E5%95%A5%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/25.%E4%B8%BA%E5%95%A5%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%8D/</guid><description>我们在优化 join 查询的时候使用到了临时表。当时，我们是这么用的：
create temporary table temp_t like t1; alter table temp_t add index(b); insert into temp_t select * from t2 where b&amp;gt;=1 and b&amp;lt;=2000; select * from t1 join temp_t on (t1.</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/26.%E8%BF%98%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8Memory%E5%BC%95%E6%93%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/26.%E8%BF%98%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8Memory%E5%BC%95%E6%93%8E/</guid><description>内存表的数据组织结构
create table t1(id int primary key, c int) engine=Memory; create table t2(id int primary key, c int) engine=innodb; insert into t1 values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(0,0); insert into t2 values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(0,0);</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/27.%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%BA%E5%95%A5%E4%B8%8D%E8%BF%9E%E7%BB%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/27.%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%BA%E5%95%A5%E4%B8%8D%E8%BF%9E%E7%BB%AD/</guid><description>由于自增主键可以让主键索引尽量地保持递增顺序插入，避免了页分裂，因此索引更紧凑。
自增主键不能保证连续递增
CREATE TABLE t ( id int(11) NOT NULL AUTO_INCREMENT, c int(11) DEFAULT NULL, d int(11) DEFAULT NULL, PRIMARY KEY (id), UNIQUE KEY c (c) ) ENGINE=InnoDB;</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/28.insert%E4%B8%BA%E5%95%A5%E9%94%81%E9%82%A3%E4%B9%88%E5%A4%9A/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/28.insert%E4%B8%BA%E5%95%A5%E9%94%81%E9%82%A3%E4%B9%88%E5%A4%9A/</guid><description>MySQL 对自增主键锁做了优化，尽量在申请到自增 id 以后，就释放自增锁。
insert 语句是一个很轻量的操作。不过，这个结论对于“普通的 insert 语句”才有效。也就是说，还有些 insert 语句是属于“特殊情况”的，在执行过程中需要给其他资源加锁，或者无法在申请到自增 id 以后就立马释放自增锁
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 CREATE TABLE t ( id int(11) NOT NULL AUTO_INCREMENT, c int(11) DEFAULT NULL, d int(11) DEFAULT NULL, PRIMARY KEY (id), UNIQUE KEY c (c) ) ENGINE=InnoDB; insert into t values(null, 1,1); insert into t values(null, 2,2); insert into t values(null, 3,3); insert into t values(null, 4,4); create table t2 like t insert … select 语句 在可重复读隔离级别下，binlog_format=statement 时执行：</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/29%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/29%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8/</guid><description>如果可以控制对源表的扫描行数和加锁范围很小的话，我们简单地使用 insert … select 语句即可实现
更稳妥的方案是先将数据写到外部文本文件，然后再写回目标表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 create database db1; use db1; create table t(id int primary key, a int, b int, index(a))engine=innodb; delimiter ;; create procedure idata() begin declare i int; set i=1; while(i&amp;lt;=1000)do insert into t values(i,i,i); set i=i+1; end while; end;; delimiter ; call idata(); create database db2; create table db2.</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/3.MySQL-%E9%94%99%E9%80%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/3.MySQL-%E9%94%99%E9%80%89/</guid><description>MySQL 中一张表其实是可以支持多个索引的。使用哪个索引是由 MySQL 来确定的。
一条本来可以执行得很快的语句，却由于 MySQL 选错了索引，而导致执行速度变得很慢
1 2 3 4 5 6 7 8 9 CREATE TABLE `t` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `a` (`a`), KEY `b` (`b`) ) ENGINE=InnoDB； 使用存储过程来插入数据</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/30.grant%E4%B9%8B%E5%90%8E%E8%A6%81%E8%B7%9F%E7%9D%80flush-privileges%E5%90%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/30.grant%E4%B9%8B%E5%90%8E%E8%A6%81%E8%B7%9F%E7%9D%80flush-privileges%E5%90%97/</guid><description>grant 语句是用来给用户赋权的。不知道你有没有见过一些操作文档里面提到，grant 之后要马上跟着执行一个 flush privileges 命令，才能使赋权语句生效
下来，我就先和你介绍一下 grant 语句和 flush privileges 语句分别做了什么事情
create user &amp;lsquo;ua&amp;rsquo;@&amp;rsquo;%&amp;rsquo; identified by &amp;lsquo;pa&amp;rsquo;;
这条语句的逻辑是创建一个用户’ua’@’%’，密码是 pa。在 MySQL 里面，用户名 (user)+ 地址 (host) 才表示一个用户，因此 ua@ip1 和 ua@ip2 代表的是两个不同的用户。</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/31-%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/31-%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8/</guid><description>分区表有什么问题，为什么公司规范不让使用分区表呢?
分区表是什么? 1 2 3 4 5 6 7 8 9 10 11 CREATE TABLE t ( ftime datetime NOT NULL, c int(11) DEFAULT NULL, KEY (ftime) ) ENGINE=InnoDB DEFAULT CHARSET=latin1 PARTITION BY RANGE (YEAR(ftime)) (PARTITION p_2017 VALUES LESS THAN (2017) ENGINE = InnoDB, PARTITION p_2018 VALUES LESS THAN (2018) ENGINE = InnoDB, PARTITION p_2019 VALUES LESS THAN (2019) ENGINE = InnoDB, PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE = InnoDB); insert into t values(&amp;#39;2017-4-1&amp;#39;,1),(&amp;#39;2018-4-1&amp;#39;,1); 我在表 t 中初始化插入了两行记录，按照定义的分区规则**，这两行记录分别落在 p_2018 和 p_2019 这两个分区**上。</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/32.%E8%87%AA%E5%A2%9Eid%E7%94%A8%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/32.%E8%87%AA%E5%A2%9Eid%E7%94%A8%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E/</guid><description>既然自增 id 有上限，就有可能被用完。但是，自增 id 用完了会怎么样呢？今天这篇文章，我们就来看看 MySQL 里面的几种自增 id，一起分析一下它们的值达到上限以后，会出现什么情况。
表定义自增值 id 表定义的自增值达到上限后的逻辑是：再申请下一个 id 时，得到的值保持不变
1 2 3 4 5 6 7 8 9 10 11 12 create table t(id int unsigned auto_increment primary key) auto_increment=4294967295; insert into t values(null); //成功插入一行 4294967295 show create table t; /* CREATE TABLE t ( id int(10) unsigned NOT NULL AUTO_INCREMENT, PRIMARY KEY (id) ) ENGINE=InnoDB AUTO_INCREMENT=4294967295; */ insert into t values(null); //Duplicate entry &amp;#39;4294967295&amp;#39; for key &amp;#39;PRIMARY&amp;#39; 以看到，第一个 insert 语句插入数据成功后，这个表的 AUTO_INCREMENT 没有改变（还是 4294967295），就导致了第二个 insert 语句又拿到相同的自增 id 值，再试图执行插入语句，报主键冲突错误</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/4.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84MySQL%E4%BC%9A%E6%8A%96%E4%B8%80%E4%B8%8B--Flush/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/4.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84MySQL%E4%BC%9A%E6%8A%96%E4%B8%80%E4%B8%8B--Flush/</guid><description>一条 SQL 语句，正常执行的时候特别快，但是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持续时间还很短。
不知道你有没有遇到过这样的场景，一条 SQL 语句，正常执行的时候特别快，但是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持续时间还很短。
你的 SQL 语句为什么变“慢”了 我为你介绍了 WAL 机制。现在你知道了，InnoDB 在处理更新语句的时候，只做了写日志这一个磁盘操作。这个日志叫作 redo log（重做日志）
当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。
做下类比的话，掌柜记账的账本是数据文件，记账用的粉板是日志文件（redo log），掌柜的记忆就是内存。
掌柜总要找时间把账本更新一下，这对应的就是把内存里的数据写入磁盘的过程，术语就是 flush</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/5.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%88%A0%E6%8E%89%E4%B8%80%E5%8D%8A%E8%A1%A8%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%8F%98---%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E7%A9%BA%E9%97%B4%E5%9B%9E%E6%94%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/5.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%88%A0%E6%8E%89%E4%B8%80%E5%8D%8A%E8%A1%A8%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%8F%98---%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E7%A9%BA%E9%97%B4%E5%9B%9E%E6%94%B6/</guid><description>一个 InnoDB 表包含两部分，即：表结构定义和数据
在 MySQL 8.0 版本以前，表结构是存在以.frm 为后缀的文件里。
而 MySQL 8.0 版本，则已经允许把表结构定义放在系统数据表中了。因为表结构定义占用的空间很小，
先和你说明为什么简单地删除表数据达不到表空间回收的效果，然后再和你介绍正确回收空间的方法。
参数 innodb_file_per_table 表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 innodb_file_per_table 控制的</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/7.-order-by-%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/7.-order-by-%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</guid><description>1 2 3 4 5 6 7 8 9 10 CREATE TABLE `t` ( `id` int(11) NOT NULL, `city` varchar(16) NOT NULL, `name` varchar(16) NOT NULL, `age` int(11) NOT NULL, `addr` varchar(128) DEFAULT NULL, PRIMARY KEY (`id`), KEY `city` (`city`) ) ENGINE=InnoDB; 1 2 select city,name,age from t where city=&amp;#39;杭州&amp;#39; order by name limit 1000 ; 全字段排序 为避免全表扫描，我们需要在 city 字段加上索引。</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/8.%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E6%98%BE%E7%A4%BA%E9%9A%8F%E6%9C%BA%E6%B6%88%E6%81%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/8.%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E6%98%BE%E7%A4%BA%E9%9A%8F%E6%9C%BA%E6%B6%88%E6%81%AF/</guid><description>英语学习 App 首页有一个随机显示单词的功能，也就是根据每个用户的级别有一个单词表，然后这个用户每次访问首页的时候，都会随机滚动显示三个单词。他们发现随着单词表变大，选单词这个逻辑变得越来越慢，甚至影响到了首页的打开速度。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 mysql&amp;gt; CREATE TABLE `words` ( `id` int(11) NOT NULL AUTO_INCREMENT, `word` varchar(64) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB; delimiter ;; create procedure idata() begin declare i int; set i=0; while i&amp;lt;10000 do insert into words(word) values(concat(char(97+(i div 1000)), char(97+(i % 1000 div 100)), char(97+(i % 100 div 10)), char(97+(i % 10)))); set i=i+1; end while; end;; delimiter ; call idata(); 接下来，我们就一起看看要随机选择 3 个单词，有什么方法实现，存在什么问题以及如何改进</description></item><item><title/><link>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/9.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%BA%9BSQL%E8%AF%AD%E5%8F%A5%E9%80%BB%E8%BE%91%E7%9B%B8%E5%90%8C%E6%80%A7%E8%83%BD%E5%8D%B4%E5%B7%AE%E5%BC%82%E5%B7%A8%E5%A4%A7%E6%A1%88%E4%BE%8B%E4%B8%80%E6%9D%A1%E4%BB%B6%E5%AD%97%E6%AE%B5%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/MySQL/%E5%AE%9E%E8%B7%B5/9.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%BA%9BSQL%E8%AF%AD%E5%8F%A5%E9%80%BB%E8%BE%91%E7%9B%B8%E5%90%8C%E6%80%A7%E8%83%BD%E5%8D%B4%E5%B7%AE%E5%BC%82%E5%B7%A8%E5%A4%A7%E6%A1%88%E4%BE%8B%E4%B8%80%E6%9D%A1%E4%BB%B6%E5%AD%97%E6%AE%B5%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C/</guid><description>案例一：条件字段函数操作 假设你现在维护了一个交易系统，其中交易记录表 tradelog 包含交易流水号（tradeid）、交易员 id（operator）、交易时间（t_modified）等字段。为了便于描述，我们先忽略其他字段。这个表的建表语句如下：
1 2 3 4 5 6 7 8 9 mysql&amp;gt; CREATE TABLE tradelog ( id int(11) NOT NULL, tradeid varchar(32) DEFAULT NULL, operator int(11) DEFAULT NULL, t_modified datetime DEFAULT NULL, PRIMARY KEY (id), KEY tradeid (tradeid), KEY t_modified (t_modified) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 现在已经记录了从 2016 年初到 2018 年底的所有数据，运营部门有一个需求是，要统计发生在所有年份中 7 月份的交易记录总数。</description></item><item><title/><link>https://googoo-s.github.io/Nginx%E4%B8%8EOpenResty/ngixn/%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Nginx%E4%B8%8EOpenResty/ngixn/%E5%9F%BA%E7%A1%80/</guid><description>Nginx (&amp;ldquo;engine x&amp;rdquo;) 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP/POP3/SMTP 代理服务器。
由于 Nginx 使用基于事件驱动的架构，能够并发处理百万级别的 TCP 连接，高度模块化的设计和自由的许可证使得扩展 Nginx 功能的第三方模块层出不穷。
因此其作为 Web 服务器被广泛应用到大流量的网站上，包括淘宝、腾讯、新浪、京东等访问量巨大的网站。
新手起步 为啥选择nginx 处理响应请求很快 在正常的情况下，单次请求会得到更快的响应。在高峰期，Nginx 可以比其它的 Web 服务器更快的响应请求。</description></item><item><title/><link>https://googoo-s.github.io/Nginx%E4%B8%8EOpenResty/ngixn/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Nginx%E4%B8%8EOpenResty/ngixn/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</guid><description>Nginx 编译安装与配置使用
1.查看系统版本/安装常用软件(系统最小化安装)
1 2 #cat /etc/centos-release CentOS Linux release 7.6.1810 (Core) 1、安装编译环境 1 yum -y install gcc gcc-c++ 2、安装pcre软件包（使nginx支持http rewrite模块） 1 yum install -y pcre pcre-devel 3、安装 openssl-devel（使 nginx 支持 ssl） 1 yum install -y openssl openssl-devel 4、安装zlib 1 yum install -y zlib zlib-devel gd gd-devel 5、创建用户 nginx 1 useradd -s /sbin/nologin nginx 6、编译安装 nginx 1、下载安装包 1 2 3 wget http://nginx.</description></item><item><title/><link>https://googoo-s.github.io/Nginx%E4%B8%8EOpenResty/OpenResty/%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Nginx%E4%B8%8EOpenResty/OpenResty/%E5%9F%BA%E7%A1%80/</guid><description>OpenResty（也称为 ngx_openresty）是一个全功能的 Web 应用服务器。它打包了标准的 Nginx 核心，很多的常用的第三方模块，以及它们的大多数依赖项。
通过揉和众多设计良好的 Nginx 模块，OpenResty 有效地把 Nginx 服务器转变为一个强大的 Web 应用服务器，基于它开发人员可以使用 Lua 编程语言对 Nginx 核心以及现有的各种 Nginx C 模块进行脚本编程，构建出可以处理一万以上并发请求的极端高性能的 Web 应用</description></item><item><title/><link>https://googoo-s.github.io/Nginx%E4%B8%8EOpenResty/Untitled/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Nginx%E4%B8%8EOpenResty/Untitled/</guid><description/></item><item><title/><link>https://googoo-s.github.io/Nginx%E4%B8%8EOpenResty/%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Nginx%E4%B8%8EOpenResty/%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>![[18道非常牛逼的Nginx面试题！.pdf]]
![[Nginx面试题.pdf]]
![[Nginx面试专题.pdf]]
![[Nginx实战书籍.pdf]]</description></item><item><title/><link>https://googoo-s.github.io/Obsidian/dataview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/dataview/</guid><description>#plugin
官方地址 代码仓库 文档地址 其他教程 Obsidian DataView 入门保姆级引导手册 元数据 元数据是一系列的键值对,可以给笔记，可以给note,list item ,task 添加元数据</description></item><item><title/><link>https://googoo-s.github.io/Obsidian/excalidraw/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/excalidraw/</guid><description>#plugin
代码仓库 note 中插入excalidraw 语法 1 ![[excalidraw]]</description></item><item><title/><link>https://googoo-s.github.io/Obsidian/obsidian-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/obsidian-overview/</guid><description>#overview
主页内容 obsidian 相关内容，包括插件
结构</description></item><item><title/><link>https://googoo-s.github.io/Obsidian/Obsidian-plugin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/Obsidian-plugin/</guid><description> advanced-table banners calendar commander dataview emoji-shortcodes emoji-toolbar excel-to-markdown-table homepage hover-editor icon-folder) icons image-toolkit minimal-settings obsidian-git recent-files settings-search style-settings tag-wrangler excalidraw</description></item><item><title/><link>https://googoo-s.github.io/Obsidian/template/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/template/</guid><description>#plugin
* 模板的使用方法 默认存放的文件夹 /template</description></item><item><title/><link>https://googoo-s.github.io/Python/1.Pipenv%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Python/1.Pipenv%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</guid><description>安装 确保python和pip安装
1 2 python --version pip --version 安装
1 pip install --user pipenv 该安装是用户安装，需要将起添加到环境变量总</description></item><item><title/><link>https://googoo-s.github.io/Python/10.%E6%B5%8B%E8%AF%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Python/10.%E6%B5%8B%E8%AF%95/</guid><description/></item><item><title/><link>https://googoo-s.github.io/Python/11.%E6%97%A5%E5%BF%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Python/11.%E6%97%A5%E5%BF%97/</guid><description/></item><item><title/><link>https://googoo-s.github.io/Python/2.%E5%B7%A5%E7%A8%8B%E7%9A%84%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Python/2.%E5%B7%A5%E7%A8%8B%E7%9A%84%E7%BB%93%E6%9E%84/</guid><description>在一个健康的开发周期中，代码风格，API 设计和自动化是非常关键的。同样的，对于工程的 架构 ,仓库的结构也是关键的一部分。
当一个潜在的用户和贡献者登录到您的仓库页面时，他们会看到这些:
工程的名字
工程的描述
一系列的文件
只有当他们滚动到目录下方时才会看到您工程的README。
如果您的仓库的目录是一团糟，没有清晰的结构，他们可能要到处寻找才能找到您写的漂亮的文档。
为您的渴望的事业而奋斗，而不是仅仅只为您现在的工作而工作。</description></item><item><title/><link>https://googoo-s.github.io/Python/3.%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Python/3.%E7%B1%BB%E5%9E%8B/</guid><description>整数 Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。
计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。
对于很大的数，例如10000000000，很难数清楚0的个数。Python允许在数字中间以_分隔，因此，写成10_000_000_000和10000000000是完全一样的。十六进制数也可以写成0xa1b2_c3d4。
浮点数 浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10(9)和12.3x10(8)是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10(9)就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。
整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。
除法运算的结果为小数，即浮点数
如果要舍弃小数部分可以使用//
1 2 3 1//2 //0 5.0//2.5 //2.0 布尔值 True</description></item><item><title/><link>https://googoo-s.github.io/Python/4.%E5%AE%B9%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Python/4.%E5%AE%B9%E5%99%A8/</guid><description>python 支持一种数据结构的基本概念，名为容器（container）。容器基本上就是可包含其他对象的对象。两种主要的容器是序列（如列表和元组）和映射（如字典）。在序列中，每个元素都有编号，而在映射中，每个元素都有名称（也叫键）。有一种既不是序列也不是映射的容器，它就是集合（set）
![[Pasted image 20230727232959.png]]
序列 python有多种序列，本章重点讨论其中最常用的两种：列表和元组。字符串也具有和列表和元组相同的特性。列表和元组的主要不同在于，列表是可以修改的，而元组不可以。这意味着列表适用于需要中途添加元素的情形，而元组适用于出于某种考虑需要禁止修改序列的情形。禁止修改序列通常出于技术方面的考虑，与Python的内部工作原理相关，这也是有些内置函数返回元组的原因所在。在你自己编写程序时，几乎在所有情况下都可使用列表来代替元组。一种例外情况是将元组用作字典键
索引 索引可以是正数 用索引来访问list中每一个位置的元素，记得索引是从0开始的：
1 2 3 4 5 6 7 8 9 10 &amp;gt;&amp;gt;&amp;gt; classmates[0] &amp;#39;Michael&amp;#39; &amp;gt;&amp;gt;&amp;gt; classmates[1] &amp;#39;Bob&amp;#39; &amp;gt;&amp;gt;&amp;gt; classmates[2] &amp;#39;Tracy&amp;#39; &amp;gt;&amp;gt;&amp;gt; classmates[3] Traceback (most recent call last): File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 1, in &amp;lt;module&amp;gt; IndexError: list index out of range 当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates) - 1。</description></item><item><title/><link>https://googoo-s.github.io/Python/4.%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Python/4.%E6%B5%81%E7%A8%8B/</guid><description/></item><item><title/><link>https://googoo-s.github.io/Python/5.%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Python/5.%E5%87%BD%E6%95%B0/</guid><description/></item><item><title/><link>https://googoo-s.github.io/Python/6.%E6%A8%A1%E5%9D%97%E5%8C%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Python/6.%E6%A8%A1%E5%9D%97%E5%8C%85/</guid><description/></item><item><title/><link>https://googoo-s.github.io/Python/7.%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Python/7.%E7%B1%BB/</guid><description/></item><item><title/><link>https://googoo-s.github.io/Python/8.%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Python/8.%E5%BC%82%E5%B8%B8/</guid><description/></item><item><title/><link>https://googoo-s.github.io/Python/9.%E6%A0%87%E5%87%86%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Python/9.%E6%A0%87%E5%87%86%E5%BA%93/</guid><description/></item><item><title/><link>https://googoo-s.github.io/Python/python-%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Python/python-%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/</guid><description>![[python编程快速上手-让繁琐工作自动化.pdf]]</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%9F%BA%E7%A1%80/AOF%E6%97%A5%E5%BF%97%E5%AE%95%E6%9C%BA%E4%BA%86Redis%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%9F%BA%E7%A1%80/AOF%E6%97%A5%E5%BF%97%E5%AE%95%E6%9C%BA%E4%BA%86Redis%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1/</guid><description>Redis 的持久化主要有两大机制，即 AOF（Append Only File）日志和 RDB 快照。
AOF日志如何实现 数据库是写前日志（Write Ahead Log, WAL），也就是说，在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复
AOF 日志正好相反，它是写后日志，“写后”的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志，如下图所示</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%9F%BA%E7%A1%80/redis-%E7%9A%84%E6%85%A2%E6%93%8D%E4%BD%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%9F%BA%E7%A1%80/redis-%E7%9A%84%E6%85%A2%E6%93%8D%E4%BD%9C/</guid><description>Redis 的快，到底是快在哪里呢？实际上，这里有一个重要的表现：它接收到一个键值对操作后，能以微秒级别的速度找到数据，并快速完成操作。
为啥 Redis 能有这么突出的表现呢？
一方面，这是因为它是内存数据库，所有操作都在内存上完成，内存的访问速度本身就很快。
另一方面，这要归功于它的数据结构。这是因为，键值对是按一定的数据结构来组织的，操作键值对最终就是对数据结构进行增删改查操作，所以高效的数据结构是 Redis 快速处理数据的基础。
一方面是因为 O(1) 复杂度的哈希表被广泛使用，包括 String、Hash 和 Set，它们的操作复杂度基本由哈希表决定，</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%9F%BA%E7%A1%80/%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%9F%BA%E7%A1%80/%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7/</guid><description>AOF 正因为记录的是操作命令，而不是实际的数据，所以，用 AOF 方法进行故障恢复的时候，需要逐一把操作日志都执行一遍。如果操作日志非常多，Redis 就会恢复得很缓慢，影响到正常使用。
另一种持久化方法：内存快照。所谓内存快照，就是指内存中的数据在某一个时刻的状态记录。
对 Redis 来说，它实现类似照片记录效果的方式，就是把某一时刻的状态以文件的形式写到磁盘上，也就是快照。这样一来，即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为 RDB 文件，其中，RDB 就是 Redis DataBase 的缩写。
有两个关键问题
对哪些数据做快照？这关系到快照的执行效率问题；
做快照时，数据还能被增删改吗？这关系到 Redis 是否被阻塞，能否同时正常处理请求。</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%9F%BA%E7%A1%80/%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%A4%9A%E4%BA%86%E6%98%AF%E8%AF%A5%E5%8A%A0%E5%86%85%E5%AD%98%E8%BF%98%E6%98%AF%E5%8A%A0%E5%AE%9E%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%9F%BA%E7%A1%80/%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%A4%9A%E4%BA%86%E6%98%AF%E8%AF%A5%E5%8A%A0%E5%86%85%E5%AD%98%E8%BF%98%E6%98%AF%E5%8A%A0%E5%AE%9E%E4%BE%8B/</guid><description>在使用 RDB 进行持久化时，Redis 会 fork 子进程来完成，fork 操作的用时和 Redis 的数据量是正相关的，而 fork 在执行时会阻塞主线程。数据量越大，fork 操作造成的主线程阻塞的时间越长。所以，在使用 RDB 对 25GB 的数据进行持久化时，数据量较大，后台运行的子进程在 fork 创建时阻塞了主线程，于是就导致 Redis 响应变慢了。</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%9F%BA%E7%A1%80/%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%E4%B8%BB%E5%BA%93%E6%8C%82%E4%BA%86%E5%A6%82%E4%BD%95%E4%B8%8D%E9%97%B4%E6%96%AD%E6%9C%8D%E5%8A%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%9F%BA%E7%A1%80/%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%E4%B8%BB%E5%BA%93%E6%8C%82%E4%BA%86%E5%A6%82%E4%BD%95%E4%B8%8D%E9%97%B4%E6%96%AD%E6%9C%8D%E5%8A%A1/</guid><description>但是，一旦有写操作请求了，按照主从库模式下的读写分离要求，需要由主库来完成写操作。如果主库挂了，如何不间断服务
如果主库挂了，我们就需要运行一个新主库，比如说把一个从库切换为主库，把它当成主库。
这就涉及到三个问题：
主库真的挂了吗？
该选择哪个从库作为主库？
怎么把新主库的相关信息通知给从库和客户端呢？
在 Redis 主从集群中，哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制模式下故障转移的这三个问题
哨兵机制的基本流程 哨兵主要负责的就是三个任务：</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%9F%BA%E7%A1%80/%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E5%93%A8%E5%85%B5%E6%8C%82%E4%BA%86%E4%B8%BB%E4%BB%8E%E5%BA%93%E5%88%87%E6%8D%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%9F%BA%E7%A1%80/%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E5%93%A8%E5%85%B5%E6%8C%82%E4%BA%86%E4%B8%BB%E4%BB%8E%E5%BA%93%E5%88%87%E6%8D%A2/</guid><description>实际上，一旦多个实例组成了哨兵集群，即使有哨兵实例出现故障挂掉了，其他哨兵还能继续协作完成主从库切换的工作，包括监控、选主、通知。
在配置哨兵的信息时，我们只需要用到下面的这个配置项，设置主库的 IP 和端口，并没有配置其他哨兵的连接信息
1 sentinel monitor &amp;lt;master-name&amp;gt; &amp;lt;ip&amp;gt; &amp;lt;redis-port&amp;gt; &amp;lt;quorum&amp;gt; 基于 pub/sub 机制的哨兵集群组成 哨兵实例之间可以相互发现，要归功于 Redis 提供的 pub/sub 机制，也就是发布 / 订阅机制.</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%9F%BA%E7%A1%80/%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E4%B8%80%E4%B8%AA%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%BB%84%E6%88%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%9F%BA%E7%A1%80/%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E4%B8%80%E4%B8%AA%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%BB%84%E6%88%90/</guid><description>如果自己设计一个键值数据库 SimpleKV
开始构造 SimpleKV 时，首先就要考虑里面可以存什么样的数据，对数据可以做什么样的操作，也就是数据模型和操作接口。它们看似简单，实际上却是我们理解 Redis 经常被用于缓存、秒杀、分布式锁等场景的重要基础。
可以存哪些数据 对于键值数据库而言，基本的数据模型是 key-value 模型.
我们在对键值数据库进行选型时，一个重要的考虑因素是它支持的 value 类型.
Memcached 支持的 value 类型仅为 String 类型.</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E4%B8%BB%E4%BB%8E%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E4%B8%BB%E4%BB%8E%E5%BA%93/</guid><description>AOF 和 RDB，如果 Redis 发生了宕机，它们可以分别通过回放日志和重新读入 RDB 文件的方式恢复数据，从而保证尽量少丢失数据，提升可靠性。
不过，即使用了这两种方法，也依然存在服务不可用的问题。比如说，我们在实际使用时只运行了一个 Redis 实例，那么，如果这个实例宕机了，它在恢复期间，是无法服务新来的数据存取请求的
Redis 具有高可靠性，又是什么意思呢？其实，这里有两层含义：
一是数据尽量少丢失，
二是服务尽量少中断
AOF 和 RDB 保证了前者，而对于后者，Redis 的做法就是增加副本冗余量，将一份数据同时保存在多个实例上</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%9F%BA%E7%A1%80/%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8BRedis%E8%83%BD%E9%82%A3%E4%B9%88%E5%BF%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%9F%BA%E7%A1%80/%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8BRedis%E8%83%BD%E9%82%A3%E4%B9%88%E5%BF%AB/</guid><description>Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。
但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。
深入地学习下 Redis 的单线程设计机制以及多路复用机制</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/Codis-vs-Redis-Cluster/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/Codis-vs-Redis-Cluster/</guid><description>要开发一个图片存储系统，要求这个系统能快速地记录图片 ID 和图片在存储系统中保存时的 ID（可以直接叫作图片存储对象 ID）。同时，还要能够根据图片 ID 快速查找到图片存储对象 ID。因为图片数量巨大，所以我们就用 10 位数来表示图片 ID 和图片存储对象 ID。
图片 ID 和图片存储对象 ID 正好一一对应，是典型的“键 - 单值”模式，String 类型提供的“一个键对应一个值的数据”的保存形式刚好契合。</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/CPU%E7%BB%93%E6%9E%84%E4%B9%9F%E4%BC%9A%E5%BD%B1%E5%93%8DRedis%E7%9A%84%E6%80%A7%E8%83%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/CPU%E7%BB%93%E6%9E%84%E4%B9%9F%E4%BC%9A%E5%BD%B1%E5%93%8DRedis%E7%9A%84%E6%80%A7%E8%83%BD/</guid><description>目前主流服务器的 CPU 架构，基于 CPU 多核架构多 CPU 架构优化 Redis 性能的方法
主流的CPU架构 一个 CPU 处理器中一般有多个运行核心，我们把一个运行核心称为一个物理核，每个物理核都可以运行应用程序。每个物理核都拥有私有的一级缓存（Level 1 cache，简称 L1 cache），包括一级指令缓存和一级数据缓存，以及私有的二级缓存（Level 2 cache，简称 L2 cache）。</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/GEO%E6%98%AF%E4%BB%80%E4%B9%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/GEO%E6%98%AF%E4%BB%80%E4%B9%88/</guid><description>我们学习了 Redis 的 5 大基本数据类型：String、List、Hash、Set 和 Sorted Set，它们可以满足大多数的数据存储需求，但是在面对海量数据统计时，它们的内存开销很大，而且对于一些特殊的场景，它们是无法支持的。所以，Redis 还提供了 3 种扩展数据类型，分别是 Bitmap、HyperLogLog 和 GEO。
面向 LBS 应用的 GEO 数据类型 位置信息服务（Location-Based Service，LBS）的应用访问的数据是和人或物关联的一组经纬度信息，而且要能查询相邻的经纬度范围，GEO 就非常适合应用在 LBS服务的场景中.</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/Pika%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8ESSD%E5%AE%9E%E7%8E%B0%E5%A4%A7%E5%AE%B9%E9%87%8FRedis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/Pika%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8ESSD%E5%AE%9E%E7%8E%B0%E5%A4%A7%E5%AE%B9%E9%87%8FRedis/</guid><description/></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/Redis-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E4%B8%8E%E6%95%85%E9%9A%9C%E5%88%87%E6%8D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/Redis-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E4%B8%8E%E6%95%85%E9%9A%9C%E5%88%87%E6%8D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91/</guid><description>主从数据不一致 那为啥会出现这个坑呢？其实这是因为主从库间的命令复制是异步进行的。
在主从库命令传播阶段，主库收到新的写命令后，会发送给从库。但是，主库并不会等到从库实际执行完命令后，再把结果返回给客户端，而是主库自己在本地执行完命令后，就会向客户端返回结果了。如果从库还没有执行主库同步过来的命令，主从库间的数据就不一致了。 那在什么情况下，从库会滞后执行同步命令呢？其实，这里主要有两个原因
一方面，主从库间的网络可能会有传输延迟，所以从库不能及时地收到主库发送的命令，从库上执行同步命令的时间就会被延后。
另一方面，即使从库及时收到了主库的命令，但是，也可能会因为正在处理其它复杂度高的命令（例如集合操作命令）而阻塞
解决方法：
首先，在硬件环境配置方面，我们要尽量保证主从库间的网络连接状况良好。
我们还可以开发一个外部程序来监控主从库间的复制进度。</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/String-%E7%9A%84%E5%B1%80%E9%99%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/String-%E7%9A%84%E5%B1%80%E9%99%90/</guid><description/></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/</guid><description>事务是数据库的一个重要功能。所谓的事务，就是指对数据进行读写的一系列操作。事务在执行时，会提供专门的属性保证，包括原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），也就是 ACID 属性。
事务 ACID 属性的要求 原子性。原子性的要求很明确，就是一个事务中的多个操作必须都完成，或者都不完成
一致性。指数据库中的数据在事务执行前后是一致的
隔离性。它要求数据库在执行一个事务时，其它操作无法存取到正在执行事务访问的数据。
持久性。数据库执行事务后，数据的修改要被持久化保存下来。当数据库重启后，数据的值需要是被修改后的值。
Redis 如何实现事务 事务的执行过程包含三个步骤，Redis 提供了 MULTI、EXEC 两个命令来完成这三个步骤。</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E4%BF%9D%E5%AD%98%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E4%BF%9D%E5%AD%98%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/</guid><description/></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%90%8E%E4%B8%BA%E5%95%A5%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E7%8E%87%E8%BF%98%E6%98%AF%E5%BE%88%E9%AB%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%90%8E%E4%B8%BA%E5%95%A5%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E7%8E%87%E8%BF%98%E6%98%AF%E5%BE%88%E9%AB%98/</guid><description>明明做了数据删除，数据量已经不大了，为什么使用 top 命令查看时，还会发现 Redis 占用了很多内存呢？
这是因为，当数据删除后，Redis 释放的内存空间会由内存分配器管理，并不会立即返回给操作系统。所以，操作系统仍然会记录着给 Redis 分配了大量内存
潜在的风险点：Redis 释放的内存空间可能并不是连续的，那么，这些不连续的内存空间很有可能处于一种闲置的状态。
这就会导致一个问题：虽然有空闲空间，Redis 却无法用来保存数据，不仅会减少 Redis 能够实际保存的数据量，还会降低 Redis 运行机器的成本回报率。</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid><description>上节课，我提到，在应对并发问题时，除了原子操作，Redis 客户端还可以通过加锁的方式，来控制并发写操作对共享数据的修改，从而保证数据的正确性。
但是，Redis 属于分布式系统，当有多个客户端需要争抢锁时，我们必须要保证，这把锁不能是某个客户端本地的锁。
在分布式系统中，当有多个客户端需要获取锁时，我们需要分布式锁。此时，锁是保存在一个共享存储系统中的，可以被多个客户端共享访问和获取。
单机上的锁和分布式锁的联系与区别 对于在单机上运行的多线程程序来说，锁本身可以用一个变量表示。
变量值为 0 时，表示没有线程获取锁；
变量值为 1 时，表示已经有线程获取到锁了
和单机上的锁类似，分布式锁同样可以用一个变量来实现，客户端加锁和释放锁的操作逻辑，也和单机上的加锁和释放锁操作逻辑一致：加锁时同样需要判断锁变量的值，根据锁变量值来判断能否加锁成功；释放锁时需要把锁变量值设置为 0，表明客户端不再持有锁，</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%98%BB%E5%A1%9E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%98%BB%E5%A1%9E/</guid><description>影响 Redis 性能的 5 大方面的潜在因素：
Redis 内部的阻塞式操作；
CPU 核和 NUMA 架构的影响；
Redis 关键系统配置；
Redis 内存碎片；</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98Redis%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98Redis%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</guid><description>Redis 提供了高性能的数据存取功能，所以广泛应用在缓存场景中，既能有效地提升业务应用的响应速度，还可以避免把高并发大压力的请求发送到数据库层。
们需要系统地掌握缓存的一系列内容：
工作原理
替换策略
异常处理
扩展机制
具体来说，我们需要解决四个关键问题：
Redis 缓存具体是怎么工作的？</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E6%97%A0%E9%94%81%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9CRedis%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E6%97%A0%E9%94%81%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9CRedis%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE/</guid><description>为了保证并发访问的正确性，Redis 提供了两种方法，分别是加锁和原子操作。
加锁是一种常用的方法，在读取数据前，客户端需要先获得锁，否则就无法进行操作。当一个客户端获得锁后，就会一直持有这把锁，直到客户端完成数据更新，才释放这把锁。
一个是，如果加锁操作多，会降低系统的并发访问性能；
第二个是，Redis 客户端要加锁时，需要用到分布式锁，而分布式锁实现复杂，需要用额外的存储系统来提供加解锁操作
原子操作是另一种提供并发访问控制的方法
原子操作是指执行过程保持原子性的操作，而且原子操作执行时并不需要再加锁，实现了无锁操作 并发访问中需要对啥进行控制？ 我们说的并发访问控制，是指对多个客户端访问操作同一份数据的过程进行控制，以保证任何一个客户端发送的操作在 Redis 实例上执行时具有互斥性？客户端 A 的访问操作在执行时，客户端 B 的操作不能执行，需要等到 A 的操作结束后，才能执行。</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5%E7%BC%93%E5%AD%98%E6%BB%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5%E7%BC%93%E5%AD%98%E6%BB%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/</guid><description>MySQL 中有 1TB 的数据，如果我们使用 Redis 把这 1TB 的数据都缓存起来，虽然应用都能在内存中访问数据了，但是，这样配置并不合理，因为性价比很低
解决这个问题就涉及到缓存系统的一个重要机制，即**缓存数据的淘汰机制。**简单来说，数据淘汰机制包括两步：
第一，根据一定的策略，筛选出对应用访问来说“不重要”的数据；
第二，将这些数据从缓存中删除，为新来的数据腾出空间，
设置多大的缓存合适 按照“八二原理”来设置缓存空间容量，也就是把缓存空间容量设置为总数据量的 20% 的话，就有可能拦截到 80% 的访问。</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E6%B3%A2%E5%8A%A8%E7%9A%84%E5%93%8D%E5%BA%94%E5%BB%B6%E8%BF%9F%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%8F%98%E6%85%A2%E7%9A%84Redis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E6%B3%A2%E5%8A%A8%E7%9A%84%E5%93%8D%E5%BA%94%E5%BB%B6%E8%BF%9F%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%8F%98%E6%85%A2%E7%9A%84Redis/</guid><description>Redis真的变慢了吗？ 一个最直接的方法，就是查看 Redis 的响应延迟。
大部分时候，Redis 延迟很低，但是在某些时刻，有些 Redis 实例会出现很高的响应延迟，甚至能达到几秒到十几秒，不过持续时间不长，这也叫**延迟“毛刺”。**当你发现 Redis 命令的执行时间突然就增长到了几秒，基本就可以认定 Redis 变慢了 第二个方法了，也就是基于当前环境下的 Redis 基线性能做判断</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97Redis%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97Redis%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid><description>Redis 适合做消息队列？这个问题的背后，隐含着两方面的核心问题
消息队列的消息存取需求是什么？
Redis 如何实现消息队列的需求？
消息队列的消息存取需求 消息队列存取消息的过程 在分布式系统中，当两个组件要基于消息队列进行通信时，
一个组件会把要处理的数据以消息的形式传递给消息队列，然后，这个组件就可以继续执行其他操作了；
远端的另一个组件从消息队列中把消息读取出来，再在本地进行处理。</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%83%BD%E5%BC%95%E5%8F%91%E6%83%A8%E6%A1%88%E7%9A%84%E5%9C%B0%E6%96%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%83%BD%E5%BC%95%E5%8F%91%E6%83%A8%E6%A1%88%E7%9A%84%E5%9C%B0%E6%96%B9/</guid><description>缓冲区的功能其实很简单，主要就是用一块内存空间来暂时存放命令数据，以免出现因为数据和命令的处理速度慢于发送速度而导致的数据丢失和性能问题，
但因为缓冲区的内存空间有限，如果往里面写入数据的速度持续地大于从里面读取数据的速度。当缓冲区占用的内存超出了设定的上限阈值时，就会出现缓冲区溢出。
缓冲区在 Redis 中的一个主要应用场景，就是在客户端和服务器端之间进行通信时，
用来暂存客户端发送的命令数据，
暂存服务器端返回给客户端的数据结果。
缓冲区的另一个主要应用场景，是在主从节点间进行数据同步时，用来暂存主节点接收的写命令和数据。
客户端输入和输出缓冲区 为了避免客户端和服务器端的请求发送和处理速度不匹配，**服务器端给每个连接的客户端都设置了一个输入缓冲区和输出缓冲区，我们称之为客户端输入缓冲区和输出缓冲区，**输入缓冲区会先把客户端发送过来的命令暂存起来，Redis 主线程再从输入缓冲区中读取命令，进行处理。当 Redis 主线程处理完数据后，会把结果写入到输出缓冲区，再通过输出缓冲区返回给客户端，如下图所示</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</guid><description>我们经常会遇到一些异常问题，概括来说有 4 个方面：
缓存中的数据和数据库中的不一致；
缓存雪崩；
缓存击穿
缓存穿透
缓存和数据库的数据不一致是如何发生的？ 其实，这里的“一致性”包含了两种情况：
缓存中有数据，那么，缓存的数据值需要和数据库中的值相同；</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%87%BB%E7%A9%BF%E7%A9%BF%E9%80%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%87%BB%E7%A9%BF%E7%A9%BF%E9%80%8F/</guid><description>缓存雪崩 缓存雪崩是指大量的应用请求无法在 Redis 缓存中进行处理，紧接着，应用将大量请求发送到数据库层，导致数据库层的压力激增。
存雪崩一般是由两个原因导致的，应对方案也有所不同：
第一个原因是：缓存中有大量数据同时过期，导致大量请求无法得到处理。
针对大量数据同时失效带来的缓存雪崩问题，我给你提供两种解决方案。
首先，我们可以避免给大量的数据设置相同的过期时间。
我们还可以通过服务降级，来应对缓存雪崩
当业务应用访问的是非核心数据（例如电商商品属性）时，暂时停止从缓存中查询这些数据，而是直接返回预定义信息、空值或是错误信息</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E7%BC%93%E5%AD%98%E8%A2%AB%E6%B1%A1%E6%9F%93%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-LFU/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E7%BC%93%E5%AD%98%E8%A2%AB%E6%B1%A1%E6%9F%93%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-LFU/</guid><description>那什么是缓存污染呢？在一些场景下，有些数据被访问的次数非常少，甚至只会被访问一次。当这些数据服务完访问请求后，如果还继续留存在缓存中的话，就只会白白占用缓存空间。
如何解决缓存污染问题 我们也能很容易想到解决方案，那就是得把不会再被访问的数据筛选出来并淘汰掉。
LFU 缓存策略的优化。
LFU 缓存策略是在 LRU 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。当使用 LFU 策略筛选淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出缓存。如果两个数据的访问次数相同，LFU 策略再比较这两个数据的访问时效性，把距离上一次访问时间更久的数据淘汰出缓存。
为了避免操作链表的开销，Redis 在实现 LRU 策略时使用了两个近似方法：
Redis 是用 RedisObject 结构来保存数据的，RedisObject 结构中设置了一个 lru 字段，用来记录数据的访问时间戳；</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97/</guid><description>RedisObject 包括元数据和指针。其中，元数据的一个功能就是用来区分不同的数据类型，指针用来指向具体的数据类型的值
Redis 的基本对象结构 RedisObject 的内部组成包括了 type、encoding、lru 和 refcount 4 个元数据，以及 1 个*ptr指针
type：表示值的类型，涵盖了我们前面学习的五大基本类型；
encoding：是值的编码方式，用来表示 Redis 中实现各个基本类型的底层数据结构，例如 SDS、压缩列表、哈希表、跳表等；</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E9%9B%86%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%85%B6%E9%9B%86%E5%90%88%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%AE%9E%E8%B7%B5/%E9%9B%86%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%85%B6%E9%9B%86%E5%90%88%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description>通常情况下，我们面临的用户数量以及访问量都是巨大的，所以，我们必须要选择能够非常高效地统计大量数据（例如亿级）的集合类型，要想选择合适的集合，我们就得了解常用的集合统计模式。四种统计模式
聚合统计
排序统计
二值状态统计
基数统计
聚合统计 所谓的聚合统计，就是指统计多个集合元素的聚合结果，包括：
统计多个集合的共有元素（交集统计）；</description></item><item><title/><link>https://googoo-s.github.io/Redis/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Redis/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>#认识 Redis #什么是 Redis？ 我们直接看 Redis 官方是怎么介绍自己的。
Redis 官方的介绍原版是英文的，我翻译成了中文后截图的，所以有些文字读起来会比较拗口，没关系，我会把里面比较重要的特性抽出来讲一下。
Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。
Redis 提供了多种数据类型来支持不同的业务场景，比如 String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是原子性的，因为执行命令由单线程负责的，不存在并发竞争的问题。
除此之外，Redis 还支持事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制等等。</description></item><item><title/><link>https://googoo-s.github.io/shell/shell-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/shell/shell-overview/</guid><description>Shell 综述 所谓的Shell，就是运行在终端中的文本互动程序。Shell分析你的文本输入，然后把文本转换成相应的计算机动作。
在后面的内容中，我将用$来表示Linux系统Shell的命令提示符。比如说输入date命令：
1 $date date用于日期时间的相关功能。敲击回车键Enter后，Shell会显示出系统当前的时间。
shell是Unix体系下的文本交互界面。你只需要用键盘来输入文本，就可以和操作系统交互。但这还是不够具体。说到底，Shell其实是一个运行着的程序。这个程序接收到你按下回车键之间的输入，就会对输入的文本进行分析。比如下面这个命令：
1 $free -h 包括空格在内总共7个字符。Shell程序会通过空格，区分出命令的不同部分
第一个部分是命令名。</description></item><item><title/><link>https://googoo-s.github.io/zookeeper/%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/zookeeper/%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>![[zookeeper面试专题.pdf]]![[Zookeeper分布式过程.pdf]]</description></item><item><title/><link>https://googoo-s.github.io/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%B0%E4%BB%93/flink/%E4%B9%A6%E7%B1%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%B0%E4%BB%93/flink/%E4%B9%A6%E7%B1%8D/</guid><description>![[基于Apache Flink的流处理 流式应用基础、实现及操作 (比安‧霍斯克 瓦西里基‧卡拉夫里) (Z-Library).pdf]]</description></item><item><title/><link>https://googoo-s.github.io/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%B0%E4%BB%93/flink/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E6%95%99%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%B0%E4%BB%93/flink/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E6%95%99%E7%A8%8B/</guid><description>![[第一章：Apache Flink介绍.pdf]]![[第二章：Flink部署与应用.pdf]]![[第三章：Flink DataStream API实践原理.pdf]]![[第四章：Flink状态管理和容错.pdf]]![[第五章：Flink Table &amp;amp; SQL实践原理（上）.pdf]]![[第六章：Flink Runtime设计与实现.pdf]]![[第七章：Flink监控与性能优化.pdf]]![[第八章：Flink组件栈介绍与使用.pdf]]![[第九章：项目实战-使用Flink构建推荐系统实时数据流.pdf]]</description></item><item><title/><link>https://googoo-s.github.io/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%B0%E4%BB%93/hadoop/Hadoop-%E7%94%9F%E6%80%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%B0%E4%BB%93/hadoop/Hadoop-%E7%94%9F%E6%80%81/</guid><description>![[Pasted image 20230728000457.png]]</description></item><item><title/><link>https://googoo-s.github.io/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%B0%E4%BB%93/spark/%E4%B9%A6%E7%B1%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%B0%E4%BB%93/spark/%E4%B9%A6%E7%B1%8D/</guid><description/></item><item><title/><link>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/kafka-%E6%9C%AF%E8%AF%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/kafka-%E6%9C%AF%E8%AF%AD/</guid><description>消息：Record。Kafka 是消息引擎嘛，这里的消息就是指 Kafka 处理的主要对象。
主题：Topic。主题是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。
分区：Partition。一个有序不变的消息序列。每个主题下可以有多个分区。
消息位移：Offset。表示分区中每条消息的位置信息，是一个单调递增且不变的值。
副本：Replica。Kafka 中同一条消息能够被拷贝到多个地方以提供数据冗余，这些地方就是所谓的副本。副本还分为领导者副本和追随者副本，各自有不同的角色划分。副本是在分区层级下的，即每个分区可配置多个副本实现高可用。
生产者：Producer。向主题发布新消息的应用程序。</description></item><item><title/><link>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E5%AE%A2%E6%88%B7%E7%AB%AF-kafka%E6%8B%A6%E6%88%AA%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E5%AE%A2%E6%88%B7%E7%AB%AF-kafka%E6%8B%A6%E6%88%AA%E5%99%A8/</guid><description>其基本思想就是允许应用程序在不修改逻辑的情况下，动态地实现一组可插拔的事件处理逻辑链。它能够在主业务操作的前后多个时间点上插入对应的“拦截”逻辑。springmvcde 拦截器的工作原理
Kafka 拦截器借鉴了这样的设计思路。你可以在消息处理的前后多个时点动态植入不同的处理逻辑，比如在消息发送前或者在消息被消费后。
Kafka 拦截器 fka 拦截器分为生产者拦截器和消费者拦截器。生产者拦截器允许你在发送消息前以及消息提交成功后植入你的拦截器逻辑；而消费者拦截器支持在消费消息前以及提交位移后编写特定逻辑。值得一提的是，这两种拦截器都支持链的方式，即你可以将一组拦截器串连成一个大的拦截器，Kafka 会按照添加顺序依次执行拦截器逻辑。
当前 Kafka 拦截器的设置方法是通过参数配置完成的。生产者和消费者两端有一个相同的参数，名字叫 interceptor.classes
1 2 3 4 5 6 7 Properties props = new Properties(); List&amp;lt;String&amp;gt; interceptors = new ArrayList&amp;lt;&amp;gt;(); interceptors.</description></item><item><title/><link>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE/</guid><description>一句话概括，Kafka 只对**“已提交”的消息（committed message）做有限度的持久化保证。**
生产者
要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。记住，一定要使用带有回调通知的 send 方法。 Broker
设置 acks = all。acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义。**如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。**这是最高等级的“已提交”定义</description></item><item><title/><link>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E5%AE%A2%E6%88%B7%E7%AB%AF-%E7%94%9F%E4%BA%A7%E8%80%85%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E5%AE%A2%E6%88%B7%E7%AB%AF-%E7%94%9F%E4%BA%A7%E8%80%85%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/</guid><description>具体来说就是用 CPU 时间去换磁盘空间或网络 I/O 传输量，希望以较小的 CPU 开销带来更少的磁盘占用或更少的网络 I/O 传输。
怎么压缩 kafka 的消息层次都分为两层：
消息集合（message set）
消息（message）。一个消息集合中包含若干条日志项（record item）,而日志项才是真正封装消息的地方</description></item><item><title/><link>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E5%AE%A2%E6%88%B7%E7%AB%AF-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E6%81%AF%E5%88%86%E5%8C%BA%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E5%AE%A2%E6%88%B7%E7%AB%AF-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E6%81%AF%E5%88%86%E5%8C%BA%E6%9C%BA%E5%88%B6/</guid><description>切记分区是实现负载均衡以及高吞吐量的关键
为什么分区 Kafka 有主题（Topic）的概念，它是承载真实数据的逻辑容器，而在主题之下还分为若干个分区，也就是说 Kafka 的消息组织方式实际上是三级结构：**主题 - 分区 - 消息。**主题下的每条消息只会保存在某一个分区中，而不会在多个分区中被保存多份
为啥要使用多个分区而不是直接使用多个主题？ 其实分区的作用就是提供负载均衡的能力
为了实现系统的高伸缩性（Scalability）。不同的分区能够被放置到不同节点的机器上，而数据的读写操作也都是针对分区这个粒度而进行的，这样每个节点的机器都能独立地执行各自分区的读写请求处理。并且，我们还可以通过添加新的节点机器来增加整体系统的吞吐量。
都有哪些分区策略 所谓分区策略是决定生产者将消息发送到哪个分区的算法。</description></item><item><title/><link>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BE%85%E7%BB%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BE%85%E7%BB%AD/</guid><description/></item><item><title/><link>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E6%B6%88%E6%81%AF%E5%BC%95%E6%93%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E6%B6%88%E6%81%AF%E5%BC%95%E6%93%8E/</guid><description>Apache Kafka 是一款开源的消息引擎系统。
最基础的消息引擎就做两个重要的事实：
消息引擎传输的对象是消息；
如何传输消息属于消息引擎设计机制的一部分。
消息的格式 那么现在我告诉你 Kafka 的选择：它使用的是纯二进制的字节序列。
传输方法 消息引擎系统还要设定具体的传输协议，即我用什么方法把消息传输出去。常见的有两种方法：
点对点模型：也叫消息队列模型。如果拿上面那个“民间版”的定义来说，那么系统 A 发送的消息只能被系统 B 接收，其他任何系统都不能读取 A 发送的消息。日常生活的例子比如电话客服就属于这种模型：同一个客户呼入电话只能被一位客服人员处理，第二个客服人员不能为该客户服务。</description></item><item><title/><link>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E7%AE%A1%E7%90%86%E7%9B%91%E6%8E%A7%E5%BE%85%E7%BB%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E7%AE%A1%E7%90%86%E7%9B%91%E6%8E%A7%E5%BE%85%E7%BB%AD/</guid><description/></item><item><title/><link>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RockerMQ/RockerMQ%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RockerMQ/RockerMQ%E4%BB%8B%E7%BB%8D/</guid><description>RocketMQ 的优缺点 RocketMQ优点：
单机吞吐量：十万级
可用性：非常高，分布式架构
消息可靠性：经过参数优化配置，消息可以做到0丢失
功能支持：MQ功能较为完善，还是分布式的，扩展性好
支持10亿级别的消息堆积，不会因为堆积导致性能下降</description></item><item><title/><link>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80/</guid><description>为什么要使用消息队列呢？ 消息队列主要有三大用途，我们拿一个电商系统的下单举例：
解耦：引入消息队列之前，下单完成之后，需要订单服务去调用库存服务减库存，调用营销服务加营销数据……引入消息队列之后，可以把订单完成的消息丢进队列里，下游服务自己去调用就行了，这样就完成了订单服务和其它服务的解耦合。
异步：订单支付之后，我们要扣减库存、增加积分、发送消息等等**，这样一来这个链路就长了，链路一长，响应时间就变长了。引入消息队列，除了 更新订单状态 ，其它的都可以异步去做，这样一来就来，就能降低响应时间。**
削峰：消息队列合一用来削峰，例如秒杀系统，平时流量很低，但是要做秒杀 活动，秒杀的时候流量疯狂怼进来，我们的服务器，Redis，MySQL各自的承受能力都不一样，直接全部流量照单全收肯定有问题啊，严重点可能直接打挂了。我们可以把请求扔到队列里面，只放出我们服务能处理的流量，这样就能抗住短时间的大流量了
主流消息队列的对比 总结下：
选择中间件的可以从这些维度来考虑：可靠性，性能，功能，可运维行，可拓展性，社区活跃度。目前常用的几个中间件，ActiveMQ作为“老古董”，市面上用的已经不多，其它几种：
RabbitMQ：
优点：轻量，迅捷，容易部署和使用，拥有灵活的路由配置</description></item><item><title/><link>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Restful/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Restful/</guid><description>何为 API？ API（Application Programming Interface） 翻译过来是应用程序编程接口的意思。
我们在进行后端开发的时候，主要的工作就是为前端或者其他后端服务提供 API 比如查询用户数据的 API 。
但是， API 不仅仅代表后端系统暴露的接口，像框架中提供的方法也属于 API 的范畴。
为了方便大家理解，我再列举几个例子 🌰：</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/HTTP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/HTTP/</guid><description/></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/IP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/IP/</guid><description/></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/TCP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/TCP/</guid><description/></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80/</guid><description/></item><item><title/><link>https://googoo-s.github.io/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F/%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F/%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>![[分布式相关面试题汇总.pdf]]</description></item></channel></rss>