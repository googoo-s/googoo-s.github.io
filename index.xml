<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://googoo-s.github.io/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 31 Jul 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://googoo-s.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>dataview</title><link>https://googoo-s.github.io/Obsidian/dataview/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/dataview/</guid><description>官方地址 代码仓库 文档地址 其他教程 Obsidian DataView 入门保姆级引导手册 元数据 元数据是一系列的键值对,可以给笔记，可以给note,list item ,task 添加元数据
如何添加元数据 Frontmatter frontmatter 是markdown的一种扩展，可以使用yaml 来添加元数据 1 2 3 4 5 6 7 --- alias: &amp;#34;document&amp;#34; last-reviewed: 2021-08-17 thoughts: rating: 8 reviewable: false --- inline fields 使用方法为在文件的任意位置添加 1 2 3 4 Basic Field:: Some random Value **Bold Field**:: Nice!</description></item><item><title>excalidraw</title><link>https://googoo-s.github.io/Obsidian/excalidraw/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/excalidraw/</guid><description> 代码仓库 note 中插入excalidraw 语法 1 ![[excalidraw]]</description></item><item><title>Front Matter</title><link>https://googoo-s.github.io/Obsidian/Front-Matter/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/Front-Matter/</guid><description>使用 Front Matter 可以保存 note 待元数据，推荐使用 Hugo 的配置 Front matter | Hugo (gohugo.io)</description></item><item><title>lua基础</title><link>https://googoo-s.github.io/lua/lua%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/lua/lua%E5%9F%BA%E7%A1%80/</guid><description>Lua 简介 Lua 是一个小巧的脚本语言。是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组并于 1993 年开发。其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。Lua 由标准 C 编写而成，几乎在所有操作系统和平台上都可以编译、运行。Lua 并没有提供强大的库，这是由它的定位决定的。所以 Lua 不适合作为开发独立应用程序的语言。Lua 有一个同时进行的 JIT 项目，提供在特定平台上的即时编译功能。</description></item><item><title>Lua高级</title><link>https://googoo-s.github.io/lua/Lua%E9%AB%98%E7%BA%A7/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/lua/Lua%E9%AB%98%E7%BA%A7/</guid><description>元表 元表 (metatable) 的表现行为类似于 C++ 语言中的操作符重载，例如我们可以重载 &amp;ldquo;__add&amp;rdquo; 元方法 (metamethod)，来计算两个 Lua 数组的并集；或者重载 &amp;ldquo;__index&amp;rdquo; 方法，来定义我们自己的 Hash 函数。Lua 提供了两个十分重要的用来处理元表的方法
setmetatable(table, metatable)：此方法用于为一个表设置元表。</description></item><item><title>obsidian overview</title><link>https://googoo-s.github.io/Obsidian/obsidian-overview/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/obsidian-overview/</guid><description>主页内容 obsidian 相关内容，包括插件
结构</description></item><item><title>Obsidian-plugin</title><link>https://googoo-s.github.io/Obsidian/Obsidian-plugin/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/Obsidian-plugin/</guid><description> advanced-table banners calendar commander dataview emoji-shortcodes emoji-toolbar excel-to-markdown-table homepage hover-editor icon-folder) icons image-toolkit minimal-settings obsidian-git recent-files settings-search style-settings tag-wrangler excalidraw</description></item><item><title>publish</title><link>https://googoo-s.github.io/Obsidian/publish/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/publish/</guid><description>obsidian 目前最完美的免费发布方案 渐进式教程 by oldwinter</description></item><item><title>template</title><link>https://googoo-s.github.io/Obsidian/template/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Obsidian/template/</guid><description> * 模板的使用方法 默认存放的文件夹 /template</description></item><item><title/><link>https://googoo-s.github.io/awesome/JavaGuide-%E7%9F%A5%E8%AF%86%E6%98%9F%E7%90%83%E4%BC%98%E8%B4%A8%E4%B8%BB%E9%A2%98%E6%B1%87%E6%80%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/awesome/JavaGuide-%E7%9F%A5%E8%AF%86%E6%98%9F%E7%90%83%E4%BC%98%E8%B4%A8%E4%B8%BB%E9%A2%98%E6%B1%87%E6%80%BB/</guid><description>为了避免这里成为知识杂货铺，我会对严格筛选入选的优质主题。
更新日期：2023-06-11
面试
● Java面试常见问题总结（2023最新版）
● 一位 HR 分享的求职建议
● 面试和简历上的一些大忌
●项目：
○ 如何回答项目遇到什么困难，如何解决这类问题
○ 项目太简单怎么办?
○ 商城项目到底能不能做？
安抚心态
如果你陷入精神内耗或者自我怀疑，不然看看下面这些内容：</description></item><item><title/><link>https://googoo-s.github.io/Dobbo/Dubbo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Dobbo/Dubbo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</guid><description>这篇文章是我根据官方文档以及自己平时的使用情况，对 Dubbo 所做的一个总结。欢迎补充！
# Dubbo 基础 # 什么是 Dubbo? Dubbo 官网
Apache Dubboopen in new window |ˈdʌbəʊ| 是一款高性能、轻量级的开源 WEB 和 RPC 框架。</description></item><item><title/><link>https://googoo-s.github.io/elastic/KQL/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/elastic/KQL/</guid><description>Kibana Query Language
https://juejin.cn/post/7003201901382598686
https://www.elastic.co/guide/en/kibana/7.14/kuery-query.html#kuery-query</description></item><item><title/><link>https://googoo-s.github.io/netty/BootStrap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/netty/BootStrap/</guid><description>简单来说，引导一个应用程序是指对它进行配置，并使它运行起来的过程—尽管该过程的具体细节可能并不如它的定义那样简单，尤其是对于一个网络应用程序来说
Netty处理引导的方式使你的应用程序和网络层相隔离，无论它是客户端还是服务器
BootStrap类 引导类的层次结构包括一个抽象的父类和两个具体的引导子类
相对于将具体的引导类分别看作用于服务器和客户端的引导来说，记住它们的本意是用来支撑不同的应用程序的功能的将有所裨益。
服务器致力于使用一个父 Channel 来接受来自客户端的连接，并创建子 Channel 以用于它们之间的通信
而客户端将最可能只需要一个单独的、没有父 Channel 的 Channel 来用于所有的网络交互</description></item><item><title/><link>https://googoo-s.github.io/netty/ByteBuf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/netty/ByteBuf/</guid><description>网络数据的基本单位总是字节。Java NIO 提供了 ByteBuffer 作为它的字节容器，但是这个类使用起来过于复杂，而且也有些繁琐。
Netty 的 ByteBuffer 替代品是 ByteBuf，一个强大的实现，既解决了 JDK API 的局限性，又为网络应用程序的开发者提供了更好的 API。
ByteBuf 的优点 Netty 的数据处理 API 通过两个组件暴露——abstract class ByteBuf 和 interface ByteBufHolder。</description></item><item><title/><link>https://googoo-s.github.io/netty/ChannelHandlerChannelPipelineChannelContext/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/netty/ChannelHandlerChannelPipelineChannelContext/</guid><description>当我们在本章中探讨 Netty 的数据流以及处理组件
在 ChannelPipeline 中将 ChannelHandler 链接在一起以组织处理逻辑。我们将会研究涉及这些类的各种用例，以及一个重要的关系—ChannelHandlerContext
ChannelHandler Channel 的生命周期 ChannelHandler的生命周期
Netty定义了两个重要的ChannelHandler
 ChannelInboundHandler——处理入站数据以及各种状态变化；</description></item><item><title/><link>https://googoo-s.github.io/netty/EventLoop-%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/netty/EventLoop-%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</guid><description>常见的线程模型 基本的线程池化模式
从池的空闲线程列表中选择一个 Thread，并且指派它去运行一个已提交的任务（一个 Runnable 的实现）；
当任务完成时，将该 Thread 返回给该列表，使其可被重用
虽然池化和重用线程相对于简单地为每个任务都创建和销毁线程是一种进步，但是它并不能消除由上下文切换所带来的开销
EventLoop 运行任务来处理在连接的生命周期内发生的事件是任何网络框架的基本功能。与之相应的编程上的构造通常被称为事件循环—一个 Netty 使用了 interface io.</description></item><item><title/><link>https://googoo-s.github.io/netty/%E4%BC%A0%E8%BE%93%E5%92%8CChannel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/netty/%E4%BC%A0%E8%BE%93%E5%92%8CChannel/</guid><description>在某些时候，你需要支撑比预期多很多的并发连接。如果你随后尝试从阻塞传输切换到非阻塞传输，那么你可能会因为这两种网络 API 的截然不同而遇到问题。
Netty 为它所有的传输实现提供了一个通用 API，这使得这种转换比你直接使用 JDK 所能够达到的简单得多。
传输方式 OIO
NIO
AIO
Channel 传输 API 的核心是 interface Channel，它被用于所有的 I/O 操作</description></item><item><title/><link>https://googoo-s.github.io/netty/%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/netty/%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</guid><description>IO 模型 IO模型详解
Java 网络编程 最早期的 Java API（java.net）只支持由本地系统套接字库提供的所谓的阻塞函数
1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 创建一个新的 ServerSocket，用以 监听指定端口上的连接请求 ServerSocket serverSocket = new ServerSocket(portNumber); // 对accept 阻塞，知道创建一个 Socket clientSocket = serverSocket.</description></item><item><title/><link>https://googoo-s.github.io/netty/%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/netty/%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/</guid><description>每个网络应用程序都必须定义如何解析在
两个节点之间来回传输的原始字节
其和 目标应用程序的数据格式做相互转换
编码器是将消息转换为适合于传输的格式（最有可能的就是字节流）；
而对应的解码器则是将网络字节流转换回应用程序的消息格式
解码器 因为解码器是负责将入站数据从一种格式转换到另一种格式的，所以知道 Netty 的解码器实现了 ChannelInboundHandler 也不会让你感到意外。</description></item><item><title/><link>https://googoo-s.github.io/statistic/%E5%BA%94%E7%94%A8%E5%B1%82.png/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/statistic/%E5%BA%94%E7%94%A8%E5%B1%82.png/</guid><description/></item><item><title/><link>https://googoo-s.github.io/statistic/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82.png/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/statistic/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82.png/</guid><description/></item><item><title/><link>https://googoo-s.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%8F%AF%E7%94%A8/%E6%97%A5%E5%BF%97/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8B%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%8F%AF%E7%94%A8/%E6%97%A5%E5%BF%97/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8B%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/</guid><description/></item><item><title/><link>https://googoo-s.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%8F%AF%E7%94%A8/%E7%9B%91%E6%8E%A7/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%81%9A/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%8F%AF%E7%94%A8/%E7%9B%91%E6%8E%A7/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%81%9A/</guid><description/></item><item><title/><link>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/RocketMQ%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/RocketMQ%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</guid><description>消息队列扫盲 消息队列顾名思义就是存放消息的队列，队列我就不解释了，别告诉我你连队列都不知道是啥吧？
所以问题并不是消息队列是什么，而是 消息队列为什么会出现？消息队列能用来干什么？用它来干这些事会带来什么好处？消息队列会带来副作用吗？
# 消息队列为什么会出现？ 消息队列算是作为后端程序员的一个必备技能吧，因为分布式应用必定涉及到各个系统之间的通信问题，这个时候消息队列也应运而生了。可以说分布式的产生是消息队列的基础，而分布式怕是一个很古老的概念了吧，所以消息队列也是一个很古老的中间件了。
# 消息队列能用来干什么？ # 异步 你可能会反驳我，应用之间的通信又不是只能由消息队列解决，好好的通信为什么中间非要插一个消息队列呢？我不能直接进行通信吗？
很好 👍，你又提出了一个概念，同步通信。就比如现在业界使用比较多的 Dubbo 就是一个适用于各个系统之间同步通信的 RPC 框架。
我来举个 🌰 吧，比如我们有一个购票系统，需求是用户在购买完之后能接收到购买完成的短信。</description></item><item><title/><link>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%9C%BA%E6%99%AF%E9%A2%98/%E5%A6%82%E4%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%9C%BA%E6%99%AF%E9%A2%98/%E5%A6%82%E4%BD%95/</guid><description/></item><item><title/><link>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%9C%BA%E6%99%AF%E9%A2%98/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%8E%92%E8%A1%8C%E6%A6%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%9C%BA%E6%99%AF%E9%A2%98/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%8E%92%E8%A1%8C%E6%A6%9C/</guid><description/></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/HTTP/7-HTTP3-%E5%BC%BA%E5%8A%BF%E6%9D%A5%E8%A2%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/HTTP/7-HTTP3-%E5%BC%BA%E5%8A%BF%E6%9D%A5%E8%A2%AD/</guid><description>HTTP/3 现在（2022 年 5 月）还没正式推出，不过自 2017 年起，HTTP/3 已经更新到 34 个草案了，基本的特性已经确定下来了，对于包格式可能后续会有变化。
所以，这次 HTTP/3 介绍不会涉及到包格式，只说它的特性。
美中不足的 HTTP/2 HTTP/2 通过头部压缩、二进制编码、多路复用、服务器推送等新特性大幅度提升了 HTTP/1.1 的性能，而美中不足的是 HTTP/2 协议是基于 TCP 实现的，于是存在的缺陷有三个。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/HTTP/9-%E6%97%A2%E7%84%B6%E6%9C%89-HTTP-%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89-WebSocket/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/HTTP/9-%E6%97%A2%E7%84%B6%E6%9C%89-HTTP-%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89-WebSocket/</guid><description>来源：公众号@小白debug
原文地址： 既然有 HTTP 协议，为什么还要有 WebSocket？
平时我们打开网页，比如购物网站某宝。都是点一下「列表商品」，跳转一下网页就到了「商品详情」。
从 HTTP 协议的角度来看，就是点一下网页上的某个按钮，前端发一次 HTTP 请求，网站返回一次 HTTP 响应。这种由客户端主动请求，服务器响应的方式也满足大部分网页的功能场景。
但有没有发现，这种情况下，服务器从来就「不会主动」给客户端发一次消息。就像你喜欢的女生从来不会主动找你一样。
但如果现在，你在刷网页的时候「右下角」突然弹出一个小广告，提示你【一个人在家偷偷才能玩哦】。
求知，好学，勤奋，这些刻在你 DNA 里的东西都动起来了。</description></item><item><title>Git 核心概念总结</title><link>https://googoo-s.github.io/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/git/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/git/</guid><description>版本控制 什么是版本控制 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。除了项目源代码，你可以对任何类型的文件进行版本控制。
为什么要版本控制 有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。
本地版本控制系统 许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单，但是特别容易犯错。有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。
为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。
集中化的版本控制系统 接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。
集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。
这么做虽然解决了本地版本控制系统无法让在不同系统上的开发者协同工作的诟病，但也还是存在下面的问题：
单点故障： 中央服务器宕机，则其他人无法使用；如果中心数据库磁盘损坏又没有进行备份，你将丢失所有数据。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。 必须联网才能工作： 受网络状况、带宽影响。 分布式版本控制系统 于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 Git 就是一个典型的分布式版本控制系统。</description></item></channel></rss>