<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="4.21 用了 TCP 协议，数据一定不会丢吗？  来源：公众号@小白debug
原文地址： 用了 TCP 协议，数据一定不会丢吗？
 大家后，我是小林。
问大家一句：TCP 是一个可靠的传输协议，那它一定能保证数据不丢失吗？
这次，就跟大家探讨这个问题。
数据包的发送流程 首先，我们两个手机的绿皮聊天软件客户端，要通信，中间会通过它们家服务器。大概长这样。
 但为了简化模型，我们把中间的服务器给省略掉，假设这是个端到端的通信。且为了保证消息的可靠性，我们盲猜它们之间用的是TCP协议进行通信。
 为了发送数据包，两端首先会通过三次握手，建立TCP连接。"><meta property="og:title" content><meta property="og:description" content="4.21 用了 TCP 协议，数据一定不会丢吗？  来源：公众号@小白debug
原文地址： 用了 TCP 协议，数据一定不会丢吗？
 大家后，我是小林。
问大家一句：TCP 是一个可靠的传输协议，那它一定能保证数据不丢失吗？
这次，就跟大家探讨这个问题。
数据包的发送流程 首先，我们两个手机的绿皮聊天软件客户端，要通信，中间会通过它们家服务器。大概长这样。
 但为了简化模型，我们把中间的服务器给省略掉，假设这是个端到端的通信。且为了保证消息的可靠性，我们盲猜它们之间用的是TCP协议进行通信。
 为了发送数据包，两端首先会通过三次握手，建立TCP连接。"><meta property="og:type" content="website"><meta property="og:image" content="https://googoo-s.github.io/icon.png"><meta property="og:url" content="https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_drop/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="4.21 用了 TCP 协议，数据一定不会丢吗？  来源：公众号@小白debug
原文地址： 用了 TCP 协议，数据一定不会丢吗？
 大家后，我是小林。
问大家一句：TCP 是一个可靠的传输协议，那它一定能保证数据不丢失吗？
这次，就跟大家探讨这个问题。
数据包的发送流程 首先，我们两个手机的绿皮聊天软件客户端，要通信，中间会通过它们家服务器。大概长这样。
 但为了简化模型，我们把中间的服务器给省略掉，假设这是个端到端的通信。且为了保证消息的可靠性，我们盲猜它们之间用的是TCP协议进行通信。
 为了发送数据包，两端首先会通过三次握手，建立TCP连接。"><meta name=twitter:image content="https://googoo-s.github.io/icon.png"><title>googoo-s 😄😸😎</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://googoo-s.github.io//icon.png><link href=https://googoo-s.github.io/styles.19109a40042e9f0e72e952fda4442a34.min.css rel=stylesheet><link href=https://googoo-s.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://googoo-s.github.io/js/darkmode.953af745b0f9342644d632fc167f3727.min.js></script>
<script src=https://googoo-s.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://googoo-s.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://googoo-s.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://googoo-s.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://googoo-s.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://googoo-s.github.io/",fetchData=Promise.all([fetch("https://googoo-s.github.io/indices/linkIndex.0be9ea5cc5a709de699463fae2ac30a8.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://googoo-s.github.io/indices/contentIndex.0d1fcd0ce55147328e47ced9d4063f41.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://googoo-s.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://googoo-s.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/googoo-s.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=googoo-s.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://googoo-s.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://googoo-s.github.io/>googoo-s 😄😸😎</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Unknown</p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#421-用了-tcp-协议数据一定不会丢吗>4.21 用了 TCP 协议，数据一定不会丢吗？</a><ol><li><a href=#数据包的发送流程>数据包的发送流程</a></li><li><a href=#建立连接时丢包>建立连接时丢包</a></li><li><a href=#流量控制丢包>流量控制丢包</a></li><li><a href=#网卡丢包>网卡丢包</a><ol><li><a href=#ringbuffer过小导致丢包>RingBuffer过小导致丢包</a></li><li><a href=#网卡性能不足>网卡性能不足</a></li></ol></li><li><a href=#接收缓冲区丢包>接收缓冲区丢包</a></li><li><a href=#两端之间的网络丢包>两端之间的网络丢包</a><ol><li><a href=#ping命令查看丢包><strong>ping命令查看丢包</strong></a></li><li><a href=#mtr命令><strong>mtr命令</strong></a></li></ol></li><li><a href=#发生丢包了怎么办>发生丢包了怎么办</a></li><li><a href=#用了tcp协议就一定不会丢包吗>用了TCP协议就一定不会丢包吗</a></li><li><a href=#这类丢包问题怎么解决>这类丢包问题怎么解决？</a></li><li><a href=#总结>总结</a></li></ol></li></ol></nav></details></aside><a href=#421-用了-tcp-协议数据一定不会丢吗><h1 id=421-用了-tcp-协议数据一定不会丢吗><span class=hanchor arialabel=Anchor># </span>4.21 用了 TCP 协议，数据一定不会丢吗？</h1></a><blockquote><p>来源：公众号@小白debug</p><p>原文地址：
<a href=https://mp.weixin.qq.com/s/XNJoaVnYT1SxHsdNWeAaUw rel=noopener>用了 TCP 协议，数据一定不会丢吗？</a></p></blockquote><p>大家后，我是小林。</p><p>问大家一句：TCP 是一个可靠的传输协议，那它一定能保证数据不丢失吗？</p><p>这次，就跟大家探讨这个问题。</p><a href=#数据包的发送流程><h2 id=数据包的发送流程><span class=hanchor arialabel=Anchor># </span>数据包的发送流程</h2></a><p>首先，我们两个手机的绿皮聊天软件客户端，要通信，中间会通过它们家服务器。大概长这样。</p><p><img src=https://img-blog.csdnimg.cn/img_convert/1d0a1d60ca4f720423911cf8f25c4ac3.png width=auto alt=聊天软件三端通信></p><p>但为了<strong>简化模型</strong>，我们把中间的服务器给省略掉，假设这是个端到端的通信。且为了保证消息的可靠性，我们盲猜它们之间用的是<strong>TCP协议</strong>进行通信。</p><p><img src=https://img-blog.csdnimg.cn/img_convert/7e8bae365b8d27560aac1cd28f501156.png width=auto alt=聊天软件两端通信></p><p>为了发送数据包，两端首先会通过<strong>三次握手</strong>，建立TCP连接。</p><p>一个数据包，从聊天框里发出，消息会从<strong>聊天软件</strong>所在的<strong>用户空间</strong>拷贝到<strong>内核空间</strong>的<strong>发送缓冲区（send buffer）</strong>，数据包就这样顺着<strong>传输层、网络层，进入到数据链路层，在这里数据包会经过流控（qdisc），再通过RingBuffer发到物理层的网卡</strong>。数据就这样顺着<strong>网卡</strong>发到了<strong>纷繁复杂</strong>的网络世界里。这里头数据会经过n多个<strong>路由器和交换机</strong>之间的跳转，最后到达<strong>目的机器的网卡</strong>处。</p><p>此时目的机器的网卡会通知<strong>DMA</strong>将数据包信息放到<code>RingBuffer</code>中，再触发一个<strong>硬中断</strong>给<code>CPU</code>，<code>CPU</code>触发<strong>软中断</strong>让<code>ksoftirqd</code>去<code>RingBuffer</code>收包，于是一个数据包就这样顺着<strong>物理层，数据链路层，网络层，传输层</strong>，最后从内核空间拷贝到用户空间里的<strong>聊天软件</strong>里。</p><p><img src=https://img-blog.csdnimg.cn/img_convert/28e4d6b004530fbf75fe346d181baa81.png width=auto alt=网络发包收包全景图></p><blockquote><p>画了那么大一张图，只水了200字做解释，我多少是有些心痛的。</p></blockquote><p>到这里，抛开一些细节，大家大概知道了一个数据包从<strong>发送到接收</strong>的宏观过程。</p><p>可以看到，这上面全是密密麻麻的<strong>名词</strong>。</p><p>整条链路下来，有不少地方可能会发生丢包。</p><p>但为了不让大家<strong>保持蹲姿太久</strong>影响身体健康，我这边只重点讲下几个<strong>常见容易发生丢包的场景</strong>。</p><a href=#建立连接时丢包><h2 id=建立连接时丢包><span class=hanchor arialabel=Anchor># </span>建立连接时丢包</h2></a><p>TCP协议会通过<strong>三次握手</strong>建立连接。大概长下面这样。</p><p><img src=https://img-blog.csdnimg.cn/img_convert/923f5005edb536c0d07b096bbf2ca282.png width=auto alt=TCP三次握手></p><p>在服务端，第一次握手之后，会先建立个<strong>半连接</strong>，然后再发出第二次握手。这时候需要有个地方可以<strong>暂存</strong>这些半连接。这个地方就叫<strong>半连接队列</strong>。</p><p>如果之后第三次握手来了，半连接就会升级为全连接，然后暂存到另外一个叫<strong>全连接队列</strong>的地方，坐等程序执行<code>accept()</code>方法将其取走使用。</p><p><img src=https://img-blog.csdnimg.cn/img_convert/02a78bb83fe167324f26e8c910d7a7a2.png width=auto alt=半连接队列和全连接队列></p><p>是队列就有长度，有长度就有可能会满，如果它们<strong>满了</strong>，那新来的包就会被<strong>丢弃</strong>。</p><p>可以通过下面的方式查看是否存在这种丢包行为。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 全连接队列溢出次数</span>
</span></span><span class=line><span class=cl><span class=c1># netstat -s | grep overflowed</span>
</span></span><span class=line><span class=cl>    <span class=m>4343</span> <span class=nb>times</span> the listen queue of a socket overflowed
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 半连接队列溢出次数</span>
</span></span><span class=line><span class=cl><span class=c1># netstat -s | grep -i &#34;SYNs to LISTEN sockets dropped&#34;</span>
</span></span><span class=line><span class=cl>    <span class=m>109</span> <span class=nb>times</span> the listen queue of a socket overflowed 
</span></span></code></pre></td></tr></table></div></div><p>从现象来看就是连接建立失败。</p><p><img src=https://img-blog.csdnimg.cn/img_convert/591d630098b4fc5316a5005f1e94b844.png width=auto alt=图片></p><a href=#流量控制丢包><h2 id=流量控制丢包><span class=hanchor arialabel=Anchor># </span>流量控制丢包</h2></a><p>应用层能发网络数据包的软件有那么多，如果所有数据不加控制一股脑冲入到网卡，网卡会吃不消，那怎么办？让数据按一定的规则排个队依次处理，也就是所谓的<strong>qdisc</strong>(<strong>Q</strong>ueueing <strong>Disc</strong>iplines，排队规则)，这也是我们常说的<strong>流量控制</strong>机制。</p><p>排队，得先有个队列，而队列有个<strong>长度</strong>。</p><p>我们可以通过下面的<code>ifconfig</code>命令查看到，里面涉及到的<code>txqueuelen</code>后面的数字<code>1000</code>，其实就是流控队列的长度。</p><p>当发送数据过快，流控队列长度<code>txqueuelen</code>又不够大时，就容易出现<strong>丢包</strong>现象。</p><p><img src=https://img-blog.csdnimg.cn/img_convert/6f2821018be08a2f27561155e8085de4.png width=auto alt=qdisc丢包></p><p>可以通过下面的<code>ifconfig</code>命令，查看TX下的dropped字段，当它大于0时，则<strong>有可能</strong>是发生了流控丢包。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># ifconfig eth0</span>
</span></span><span class=line><span class=cl>eth0: <span class=nv>flags</span><span class=o>=</span>4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class=m>1500</span>
</span></span><span class=line><span class=cl>        inet 172.21.66.69  netmask 255.255.240.0  broadcast 172.21.79.255
</span></span><span class=line><span class=cl>        inet6 fe80::216:3eff:fe25:269f  prefixlen <span class=m>64</span>  scopeid 0x20&lt;link&gt;
</span></span><span class=line><span class=cl>        ether 00:16:3e:25:26:9f  txqueuelen <span class=m>1000</span>  <span class=o>(</span>Ethernet<span class=o>)</span>
</span></span><span class=line><span class=cl>        RX packets <span class=m>6962682</span>  bytes <span class=m>1119047079</span> <span class=o>(</span>1.0 GiB<span class=o>)</span>
</span></span><span class=line><span class=cl>        RX errors <span class=m>0</span>  dropped <span class=m>0</span>  overruns <span class=m>0</span>  frame <span class=m>0</span>
</span></span><span class=line><span class=cl>        TX packets <span class=m>9688919</span>  bytes <span class=m>2072511384</span> <span class=o>(</span>1.9 GiB<span class=o>)</span>
</span></span><span class=line><span class=cl>        TX errors <span class=m>0</span>  dropped <span class=m>0</span> overruns <span class=m>0</span>  carrier <span class=m>0</span>  collisions <span class=m>0</span>
</span></span></code></pre></td></tr></table></div></div><p>当遇到这种情况时，我们可以尝试修改下流控队列的长度。比如像下面这样将eth0网卡的流控队列长度从1000提升为1500.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># ifconfig eth0 txqueuelen 1500</span>
</span></span></code></pre></td></tr></table></div></div><a href=#网卡丢包><h2 id=网卡丢包><span class=hanchor arialabel=Anchor># </span>网卡丢包</h2></a><p>网卡和它的驱动导致丢包的场景也比较常见，原因很多，比如<strong>网线质量差，接触不良</strong>。除此之外，我们来聊几个常见的场景。</p><a href=#ringbuffer过小导致丢包><h3 id=ringbuffer过小导致丢包><span class=hanchor arialabel=Anchor># </span>RingBuffer过小导致丢包</h3></a><p>上面提到，在接收数据时，会将数据暂存到<code>RingBuffer</code>接收缓冲区中，然后等着内核触发软中断慢慢收走。如果这个<strong>缓冲区过小</strong>，而这时候发送的数据又过快，就有可能发生溢出，此时也会产生<strong>丢包</strong>。</p><p><img src=https://img-blog.csdnimg.cn/img_convert/8f3ed2d6c4e2e154849f1e661528fe89.png width=auto alt=RingBuffer满了导致丢包></p><p>我们可以通过下面的命令去查看是否发生过这样的事情。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># ifconfig</span>
</span></span><span class=line><span class=cl>eth0:  RX errors <span class=m>0</span>  dropped <span class=m>0</span>  overruns <span class=m>0</span>  frame <span class=m>0</span>
</span></span></code></pre></td></tr></table></div></div><p>查看上面的<code>overruns</code>指标，它记录了由于<code>RingBuffer</code>长度不足导致的溢出次数。</p><p>当然，用<code>ethtool</code>命令也能查看。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># ethtool -S eth0|grep rx_queue_0_drops</span>
</span></span></code></pre></td></tr></table></div></div><p>但这里需要注意的是，因为一个网卡里是可以有<strong>多个RingBuffer</strong>的，所以上面的<code>rx_queue_0_drops</code>里的0代表的是<strong>第0个RingBuffer</strong>的丢包数，对于多队列的网卡，这个0还可以改成其他数字。但我的家庭条件不允许我看其他队列的丢包数，所以上面的命令对我来说是够用了。。。</p><p>当发现有这类型丢包的时候，可以通过下面的命令查看当前网卡的配置。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#ethtool -g eth0</span>
</span></span><span class=line><span class=cl>Ring parameters <span class=k>for</span> eth0:
</span></span><span class=line><span class=cl>Pre-set maximums:
</span></span><span class=line><span class=cl>RX:        <span class=m>4096</span>
</span></span><span class=line><span class=cl>RX Mini:    <span class=m>0</span>
</span></span><span class=line><span class=cl>RX Jumbo:    <span class=m>0</span>
</span></span><span class=line><span class=cl>TX:        <span class=m>4096</span>
</span></span><span class=line><span class=cl>Current hardware settings:
</span></span><span class=line><span class=cl>RX:        <span class=m>1024</span>
</span></span><span class=line><span class=cl>RX Mini:    <span class=m>0</span>
</span></span><span class=line><span class=cl>RX Jumbo:    <span class=m>0</span>
</span></span><span class=line><span class=cl>TX:        <span class=m>1024</span>
</span></span></code></pre></td></tr></table></div></div><p>上面的输出内容，含义是<strong>RingBuffer最大支持4096的长度，但现在实际只用了1024。</strong></p><p>想要修改这个长度可以执行<code>ethtool -G eth1 rx 4096 tx 4096</code>将发送和接收RingBuffer的长度都改为4096。</p><p><strong>RingBuffer</strong>增大之后，可以减少因为容量小而导致的丢包情况。</p><a href=#网卡性能不足><h3 id=网卡性能不足><span class=hanchor arialabel=Anchor># </span>网卡性能不足</h3></a><p>网卡作为硬件，<strong>传输速度是有上限的</strong>。当网络传输速度过大，达到网卡上限时，就会发生丢包。这种情况一般常见于压测场景。</p><p>我们可以通过<code>ethtool</code>加网卡名，获得当前网卡支持的最大速度。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># ethtool eth0</span>
</span></span><span class=line><span class=cl>Settings <span class=k>for</span> eth0:
</span></span><span class=line><span class=cl>    Speed: 10000Mb/s
</span></span></code></pre></td></tr></table></div></div><p>可以看到，我这边用的网卡能支持的最大传输速度<strong>speed=1000Mb/s</strong>。</p><p>也就是俗称的千兆网卡，但注意这里的单位是<strong>Mb</strong>，这里的<strong>b是指bit，而不是Byte。1Byte=8bit</strong>。所以10000Mb/s还要除以8，也就是理论上网卡最大传输速度是<code>1000/8 = 125MB/s</code>。</p><p>我们可以通过<code>sar命令</code>从网络接口层面来分析数据包的收发情况。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># sar -n DEV 1</span>
</span></span><span class=line><span class=cl>Linux 3.10.0-1127.19.1.el7.x86_64      2022年07月27日     _x86_64_    <span class=o>(</span><span class=m>1</span> CPU<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>08时35分39秒     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s    rxcmp/s   txcmp/s  rxmcst/s
</span></span><span class=line><span class=cl>08时35分40秒      eth0      6.06      4.04      0.35    121682.33   0.00    0.00     0.00
</span></span></code></pre></td></tr></table></div></div><p>其中 <strong>txkB/s是指当前每秒发送的字节（byte）总数，rxkB/s是指每秒接收的字节（byte）总数</strong>。</p><p>当两者加起来的值约等于<code>12~13w字节</code>的时候，也就对应大概<code>125MB/s</code>的传输速度。此时达到网卡性能极限，就会开始丢包。</p><p>遇到这个问题，优先看下你的服务是不是真有这么大的<strong>真实流量</strong>，如果是的话可以考虑下拆分服务，或者就忍痛充钱升级下配置吧。</p><a href=#接收缓冲区丢包><h2 id=接收缓冲区丢包><span class=hanchor arialabel=Anchor># </span>接收缓冲区丢包</h2></a><p>我们一般使用<code>TCP socket</code>进行网络编程的时候，内核都会分配一个<strong>发送缓冲区</strong>和一个<strong>接收缓冲区</strong>。</p><p>当我们想要发一个数据包，会在代码里执行<code>send(msg)</code>，这时候数据包并不是一把梭直接就走网卡飞出去的。而是将数据拷贝到内核<strong>发送缓冲区</strong>就完事<strong>返回</strong>了，至于<strong>什么时候发数据，发多少数据</strong>，这个后续由内核自己做决定。</p><p><img src=https://img-blog.csdnimg.cn/img_convert/9cd22437777205662048c73cc5855add.png width=auto alt=tcp_sendmsg逻辑></p><p>而<strong>接收缓冲区</strong>作用也类似，从外部网络收到的数据包就暂存在这个地方，然后坐等用户空间的应用程序将数据包取走。</p><p>这两个缓冲区是有大小限制的，可以通过下面的命令去查看。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 查看接收缓冲区</span>
</span></span><span class=line><span class=cl><span class=c1># sysctl net.ipv4.tcp_rmem</span>
</span></span><span class=line><span class=cl>net.ipv4.tcp_rmem <span class=o>=</span> <span class=m>4096</span>    <span class=m>87380</span>   <span class=m>6291456</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看发送缓冲区</span>
</span></span><span class=line><span class=cl><span class=c1># sysctl net.ipv4.tcp_wmem</span>
</span></span><span class=line><span class=cl>net.ipv4.tcp_wmem <span class=o>=</span> <span class=m>4096</span>    <span class=m>16384</span>   <span class=m>4194304</span>
</span></span></code></pre></td></tr></table></div></div><p>不管是接收缓冲区还是发送缓冲区，都能看到三个数值，分别对应缓冲区的<strong>最小值，默认值和最大值 （min、default、max）。缓冲区会在min和max之间动态调整。</strong></p><p><strong>那么问题来了，如果缓冲区设置过小会怎么样？</strong></p><p>对于<strong>发送缓冲区</strong>，执行send的时候，如果是<strong>阻塞</strong>调用，那就会等，等到缓冲区有空位可以发数据。</p><p><img src=https://img-blog.csdnimg.cn/img_convert/7312e536393463dcf0d57aeb07f28ed5.gif width=auto alt=send阻塞></p><p>如果是<strong>非阻塞</strong>调用，就会<strong>立刻返回</strong>一个 <code>EAGAIN</code> 错误信息，意思是 <code>Try again</code>。让应用程序下次再重试。这种情况下一般不会发生丢包。</p><p><img src=https://img-blog.csdnimg.cn/img_convert/f378a299ca60c490ee5437e1143916c8.gif width=auto alt=send非阻塞></p><p>当接受缓冲区满了，事情就不一样了，它的TCP接收窗口会变为0，也就是所谓的<strong>零窗口</strong>，并且会通过数据包里的<code>win=0</code>，告诉发送端，&ldquo;球球了，顶不住了，别发了&rdquo;。一般这种情况下，发送端就该停止发消息了，但如果这时候确实还有数据发来，就会发生<strong>丢包</strong>。</p><p><img src=https://img-blog.csdnimg.cn/img_convert/2df66c2e1d9f1245813e8d1de7482e0c.png width=auto alt=recv_buffer丢包></p><p>我们可以通过下面的命令里的<code>TCPRcvQDrop</code>查看到有没有发生过这种丢包现象。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>cat /proc/net/netstat
</span></span><span class=line><span class=cl>TcpExt: SyncookiesSent TCPRcvQDrop SyncookiesFailed
</span></span><span class=line><span class=cl>TcpExt: <span class=m>0</span>              <span class=m>157</span>              <span class=m>60116</span>
</span></span></code></pre></td></tr></table></div></div><p>但是说个伤心的事情，我们一般也看不到这个<code>TCPRcvQDrop</code>，因为这个是<code>5.9版本</code>里引入的打点，而我们的服务器用的一般是<code>2.x~3.x</code>左右版本。你可以通过下面的命令查看下你用的是什么版本的linux内核。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># cat /proc/version</span>
</span></span><span class=line><span class=cl>Linux version 3.10.0-1127.19.1.el7.x86_64
</span></span></code></pre></td></tr></table></div></div><a href=#两端之间的网络丢包><h2 id=两端之间的网络丢包><span class=hanchor arialabel=Anchor># </span>两端之间的网络丢包</h2></a><p>前面提到的是两端机器内部的网络丢包，除此之外，两端之间那么长的一条链路都属于外部网络，这中间有各种路由器和交换机还有光缆啥的，丢包也是很经常发生的。</p><p>这些丢包行为发生在中间链路的某些个机器上，我们当然是没权限去登录这些机器。但我们可以通过一些命令观察整个链路的连通情况。</p><a href=#ping命令查看丢包><h3 id=ping命令查看丢包><span class=hanchor arialabel=Anchor># </span><strong>ping命令查看丢包</strong></h3></a><p>比如我们知道目的地的域名是 <code>baidu.com</code>。想知道你的机器到baidu服务器之间，有没有产生丢包行为。可以使用ping命令。</p><p><img src=https://img-blog.csdnimg.cn/img_convert/56bdca9995c0c2a343b2b73b67933b78.png width=auto alt=ping查看丢包></p><p>倒数第二行里有个<code>100% packet loss</code>，意思是丢包率100%。</p><p>但这样其实你只能知道<strong>你的机器和目的机器之间有没有丢包。</strong></p><p><strong>那如果你想知道你和目的机器之间的这条链路，哪个节点丢包了，有没有办法呢?</strong></p><p>有。</p><a href=#mtr命令><h3 id=mtr命令><span class=hanchor arialabel=Anchor># </span><strong>mtr命令</strong></h3></a><p>mtr命令可以查看到你的机器和目的机器之间的每个节点的丢包情况。</p><p>像下面这样执行命令。</p><p><img src=https://img-blog.csdnimg.cn/img_convert/4a2d8dbfb648bcced864fb653af9f036.png width=auto alt=mtr_icmp></p><p>其中 -r 是指report，以报告的形式打印结果。</p><p>可以看到<code>Host</code>那一列，出现的都是链路中间每一跳的机器，<code>Loss</code>的那一列就是指这一跳对应的丢包率。</p><p>需要注意的是，中间有一些是host是<code>???</code>，那个是因为<strong>mtr默认用的是ICMP包</strong>，有些节点限制了<strong>ICMP包</strong>，导致不能正常展示。</p><p>我们可以在mtr命令里加个<code>-u</code>，也就是使用<strong>udp包</strong>，就能看到部分???对应的IP。</p><p><img src=https://img-blog.csdnimg.cn/img_convert/0650adc524ab7d82028dc83cfc9961e1.png width=auto alt=mtr-udp></p><p>把<strong>ICMP包和UDP包的结果</strong>拼在一起看，就是<strong>比较完整</strong>的链路图了。</p><p>还有个小细节，<code>Loss</code>那一列，我们在icmp的场景下，关注<strong>最后一行</strong>，如果是0%，那不管前面loss是100%还是80%都无所谓，那些都是<strong>节点限制</strong>导致的<strong>虚报</strong>。</p><p>但如果<strong>最后一行是20%，再往前几行都是20%左右</strong>，那说明丢包就是从最接近的那一行开始产生的，长时间是这样，那很可能这一跳出了点问题。如果是公司内网的话，你可以带着这条线索去找对应的网络同事。如果是外网的话，那耐心点等等吧，别人家的开发会比你更着急。</p><p><img src=https://img-blog.csdnimg.cn/img_convert/7142a4e285024dc6aadea4255984c485.png width=auto alt=图片></p><a href=#发生丢包了怎么办><h2 id=发生丢包了怎么办><span class=hanchor arialabel=Anchor># </span>发生丢包了怎么办</h2></a><p>说了这么多。只是想告诉大家，<strong>丢包是很常见的，几乎不可避免的一件事情</strong>。</p><p>但问题来了，发生丢包了怎么办？</p><p>这个好办，用<strong>TCP协议</strong>去做传输。</p><p><img src=https://img-blog.csdnimg.cn/img_convert/b2225e071fec7cfb240aa295ed4037bf.png width=auto alt=TCP是什么></p><p>建立了TCP连接的两端，发送端在发出数据后会等待接收端回复<code>ack包</code>，<code>ack包</code>的目的是为了告诉对方自己确实收到了数据，但如果中间链路发生了丢包，那发送端会迟迟收不到确认ack，于是就会进行<strong>重传</strong>。以此来保证每个数据包都确确实实到达了接收端。</p><p>假设现在网断了，我们还用聊天软件发消息，聊天软件会使用TCP不断尝试重传数据，<strong>如果重传期间网络恢复了</strong>，那数据就能正常发过去。但如果多次重试直到超时都还是失败，这时候你将收获一个<strong>红色感叹号</strong>。</p><p><img src=https://img-blog.csdnimg.cn/img_convert/c1460d52efe7c5e4d80c2f7160d5b126.png width=auto alt=图片></p><p>这时候问题又来了。</p><p>假设<strong>某绿皮聊天软件用的就是TCP协议。</strong></p><p>在聊天的时候， 发生丢包了，丢包了会<strong>重试</strong>，重试失败了还会出现<strong>红色感叹号。</strong></p><p>于是乎，问题就变成了，<strong>用了 TCP 协议，就一定不会丢包吗？</strong></p><a href=#用了tcp协议就一定不会丢包吗><h2 id=用了tcp协议就一定不会丢包吗><span class=hanchor arialabel=Anchor># </span>用了TCP协议就一定不会丢包吗</h2></a><p>我们知道TCP位于<strong>传输层</strong>，在它的上面还有各种<strong>应用层协议</strong>，比如常见的HTTP或者各类RPC协议。</p><p><img src=https://img-blog.csdnimg.cn/img_convert/c6794dd51c8780f12e4022fc964ebb0a.png width=auto alt=四层网络协议></p><p>TCP保证的可靠性，是<strong>传输层的可靠性</strong>。也就是说，<strong>TCP只保证数据从A机器的传输层可靠地发到B机器的传输层。</strong></p><p>至于数据到了接收端的传输层之后，能不能保证到应用层，TCP并不管。</p><p>假设现在，我们输入一条消息，从聊天框发出，走到<strong>传输层TCP协议的发送缓冲区</strong>，不管中间有没有丢包，最后通过重传都保证发到了对方的<strong>传输层TCP接收缓冲区</strong>，此时接收端回复了一个<code>ack</code>，发送端收到这个<code>ack</code>后就会将自己<strong>发送缓冲区</strong>里的消息给扔掉。到这里TCP的任务就结束了。</p><p>TCP任务是结束了，但聊天软件的任务没结束。</p><p><strong>聊天软件还需要将数据从TCP的接收缓冲区里读出来，如果在读出来这一刻，手机由于内存不足或其他各种原因，导致软件崩溃闪退了。</strong></p><p>发送端以为自己发的消息已经发给对方了，但接收端却并没有收到这条消息。</p><p>于是乎，<strong>消息就丢了。</strong></p><p><img src=https://img-blog.csdnimg.cn/img_convert/9286ab84bcaa74576bc11c8e9322fee9.png width=auto alt=使用TCP协议却发生丢包></p><p><strong>虽然概率很小，但它就是发生了</strong>。</p><p>合情合理，逻辑自洽。</p><a href=#这类丢包问题怎么解决><h2 id=这类丢包问题怎么解决><span class=hanchor arialabel=Anchor># </span>这类丢包问题怎么解决？</h2></a><p>故事到这里也到尾声了，感动之余，我们来<strong>聊点掏心窝子的话</strong>。</p><p><strong>其实前面说的都对，没有一句是假话</strong>。</p><p>但某绿皮聊天软件这么成熟，怎么可能没考虑过这一点呢。</p><p>大家应该还记得我们文章开头提到过，<strong>为了简单</strong>，就将服务器那一方给省略了，从三端通信变成了两端通信，所以才有了这个丢包问题。</p><p><strong>现在我们重新将服务器加回来。</strong></p><p><img src=https://img-blog.csdnimg.cn/img_convert/d53659df39d64db4780d2816bd8314d1.png width=auto alt=聊天软件三端通信></p><p>大家有没有发现，有时候我们在手机里聊了一大堆内容，然后登录电脑版，它能将最近的聊天记录都同步到电脑版上。也就是说服务器<strong>可能</strong>记录了我们最近发过什么数据，假设<strong>每条消息都有个id</strong>，服务器和聊天软件每次都拿<strong>最新消息的id</strong>进行对比，就能知道两端消息是否一致，就像<strong>对账</strong>一样。</p><p>对于<strong>发送方</strong>，只要定时跟服务端的内容对账一下，就知道哪条消息没发送成功，直接重发就好了。</p><p>如果<strong>接收方</strong>的聊天软件崩溃了，重启后跟服务器稍微通信一下就知道少了哪条数据，同步上来就是了，所以也不存在上面提到的丢包情况。</p><p>可以看出，<strong>TCP只保证传输层的消息可靠性，并不保证应用层的消息可靠性。如果我们还想保证应用层的消息可靠性，就需要应用层自己去实现逻辑做保证。</strong></p><p>那么问题叒来了，<strong>两端通信的时候也能对账，为什么还要引入第三端服务器？</strong></p><p>主要有三个原因。</p><ul><li>第一，如果是两端通信，你聊天软件里有<code>1000个</code>好友，你就得建立<code>1000个</code>连接。但如果引入服务端，你只需要跟服务器建立<code>1个</code>连接就够了，<strong>聊天软件消耗的资源越少，手机就越省电</strong>。</li><li>第二，就是<strong>安全问题</strong>，如果还是两端通信，随便一个人找你对账一下，你就把聊天记录给同步过去了，这并不合适吧。如果对方别有用心，信息就泄露了。引入第三方服务端就可以很方便的做各种<strong>鉴权</strong>校验。</li><li>第三，是<strong>软件版本问题</strong>。软件装到用户手机之后，软件更不更新就是由用户说了算了。如果还是两端通信，且两端的<strong>软件版本跨度太大</strong>，很容易产生各种兼容性问题，但引入第三端服务器，就可以强制部分过低版本升级，否则不能使用软件。但对于大部分兼容性问题，给服务端加兼容逻辑就好了，不需要强制用户更新软件。</li></ul><p>所以看到这里大家应该明白了，我把服务端去掉，并不单纯是<strong>为了简单</strong>。</p><a href=#总结><h2 id=总结><span class=hanchor arialabel=Anchor># </span>总结</h2></a><ul><li>数据从发送端到接收端，链路很长，任何一个地方都可能发生丢包，几乎可以说丢包不可避免。</li><li>平时没事也不用关注丢包，大部分时候TCP的重传机制保证了消息可靠性。</li><li>当你发现服务异常的时候，比如接口延时很高，总是失败的时候，可以用ping或者mtr命令看下是不是中间链路发生了丢包。</li><li>TCP只保证传输层的消息可靠性，并不保证应用层的消息可靠性。如果我们还想保证应用层的消息可靠性，就需要应用层自己去实现逻辑做保证。</li></ul><hr><p><em><strong>哈喽，我是小林，就爱图解计算机基础，如果觉得文章对你有帮助，欢迎微信搜索「小林coding」</strong></em></p><p><img src=https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E5%85%B6%E4%BB%96/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BB%8B%E7%BB%8D.png width=auto alt=img></p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/%E7%BD%91%E7%BB%9C/README/ data-ctx="用了 TCP 协议，数据一定不会丢吗？" data-src=/%E7%BD%91%E7%BB%9C/README class=internal-link>README</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://googoo-s.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by googoo-s using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://googoo-s.github.io/>Home</a></li><li><a href=https://github.com/googoo-s>GitHub</a></li></ul></footer></div></div></body></html>