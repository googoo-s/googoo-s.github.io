<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>网络s on</title><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/</link><description>Recent content in 网络s on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/1_base/how_os_deal_network_package/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/1_base/how_os_deal_network_package/</guid><description>2.3 Linux 系统是如何收发网络包的？ 这次，就围绕一个问题来说。
Linux 系统是如何收发网络包的？
网络模型 为了使得多种设备能通过网络相互通信，和为了解决各种不同设备在网络互联中的兼容性问题，国际标准化组织制定了开放式系统互联通信参考模型（Open System Interconnection Reference Model），也就是 OSI 网络模型，该模型主要有 7 层，分别是应用层、表示层、会话层、传输层、网络层、数据链路层以及物理层。
每一层负责的职能都不同，如下：
应用层，负责给应用程序提供统一的接口； 表示层，负责把数据转换成兼容另一个系统能识别的格式； 会话层，负责建立、管理和终止表示层实体之间的通信会话； 传输层，负责端到端的数据传输； 网络层，负责数据的路由、转发、分片； 数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址； 物理层，负责在物理网络中传输数据帧； 由于 OSI 模型实在太复杂，提出的也只是概念理论上的分层，并没有提供具体的实现方案。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/1_base/tcp_ip_model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/1_base/tcp_ip_model/</guid><description>2.1 TCP/IP 网络模型有哪几层？ 问大家，为什么要有 TCP/IP 网络模型？
对于同一台设备上的进程间通信，有很多种方式，比如有管道、消息队列、共享内存、信号等方式，而对于不同设备上的进程间通信，就需要网络通信，而设备是多样性的，所以要兼容多种多样的设备，就协商出了一套通用的网络协议。
这个网络协议是分层的，每一层都有各自的作用和职责，接下来就根据「 TCP/IP 网络模型」分别对每一层进行介绍。
应用层 最上层的，也是我们能直接接触到的就是应用层（Application Layer），我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。
所以，应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。
应用层是不用去关心数据是如何传输的，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快递是如何被运输的。
而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。
传输层 应用层的数据包会传给传输层，传输层（Transport Layer）是为应用层提供网络支持的。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/1_base/what_happen_url/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/1_base/what_happen_url/</guid><description>2.2 键入网址到网页显示，期间发生了什么？ 想必不少小伙伴面试过程中，会遇到「当键入网址后，到网页显示，其间发生了什么」的面试题。
还别说，这问题真挺常问的，前几天坐在我旁边的主管电话面试应聘者的时候，也问了这个问题。
接下来以下图较简单的网络拓扑模型作为例子，探究探究其间发生了什么？
孤单小弟 —— HTTP 浏览器做的第一步工作是解析 URL
首先浏览器做的第一步工作就是要对 URL 进行解析，从而生成发送给 Web 服务器的请求信息。
让我们看看一条长长的 URL 里的各个元素的代表什么，见下图：</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/2_http/http2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/2_http/http2/</guid><description>3.6 HTTP/2 牛逼在哪？ 不多 BB 了，直接发车！
一起来看看 HTTP/2 牛逼在哪？
HTTP/1.1 协议的性能问题 我们得先要了解下 HTTP/1.1 协议存在的性能问题，因为 HTTP/2 协议就是把这些性能问题逐个攻破了。
现在的站点相比以前变化太多了，比如：
消息的大小变大了，从几 KB 大小的消息，到几 MB 大小的消息； 页面资源变多了，从每个页面不到 10 个的资源，到每页超 100 多个资源； 内容形式变多样了，从单纯到文本内容，到图片、视频、音频等内容； 实时性要求变高了，对页面的实时性要求的应用越来越多； 这些变化带来的最大性能问题就是 HTTP/1.</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/2_http/http3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/2_http/http3/</guid><description>3.7 HTTP/3 强势来袭 HTTP/3 现在（2022 年 5 月）还没正式推出，不过自 2017 年起，HTTP/3 已经更新到 34 个草案了，基本的特性已经确定下来了，对于包格式可能后续会有变化。
所以，这次 HTTP/3 介绍不会涉及到包格式，只说它的特性。
美中不足的 HTTP/2 HTTP/2 通过头部压缩、二进制编码、多路复用、服务器推送等新特性大幅度提升了 HTTP/1.</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/2_http/http_interview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/2_http/http_interview/</guid><description>3.1 HTTP 常见面试题 在面试过程中，HTTP 被提问的概率还是比较高的。
小林我搜集了 6 大类 HTTP 面试常问的题目，同时这 6 大类题跟 HTTP 的发展和演变关联性是比较大的，通过问答 + 图解的形式由浅入深的方式帮助大家进一步的学习和理解 HTTP。
HTTP 基本概念 Get 与 Post HTTP 特性 HTTP 缓存技术 HTTPS 与 HTTP HTTP/1.</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/2_http/http_optimize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/2_http/http_optimize/</guid><description>3.2 HTTP/1.1 如何优化？ 问你一句：「你知道 HTTP/1.1 该如何优化吗？」
我们可以从下面这三种优化思路来优化 HTTP/1.1 协议：
尽量避免发送 HTTP 请求； 在需要发送 HTTP 请求时，考虑如何减少请求次数； 减少服务器的 HTTP 响应的数据大小； 下面，就针对这三种思路具体看看有哪些优化方法。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/2_http/http_rpc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/2_http/http_rpc/</guid><description>3.8 既然有 HTTP 协议，为什么还要有 RPC？ 来源：公众号@小白debug
原文地址： 既然有 HTTP 协议，为什么还要有 RPC？
我想起了我刚工作的时候，第一次接触 RPC 协议，当时就很懵，我 HTTP 协议用的好好的，为什么还要用 RPC 协议？</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/2_http/http_websocket/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/2_http/http_websocket/</guid><description>3.9 既然有 HTTP 协议，为什么还要有 WebSocket？ 来源：公众号@小白debug
原文地址： 既然有 HTTP 协议，为什么还要有 WebSocket？
平时我们打开网页，比如购物网站某宝。都是点一下「列表商品」，跳转一下网页就到了「商品详情」。
从 HTTP 协议的角度来看，就是点一下网页上的某个按钮，前端发一次 HTTP 请求，网站返回一次 HTTP 响应。这种由客户端主动请求，服务器响应的方式也满足大部分网页的功能场景。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/2_http/https_ecdhe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/2_http/https_ecdhe/</guid><description>3.4 HTTPS ECDHE 握手解析 HTTPS 常用的密钥交换算法有两种，分别是 RSA 和 ECDHE 算法。
其中，RSA 是比较传统的密钥交换算法，它不具备前向安全的性质，因此现在很少服务器使用的。而 ECDHE 算法具有前向安全，所以被广泛使用。
我在上一篇已经介绍了 RSA 握手的过程，今天这一篇就「从理论再到实战抓包」介绍 ECDHE 算法。
离散对数 ECDHE 密钥协商算法是 DH 算法演进过来的，所以我们先从 DH 算法说起。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/2_http/https_optimize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/2_http/https_optimize/</guid><description>3.5 HTTPS 如何优化？ 由裸数据传输的 HTTP 协议转成加密数据传输的 HTTPS 协议，给应用数据套了个「保护伞」，提高安全性的同时也带来了性能消耗。
因为 HTTPS 相比 HTTP 协议多一个 TLS 协议握手过程，目的是为了通过非对称加密握手协商或者交换出对称加密密钥，这个过程最长可以花费掉 2 RTT，接着后续传输的应用数据都得使用对称加密密钥来加密/解密。
为了数据的安全性，我们不得不使用 HTTPS 协议，至今大部分网址都已从 HTTP 迁移至 HTTPS 协议，因此针对 HTTPS 的优化是非常重要的。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/2_http/https_rsa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/2_http/https_rsa/</guid><description>3.3 HTTPS RSA 握手解析 我前面讲，简单给大家介绍了的 HTTPS 握手过程，但是还不够细！
只讲了比较基础的部分，所以这次我们再来深入一下 HTTPS，用实战抓包的方式，带大家再来窥探一次 HTTPS。
对于还不知道对称加密和非对称加密的同学，你先复习我以前的这篇文章 「硬核！30 张图解 HTTP 常见的面试题」，本篇文章默认大家已经具备了这些知识。
TLS 握手过程 HTTP 由于是明文传输，所谓的明文，就是说客户端与服务端通信的信息都是肉眼可见的，随意使用一个抓包工具都可以截获通信的内容。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/challenge_ack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/challenge_ack/</guid><description>4.9 已建立连接的 TCP，收到 SYN 会发生什么？ 大家好，我是小林。
昨晚有位读者问了我这么个问题：
大概意思是，一个已经建立的 TCP 连接，客户端中途宕机了，而服务端此时也没有数据要发送，一直处于 Established 状态，客户端恢复后，向服务端建立连接，此时服务端会怎么处理？
看过我的图解网络的读者都知道，TCP 连接是由「四元组」唯一确认的。
然后这个场景中，客户端的 IP、服务端 IP、目的端口并没有变化，所以这个问题关键要看客户端发送的 SYN 报文中的源端口是否和上一次连接的源端口相同。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/isn_deff/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/isn_deff/</guid><description>4.7 为什么 TCP 每次建立连接时，初始化序列号都要不一样呢？ 大家好，我是小林。
为什么 TCP 每次建立连接时，初始化序列号都要不一样呢？
接下来，我一步一步给大家讲明白，我觉得应该有不少人会有类似的问题，所以今天在肝一篇！
为什么 TCP 每次建立连接时，初始化序列号都要不一样呢？
主要原因是为了防止历史报文被下一个相同四元组的连接接收。
TCP 四次挥手中的 TIME_WAIT 状态不是会持续 2 MSL 时长，历史报文不是早就在网络中消失了吗？</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/out_of_order_fin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/out_of_order_fin/</guid><description>4.10 四次挥手中收到乱序的 FIN 包会如何处理？ 大家好，我是小林。
收到个读者的问题，他在面试鹅厂的时候，被搞懵了，因为面试官问了他这么一个网络问题：
不得不说，鹅厂真的很喜欢问网络问题，而且爱问异常情况下的网络问题，之前也有篇另外一个读者面试鹅厂的网络问题：「 被鹅厂面怕了！」。
不过这道鹅厂的网络题可能是提问的读者表述有问题，因为如果 FIN 报文比数据包先抵达客户端，此时 FIN 报文其实是一个乱序的报文，此时客户端的 TCP 连接并不会从 FIN_WAIT_2 状态转换到 TIME_WAIT 状态。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/port/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/port/</guid><description>4.18 TCP 和 UDP 可以使用同一个端口吗？ 大家好，我是小林。
之前有读者在字节面试的时候，被问到：TCP 和 UDP 可以同时监听相同的端口吗？
关于端口的知识点，还是挺多可以讲的，比如还可以牵扯到这几个问题：
多个 TCP 服务进程可以同时绑定同一个端口吗？ 重启 TCP 服务进程时，为什么会出现“Address in use”的报错信息？又该怎么避免？ 客户端的端口可以重复使用吗？ 客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？ 所以，这次就跟大家盘一盘这些问题。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/quic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/quic/</guid><description>4.17 如何基于 UDP 协议实现可靠传输？ 大家好，我是小林。
我记得之前在群里看到，有位读者字节一面的时候被问到：「如何基于 UDP 协议实现可靠传输？」
很多同学第一反应就会说把 TCP 可靠传输的特性（序列号、确认应答、超时重传、流量控制、拥塞控制）在应用层实现一遍。
实现的思路确实这样没错，但是有没有想过，既然 TCP 天然支持可靠传输，为什么还需要基于 UDP 实现可靠传输呢？这不是重复造轮子吗？
所以，我们要先弄清楚 TCP 协议有哪些痛点？而这些痛点是否可以在基于 UDP 协议实现的可靠传输协议中得到改进？</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/syn_drop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/syn_drop/</guid><description>4.8 SYN 报文什么时候情况下会被丢弃？ 大家好，我是小林。
之前有个读者在秋招面试的时候，被问了这么一个问题：SYN 报文什么时候情况下会被丢弃？
好家伙，现在面试都问那么细节了吗？
不过话说回来，这个问题跟工作上也是有关系的，因为我就在工作中碰到这么奇怪的时候，客户端向服务端发起了连接，但是连接并没有建立起来，通过抓包分析发现，服务端是收到 SYN 报文了，但是并没有回复 SYN+ACK（TCP 第二次握手），说明 SYN 报文被服务端忽略了，然后客户端就一直在超时重传 SYN 报文，直到达到最大的重传次数。
接下来，我就给出我遇到过 SYN 报文被丢弃的两种场景：</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_down_and_crash/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_down_and_crash/</guid><description>4.12 TCP 连接，一端断电和进程崩溃有什么区别？ 有位读者找我说，他在面试腾讯的时候，遇到了这么个问题：
这个属于 TCP 异常断开连接的场景，这部分内容在我的「图解网络」还没有详细介绍过，这次就乘着这次机会补一补。
这个问题有几个关键词：
没有开启 keepalive； 一直没有数据交互； 进程崩溃； 主机崩溃； 我们先来认识认识什么是 TCP keepalive 呢？</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_drop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_drop/</guid><description>4.21 用了 TCP 协议，数据一定不会丢吗？ 来源：公众号@小白debug
原文地址： 用了 TCP 协议，数据一定不会丢吗？
大家后，我是小林。
问大家一句：TCP 是一个可靠的传输协议，那它一定能保证数据不丢失吗？
这次，就跟大家探讨这个问题。
数据包的发送流程 首先，我们两个手机的绿皮聊天软件客户端，要通信，中间会通过它们家服务器。大概长这样。
但为了简化模型，我们把中间的服务器给省略掉，假设这是个端到端的通信。且为了保证消息的可靠性，我们盲猜它们之间用的是TCP协议进行通信。
为了发送数据包，两端首先会通过三次握手，建立TCP连接。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_feature/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_feature/</guid><description>4.2 TCP 重传、滑动窗口、流量控制、拥塞控制 TCP 巨复杂，它为了保证可靠性，用了巨多的机制来保证，真是个「伟大」的协议，写着写着发现这水太深了。。。
本文的全部图片都是小林绘画的，非常的辛苦且累，不废话了，直接进入正文，Go！
相信大家都知道 TCP 是一个可靠传输的协议，那它是如何保证可靠的呢？
为了实现可靠性传输，需要考虑很多事情，例如数据的破坏、丢包、重复以及分片顺序混乱等问题。如不能解决这些问题，也就无从谈起可靠传输。
那么，TCP 是通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输的。
今天，将重点介绍 TCP 的重传机制、滑动窗口、流量控制、拥塞控制。
重传机制 TCP 实现可靠传输的方式之一，是通过序列号与确认应答。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_http_keepalive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_http_keepalive/</guid><description>4.15 TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？ 大家好，我是小林。
之前有读者问了我这么个问题：
大致问题是，TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？
这是个好问题，应该有不少人都会搞混，因为这两个东西看上去太像了，很容易误以为是同一个东西。
事实上，这两个完全是两样不同东西，实现的层面也不同：</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_interview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_interview/</guid><description>4.1 TCP 三次握手与四次挥手面试题 大家好，我是小林。
任 TCP 虐我千百遍，我仍待 TCP 如初恋。
巨巨巨巨长的提纲，发车！发车！
PS：本次文章不涉及 TCP 流量控制、拥塞控制、可靠性传输等方面知识，这些知识在这篇： 你还在为 TCP 重传、滑动窗口、流量控制、拥塞控制发愁吗？看完图解就不愁了
TCP 基本认识 TCP 头格式有哪些？ 我们先来看看 TCP 头的格式，标注颜色的表示与本文关联比较大的字段，其他字段不做详细阐述。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_no_accpet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_no_accpet/</guid><description>4.20 没有 accept，能建立 TCP 连接吗？ 来源：公众号@小白debug 原文地址： 阿里二面：没有 accept，能建立 TCP 连接吗？
大家好，我是小林。
这次，我们来讨论一下，没有 accept，能建立 TCP 连接吗？
下面这个动图，是我们平时客户端和服务端建立连接时的代码流程。
对应的是下面一段简化过的服务端伪代码。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_no_listen/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_no_listen/</guid><description>4.19 服务端没有 listen，客户端发起连接建立，会发生什么？ 大家好，我是小林。
早上看到一个读者说面字节三面的时候，问了这个问题：
这位读者的角度是以为服务端没有调用 listen，客户端会 ping 不通服务器，很明显，搞错了。
ping 使用的协议是 ICMP，属于网络层的事情，而面试官问的是传输层的问题。
针对这个问题，服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了 TCP 连接建立，此时那么会发生什么呢？</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_optimize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_optimize/</guid><description>4.5 如何优化 TCP? TCP 性能的提升不仅考察 TCP 的理论知识，还考察了对于操作系统提供的内核参数的理解与应用。
TCP 协议是由操作系统实现，所以操作系统提供了不少调节 TCP 的参数。
如何正确有效的使用这些参数，来提高 TCP 性能是一个不那么简单事情。我们需要针对 TCP 每个阶段的问题来对症下药，而不是病急乱投医。
接下来，将以三个角度来阐述提升 TCP 的策略，分别是：</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_problem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_problem/</guid><description>4.16 TCP 协议有什么缺陷？ 大家好，我是小林。
写的多了后，忽然思考一个问题，TCP 通过序列号、确认应答、超时重传、流量控制、拥塞控制等方式实现了可靠传输，看起来它很完美，事实真的是这样吗？TCP 就没什么缺陷吗？
所以，今天就跟大家聊聊，TCP 协议有哪些缺陷？主要有四个方面：
升级 TCP 的工作很困难； TCP 建立连接的延迟； TCP 存在队头阻塞问题； 网络迁移需要重新建立 TCP 连接； 接下来，针对这四个方面详细说一下。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_queue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_queue/</guid><description>4.4 TCP 半连接队列和全连接队列 网上许多博客针对增大 TCP 半连接队列和全连接队列的方式如下：
增大 TCP 半连接队列的方式是增大 /proc/sys/net/ipv4/tcp_max_syn_backlog； 增大 TCP 全连接队列的方式是增大 listen() 函数中的 backlog； 这里先跟大家说下，上面的方式都是不准确的。
“你怎么知道不准确？”</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_stream/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_stream/</guid><description>4.6 如何理解是 TCP 面向字节流协议？ 有个读者问我，这么个问题：
TCP 是面向字节流的协议，UDP 是面向报文的协议？这里的「面向字节流」和「面向报文」该如何理解。
如何理解字节流？ 之所以会说 TCP 是面向字节流的协议，UDP 是面向报文的协议，是因为操作系统对 TCP 和 UDP 协议的发送方的机制不同，也就是问题原因在发送方。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_tcpdump/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_tcpdump/</guid><description>4.3 TCP 实战抓包分析 为了让大家更容易「看得见」 TCP，我搭建不少测试环境，并且数据包抓很多次，花费了不少时间，才抓到比较容易分析的数据包。
接下来丢包、乱序、超时重传、快速重传、选择性确认、流量控制等等 TCP 的特性，都能「一览无余」。
没错，我把 TCP 的&amp;quot;衣服扒光&amp;quot;了，就为了给大家看的清楚，嘻嘻。
显形“不可见”的网络包 网络世界中的数据包交互我们肉眼是看不见的，它们就好像隐形了一样，我们对着课本学习计算机网络的时候就会觉得非常的抽象，加大了学习的难度。
还别说，我自己在大学的时候，也是如此。
直到工作后，认识了两大分析网络的利器：tcpdump 和 Wireshark，这两大利器把我们“看不见”的数据包，呈现在我们眼前，一目了然。
唉，当初大学学习计网的时候，要是能知道这两个工具，就不会学的一脸懵逼。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_three_fin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_three_fin/</guid><description>4.22 TCP 四次挥手，可以变成三次吗？ 大家好，我是小林。
有位读者面美团时，被问到：TCP 四次挥手中，能不能把第二次的 ACK 报文， 放到第三次 FIN 报文一起发送？
虽然我们在学习 TCP 挥手时，学到的是需要四次来完成 TCP 挥手，但是在一些情况下， TCP 四次挥手是可以变成 TCP 三次挥手的。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_tls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_tls/</guid><description>4.14 HTTPS 中 TLS 和 TCP 能同时握手吗？ 大家好，我是小林。
有位读者在面试的时候，碰到这么个问题：
面试官跟他说 HTTPS 中的 TLS 握手过程可以同时进行三次握手，然后读者之前看我的文章是说「先进行 TCP 三次握手，再进行 TLS 四次握手」，他跟面试官说了这个，面试官说他不对，他就感到很困惑。
我们先不管面试官说的那句「HTTPS 中的 TLS 握手过程可以同时进行三次握手」对不对。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_tw_reuse_close/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_tw_reuse_close/</guid><description>4.14 tcp_tw_reuse 为什么默认是关闭的？ 大家好，我是小林。
上周有个读者在面试微信的时候，被问到既然打开 net.ipv4.tcp_tw_reuse 参数可以快速复用处于 TIME_WAIT 状态的 TCP 连接，那为什么 Linux 默认是关闭状态呢？
好家伙，真的问好细节！
当时看到读者这个问题的时候，我也是一脸懵逼的，经过我的一番思考后，终于知道怎么回答这题了。
其实这题在变相问「如果 TIME_WAIT 状态持续时间过短或者没有，会有什么问题？」</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_unplug_the_network_cable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/tcp_unplug_the_network_cable/</guid><description>4.13 拔掉网线后， 原本的 TCP 连接还存在吗？ 大家好，我是小林。
今天，聊一个有趣的问题：拔掉网线几秒，再插回去，原本的 TCP 连接还存在吗？
可能有的同学会说，网线都被拔掉了，那说明物理层被断开了，那在上层的传输层理应也会断开，所以原本的 TCP 连接就不会存在的了。就好像， 我们拨打有线电话的时候，如果某一方的电话线被拔了，那么本次通话就彻底断了。
真的是这样吗？
上面这个逻辑就有问题。问题在于，错误的认为拔掉网线这个动作会影响传输层，事实上并不会影响。
实际上，TCP 连接在 Linux 内核中是一个名为 struct socket 的结构体，该结构体的内容包含 TCP 连接的状态等信息。当拔掉网线的时候，操作系统并不会变更该结构体的任何内容，所以 TCP 连接的状态也不会发生改变。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/time_wait_recv_syn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/3_tcp/time_wait_recv_syn/</guid><description>4.11 在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？ 大家好，我是小林。
周末跟朋友讨论了一些 TCP 的问题，在查阅《Linux 服务器高性能编程》这本书的时候，发现书上写了这么一句话：
书上说，处于 TIME_WAIT 状态的连接，在收到相同四元组的 SYN 后，会回 RST 报文，对方收到后就会断开连接。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/4_ip/ip_base/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/4_ip/ip_base/</guid><description>5.1 IP 基础知识全家桶 前段时间，有读者希望我写一篇关于 IP 分类地址、子网划分等的文章，他反馈常常混淆，摸不着头脑。
那么，说来就来！而且要盘就盘全一点，顺便挑战下小林的图解功力，所以就来个 IP 基础知识全家桶。
吃完这个 IP 基础知识全家桶，包你撑着肚子喊出：“真香！”
不多说，直接上菜，共分为三道菜：
首先是前菜 「 IP 基本认识 」 其次是主菜 「IP 地址的基础知识」 最后是点心 「IP 协议相关技术」 为啥要比喻成菜？因为小林是菜狗（押韵不？）</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/4_ip/ping/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/4_ip/ping/</guid><description>5.2 ping 的工作原理 在日常生活或工作中，我们在判断与对方网络是否畅通，使用的最多的莫过于 ping 命令了。
“那你知道 ping 是如何工作的吗？” —— 来自小林的灵魂拷问
可能有的小伙伴奇怪的问：“我虽然不明白它的工作，但 ping 我也用的贼 6 啊！”
你用的是 6 ，但你在面试官面前，你就 6 不起来了，毕竟他们也爱问。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/4_ip/ping_lo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/4_ip/ping_lo/</guid><description>5.3 断网了，还能 ping 通 127.0.0.1 吗？ 来源：公众号@小白debug
原文地址： 断网了，还能 ping 通 127.0.0.1 吗？
你女神爱不爱你，你问她，她可能不会告诉你。
但网通不通，你 ping 一下就知道了。
可能看到标题，你就知道答案了，但是你了解背后的原因吗？</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/5_learn/draw/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/5_learn/draw/</guid><description>6.2 画图经验分享 小林写这么多篇图解文章，你们猜我收到的最多的读者问题是什么？没错，就是问我是使用什么画图工具，看来对这一点大家都相当好奇，那干脆不如写一篇介绍下我是怎么画图的。
如果我的文章缺少了自己画的图片，相当于失去了灵魂，技术文章本身就很枯燥，如果文章中没有几张图片，读者被劝退的概率飙飙升，剩下没被劝退的估计看着看着就睡着了。所以，精美的图片可以说是必不可少的一部分，不仅在阅读时能带来视觉的冲击，而且图片相比文字能涵盖更多的信息，不然怎会有一图胜千言的说法呢？
这时，可能有的读者会说自己不写文章呀，是不是没有必要了解画图了？我觉得这是不对，画图在我们工作中其实也是有帮助的，比如如果你想跟领导汇报一个业务流程的问题，把业务流程画出来，肯定用图的方式比用文字的方式交流起来会更有效率，更轻松些；如果你参与了一个比较复杂的项目开发，你也可以把代码的流程图给画出来，不仅能帮助自己加深理解，也能帮助后面参与的同事能更快的接手这个项目；甚至如果你要晋升级别了，演讲 PTT 里的配图也是必不可少的。
不过很多人都是纠结用什么画图工具，其实小林觉得再烂的画图工具，只要你思路清晰，确定自己要表达出什么信息，也是能把图画好的，所以不必纠结哪款画图工具，挑一款自己画起来舒服的就行了。
“小林，你说的我都懂，我就是喜欢你的画图风格嘛，你就说说你用啥画的？”
咳咳，没问题，直接坦白讲，我用的是一个在线的画图网址，地址是：
https://draw.io 用它的原因是使用方便和简单，当然最重要的是它完全免费，没有什么限制，甚至还能直接把图片保存到 GoogleDrive 、 OneDrive 和 Github，我就是保存到 Github，然后用 Github 作为我的图床。</description></item><item><title/><link>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/README/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/%E7%BD%91%E7%BB%9C/README/</guid><description>图解网络介绍 大家好，我是小林，是《图解网络》的作者，本站的内容都是整理于我 公众号里的图解文章。
还没关注的朋友，可以微信搜索「小林coding」，关注我的公众号，后续最新版本的 PDF 会在我的公众号第一时间发布，而且会有更多其他系列的图解文章，比如操作系统、计算机组成、数据库、算法等等。
简单介绍下《图解网络》，整个内容共有 20W 字 + 500 张图，每一篇都自己手绘了很多图，目的也很简单，击破大家对于「八股文」的恐惧。
适合什么群体？ 《图解网络》写的网络知识主要是面向程序员的，因为小林本身也是个程序员，所以涉及到的知识主要是关于程序员日常工作或者面试的网络知识。
非常适合有一点网络基础，但是又不怎么扎实，或者知识点串不起来的同学，说白这本图解网络就是为了拯救半桶水的同学而出来的。
因为小林写的图解网络就四个字，通俗易懂！
相信你在看这本图解网络的时候，你心里的感受会是：
「卧槽，原来是这样，大学老师教知识原来是这么理解」 「卧槽，我的网络知识串起来了」 「卧槽，我感觉面试稳了」 「卧槽，相见恨晚」 当然，也适合面试突击网络知识时拿来看。图解网络里的内容基本是面试常见的协议，比如 HTTP、HTTPS、TCP、UDP、IP 等等，也有很多面试常问的问题，比如：</description></item></channel></rss>