<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="乐观锁和悲观锁   悲观锁：悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放
  共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程
  Java 中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现
  悲观锁通常多用于写多比较多的情况下（多写场景），避免频繁失败和重试影响性能
    乐观锁：总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）"><meta property="og:title" content><meta property="og:description" content="乐观锁和悲观锁   悲观锁：悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放
  共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程
  Java 中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现
  悲观锁通常多用于写多比较多的情况下（多写场景），避免频繁失败和重试影响性能
    乐观锁：总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）"><meta property="og:type" content="website"><meta property="og:image" content="https://googoo-s.github.io/icon.png"><meta property="og:url" content="https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="乐观锁和悲观锁   悲观锁：悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放
  共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程
  Java 中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现
  悲观锁通常多用于写多比较多的情况下（多写场景），避免频繁失败和重试影响性能
    乐观锁：总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）"><meta name=twitter:image content="https://googoo-s.github.io/icon.png"><title>googoo-s</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://googoo-s.github.io//icon.png><link href=https://googoo-s.github.io/styles.19109a40042e9f0e72e952fda4442a34.min.css rel=stylesheet><link href=https://googoo-s.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://googoo-s.github.io/js/darkmode.953af745b0f9342644d632fc167f3727.min.js></script>
<script src=https://googoo-s.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://googoo-s.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://googoo-s.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://googoo-s.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://googoo-s.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://googoo-s.github.io/",fetchData=Promise.all([fetch("https://googoo-s.github.io/indices/linkIndex.26897e4d1acf67c094aa607e8f2e6316.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://googoo-s.github.io/indices/contentIndex.ca4acdfca5978eac73c0a8c823a6b4e4.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://googoo-s.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://googoo-s.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/googoo-s.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=googoo-s.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://googoo-s.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://googoo-s.github.io/>googoo-s</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Unknown</p><ul class=tags></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#如何实现乐观锁>如何实现乐观锁</a><ol><li><a href=#cas算法>cas算法</a></li><li><a href=#版本号机制>版本号机制</a></li></ol></li><li><a href=#乐观锁存在的问题>乐观锁存在的问题</a><ol><li><a href=#aba问题>ABA问题</a></li><li><a href=#循环时间开销大>循环时间开销大</a></li></ol></li><li><a href=#java-有那些保证原子性的方法如何保证多线程下i结果正确>Java 有那些保证原子性的方法。如何保证多线程下i++结果正确？</a></li><li><a href=#原子操作类了解多少>原子操作类了解多少</a></li><li><a href=#atomicinteger-的原理><strong>AtomicInteger</strong> 的原理</a></li></ol><ol><li><a href=#synchronized是啥有啥用>synchronized是啥？有啥用？</a></li><li><a href=#如何使用-synchronized>如何使用 synchronized？</a></li><li><a href=#构造方法可以用-synchronized-修饰么>构造方法可以用 synchronized 修饰么？</a></li><li><a href=#synchronized-底层原理了解吗>synchronized 底层原理了解吗？</a><ol><li><a href=#synchronized-同步语句块的情况>synchronized 同步语句块的情况</a></li><li><a href=#synchronized-修饰方法的的情况>synchronized 修饰方法的的情况</a></li><li><a href=#synchronized锁住的是啥>Synchronized锁住的是啥？</a></li></ol></li><li><a href=#synchronized可见性有序性可重入性怎么实现><strong>synchronized</strong>可见性，有序性，可重入性怎么实现？</a><ol><li><a href=#synchronized-怎么保证可见性>synchronized 怎么保证可见性？</a></li><li><a href=#synchronized-怎么保证有序性>synchronized 怎么保证有序性</a></li><li><a href=#synchronized怎么实现可重入的>synchronized怎么实现可重入的？</a></li></ol></li><li><a href=#jdk16-之后的-synchronized-底层做了哪些优化>JDK1.6 之后的 synchronized 底层做了哪些优化？</a><ol><li><a href=#做了那些优化>做了那些优化？</a></li><li><a href=#锁升级>锁升级</a></li></ol></li><li><a href=#2轻量级锁><strong>2、轻量级锁</strong></a><ol><li></li></ol></li><li><a href=#3重量级锁><strong>3、重量级锁</strong></a></li><li><a href=#synchronized-和-volatile-有什么区别>synchronized 和 volatile 有什么区别？</a></li></ol><ol><li><a href=#reentrantlock-是什么>ReentrantLock 是什么？</a></li><li><a href=#aqs-介绍>AQS 介绍</a><ol><li><a href=#aqs-原理>AQS 原理</a></li><li><a href=#aqs-核心思想>AQS 核心思想</a></li><li><a href=#aqs-资源共享方式>AQS 资源共享方式</a></li><li><a href=#自定义同步器>自定义同步器</a></li></ol></li><li><a href=#公平锁和非公平锁有什么区别>公平锁和非公平锁有什么区别？</a></li><li><a href=#synchronized-和-reentrantlock-有什么区别>synchronized 和 ReentrantLock 有什么区别？</a><ol><li><a href=#两者都是可重入锁>两者都是可重入锁</a></li><li><a href=#synchronized-依赖于-jvm-而-reentrantlock-依赖于-api>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</a></li><li><a href=#reentrantlock-比-synchronized-增加了一些高级功能>ReentrantLock 比 synchronized 增加了一些高级功能</a></li><li><a href=#可中断锁和不可中断锁有什么区别>可中断锁和不可中断锁有什么区别？</a></li></ol></li></ol><ol><li><a href=#reentrantreadwritelock-是什么>ReentrantReadWriteLock 是什么？</a></li><li><a href=#reentrantreadwritelock-适合什么场景>ReentrantReadWriteLock 适合什么场景？</a></li><li><a href=#共享锁和独占锁有什么区别>共享锁和独占锁有什么区别？</a></li><li><a href=#线程持有读锁还能获取写锁吗>线程持有读锁还能获取写锁吗？</a></li><li><a href=#读锁为什么不能升级为写锁>读锁为什么不能升级为写锁？</a></li></ol><ol><li><a href=#stampedlock-是什么>StampedLock 是什么？</a></li><li><a href=#stampedlock-的性能为什么更好>StampedLock 的性能为什么更好？</a></li><li><a href=#stampedlock-适合什么场景>StampedLock 适合什么场景？</a></li><li><a href=#stampedlock-的底层原理了解吗>StampedLock 的底层原理了解吗？</a></li></ol></nav></details></aside><a href=#乐观锁和悲观锁><h1 id=乐观锁和悲观锁><span class=hanchor arialabel=Anchor># </span>乐观锁和悲观锁</h1></a><ul><li><p><strong>悲观锁</strong>：悲观锁总是假设最坏的情况，认为<strong>共享资源每次被访问的时候就会出现问题</strong>(比如共享数据被修改)，所以每次在<strong>获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞</strong>直到锁被上一个持有者释放</p><ul><li><p>共享资源每次<strong>只给一个线程使用，其它线程阻塞</strong>，用完后再把资源转让给其它线程</p></li><li><p>Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现</p></li><li><p>悲观锁通常多用于写多比较多的情况下（多写场景），避免频繁失败和重试影响性能</p></li></ul></li><li><p>乐观锁：总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，<strong>只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法</strong>）</p><ul><li><p><code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p></li><li><p>乐观锁通常多于写比较少的情况下（多读场景），避免频繁加锁影响性能，大大提升了系统的吞吐量</p></li></ul></li></ul><a href=#如何实现乐观锁><h2 id=如何实现乐观锁><span class=hanchor arialabel=Anchor># </span>如何实现乐观锁</h2></a><p>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些</p><a href=#cas算法><h3 id=cas算法><span class=hanchor arialabel=Anchor># </span>cas算法</h3></a><p>CAS 的全称是 Compare And Swap（比较与交换） ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，<strong>就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新</strong></p><ul><li>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。</li></ul><blockquote><p>CAS 涉及到三个操作数：</p><ul><li><p>V ：要更新的变量值(Var)</p></li><li><p>E ：预期值(Expected)</p></li><li><p>N ：拟写入的新值(New)</p></li></ul><p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</p></blockquote><p><code>sun.misc</code>包下的<code>Unsafe</code>类提供了<code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>方法来实现的对<code>Object</code>、<code>int</code>、<code>long</code>类型的 CAS 操作</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>        *  CAS
</span></span></span><span class=line><span class=cl><span class=cm>  * @param o         包含要修改field的对象
</span></span></span><span class=line><span class=cl><span class=cm>  * @param offset    对象中某field的偏移量
</span></span></span><span class=line><span class=cl><span class=cm>  * @param expected  期望值
</span></span></span><span class=line><span class=cl><span class=cm>  * @param update    更新值
</span></span></span><span class=line><span class=cl><span class=cm>  * @return          true | false
</span></span></span><span class=line><span class=cl><span class=cm>  */</span>
</span></span><span class=line><span class=cl><span class=nx>public</span> <span class=nx>final</span> <span class=nx>native</span> <span class=nx>boolean</span> <span class=nf>compareAndSwapObject</span><span class=p>(</span><span class=nx>Object</span> <span class=nx>o</span><span class=p>,</span> <span class=nx>long</span> <span class=nx>offset</span><span class=p>,</span>  <span class=nx>Object</span> <span class=nx>expected</span><span class=p>,</span> <span class=nx>Object</span> <span class=nx>update</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>public</span> <span class=nx>final</span> <span class=nx>native</span> <span class=nx>boolean</span> <span class=nf>compareAndSwapInt</span><span class=p>(</span><span class=nx>Object</span> <span class=nx>o</span><span class=p>,</span> <span class=nx>long</span> <span class=nx>offset</span><span class=p>,</span> <span class=kt>int</span> <span class=nx>expected</span><span class=p>,</span><span class=kt>int</span> <span class=nx>update</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>public</span> <span class=nx>final</span> <span class=nx>native</span> <span class=nx>boolean</span> <span class=nf>compareAndSwapLong</span><span class=p>(</span><span class=nx>Object</span> <span class=nx>o</span><span class=p>,</span> <span class=nx>long</span> <span class=nx>offset</span><span class=p>,</span> <span class=nx>long</span> <span class=nx>expected</span><span class=p>,</span> <span class=nx>long</span> <span class=nx>update</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>关于 <code>Unsafe</code> 类的详细介绍可以看这篇文章：
<a href=https://javaguide.cn/java/basis/unsafe.html rel=noopener>Java 魔法类 Unsafe 详解 - JavaGuide - 2022</a></p><a href=#版本号机制><h3 id=版本号机制><span class=hanchor arialabel=Anchor># </span>版本号机制</h3></a><p>一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。</p><ul><li><p>当数据被修改时，<code>version</code> 值会加一。</p></li><li><p>当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，</p><ul><li><p>在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新，</p></li><li><p>否则重试更新操作，直到更新成功。</p></li></ul></li></ul><a href=#乐观锁存在的问题><h2 id=乐观锁存在的问题><span class=hanchor arialabel=Anchor># </span>乐观锁存在的问题</h2></a><a href=#aba问题><h3 id=aba问题><span class=hanchor arialabel=Anchor># </span>ABA问题</h3></a><ul><li><p>如果一个变量 V 初次读取的时候是 A 值，<strong>在这段时间它的值可能被改为其他值，然后又改回 A</strong>，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>&ldquo;ABA"问题。</strong></p></li><li><p>解决思路 ：变量前面追加上版本号或者时间戳</p><ul><li><code>AtomicStampedReference</code> 类就是用来解决 ABA 问题的</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=nx>public</span> <span class=nx>boolean</span> <span class=nf>compareAndSet</span><span class=p>(</span><span class=nx>V</span>   <span class=nx>expectedReference</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                             <span class=nx>V</span>   <span class=nx>newReference</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                             <span class=kt>int</span> <span class=nx>expectedStamp</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                             <span class=kt>int</span> <span class=nx>newStamp</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Pair</span><span class=p>&lt;</span><span class=nx>V</span><span class=p>&gt;</span> <span class=nx>current</span> <span class=p>=</span> <span class=nx>pair</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=nx>expectedReference</span> <span class=o>==</span> <span class=nx>current</span><span class=p>.</span><span class=nx>reference</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>        <span class=nx>expectedStamp</span> <span class=o>==</span> <span class=nx>current</span><span class=p>.</span><span class=nx>stamp</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>        <span class=p>((</span><span class=nx>newReference</span> <span class=o>==</span> <span class=nx>current</span><span class=p>.</span><span class=nx>reference</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>          <span class=nx>newStamp</span> <span class=o>==</span> <span class=nx>current</span><span class=p>.</span><span class=nx>stamp</span><span class=p>)</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>         <span class=nf>casPair</span><span class=p>(</span><span class=nx>current</span><span class=p>,</span> <span class=nx>Pair</span><span class=p>.</span><span class=nf>of</span><span class=p>(</span><span class=nx>newReference</span><span class=p>,</span> <span class=nx>newStamp</span><span class=p>)));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><a href=#循环时间开销大><h3 id=循环时间开销大><span class=hanchor arialabel=Anchor># </span>循环时间开销大</h3></a><p>CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销</p><p>如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：</p><ol><li><p>可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。</p></li><li><p>可以避免在退出循环的时候因内存顺序冲而引起 CPU 流水线被清空，从而提高 CPU 的执行效率</p></li></ol><a href=#只能保证一个共享变量的原子操作><h4 id=只能保证一个共享变量的原子操作><span class=hanchor arialabel=Anchor># </span>只能保证一个共享变量的原子操作</h4></a><p><strong>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效</strong>。</p><ul><li><code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作。</li></ul><a href=#java-有那些保证原子性的方法如何保证多线程下i结果正确><h2 id=java-有那些保证原子性的方法如何保证多线程下i结果正确><span class=hanchor arialabel=Anchor># </span>Java 有那些保证原子性的方法。如何保证多线程下i++结果正确？</h2></a><p><img src=https://googoo-s.github.io//statistic/asynccode-91.png width=auto alt></p><a href=#原子操作类了解多少><h2 id=原子操作类了解多少><span class=hanchor arialabel=Anchor># </span>原子操作类了解多少</h2></a><p>在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是<strong>原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）</strong></p><p><img src=https://googoo-s.github.io//statistic/asynccode-103.png width=auto alt></p><p>Atomic包里的类基本都是使用Unsafe实现的包装类。</p><ul><li><p>更新基本类型，</p><ul><li><p>AtomicBoolean：原子更新布尔类型。</p></li><li><p>AtomicInteger：原子更新整型。</p></li><li><p>AtomicLong：原子更新长整型。</p></li></ul></li><li><p>通过原子的方式更新数组里的某个元素，Atomic包提供了以下4个类：</p><ul><li><p>AtomicIntegerArray：原子更新整型数组里的元素。</p></li><li><p>AtomicLongArray：原子更新长整型数组里的元素。</p></li><li><p>AtomicReferenceArray：原子更新引用类型数组里的元素。</p></li><li><p>AtomicIntegerArray：类主要是提供原子的方式更新数组里的整型</p></li></ul></li><li><p>原子更新引用类型提供的类。</p><ul><li><p>AtomicReference：原子更新引用类型。AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</p></li><li><p>AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，boolean initialMark）。</p></li></ul></li><li><p>原子更新字段类，：</p><ul><li><p>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</p></li><li><p>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</p></li><li><p>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的 ABA问题。</p></li></ul></li></ul><a href=#atomicinteger-的原理><h2 id=atomicinteger-的原理><span class=hanchor arialabel=Anchor># </span><strong>AtomicInteger</strong> 的原理</h2></a><p>使用CAS</p><p>以AtomicInteger的添加方法为例：</p><p><img src=https://googoo-s.github.io//statistic/asynccode-100.png width=auto alt></p><p>通过 Unsafe 类的实例来进行添加操作，来看看具体的CAS操作：</p><p><img src=https://googoo-s.github.io//statistic/asynccode-89.png width=auto alt></p><p>compareAndSwapInt 是一个native方法，基于CAS来操作int类型变量。其它的原子操作类基本都是大同小异。</p><a href=#synchronized><h1 id=synchronized><span class=hanchor arialabel=Anchor># </span>synchronized</h1></a><a href=#synchronized是啥有啥用><h2 id=synchronized是啥有啥用><span class=hanchor arialabel=Anchor># </span>synchronized是啥？有啥用？</h2></a><p>Synchronized 是Java的一个关键字，翻译成中文是<strong>同步的意思</strong>，主要解决的是多个线程之间访问资源的同步性，可以保证被<strong>它修饰的方法或者代码块在任意时刻只能有一个线程执行</strong>。</p><ul><li><p>早期版本中，<code>synchronized</code> 属于<strong>重量级锁，<strong>这是因为</strong>监视器锁（monitor）是依赖于底层的操作系统的</strong> <strong><code>Mutex Lock</code></strong> <strong>来实现的</strong>，Java 的线程是映射到操作系统的原生线程之上的。而操作系统实现线程之间的切换时需要从<strong>用户态转换到内核态</strong>，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p></li><li><p>java6 以后，引入了大量的优化如<strong>自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销</strong>，这些优化让 <code>synchronized</code> 锁的效率提升了很多</p></li></ul><a href=#如何使用-synchronized><h2 id=如何使用-synchronized><span class=hanchor arialabel=Anchor># </span>如何使用 synchronized？</h2></a><p><code>synchronized</code> 关键字的使用方式主要有下面 3 种：</p><ol><li><p>修饰实例方法</p></li><li><p>修饰静态方法</p></li><li><p>修饰代码块</p></li></ol><p><strong>1、修饰实例方法</strong> （<strong>锁当前对象实例</strong>）</p><p>给当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong> 。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>synchronized</span> <span class=kt>void</span> <span class=nf>method</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//业务代码
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>2、修饰静态方法</strong> （<strong>锁当前类</strong>）</p><p>给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。</p><p>这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>synchronized</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>method</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//业务代码
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 方法之间的调用互斥么？</p><p>不互斥！因为他们的锁不一致</p><p><strong>3、修饰代码块</strong> （锁指定对象/类）</p><p>对括号里指定的对象/类加锁：</p><ul><li><p><code>synchronized(object)</code> 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。</p></li><li><p><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>synchronized</span><span class=o>(</span><span class=k>this</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//业务代码
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>总结：</strong></p><ul><li><p><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁；</p></li><li><p><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁；</p></li><li><p>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能。</p></li></ul><a href=#构造方法可以用-synchronized-修饰么><h2 id=构造方法可以用-synchronized-修饰么><span class=hanchor arialabel=Anchor># </span>构造方法可以用 synchronized 修饰么？</h2></a><p>先说结论：<strong>构造方法不能使用 synchronized 关键字修饰。</strong></p><p>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p><a href=#synchronized-底层原理了解吗><h2 id=synchronized-底层原理了解吗><span class=hanchor arialabel=Anchor># </span>synchronized 底层原理了解吗？</h2></a><p>synchronized 关键字底层原理属于 JVM 层面的东西。</p><a href=#synchronized-同步语句块的情况><h3 id=synchronized-同步语句块的情况><span class=hanchor arialabel=Anchor># </span>synchronized 同步语句块的情况</h3></a><ul><li>synchronized修饰代码块时，JVM采用 monitorenter 、 monitorexit 两个指令来实现同步， monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指向同步代码块的结束位置。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SynchronizedDemo</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>method</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>synchronized</span> <span class=o>(</span><span class=k>this</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;synchronized 代码块&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p><img src=https://googoo-s.github.io//statistic/asynccode-94.png width=auto alt></p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器</strong> <strong><code>monitor</code></strong> <strong>的持有权</strong>。</p><blockquote><p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由
<a href=https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp rel=noopener>ObjectMonitoropen in new window</a>实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p><p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p></blockquote><a href=#synchronized-修饰方法的的情况><h3 id=synchronized-修饰方法的的情况><span class=hanchor arialabel=Anchor># </span>synchronized 修饰方法的的情况</h3></a><p><strong>JVM采用 ACC_SYNCHRONIZED 标记符来实现同 步，这个标识指明了该方法是一个同步方法。</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SynchronizedDemo2</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>void</span> <span class=nf>method</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;synchronized 方法&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p><img src=https://googoo-s.github.io//statistic/asynccode-88.png width=auto alt></p><a href=#synchronized锁住的是啥><h3 id=synchronized锁住的是啥><span class=hanchor arialabel=Anchor># </span>Synchronized锁住的是啥？</h3></a><p>monitorenter、monitorexit或者ACC_SYNCHRONIZED都是基于<strong>Monitor</strong>实现的。</p><ul><li><p>实例对象结构里有对象头，对象头里面有一块结构叫Mark Word，Mark Word指针指 向了<strong>monitor</strong>。</p></li><li><p>所谓的Monitor其实是一种同步工具，也可以说是一种同步机制。在Java虚拟机 HotSpot）中，Monitor是由<strong>ObjectMonitor</strong>实现的，可以叫做内部锁，或者Monitor 锁</p></li></ul><a href=#objectmonitor的工作原理><h4 id=objectmonitor的工作原理><span class=hanchor arialabel=Anchor># </span>ObjectMonitor的工作原理</h4></a><ul><li><p>ObjectMonitor有两个队列： WaitSet、 EntryList，用来保存ObjectWaiter 对象列表</p></li><li><p>_owner，获取 Monitor 对象的线程进入 _owner 区时， _count + 1。如果线程调用了 wait() 方法，此时会释放 Monitor 对象， _owner 恢复为空， _count - 1。同时该等待线程进入 _WaitSet 中，等待被唤醒。</p></li></ul><p><img src=https://googoo-s.github.io//statistic/asynccode-96.png width=auto alt></p><p><img src=https://googoo-s.github.io//statistic/asynccode-101.png width=auto alt></p><p>同步对象锁住的是啥了</p><ul><li><p>monitorenter，在判断拥有同步标识 ACC_SYNCHRONIZED 抢先进入此方法的线 程会优先拥有 Monitor 的 owner ，此时计数器 +1。</p></li><li><p>monitorexit，当执行完退出后，计数器 -1，归 0 后被其他进入的线程获得。</p></li></ul><p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-104.png width=auto alt></p><p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。<strong>在执行</strong> <strong><code>monitorexit</code></strong> **指令后，将锁计数器设为 0，**表明锁被释放，其他线程可以尝试获取锁。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-90.png width=auto alt></p><p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><blockquote><p>相关推荐：
<a href=https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/ rel=noopener>Java 锁与线程的那些事 - 有赞技术团队open in new window</a> 。</p></blockquote><a href=#synchronized可见性有序性可重入性怎么实现><h2 id=synchronized可见性有序性可重入性怎么实现><span class=hanchor arialabel=Anchor># </span><strong>synchronized</strong>可见性，有序性，可重入性怎么实现？</h2></a><a href=#synchronized-怎么保证可见性><h3 id=synchronized-怎么保证可见性><span class=hanchor arialabel=Anchor># </span>synchronized 怎么保证可见性？</h3></a><ul><li><p>线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。</p></li><li><p>线程加锁后，其它线程无法获取主内存中的共享变量。</p></li><li><p>线程解锁前，必须把共享变量的最新值刷新到主内存中</p></li></ul><a href=#synchronized-怎么保证有序性><h3 id=synchronized-怎么保证有序性><span class=hanchor arialabel=Anchor># </span>synchronized 怎么保证有序性</h3></a><ul><li><p>synchronized同步的代码块，具有排他性，一次只能被一个线程拥有，所以 synchronized保证同一时刻，代码是单线程执行的</p></li><li><p>as-if-serial语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排。</p></li></ul><p>synchronized保证的有序是<strong>执行结果的有序性，而不是防止指令重排的有序性</strong></p><a href=#synchronized怎么实现可重入的><h3 id=synchronized怎么实现可重入的><span class=hanchor arialabel=Anchor># </span>synchronized怎么实现可重入的？</h3></a><p>synchronized 是可重入锁，也就是说，<strong>允许一个线程二次请求自己持有对象锁的临界资源</strong>，这种情况称为可重入锁。</p><p>之所以，是可重入的。是因为 synchronized 锁对象有个计数器，会随着<strong>线程获取锁后 +1 计数，当线程执行完毕后 -1，直到清零释放锁</strong>。</p><a href=#jdk16-之后的-synchronized-底层做了哪些优化><h2 id=jdk16-之后的-synchronized-底层做了哪些优化><span class=hanchor arialabel=Anchor># </span>JDK1.6 之后的 synchronized 底层做了哪些优化？</h2></a><a href=#做了那些优化><h3 id=做了那些优化><span class=hanchor arialabel=Anchor># </span>做了那些优化？</h3></a><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p><ul><li><p>偏向锁：在<strong>无竞争的情况下</strong>，只是在<strong>Mark Word里存储当前线程指针</strong>，CAS操作都不做。</p></li><li><p>轻量级锁：在<strong>没有多线程竞争时</strong>，相对重量级锁，<strong>减少操作系统互斥量</strong>带来的性能消耗。但是，如果存在锁竞争，除了互斥量本身开销，还<strong>额外有CAS操作的开销</strong>。</p></li><li><p>自旋锁：减少不必要的CPU上下文切换。<strong>在轻量级锁升级为重量级锁时，就使用了自旋加锁的方式</strong></p></li><li><p>锁粗化：<strong>将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁</strong>。</p></li><li><p>锁消除：虚拟机即时编译器在运行时，对一些代码上要求同步，但是被<strong>检测到不可能存在共享数据竞争的锁进行消除</strong>。</p></li></ul><a href=#锁升级><h3 id=锁升级><span class=hanchor arialabel=Anchor># </span>锁升级</h3></a><ul><li><p>锁主要存在四种状态，依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态、重量级锁</strong></p></li><li><p><strong>锁可以升级不可降级</strong>，这种策略是为了提高获得锁和释放锁的效率。</p></li></ul><p>关于这几种优化的详细信息可以查看下面这篇文章：
<a href=https://www.cnblogs.com/wuqinglong/p/9945618.html rel=noopener>Java6 及以上版本对 synchronized 的优化open in new window</a> 。</p><a href=#各个锁的说明><h4 id=各个锁的说明><span class=hanchor arialabel=Anchor># </span>各个锁的说明</h4></a><ul><li><p>偏向锁：<strong>针对于一个线程而言的</strong>，线程<strong>获得锁之后就不会再有解锁等操作了</strong>，这样可以省略很多开销。假如有<strong>两个线程来竞争该锁话，那么偏向锁就失效了，进而升级成轻量级锁</strong>了</p></li><li><p>轻量级锁：之所以是轻量级，是因为它<strong>仅仅使用 CAS 进行操作</strong>，实现获取锁。</p></li><li><p>重量级锁：重量级锁（<code>heavy weight lock</code>），是使用<strong>操作系统互斥量（<strong><strong><code>mutex</code></strong></strong>）来实现的传统锁</strong>。 当所有对锁的优化都失效时，将退回到重量级锁。它与轻量级锁不同竞争的线程不再通过自旋来竞争线程， <strong>而是直接进入堵塞状态，此时不消耗CPU，然后等拥有锁的线程释放锁后，唤醒堵塞的线程</strong>， 然后线程再次竞争锁</p></li></ul><a href=#markword-的内容><h4 id=markword-的内容><span class=hanchor arialabel=Anchor># </span>MarkWord 的内容</h4></a><a href=#1无锁状态><h5 id=1无锁状态><span class=hanchor arialabel=Anchor># </span><strong>1、无锁状态</strong></h5></a><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>25bit</td><td>4bit</td><td>1bit(是否是偏向锁)</td><td>2bit(锁标志位)</td></tr><tr><td>对象的hashCode</td><td>对象分代年龄</td><td>0</td><td>1</td></tr></tbody></table><p>这里的 hashCode 是 Object#hashCode 或者 System#identityHashCode 计算出来的值，不是用户覆盖产生的 hashCode。</p><a href=#2偏向锁状态><h5 id=2偏向锁状态><span class=hanchor arialabel=Anchor># </span><strong>2、偏向锁状态</strong></h5></a><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>23bit</td><td>2bit</td><td>4bit</td><td>1bit</td><td>2bit</td></tr><tr><td>线程ID</td><td>epoch</td><td>对象分代年龄</td><td>1</td><td>1</td></tr></tbody></table><p>这里 <strong>线程ID</strong> 和 epoch 占用了 hashCode 的位置，所以，如果对象如果计算过 identityHashCode 后，便无法进入偏向锁状态，反过来，如果对象处于偏向锁状态，并且需要计算其 identityHashCode 的话，则偏向锁会被撤销，升级为重量级锁。</p><p>epoch：</p><p>对于偏向锁，如果 线程ID = 0 表示未加锁。</p><a href=#3轻量级锁状态><h5 id=3轻量级锁状态><span class=hanchor arialabel=Anchor># </span><strong>3、轻量级锁状态</strong></h5></a><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>30bit</td><td>2bit</td></tr><tr><td>指向线程栈锁记录的指针</td><td>0</td></tr></tbody></table><p>这里指向<strong>栈帧中的 Lock Record 记录</strong>，里面当然可以记录对象的 identityHashCode。</p><a href=#4重量级锁状态><h5 id=4重量级锁状态><span class=hanchor arialabel=Anchor># </span><strong>4、重量级锁状态</strong></h5></a><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>30bit</td><td>2bit</td></tr><tr><td>指向锁监视器的指针</td><td>10</td></tr></tbody></table><p>这里<strong>指向了内存中对象的 ObjectMonitor 对象</strong>，而 ObectMontitor 对象可以存储对象的 identityHashCode 的值</p><a href=#1偏向锁><h4 id=1偏向锁><span class=hanchor arialabel=Anchor># </span><strong>1、偏向锁</strong></h4></a><p>偏向锁是针对于一个线程而言的，线程获得锁之后就不会再有解锁等操作了，这样可以省略很多开销。假如有两个线程来竞争该锁话，那么偏向锁就失效了，进而升级成轻量级锁了。</p><blockquote><p><em>为什么要这样做呢？因为经验表明，其实大部分情况下，都会是同一个线程进入同一块同步代码块的。这也是为什么会有偏向锁出现的原因。</em></p></blockquote><p>如果支持偏向锁（没有计算 hashCode），那么在分配对象时，分配一个可偏向而未偏向的对象（MarkWord的最后 3 位为 101，并且 Thread Id 字段的值为 0）。</p><a href=#a偏向锁的加锁><h5 id=a偏向锁的加锁><span class=hanchor arialabel=Anchor># </span><strong>a、偏向锁的加锁</strong></h5></a><ol><li><p>偏向锁标志是未偏向状态，<strong>使用 CAS 将 MarkWord 中的线程ID设置为自己的线程ID</strong>，</p><ol><li><p>如果成功，则获取偏向锁成功。</p></li><li><p>如果失败，则进行锁升级。</p></li></ol></li><li><p>偏向锁标志是已偏向状态</p><ol><li><p>MarkWord 中的线程 ID 是自己的线程 ID，成功获取锁</p></li><li><p>MarkWord 中的线程 ID 不是自己的线程 ID，需要进行锁升级</p></li></ol></li></ol><p>偏向锁的锁升级需要进行偏向锁的撤销。</p><a href=#b偏向锁的撤销><h5 id=b偏向锁的撤销><span class=hanchor arialabel=Anchor># </span><strong>b、偏向锁的撤销</strong></h5></a><ol><li><p><strong>偏向锁不会主动释放(撤销)</strong>，只有遇到其他线程竞争时才会执行撤销，由于撤销需要知道当前持有该偏向锁的可偏向状态。因此要等到safepoint时执行。</p></li><li><p>判断是否是可偏向状态（<strong>MarkWord中锁标志是否为‘01’，是否偏向锁是否为‘1’</strong> ）</p></li><li><p>对象是不可偏向状态</p><ol><li>不需要撤销</li></ol></li><li><p>对象是可偏向状态</p><ol><li><p>MarkWord 中指向的线程不存活</p><ol><li><p>允许重偏向：退回到可偏向但未偏向的状态</p></li><li><p>不允许重偏向：变为无锁状态</p></li></ol></li><li><p>MarkWord 中的线程存活</p><ol><li><p>线程ID指向的线程仍然拥有锁</p><ol><li>升级为轻量级锁，将 mark word 复制到线程栈中</li></ol></li><li><p>不再拥有锁</p><ol><li><p>允许重偏向：退回到可偏向但未偏向的状态</p></li><li><p>不允许重偏向：变为无锁状态</p></li></ol></li></ol></li></ol></li></ol><p>偏向锁的撤销流程</p><p><img src=https://googoo-s.github.io//statistic/asynccode-98.png width=auto alt></p><a href=#2轻量级锁><h2 id=2轻量级锁><span class=hanchor arialabel=Anchor># </span><strong>2、轻量级锁</strong></h2></a><p>之所以是轻量级，是因为它仅仅使用 CAS 进行操作，实现获取锁。</p><a href=#a加锁流程><h4 id=a加锁流程><span class=hanchor arialabel=Anchor># </span><strong>a、加锁流程</strong></h4></a><ol><li><p>进行加锁操作时，jvm会判断是否已经是<strong>重量级锁</strong>，如果不是，则会在当前线程栈帧中划出一块空间，作为该锁的锁记录，并且将锁对象MarkWord复制到该锁记录中</p></li><li><p>复制成功之后，jvm使用CAS操作将对象头MarkWord更新为**指向锁记录的指针，**并将锁记录里的owner指针指向对象头的MarkWord。</p><ol><li><p>更新成功，则当前线程持有该对象锁，并且对象MarkWord锁标志设置为‘00’，即表示此对象处于轻量级锁状态</p></li><li><p>更新失败，jvm先检查对象MarkWord是否指向当前线程栈帧中的锁记录，如果是则执行‘5’，否则执行‘4’</p><ol><li><p>如果是表示锁重入；然后当前线程栈帧中增加一个锁记录第一部分（Displaced Mark Word）为null，并指向Mark Word的锁对象，起到一个重入计数器的作用。</p></li><li><p>如果不是，表示该锁对象已经被其他线程抢占，则进行 自旋等待 （默认10次），等待次数达到阈值仍未获取到锁，则升级为重量级锁</p></li></ol></li></ol></li></ol><a href=#b撤销流程><h5 id=b撤销流程><span class=hanchor arialabel=Anchor># </span><strong>b、撤销流程</strong></h5></a><p>轻量级锁解锁时，如果对象的Mark Word仍然指向着线程的锁记录，会使用CAS操作， 将Dispalced Mark Word替换到对象头，如果成功，则表示没有竞争发生。如果失败， 表示当前锁存在锁竞争，锁就会膨胀为重量级锁。</p><a href=#3重量级锁><h2 id=3重量级锁><span class=hanchor arialabel=Anchor># </span><strong>3、重量级锁</strong></h2></a><p>重量级锁（<code>heavy weight lock</code>），是使用操作系统互斥量（<code>mutex</code>）来实现的传统锁。 当所有对锁的优化都失效时，将退回到重量级锁。它与轻量级锁不同竞争的线程不再通过自旋来竞争线程， 而是直接进入堵塞状态，此时不消耗CPU，然后等拥有锁的线程释放锁后，唤醒堵塞的线程， 然后线程再次竞争锁。但是注意，当锁膨胀（<code>inflate</code>）为重量锁时，就不能再退回到轻量级锁。</p><p>大体的升级流程</p><p><img src=https://googoo-s.github.io//statistic/asynccode-92.png width=auto alt></p><p>完整的升级流程</p><p><img src=https://googoo-s.github.io//statistic/asynccode-99.png width=auto alt></p><a href=#synchronized-和-volatile-有什么区别><h2 id=synchronized-和-volatile-有什么区别><span class=hanchor arialabel=Anchor># </span>synchronized 和 volatile 有什么区别？</h2></a><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p><ul><li><p><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</p></li><li><p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p></li><li><p><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</p></li></ul><a href=#reentrantlock><h1 id=reentrantlock><span class=hanchor arialabel=Anchor># </span>ReentrantLock</h1></a><a href=#reentrantlock-是什么><h2 id=reentrantlock-是什么><span class=hanchor arialabel=Anchor># </span>ReentrantLock 是什么？</h2></a><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个<strong>可重入且独占式的锁</strong>，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ReentrantLock</span> <span class=kd>implements</span> <span class=n>Lock</span><span class=o>,</span> <span class=n>java</span><span class=o>.</span><span class=na>io</span><span class=o>.</span><span class=na>Serializable</span> <span class=o>{}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>ReentrantLock</code> 里面有一个<strong>内部类</strong> <strong><code>Sync</code></strong>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-95.png width=auto alt></p><p><code>ReentrantLock</code> 默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=c1>// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=nf>ReentrantLock</span><span class=o>(</span><span class=kt>boolean</span> <span class=n>fair</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>sync</span> <span class=o>=</span> <span class=n>fair</span> <span class=o>?</span> <span class=k>new</span> <span class=n>FairSync</span><span class=o>()</span> <span class=o>:</span> <span class=k>new</span> <span class=n>NonfairSync</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>从上面的内容可以看出， <code>ReentrantLock</code> 的底层就是由 AQS 来实现的。关于 AQS 的相关内容推荐阅读
<a href=https://javaguide.cn/java/concurrent/aqs.html rel=noopener>AQS 详解open in new window</a> 这篇文章。</p><a href=#aqs-介绍><h2 id=aqs-介绍><span class=hanchor arialabel=Anchor># </span>AQS 介绍</h2></a><p><a href=https://javaguide.cn/java/concurrent/aqs.html rel=noopener>AQS 详解</a></p><p><img src=https://googoo-s.github.io//statistic/asynccode-97.png width=auto alt></p><p>AQS 的全称为 <code>AbstractQueuedSynchronizer</code> ，翻译过来的意思就是抽象队列同步器。这个类在 <code>java.util.concurrent.locks</code> 包下面。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-101.png width=auto alt></p><p>AQS 就是一个抽象类，主要用来构建锁和同步器。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>abstract</span> <span class=kd>class</span> <span class=nc>AbstractQueuedSynchronizer</span> <span class=kd>extends</span> <span class=n>AbstractOwnableSynchronizer</span> <span class=kd>implements</span> <span class=n>java</span><span class=o>.</span><span class=na>io</span><span class=o>.</span><span class=na>Serializable</span> <span class=o>{</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>AQS 为构建锁和同步器提供了一些通用功能的是实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>等等皆是基于 AQS 的。</p><a href=#aqs-原理><h3 id=aqs-原理><span class=hanchor arialabel=Anchor># </span>AQS 原理</h3></a><p>在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于 AQS 原理的理解”。下面给大家一个示例供大家参考，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。</p><a href=#aqs-核心思想><h3 id=aqs-核心思想><span class=hanchor arialabel=Anchor># </span>AQS 核心思想</h3></a><p>AQS 核心思想是，</p><ul><li><p><strong>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态</strong>。</p></li><li><p>如果被请求的共享资源被占用，那么就需要<strong>一套线程阻塞等待以及被唤醒时锁分配的机制</strong>，这个机制 AQS 是基于 <strong>CLH 锁</strong> （Craig, Landin, and Hagersten locks） 实现的。</p><ul><li>CLH 锁是对自旋锁的一种改进，<strong>是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 CLH 队列锁的一个结点（Node）来实现锁的分配</strong>。在 CLH 队列锁中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</li></ul></li></ul><p>CLH 队列锁结构如下图所示：</p><p><img src=https://googoo-s.github.io//statistic/asynccode-102.png width=auto alt></p><p>关于AQS 核心数据结构-CLH 锁的详细解读，强烈推荐阅读
<a href=https://mp.weixin.qq.com/s/jEx-4XhNGOFdCo4Nou5tqg rel=noopener>Java AQS 核心数据结构-CLH 锁 - Qunar技术沙龙open in new window</a> 这篇文章。</p><p>AQS(<code>AbstractQueuedSynchronizer</code>)的核心原理图（图源
<a href=https://www.cnblogs.com/waterystone/p/4920797.html rel=noopener>Java 并发之 AQS 详解open in new window</a>）如下：</p><p><img src=https://googoo-s.github.io//statistic/asynccode-93.png width=auto alt></p><p>AQS 使用 <strong>int 成员变量</strong> <strong><code>state</code></strong> <strong>表示同步状态</strong>，通过内置的 <strong>线程等待队列</strong> 来完成获取资源线程的排队工作。</p><p><code>state</code> 变量由 <code>volatile</code> 修饰，用于展示当前临界资源的获锁情况。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=c1>// 共享变量，使用volatile修饰保证线程可见性
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=kd>volatile</span> <span class=kt>int</span> <span class=n>state</span><span class=o>;</span>
</span></span></code></pre></td></tr></table></div></div><p>另外，状态信息 <code>state</code> 可以通过 <code>protected</code> 类型的<code>getState()</code>、<code>setState()</code>和<code>compareAndSetState()</code> 进行操作。并且，这几个方法都是 <code>final</code> 修饰的，在子类中无法被重写。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=c1>//返回同步状态的当前值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>protected</span> <span class=kd>final</span> <span class=kt>int</span> <span class=nf>getState</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>     <span class=k>return</span> <span class=n>state</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl> <span class=c1>// 设置同步状态的值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>protected</span> <span class=kd>final</span> <span class=kt>void</span> <span class=nf>setState</span><span class=o>(</span><span class=kt>int</span> <span class=n>newState</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>     <span class=n>state</span> <span class=o>=</span> <span class=n>newState</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=c1>//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>protected</span> <span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>compareAndSetState</span><span class=o>(</span><span class=kt>int</span> <span class=n>expect</span><span class=o>,</span> <span class=kt>int</span> <span class=n>update</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>unsafe</span><span class=o>.</span><span class=na>compareAndSwapInt</span><span class=o>(</span><span class=k>this</span><span class=o>,</span> <span class=n>stateOffset</span><span class=o>,</span> <span class=n>expect</span><span class=o>,</span> <span class=n>update</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>以 <code>ReentrantLock</code> 为例，<strong><code>state</code></strong> <strong>初始值为 0，表示未锁定状态</strong>。</p><ul><li><p>A 线程 <code>lock()</code> 时，会调用 <code>tryAcquire()</code> 独占该锁并将 <code>state+1</code> 。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，</p></li><li><p>直到 A 线程 <code>unlock()</code> 到 <code>state=</code>0（即释放锁）为止，其它线程才有机会获取该锁。<strong>当然，释放锁之前，A 线程自己是可以重复获取此锁的（****<code>state</code></strong> <strong>会累加），这就是可重入的概念</strong>。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。相关阅读：
<a href=https://javaguide.cn/java/concurrent/reentrantlock.html rel=noopener>从ReentrantLock的实现看AQS的原理及应用</a></p></li></ul><p>再以 <code>CountDownLatch</code> 以例，</p><ul><li><p>任务分为 N 个子线程去执行，<code>state</code> 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，</p></li><li><p>每个子线程执行完后<code>countDown()</code> 一次，state 会 CAS(Compare and Swap) 减 1。</p></li><li><p>等到所有子线程都执行完后(即 <code>state=0</code> )，会 <code>unpark()</code> 主调用线程，然后主调用线程就会从 <code>await()</code> 函数返回，继续后余动作。</p></li></ul><a href=#aqs-资源共享方式><h3 id=aqs-资源共享方式><span class=hanchor arialabel=Anchor># </span>AQS 资源共享方式</h3></a><p>AQS 定义两种资源共享方式：<code>Exclusive</code>（独占，只有一个线程能执行，如<code>ReentrantLock</code>）和<code>Share</code>（共享，多个线程可同时执行，如<code>Semaphore</code>/<code>CountDownLatch</code>）。</p><p>一般来说，自定义同步器的共享方式要么是独占，要么是共享，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p><a href=#自定义同步器><h3 id=自定义同步器><span class=hanchor arialabel=Anchor># </span>自定义同步器</h3></a><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p><ol><li><p>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法。</p></li><li><p>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</p></li></ol><p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p><p><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的钩子方法：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=c1>//独占方式。尝试获取资源，成功则返回true，失败则返回false。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>protected</span> <span class=kt>boolean</span> <span class=nf>tryAcquire</span><span class=o>(</span><span class=kt>int</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=c1>//独占方式。尝试释放资源，成功则返回true，失败则返回false。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>protected</span> <span class=kt>boolean</span> <span class=nf>tryRelease</span><span class=o>(</span><span class=kt>int</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=c1>//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>protected</span> <span class=kt>int</span> <span class=nf>tryAcquireShared</span><span class=o>(</span><span class=kt>int</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=c1>//共享方式。尝试释放资源，成功则返回true，失败则返回false。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>protected</span> <span class=kt>boolean</span> <span class=nf>tryReleaseShared</span><span class=o>(</span><span class=kt>int</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=c1>//该线程是否正在独占资源。只有用到condition才需要去实现它。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>protected</span> <span class=kt>boolean</span> <span class=nf>isHeldExclusively</span><span class=o>()</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>什么是钩子方法呢？</strong> 钩子方法是一种被声明在抽象类中的方法，一般使用 <code>protected</code> 关键字修饰，它可以是空方法（由子类实现），也可以是默认实现的方法。模板设计模式通过钩子方法控制固定步骤的实现。</p><p>篇幅问题，这里就不详细介绍模板方法模式了，不太了解的小伙伴可以看看这篇文章：
<a href=https://mp.weixin.qq.com/s/zpScSCktFpnSWHWIQem2jg rel=noopener>用 Java8 改造后的模板方法模式真的是 yyds!open in new window</a>。</p><p>除了上面提到的钩子方法之外，AQS 类中的其他方法都是 <code>final</code> ，所以无法被其他类重写。</p><a href=#公平锁和非公平锁有什么区别><h2 id=公平锁和非公平锁有什么区别><span class=hanchor arialabel=Anchor># </span>公平锁和非公平锁有什么区别？</h2></a><ul><li><p><strong>公平锁</strong> : 锁被释放之后，<strong>先申请的线程先得到锁</strong>。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</p></li><li><p><strong>非公平锁</strong> ：锁被释放之后，<strong>后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的</strong>。性能更好，但可能会导致某些线程永远无法获取到锁。</p></li></ul><a href=#synchronized-和-reentrantlock-有什么区别><h2 id=synchronized-和-reentrantlock-有什么区别><span class=hanchor arialabel=Anchor># </span>synchronized 和 ReentrantLock 有什么区别？</h2></a><a href=#两者都是可重入锁><h3 id=两者都是可重入锁><span class=hanchor arialabel=Anchor># </span>两者都是可重入锁</h3></a><p><strong>可重入锁</strong> 也叫递归锁，指的是<strong>线程可以再次获取自己的内部锁</strong>。</p><p>在下面的代码中，<code>method1()</code> 和 <code>method2()</code>都被 <code>synchronized</code> 关键字修饰，<code>method1()</code>调用了<code>method2()</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ReentrantLockDemo</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>void</span> <span class=nf>method1</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;方法1&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>method2</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>void</span> <span class=nf>method2</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;方法2&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>由于 <code>synchronized</code>锁是可重入的，同一个线程在调用<code>method1()</code> 时可以直接获得当前对象的锁，执行 <code>method2()</code> 的时候可以再次获取这个对象的锁，<strong>不会产生死锁问题</strong>。</p><a href=#synchronized-依赖于-jvm-而-reentrantlock-依赖于-api><h3 id=synchronized-依赖于-jvm-而-reentrantlock-依赖于-api><span class=hanchor arialabel=Anchor># </span>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</h3></a><p><code>synchronized</code> 是依赖于 JVM 实现的</p><p><code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成）</p><a href=#reentrantlock-比-synchronized-增加了一些高级功能><h3 id=reentrantlock-比-synchronized-增加了一些高级功能><span class=hanchor arialabel=Anchor># </span>ReentrantLock 比 synchronized 增加了一些高级功能</h3></a><p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p><ul><li><p><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</p></li><li><p><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</p></li><li><p><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</p></li></ul><p>如果你想使用上述功能，那么选择 <code>ReentrantLock</code> 是一个不错的选择。</p><p>关于 <code>Condition</code>接口的补充：</p><blockquote><p><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的</strong>**<code>Condition</code><strong><strong>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用</strong></strong><code>notify()/notifyAll()</code><strong><strong>方法进行通知时，被通知的线程是由 JVM 选择的，用</strong></strong><code>ReentrantLock</code><strong><strong>类结合</strong></strong><code>Condition</code>**<strong>实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 <code>Condition</code> 接口默认提供的。而<code>synchronized</code>关键字就相当于整个 <code>Lock</code> 对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而<code>Condition</code>实例的<code>signalAll()</code>方法，只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p></blockquote><a href=#可中断锁和不可中断锁有什么区别><h3 id=可中断锁和不可中断锁有什么区别><span class=hanchor arialabel=Anchor># </span>可中断锁和不可中断锁有什么区别？</h3></a><ul><li><p><strong>可中断锁</strong> ：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</p></li><li><p><strong>不可中断锁</strong> ：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁。</p></li></ul><a href=#reentrantreadwritelock><h1 id=reentrantreadwritelock><span class=hanchor arialabel=Anchor># </span>ReentrantReadWriteLock</h1></a><p><code>ReentrantReadWriteLock</code> 在实际项目中使用的并不多，面试中也问的比较少，简单了解即可。JDK 1.8 引入了性能更好的读写锁 <code>StampedLock</code> 。</p><a href=#reentrantreadwritelock-是什么><h2 id=reentrantreadwritelock-是什么><span class=hanchor arialabel=Anchor># </span>ReentrantReadWriteLock 是什么？</h2></a><p><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> ，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ReentrantReadWriteLock</span>
</span></span><span class=line><span class=cl>        <span class=kd>implements</span> <span class=n>ReadWriteLock</span><span class=o>,</span> <span class=n>java</span><span class=o>.</span><span class=na>io</span><span class=o>.</span><span class=na>Serializable</span><span class=o>{</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>ReadWriteLock</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Lock</span> <span class=nf>readLock</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Lock</span> <span class=nf>writeLock</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。</p></li><li><p>读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥（只有读读不互斥）。</p></li></ul><p><strong><code>ReentrantReadWriteLock</code></strong> <strong>其实是两把锁，一把是</strong> <strong><code>WriteLock</code></strong> <strong>(写锁)，一把是</strong> **<code>ReadLock</code>****（读锁） 。读锁是共享锁，写锁是独占锁。**读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。</p><p>和 <code>ReentrantLock</code> 一样，<code>ReentrantReadWriteLock</code> 底层也是基于 AQS 实现的。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-103.png width=auto alt></p><p><code>ReentrantReadWriteLock</code> 也支持公平锁和非公平锁，默认使用非公平锁，可以通过构造器来显示的指定。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=c1>// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁public ReentrantReadWriteLock(boolean fair) {
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>sync</span> <span class=o>=</span> <span class=n>fair</span> <span class=o>?</span> <span class=k>new</span> <span class=n>FairSync</span><span class=o>()</span> <span class=o>:</span> <span class=k>new</span> <span class=n>NonfairSync</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>readerLock</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ReadLock</span><span class=o>(</span><span class=k>this</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>writerLock</span> <span class=o>=</span> <span class=k>new</span> <span class=n>WriteLock</span><span class=o>(</span><span class=k>this</span><span class=o>);}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#reentrantreadwritelock-适合什么场景><h2 id=reentrantreadwritelock-适合什么场景><span class=hanchor arialabel=Anchor># </span>ReentrantReadWriteLock 适合什么场景？</h2></a><p>由于 <code>ReentrantReadWriteLock</code> 既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。因此，在读多写少的情况下，使用 <code>ReentrantReadWriteLock</code> 能够明显提升系统性能。</p><a href=#共享锁和独占锁有什么区别><h2 id=共享锁和独占锁有什么区别><span class=hanchor arialabel=Anchor># </span>共享锁和独占锁有什么区别？</h2></a><ul><li><p><strong>共享锁</strong> ：一把锁可以被多个线程同时获得。</p></li><li><p><strong>独占锁</strong> ：一把锁只能被一个线程获得。</p></li></ul><a href=#线程持有读锁还能获取写锁吗><h2 id=线程持有读锁还能获取写锁吗><span class=hanchor arialabel=Anchor># </span>线程持有读锁还能获取写锁吗？</h2></a><ul><li><p>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</p></li><li><p>在线程持有写锁的情况下，<strong>该线程可以继续获取读锁</strong>（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</p></li></ul><p>读写锁的源码分析，推荐阅读
<a href=https://mp.weixin.qq.com/s/h3VIUyH9L0v14MrQJiiDbw rel=noopener>聊聊 Java 的几把 JVM 级锁 - 阿里巴巴中间件 open in new window</a> 这篇文章，写的很不错。</p><a href=#读锁为什么不能升级为写锁><h2 id=读锁为什么不能升级为写锁><span class=hanchor arialabel=Anchor># </span>读锁为什么不能升级为写锁？</h2></a><p><strong>写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺</strong>，毕竟写锁属于是独占锁，这样的话，会影响性能。</p><p>另外，还可能会有死锁问题发生。举个例子：假设两个线程的读锁都想升级写锁，则需要对方都释放自己锁，而双方都不释放，就会产生死锁。</p><a href=#stampedlock><h1 id=stampedlock><span class=hanchor arialabel=Anchor># </span>StampedLock</h1></a><p><code>StampedLock</code> 面试中问的比较少，不是很重要，简单了解即可。</p><a href=#stampedlock-是什么><h2 id=stampedlock-是什么><span class=hanchor arialabel=Anchor># </span>StampedLock 是什么？</h2></a><p><code>StampedLock</code> 是 JDK 1.8 引入的性能更好的读写锁，不可重入且不支持条件变量 <code>Conditon</code>。</p><p>不同于一般的 <code>Lock</code> 类，<code>StampedLock</code> 并不是直接实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <strong>CLH 锁</strong> 独立实现的（AQS 也是基于这玩意）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>StampedLock</span> <span class=kd>implements</span> <span class=n>java</span><span class=o>.</span><span class=na>io</span><span class=o>.</span><span class=na>Serializable</span> <span class=o>{}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>StampedLock</code> 提供了三种模式的读写控制模式：读锁、写锁和乐观读。</p><ul><li><p><strong>写锁</strong>：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 <code>ReentrantReadWriteLock</code> 的写锁，不过这里的写锁是不可重入的。</p></li><li><p><strong>读锁</strong> （悲观读）：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 <code>ReentrantReadWriteLock</code> 的读锁，不过这里的读锁是不可重入的。</p></li><li><p><strong>乐观读</strong> ：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。</p></li></ul><p>另外，<code>StampedLock</code> 还支持这三种锁在一定条件下进行相互转换 。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kt>long</span> <span class=nf>tryConvertToWriteLock</span><span class=o>(</span><span class=kt>long</span> <span class=n>stamp</span><span class=o>){}</span>
</span></span><span class=line><span class=cl><span class=kt>long</span> <span class=nf>tryConvertToReadLock</span><span class=o>(</span><span class=kt>long</span> <span class=n>stamp</span><span class=o>){}</span>
</span></span><span class=line><span class=cl><span class=kt>long</span> <span class=nf>tryConvertToOptimisticRead</span><span class=o>(</span><span class=kt>long</span> <span class=n>stamp</span><span class=o>){}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>StampedLock</code> 在获取锁的时候会返回一个 long 型的数据戳，该数据戳用于稍后的锁释放参数，如果返回的数据戳为 0 则表示锁获取失败。当前线程持有了锁再次获取锁还是会返回一个新的数据戳，这也是<code>StampedLock</code>不可重入的原因。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=c1>// 写锁public long writeLock() {long s, next;  // bypass acquireWrite in fully unlocked case onlyreturn ((((s = state) &amp; ABITS) == 0L &amp;&amp;U.compareAndSwapLong(this, STATE, s, next = s + WBIT)) ?
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>next</span> <span class=o>:</span> <span class=n>acquireWrite</span><span class=o>(</span><span class=kc>false</span><span class=o>,</span> <span class=n>0L</span><span class=o>));}</span><span class=c1>// 读锁public long readLock() {long s = state, next;  // bypass acquireRead on common uncontended casereturn ((whead == wtail &amp;&amp; (s &amp; ABITS) &lt; RFULL &amp;&amp;U.compareAndSwapLong(this, STATE, s, next = s + RUNIT)) ?
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>next</span> <span class=o>:</span> <span class=n>acquireRead</span><span class=o>(</span><span class=kc>false</span><span class=o>,</span> <span class=n>0L</span><span class=o>));}</span><span class=c1>// 乐观读public long tryOptimisticRead() {long s;return (((s = state) &amp; WBIT) == 0L) ? (s &amp; SBITS) : 0L;}
</span></span></span></code></pre></td></tr></table></div></div><a href=#stampedlock-的性能为什么更好><h2 id=stampedlock-的性能为什么更好><span class=hanchor arialabel=Anchor># </span>StampedLock 的性能为什么更好？</h2></a><p>相比于传统读写锁多出来的乐观读是<code>StampedLock</code>比 <code>ReadWriteLock</code> 性能更好的关键原因。<code>StampedLock</code> 的乐观读允许一个写线程获取写锁，所以不会导致所有写线程阻塞，也就是当读多写少的时候，写线程有机会获取写锁，减少了线程饥饿的问题，吞吐量大大提高。</p><a href=#stampedlock-适合什么场景><h2 id=stampedlock-适合什么场景><span class=hanchor arialabel=Anchor># </span>StampedLock 适合什么场景？</h2></a><p>和 <code>ReentrantReadWriteLock</code> 一样，<code>StampedLock</code> 同样适合读多写少的业务场景，可以作为 <code>ReentrantReadWriteLock</code>的替代品，性能更好。</p><p>不过，需要注意的是<code>StampedLock</code>不可重入，不支持条件变量 <code>Conditon</code>，对中断操作支持也不友好（使用不当容易导致 CPU 飙升）。如果你需要用到 <code>ReentrantLock</code> 的一些高级性能，就不太建议使用 <code>StampedLock</code> 了。</p><p>另外，<code>StampedLock</code> 性能虽好，但使用起来相对比较麻烦，一旦使用不当，就会出现生产问题。强烈建议你在使用<code>StampedLock</code> 之前，看看
<a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/StampedLock.html rel=noopener>StampedLock 官方文档中的案例open in new window</a>。</p><a href=#stampedlock-的底层原理了解吗><h2 id=stampedlock-的底层原理了解吗><span class=hanchor arialabel=Anchor># </span>StampedLock 的底层原理了解吗？</h2></a><p><code>StampedLock</code> 不是直接实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <strong>CLH 锁</strong> 实现的（AQS 也是基于这玩意），CLH 锁是对自旋锁的一种改良，是一种隐式的链表队列。<code>StampedLock</code> 通过 CLH 队列进行线程的管理，通过同步状态值 <code>state</code> 来表示锁的状态和类型。</p><p><code>StampedLock</code> 的原理和 AQS 原理比较类似，这里就不详细介绍了，感兴趣的可以看看下面这两篇文章：</p><ul><li><p><a href=https://javaguide.cn/java/concurrent/aqs.html rel=noopener>AQS 详解open in new window</a></p></li><li><p><a href=https://segmentfault.com/a/1190000015808032 rel=noopener>StampedLock 底层原理分析open in new window</a></p></li></ul><p>如果你只是准备面试的话，建议多花点精力搞懂 AQS 原理即可，<code>StampedLock</code> 底层原理在面试中遇到的概率非常小</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://googoo-s.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by googoo-s using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://googoo-s.github.io/>Home</a></li><li><a href=https://github.com/googoo-s>GitHub</a></li></ul></footer></div></div></body></html>