<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="线程池
什么是线程池? 顾名思义，线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。
为什么要用线程池？ 池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。
线程池提供了一种限制和管理资源（包括执行一个任务）的方式。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。
这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：
  降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
  提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
  提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
  如何创建线程池？ 方式一：通过**ThreadPoolExecutor**构造函数来创建（推荐）。"><meta property="og:title" content><meta property="og:description" content="线程池
什么是线程池? 顾名思义，线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。
为什么要用线程池？ 池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。
线程池提供了一种限制和管理资源（包括执行一个任务）的方式。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。
这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：
  降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
  提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
  提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
  如何创建线程池？ 方式一：通过**ThreadPoolExecutor**构造函数来创建（推荐）。"><meta property="og:type" content="website"><meta property="og:image" content="https://googoo-s.github.io/icon.png"><meta property="og:url" content="https://googoo-s.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="线程池
什么是线程池? 顾名思义，线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。
为什么要用线程池？ 池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。
线程池提供了一种限制和管理资源（包括执行一个任务）的方式。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。
这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：
  降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
  提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
  提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
  如何创建线程池？ 方式一：通过**ThreadPoolExecutor**构造函数来创建（推荐）。"><meta name=twitter:image content="https://googoo-s.github.io/icon.png"><title>googoo-s</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://googoo-s.github.io//icon.png><link href=https://googoo-s.github.io/styles.19109a40042e9f0e72e952fda4442a34.min.css rel=stylesheet><link href=https://googoo-s.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://googoo-s.github.io/js/darkmode.953af745b0f9342644d632fc167f3727.min.js></script>
<script src=https://googoo-s.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://googoo-s.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://googoo-s.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://googoo-s.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://googoo-s.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://googoo-s.github.io/",fetchData=Promise.all([fetch("https://googoo-s.github.io/indices/linkIndex.26897e4d1acf67c094aa607e8f2e6316.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://googoo-s.github.io/indices/contentIndex.0ac1455204506c058198872f05e49d0d.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://googoo-s.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://googoo-s.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/googoo-s.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=googoo-s.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://googoo-s.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://googoo-s.github.io/>googoo-s</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Unknown
<a href=/Java/%e5%a4%9a%e7%ba%bf%e7%a8%8b/%e7%ba%bf%e7%a8%8b%e6%b1%a0.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents></nav></details></aside><p>线程池</p><a href=#什么是线程池><h1 id=什么是线程池><span class=hanchor arialabel=Anchor># </span>什么是线程池?</h1></a><p>顾名思义，线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p><a href=#为什么要用线程池><h1 id=为什么要用线程池><span class=hanchor arialabel=Anchor># </span>为什么要用线程池？</h1></a><p>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p><p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p><p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p><ul><li><p><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p></li><li><p><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p></li><li><p><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p></li></ul><a href=#如何创建线程池><h1 id=如何创建线程池><span class=hanchor arialabel=Anchor># </span>如何创建线程池？</h1></a><p><strong>方式一：通过</strong>**<code>ThreadPoolExecutor</code>**<strong>构造函数来创建（推荐）。</strong></p><p><strong>方式二：通过</strong> <strong><code>Executor</code></strong> <strong>框架的工具类</strong> <strong><code>Executors</code></strong> <strong>来创建。</strong></p><p>我们可以创建多种类型的 <code>ThreadPoolExecutor</code>：</p><ul><li><p><strong><code>FixedThreadPool</code></strong> ： <strong>该方法返回一个固定线程数量的线程池</strong>。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p></li><li><p><strong><code>SingleThreadExecutor</code>****：</strong> 该方法返回一个<strong>只有一个线程的线程池</strong>。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</p></li><li><p><strong><code>CachedThreadPool</code>****：</strong> 该方法返回一个<strong>可根据实际情况调整线程数量的线程池</strong>。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</p></li><li><p><strong><code>ScheduledThreadPool</code></strong> ：该<strong>返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池</strong>。</p></li></ul><p>对应 <code>Executors</code> 工具类中的方法如图所示：</p><p><img src=https://googoo-s.github.io//statistic/asynccode-128.png width=auto alt></p><a href=#为什么不推荐使用内置线程池><h1 id=为什么不推荐使用内置线程池><span class=hanchor arialabel=Anchor># </span>为什么不推荐使用内置线程池？</h1></a><p><strong>为什么呢？</strong></p><blockquote><p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p></blockquote><p>另外，《阿里巴巴 Java 开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><p><code>Executors</code> 返回线程池对象的弊端如下(后文会详细介绍到)：</p><ul><li><p><strong><code>FixedThreadPool</code></strong> <strong>和</strong> <strong><code>SingleThreadExecutor</code></strong> ： 使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</p></li><li><p><strong><code>CachedThreadPool</code></strong> ：使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</p></li><li><p><strong><code>ScheduledThreadPool</code></strong> <strong>和</strong> <strong><code>SingleThreadScheduledExecutor</code></strong> : 使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</p></li></ul><a href=#线程池常见参数有哪些如何解释><h1 id=线程池常见参数有哪些如何解释><span class=hanchor arialabel=Anchor># </span>线程池常见参数有哪些？如何解释？</h1></a><p><img src=https://googoo-s.github.io//statistic/asynccode-126.png width=auto alt></p><p><strong><code>ThreadPoolExecutor</code></strong> <strong>3 个最重要的参数：</strong></p><ul><li><p><strong><code>corePoolSize</code></strong> <strong>:</strong> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</p></li><li><p><strong><code>maximumPoolSize</code></strong> <strong>:</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</p></li><li><p><strong><code>workQueue</code>****:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p></li></ul><p><code>ThreadPoolExecutor</code>其他常见参数 :</p><ul><li><p><strong><code>keepAliveTime</code></strong>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</p></li><li><p><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</p></li><li><p><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</p></li><li><p><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</p></li></ul><p><img src=https://googoo-s.github.io//statistic/asynccode-134.png width=auto alt></p><a href=#线程池的饱和策略有哪些><h1 id=线程池的饱和策略有哪些><span class=hanchor arialabel=Anchor># </span>线程池的饱和策略有哪些？</h1></a><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p><ul><li><p><strong><code>ThreadPoolExecutor.AbortPolicy</code>****：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</p></li><li><p><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>****：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</p></li><li><p><strong><code>ThreadPoolExecutor.DiscardPolicy</code>****：</strong> 不处理新任务，直接丢弃掉。</p></li><li><p><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>****：</strong> 此策略将丢弃最早的未处理的任务请求。</p></li></ul><a href=#线程池常用的阻塞队列有哪些><h1 id=线程池常用的阻塞队列有哪些><span class=hanchor arialabel=Anchor># </span>线程池常用的阻塞队列有哪些？</h1></a><p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p><p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p><ul><li><p><strong>ArrayBlockingQueue</strong>：ArrayBlockingQueue（有界队列）是一个用数组实现的有 界阻塞队列，按FIFO排序量。</p></li><li><p><strong><code>LinkedBlockingQueue</code></strong>：容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列）：<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code> 。由于队列永远不会被放满，因此<code>FixedThreadPool</code>最多只能创建核心线程数的线程。</p></li><li><p><strong><code>DelayedWorkQueue</code>****（延迟阻塞队列）</strong>：<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 。<code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</p></li><li><p><strong><code>SynchronousQueue</code>****（同步队列</strong>） ：<code>CachedThreadPool</code> 。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</p></li><li><p><strong>PriorityBlockingQueue</strong>：PriorityBlockingQueue（优先级队列）是具有优先级的无界阻塞队列</p></li><li><p><strong>SynchronousQueue</strong>：SynchronousQueue（同步队列）是一个不存储元素的阻塞队 列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。</p></li></ul><a href=#线程池提交execute和submit的区别><h1 id=线程池提交execute和submit的区别><span class=hanchor arialabel=Anchor># </span>线程池提交execute和submit的区别</h1></a><ul><li>execute 用于提交不需要返回值的任务</li></ul><p><img src=https://googoo-s.github.io//statistic/asynccode-132.png width=auto alt></p><ul><li>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个 future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值</li></ul><p><img src=https://googoo-s.github.io//statistic/asynccode-133.png width=auto alt></p><a href=#线程池处理任务的流程了解吗><h1 id=线程池处理任务的流程了解吗><span class=hanchor arialabel=Anchor># </span>线程池处理任务的流程了解吗？</h1></a><p><img src=https://googoo-s.github.io//statistic/asynccode-125.png width=auto alt></p><ol><li><p>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</p></li><li><p>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</p></li><li><p>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</p></li><li><p>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</p></li></ol><a href=#如何给线程池命名><h1 id=如何给线程池命名><span class=hanchor arialabel=Anchor># </span>如何给线程池命名？</h1></a><p>初始化线程池的时候需要显示命名（设置线程池名称前缀），有利于定位问题。</p><p>默认情况下创建的线程名字类似 <code>pool-1-thread-n</code> 这样的，没有业务含义，不利于我们定位问题。</p><p>给线程池里的线程命名通常有下面两种方式：</p><p><strong>1、利用 guava 的</strong> <strong><code>ThreadFactoryBuilder</code></strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=n>ThreadFactory</span> <span class=n>threadFactory</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ThreadFactoryBuilder</span><span class=o>()</span>
</span></span><span class=line><span class=cl>                            <span class=o>.</span><span class=na>setNameFormat</span><span class=o>(</span><span class=n>threadNamePrefix</span> <span class=o>+</span> <span class=s>&#34;-%d&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                            <span class=o>.</span><span class=na>setDaemon</span><span class=o>(</span><span class=kc>true</span><span class=o>).</span><span class=na>build</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=n>ExecutorService</span> <span class=n>threadPool</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ThreadPoolExecutor</span><span class=o>(</span><span class=n>corePoolSize</span><span class=o>,</span> <span class=n>maximumPoolSize</span><span class=o>,</span> <span class=n>keepAliveTime</span><span class=o>,</span> <span class=n>TimeUnit</span><span class=o>.</span><span class=na>MINUTES</span><span class=o>,</span> <span class=n>workQueue</span><span class=o>,</span> <span class=n>threadFactory</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>2、自己实现</strong> <strong><code>ThreadFactor</code>****。</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.Executors</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.ThreadFactory</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.atomic.AtomicInteger</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 线程工厂，它设置线程名称，有利于我们定位问题。
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl> <span class=kd>public</span> <span class=kd>final</span> <span class=kd>class</span> <span class=nc>NamingThreadFactory</span> <span class=kd>implements</span> <span class=n>ThreadFactory</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>     <span class=kd>private</span> <span class=kd>final</span> <span class=n>AtomicInteger</span> <span class=n>threadNum</span> <span class=o>=</span> <span class=k>new</span> <span class=n>AtomicInteger</span><span class=o>();</span>
</span></span><span class=line><span class=cl>     <span class=kd>private</span> <span class=kd>final</span> <span class=n>ThreadFactory</span> <span class=n>delegate</span><span class=o>;</span><span class=kd>private</span> <span class=kd>final</span> <span class=n>String</span> <span class=n>name</span><span class=o>;</span>
</span></span><span class=line><span class=cl>     
</span></span><span class=line><span class=cl>     <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 创建一个带名字的线程池生产工厂
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>     <span class=kd>public</span> <span class=nf>NamingThreadFactory</span><span class=o>(</span><span class=n>ThreadFactory</span> <span class=n>delegate</span><span class=o>,</span> <span class=n>String</span> <span class=n>name</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>         <span class=k>this</span><span class=o>.</span><span class=na>delegate</span> <span class=o>=</span> <span class=n>delegate</span><span class=o>;</span>
</span></span><span class=line><span class=cl>         <span class=k>this</span><span class=o>.</span><span class=na>name</span> <span class=o>=</span> <span class=n>name</span><span class=o>;</span> <span class=c1>// TODO consider uniquifying this
</span></span></span><span class=line><span class=cl><span class=c1></span>     <span class=o>}</span>
</span></span><span class=line><span class=cl>     
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Thread</span> <span class=nf>newThread</span><span class=o>(</span><span class=n>Runnable</span> <span class=n>r</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Thread</span> <span class=n>t</span> <span class=o>=</span> <span class=n>delegate</span><span class=o>.</span><span class=na>newThread</span><span class=o>(</span><span class=n>r</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span><span class=o>.</span><span class=na>setName</span><span class=o>(</span><span class=n>name</span> <span class=o>+</span> <span class=s>&#34; [#&#34;</span> <span class=o>+</span> <span class=n>threadNum</span><span class=o>.</span><span class=na>incrementAndGet</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34;]&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>t</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#如何设定线程池的大小><h1 id=如何设定线程池的大小><span class=hanchor arialabel=Anchor># </span>如何设定线程池的大小？</h1></a><p><strong>并不是人多就能把事情做好，增加了沟通交流成本。你本来一件事情只需要 3 个人做，你硬是拉来了 6 个人，会提升做事效率嘛？我想并不会。</strong> 线程数量过多的影响也是和我们分配多少人做事情一样，对于多线程这个场景来说主要是增加了<strong>上下文切换</strong>成本。不清楚什么是上下文切换的话，可以看我下面的介绍。</p><blockquote><p>上下文切换：</p><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为<strong>每个线程分配时间片并轮转的形式</strong>。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：<strong>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换</strong>。</p><p>上下文切换通常是<strong>计算密集型</strong>的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p></blockquote><p>类比于实现世界中的人类通过合作做某件事情，我们可以肯定的一点是线程池大小设置过大或者过小都会有问题，合适的才是最好。</p><ul><li><p><strong>如果我们设置的线程池数量太小的话</strong>，如果同一时间有大量任务/请求需要处理，可能<strong>会导致大量的请求/任务在任务队列中排队等待执行</strong>，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者<del>大量任务堆积在任务队列导致 OOM</del>。这样很明显是有问题的，CPU 根本没有得到充分利用。</p></li><li><p>如果我们设置线程数量太大，<strong>大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换</strong>，从而增加线程的执行时间，影响了整体执行效率。</p></li></ul><p>有一个简单并且适用面比较广的公式：</p><ul><li><p><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，<strong>可以将线程数设置为 N（CPU 核心数）+1</strong>。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p></li><li><p><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，<strong>具体的计算方法是 2N</strong>。</p></li></ul><p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><blockquote><p>🌈 拓展一下（参见：
<a href=https://github.com/Snailclimb/JavaGuide/issues/1737 rel=noopener>issue#1737open in new window</a>）：</p><p>线程数更严谨的计算的方法应该是：<code>最佳线程数 = N（CPU 核心数）∗（1+WT（线程等待时间）/ST（线程计算时间））</code>，其中 <code>WT（线程等待时间）=线程运行总时间 - ST（线程计算时间）</code>。</p><p>线程等待时间所占比例越高，需要越多线程。线程计算时间所占比例越高，需要越少线程。</p><p>我们可以通过 JDK 自带的工具 VisualVM 来查看 <code>WT/ST</code> 比例。</p><p>CPU 密集型任务的 <code>WT/ST</code> 接近或者等于 0，因此， 线程数可以设置为 N（CPU 核心数）∗（1+0）= N，和我们上面说的 N（CPU 核心数）+1 差不多。</p><p>IO 密集型任务下，几乎全是线程等待时间，从理论上来说，你就可以将线程数设置为 2N（按道理来说，WT/ST 的结果应该比较大，这里选择 2N 的原因应该是为了避免创建过多线程吧）。</p></blockquote><p>公示也只是参考，具体还是要根据项目实际线上运行情况来动态调整。我在后面介绍的美团的线程池参数动态配置这种方案就非常不错，很实用！</p><a href=#如何动态修改线程池的参数><h1 id=如何动态修改线程池的参数><span class=hanchor arialabel=Anchor># </span>如何动态修改线程池的参数？</h1></a><p>美团技术团队在
<a href=https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html rel=noopener>《Java 线程池实现原理及其在美团业务中的实践》open in new window</a>这篇文章中介绍到对线程池参数实现可自定义配置的思路和方法。</p><p>美团技术团队的思路是主要对线程池的核心参数实现自定义可配置。这三个核心参数是：</p><ul><li><p><strong><code>corePoolSize</code></strong> <strong>:</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</p></li><li><p><strong><code>maximumPoolSize</code></strong> <strong>:</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</p></li><li><p><strong><code>workQueue</code>****:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p></li></ul><p><strong>为什么是这三个参数？</strong></p><p>我在
<a href=https://javaguide.cn/java/concurrent/java-thread-pool-summary.html rel=noopener>Java 线程池详解open in new window</a> 这篇文章中就说过这三个参数是 <code>ThreadPoolExecutor</code> 最重要的参数，它们基本决定了线程池对于任务的处理策略。</p><p><strong>如何支持参数动态配置？</strong> 且看 <code>ThreadPoolExecutor</code> 提供的下面这些方法。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-130.png width=auto alt></p><p>格外需要注意的是<code>corePoolSize</code>， 程序运行期间的时候，我们调用 <code>setCorePoolSize（）</code>这个方法的话，线程池会首先判断当前工作线程数是否大于<code>corePoolSize</code>，如果大于的话就会回收工作线程。</p><p>另外，你也看到了上面并没有动态指定队列长度的方法，美团的方式是自定义了一个叫做 <code>ResizableCapacityLinkedBlockIngQueue</code> 的队列（主要就是把<code>LinkedBlockingQueue</code>的 capacity 字段的 final 关键字修饰给去掉了，让它变为可变的）。</p><p>最终实现的可动态修改线程池参数效果如下。👏👏👏</p><p><img src=https://googoo-s.github.io//statistic/asynccode-127.png width=auto alt></p><p>还没看够？推荐 why 神的
<a href=https://mp.weixin.qq.com/s/9HLuPcoWmTqAeFKa1kj-_A rel=noopener>如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答。open in new window</a>这篇文章，深度剖析，很不错哦！</p><p>如果我们的项目也想要实现这种效果的话，可以借助现成的开源项目：</p><ul><li><p><strong><a href=https://github.com/opengoofy/hippo4j rel=noopener>Hippo-4 （open in new windo</a>****）</strong> ：一款强大的动态线程池框架，解决了传统线程池使用存在的一些痛点比如线程池参数没办法动态修改、不支持运行时变量的传递、无法执行优雅关闭。除了支持动态修改线程池参数、线程池任务传递上下文，还支持通知报警、运行监控等开箱即用的功能。</p></li><li><p><strong><a href=https://github.com/dromara/dynamic-tp rel=noopener>Dynamic TP （open in new window</a>****）</strong> ：轻量级动态线程池，内置监控告警功能，集成三方中间件线程池管理，基于主流配置中心（已支持Nacos、Apollo，Zookeeper、Consul、Etcd，可通过SPI自定义实现）。</p></li></ul><a href=#线程池如何关闭><h1 id=线程池如何关闭><span class=hanchor arialabel=Anchor># </span>线程池如何关闭？</h1></a><p>可以通过调用线程池的 <strong>shutdown 或 shutdownNow</strong> 方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的<strong>interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止</strong>。</p><ul><li><p><strong>shutdown()</strong> 将线程池状态置为**shutdown,**并不会立即停止</p><ul><li><p>停止接收外部submit的任务</p></li><li><p>内部正在跑的任务和队列里等待的任务，会执行完</p></li><li><p>等到第二步完成后，才真正停止</p></li></ul></li><li><p><strong>shutdownNow()</strong> 将线程池状态置为<strong>stop</strong>。一般会立即停止，事实上不一定：</p><ul><li><p>和shutdown()一样，先停止接收外部提交的任务</p></li><li><p>忽略队列里等待的任务</p></li><li><p>尝试将正在跑的任务interrupt中断</p></li><li><p>返回未执行的任务列表</p></li></ul></li></ul><p>shutdown 和shutdownnow简单来说区别如下：</p><ul><li><p>shutdownNow()能立即停止线程池，正在跑的和正在等待的任务都停下了。这样 做立即生效，但是风险也比较大。</p></li><li><p>shutdown()只是关闭了提交通道，用submit()是无效的；而内部的任务该怎么跑还是怎么跑，跑完再彻底停止线程池</p></li></ul><a href=#线程池异常如何处理><h1 id=线程池异常如何处理><span class=hanchor arialabel=Anchor># </span>线程池异常如何处理？</h1></a><p><img src=https://googoo-s.github.io//statistic/asynccode-131.png width=auto alt></p><a href=#线程池的几种状态><h1 id=线程池的几种状态><span class=hanchor arialabel=Anchor># </span>线程池的几种状态</h1></a><p>线程池有这几个状态：RUNNING,SHUTDOWN,STOP,TIDYING,TERMINATED。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-131.png width=auto alt></p><p><img src=https://googoo-s.github.io//statistic/asynccode-131.png width=auto alt></p><ul><li><p><strong>RUNNING</strong></p><ul><li><p>该状态的线程池会接收新任务，并处理阻塞队列中的任务;</p></li><li><p>调用线程池的shutdown()方法，可以切换到SHUTDOWN状态;</p></li><li><p>调用线程池的shutdownNow()方法，可以切换到STOP状态;</p></li></ul></li><li><p><strong>SHUTDOWN</strong></p><ul><li><p>该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</p></li><li><p>队列为空，并且线程池中执行的任务也为空,进入TIDYING状态;</p></li></ul></li><li><p><strong>STOP</strong></p><ul><li><p>该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</p></li><li><p>线程池中执行的任务为空,进入TIDYING状态;</p></li></ul></li><li><p><strong>TIDYING</strong></p><ul><li><p>该状态表明所有的任务已经运行终止，记录的任务数量为0。</p></li><li><p>terminated()执行完毕，进入TERMINATED状态</p></li></ul></li><li><p><strong>TERMINATED</strong></p><ul><li>该状态表示线程池彻底终止</li></ul></li></ul><a href=#线程池调优了解吗><h1 id=线程池调优了解吗><span class=hanchor arialabel=Anchor># </span>线程池调优了解吗？</h1></a><p>上线之前也要进行充分的测试，上线之后要建立完善的线程池监控机制。事中结合监控告警机制，分析线程池的问题，或者可优化点，结合线程池动态参数</p><p>配置机制来调整配置。</p><p>事后要注意仔细观察，随时调整</p><p><img src=https://googoo-s.github.io//statistic/asynccode-135.png width=auto alt></p><a href=#forkjoin框架><h1 id=forkjoin框架><span class=hanchor arialabel=Anchor># </span>ForkJoin框架</h1></a><ul><li>分而治之</li></ul><p>Fork/Join框架的定义，其实就体现了分治思想：将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同</p><p><img src=https://googoo-s.github.io//statistic/asynccode-129.png width=auto alt></p><p><img src=https://googoo-s.github.io//statistic/asynccode-129.png width=auto alt></p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://googoo-s.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by googoo-s using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://googoo-s.github.io/>Home</a></li><li><a href=https://github.com/googoo-s>GitHub</a></li></ul></footer></div></div></body></html>