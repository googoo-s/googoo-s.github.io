<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="运行时数据区域 Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK 1.8 和之前的版本略有不同，下面会介绍到。
JDK 1.8 之前 ：
 JDK 1.8 之后 ：
 线程私有的：
  程序计数器"><meta property="og:title" content><meta property="og:description" content="运行时数据区域 Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK 1.8 和之前的版本略有不同，下面会介绍到。
JDK 1.8 之前 ：
 JDK 1.8 之后 ：
 线程私有的：
  程序计数器"><meta property="og:type" content="website"><meta property="og:image" content="https://googoo-s.github.io/icon.png"><meta property="og:url" content="https://googoo-s.github.io/Java/JVM/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="运行时数据区域 Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK 1.8 和之前的版本略有不同，下面会介绍到。
JDK 1.8 之前 ：
 JDK 1.8 之后 ：
 线程私有的：
  程序计数器"><meta name=twitter:image content="https://googoo-s.github.io/icon.png"><title>googoo-s</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://googoo-s.github.io//icon.png><link href=https://googoo-s.github.io/styles.19109a40042e9f0e72e952fda4442a34.min.css rel=stylesheet><link href=https://googoo-s.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://googoo-s.github.io/js/darkmode.953af745b0f9342644d632fc167f3727.min.js></script>
<script src=https://googoo-s.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://googoo-s.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://googoo-s.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://googoo-s.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://googoo-s.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://googoo-s.github.io/",fetchData=Promise.all([fetch("https://googoo-s.github.io/indices/linkIndex.26897e4d1acf67c094aa607e8f2e6316.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://googoo-s.github.io/indices/contentIndex.ca4acdfca5978eac73c0a8c823a6b4e4.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://googoo-s.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://googoo-s.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/googoo-s.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=googoo-s.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://googoo-s.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://googoo-s.github.io/>googoo-s</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Unknown</p><ul class=tags></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#运行时数据区域>运行时数据区域</a></li><li><a href=#程序计数器>程序计数器</a></li><li><a href=#java-虚拟机栈>Java 虚拟机栈</a><ol><li><a href=#局部变量表><strong>局部变量表</strong></a></li><li><a href=#操作数栈><strong>操作数栈</strong></a></li><li><a href=#动态链接><strong>动态链接</strong></a></li></ol></li><li><a href=#本地方法栈>本地方法栈</a></li><li><a href=#堆>堆</a></li><li><a href=#方法区>方法区</a><ol><li><a href=#运行时常量池>运行时常量池</a></li><li><a href=#字符串常量池>字符串常量池</a></li></ol></li><li><a href=#直接内存>直接内存</a></li></ol><ol><li><a href=#对象的创建>对象的创建</a><ol><li><a href=#step1类加载检查>Step1:类加载检查</a></li><li><a href=#step2分配内存>Step2:分配内存</a></li><li><a href=#step3初始化零值>Step3:初始化零值</a></li><li><a href=#step4设置对象头>Step4:设置对象头</a></li><li><a href=#step5执行-init-方法>Step5:执行 init 方法</a></li></ol></li></ol><ol><li><ol><li><a href=#句柄>句柄</a></li><li><a href=#直接指针>直接指针</a></li></ol></li></ol></nav></details></aside><a href=#运行时数据区域><h2 id=运行时数据区域><span class=hanchor arialabel=Anchor># </span>运行时数据区域</h2></a><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK 1.8 和之前的版本略有不同，下面会介绍到。</p><p><strong>JDK 1.8 之前</strong> ：</p><p><img src=https://googoo-s.github.io//statistic/asynccode-196.png width=auto alt></p><p><strong>JDK 1.8 之后</strong> ：</p><p><img src=https://googoo-s.github.io//statistic/asynccode-206.png width=auto alt></p><p><strong>线程私有的：</strong></p><ul><li><p>程序计数器</p></li><li><p>虚拟机栈</p></li><li><p>本地方法栈</p></li></ul><p><strong>线程共享的：</strong></p><ul><li><p>堆</p></li><li><p>方法区</p></li><li><p>直接内存 (非运行时数据区的一部分)</p></li></ul><p>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</p><a href=#程序计数器><h2 id=程序计数器><span class=hanchor arialabel=Anchor># </span>程序计数器</h2></a><p><strong>程序计数器是一块较小的内存空间</strong>，可以看作是当前线程<strong>所执行的字节码的行号指示器</strong>。字节码解释器工作时通过<strong>改变这个计数器的值来选取下一条需要执行的字节码指令</strong>，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p><p>另外**，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器**，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>从上面的介绍中我们知道了程序计数器主要有两个作用：</p><ul><li><p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</p></li><li><p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</p></li></ul><p>⚠️ 注意 ：<strong>程序计数器是唯一一个不会出现</strong> <strong><code>OutOfMemoryError</code></strong> <strong>的内存区域</strong>，<strong>它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p><a href=#java-虚拟机栈><h2 id=java-虚拟机栈><span class=hanchor arialabel=Anchor># </span>Java 虚拟机栈</h2></a><ul><li><p>与程序计数器一样，<strong>Java 虚拟机栈（后文简称栈）也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。</strong></p></li><li><p><strong>所有的 Java 方法调用都是通过栈来实现的（也需要和其他运行时数据区域比如程序计数器配合）</strong>。<strong>方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。</strong></p></li></ul><p>而每个栈帧中都拥有：</p><ul><li><p>局部变量表</p></li><li><p>操作数栈</p></li><li><p>动态链接</p></li><li><p>方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。</p></li></ul><p><img src=https://googoo-s.github.io//statistic/asynccode-200.png width=auto alt></p><a href=#局部变量表><h3 id=局部变量表><span class=hanchor arialabel=Anchor># </span><strong>局部变量表</strong></h3></a><p><strong>主要存放了编译期可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，<strong>可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置</strong>）。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-204.png width=auto alt></p><a href=#操作数栈><h3 id=操作数栈><span class=hanchor arialabel=Anchor># </span><strong>操作数栈</strong></h3></a><p>主要作为方法调用的中转站使用，<strong>用于存放方法执行过程中产生的中间计算结果</strong>。另外，计算过程中产生的临时变量也会放在操作数栈中。</p><a href=#动态链接><h3 id=动态链接><span class=hanchor arialabel=Anchor># </span><strong>动态链接</strong></h3></a><p><strong>主要服务一个方法需要调用其他方法的场景</strong>。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。</p><p>当一个方法要调用其他方法，</p><ul><li><p>需要将常量池中指向方法的<strong>符号引用转化为其在内存地址中的直接引用</strong>。</p></li><li><p><strong>动态链接的作用就是为了将符号引用转换为调用方法的直接引用</strong>，这个过程也被称为 <strong>动态连接</strong> 。</p></li></ul><p><img src=https://googoo-s.github.io//statistic/asynccode-195.png width=auto alt></p><p>栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。<strong>不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出</strong> <strong><code>StackOverFlowError</code></strong> <strong>错误</strong>。</p><p>Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， <strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong></p><p>简单总结一下程序运行中栈可能会出现两种错误：</p><ul><li><p><strong><code>StackOverFlowError</code>****：</strong> 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</p></li><li><p><strong><code>OutOfMemoryError</code>****：</strong> 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</p></li></ul><a href=#本地方法栈><h2 id=本地方法栈><span class=hanchor arialabel=Anchor># </span>本地方法栈</h2></a><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在<strong>本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</strong></p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <strong><code>StackOverFlowError</code></strong> <strong>和</strong> <strong><code>OutOfMemoryError</code></strong> <strong>两种错误。</strong></p><a href=#堆><h2 id=堆><span class=hanchor arialabel=Anchor># </span>堆</h2></a><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p>Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，<strong>栈上分配、标量替换优化技术将会导致一些微妙的变化</strong>，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经<strong>默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</strong></p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用<strong>分代垃圾收集算法。</strong></p><ul><li><p>新生代</p><ul><li><p>Eden</p></li><li><p>Survivor</p></li><li><p>Old</p></li></ul></li><li><p>老年代</p></li></ul><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li><p>新生代内存(Young Generation)</p></li><li><p>老生代(Old Generation)</p></li><li><p>永久代(Permanent Generation)</p></li></ol><p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-203.png width=auto alt></p><p><strong>JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存。</strong> （我会在方法区这部分内容详细介绍到）。</p><p>大部分情况，<strong>对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数</strong> <strong><code>-XX:MaxTenuringThreshold</code></strong> <strong>来设置</strong>。</p><blockquote><p><strong>🐛 修正（参见：<strong><strong>
<a href=https://github.com/Snailclimb/JavaGuide/issues/552 rel=noopener>issue552open in new window</a></strong></strong>）</strong> ：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p><p><strong>动态年龄计算的代码如下</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>uint</span> <span class=n>ageTable</span><span class=o>::</span><span class=n>compute_tenuring_threshold</span><span class=p>(</span><span class=n>size_t</span> <span class=n>survivor_capacity</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//survivor_capacity是survivor空间的大小
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>size_t</span> <span class=n>desired_survivor_size</span> <span class=o>=</span> <span class=p>(</span><span class=n>size_t</span><span class=p>)((((</span><span class=kt>double</span><span class=p>)</span> <span class=n>survivor_capacity</span><span class=p>)</span><span class=o>*</span><span class=n>TargetSurvivorRatio</span><span class=p>)</span><span class=o>/</span><span class=mi>100</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>size_t</span> <span class=n>total</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>uint</span> <span class=n>age</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>age</span> <span class=o>&lt;</span> <span class=n>table_size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=n>total</span> <span class=o>+=</span> <span class=n>sizes</span><span class=p>[</span><span class=n>age</span><span class=p>];</span><span class=c1>//sizes数组是每个年龄段对象大小
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>total</span> <span class=o>&gt;</span> <span class=n>desired_survivor_size</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>age</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>uint</span> <span class=n>result</span> <span class=o>=</span> <span class=n>age</span> <span class=o>&lt;</span> <span class=n>MaxTenuringThreshold</span> <span class=o>?</span> <span class=nl>age</span> <span class=p>:</span> <span class=n>MaxTenuringThreshold</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></blockquote><p>堆这里最容易出现的就是 <code>OutOfMemoryError</code> 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p><ol><li><p><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</p></li><li><p><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> <strong>:假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误</strong>。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过<code>-Xmx</code>参数配置，若没有特别配置，将会使用默认值，详见：
<a href=https://stackoverflow.com/questions/28272923/default-xmxsize-in-java-8-max-heap-size rel=noopener>Default Java 8 max heap sizeopen in new window</a>)</p></li><li><p>&mldr;&mldr;</p></li></ol><a href=#方法区><h2 id=方法区><span class=hanchor arialabel=Anchor># </span>方法区</h2></a><p>方法区属于是 <strong>JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域</strong>。</p><p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p><p><strong>方法区和永久代以及元空间是什么关系呢？</strong></p><p><strong>永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式</strong>。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-195.png width=auto alt></p><p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p><p>下图来自《深入理解 Java 虚拟机》第 3 版 2.2.5</p><p><img src=https://googoo-s.github.io//statistic/asynccode-196.png width=auto alt></p><p>1、<strong>整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整</strong>，而<strong>元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小</strong>。</p><blockquote><p>当元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p></blockquote><p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p><p>2、<strong>元空间里面存放的是类的元数据</strong>，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，<strong>这样能加载的类就更多了。</strong></p><p>3、在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p><a href=#运行时常量池><h3 id=运行时常量池><span class=hanchor arialabel=Anchor># </span>运行时常量池</h3></a><p>Class 文件中除了有<strong>类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 常量池表(Constant Pool Table) 。</strong></p><p>字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义**。字面量包括整数、浮点数和字符串字面量。常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号。**</p><p>《深入理解 Java 虚拟机》7.34 节第三版对符号引用和直接引用的解释如下：</p><p><img src=https://googoo-s.github.io//statistic/asynccode-176.png width=auto alt></p><p>常量池表会在类加载后存放到方法区的运行时常量池中。</p><p><strong>运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。</strong></p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。</p><a href=#字符串常量池><h3 id=字符串常量池><span class=hanchor arialabel=Anchor># </span>字符串常量池</h3></a><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存<strong>消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建</strong>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=c1>// 在堆中创建字符串对象”ab“
</span></span></span><span class=line><span class=cl><span class=c1>// 将字符串对象”ab“的引用保存在字符串常量池中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>String</span> <span class=n>aa</span> <span class=o>=</span> <span class=s>&#34;ab&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 直接返回字符串常量池中字符串对象”ab“的引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>String</span> <span class=n>bb</span> <span class=o>=</span> <span class=s>&#34;ab&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>aa</span><span class=o>==</span><span class=n>bb</span><span class=o>);</span><span class=c1>// true
</span></span></span></code></pre></td></tr></table></div></div><ul><li><p><strong>HotSpot 虚拟机中字符串常量池的实现是</strong> <strong><code>src/hotspot/share/classfile/stringTable.cpp</code></strong> <strong>,****<code>StringTable</code></strong> <strong>本质上就是一个</strong>**<code>HashSet&lt;String></code>**</p></li><li><p><strong><code>StringTable</code></strong> <strong>中保存的是字符串对象的引用，字符串对象的引用指向堆中的字符串对象。</strong></p></li></ul><p>JDK1.7 之前，<strong>字符串常量池存放在永久代</strong>。JDK1.7 字<strong>符串常量池和静态变量从永久代移动了 Java 堆中</strong>。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-197.png width=auto alt></p><p><img src=https://googoo-s.github.io//statistic/asynccode-198.png width=auto alt></p><p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p><p><strong>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC</strong>。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p><p>相关问题：
<a href=https://www.zhihu.com/question/57109429/answer/151717241 rel=noopener>JVM 常量池中存储的是对象还是引用呢？ - RednaxelaFX - 知乎open in new window</a></p><p>最后再来分享一段周志明老师在
<a href=https://github.com/fenixsoft/jvm_book rel=noopener>《深入理解 Java 虚拟机（第 3 版）》样例代码&勘误open in new window</a> Github 仓库的
<a href=https://github.com/fenixsoft/jvm_book/issues/112 rel=noopener>issue#112open in new window</a> 中说过的话：</p><blockquote><p><strong>运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。</strong></p></blockquote><a href=#直接内存><h2 id=直接内存><span class=hanchor arialabel=Anchor># </span>直接内存</h2></a><p>直接内存是一种特殊的内存缓冲区，<strong>并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的</strong>。</p><p>直接内存并<strong>不是虚拟机运行时数据区的一部</strong>分，也不是虚拟机规范中定义的内存区域，但<strong>是这部分内存也被频繁地使用。而且也可能导致</strong> <strong><code>OutOfMemoryError</code></strong> <strong>错误出现</strong>。</p><ul><li><strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</li></ul><p>类似的概念还有 <strong>堆外内存</strong> 。在一些文章中将直接内存等价于堆外内，个人觉得不是特别准确。</p><p>堆外内存就是把内存对象分配在堆（新生代+老年代+永久代）以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够<strong>在一定程度上减少垃圾回收对应用程序造成的影响</strong>。</p><a href=#hotspot-虚拟机对象探秘><h1 id=hotspot-虚拟机对象探秘><span class=hanchor arialabel=Anchor># </span>HotSpot 虚拟机对象探秘</h1></a><p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p><a href=#对象的创建><h2 id=对象的创建><span class=hanchor arialabel=Anchor># </span>对象的创建</h2></a><p>Java 对象的创建过程我建议最好是能默写出来，并且要掌握每一步在做什么。</p><a href=#step1类加载检查><h3 id=step1类加载检查><span class=hanchor arialabel=Anchor># </span>Step1:类加载检查</h3></a><p>虚拟机遇到一条 new 指令时，</p><ul><li>首先将去检查这个指令的参数是否能在<strong>常量池中定位到这个类的符号引用</strong>，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li></ul><a href=#step2分配内存><h3 id=step2分配内存><span class=hanchor arialabel=Anchor># </span>Step2:分配内存</h3></a><ul><li>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</li></ul><a href=#内存分配的两种方式-补充内容需要掌握><h4 id=内存分配的两种方式-补充内容需要掌握><span class=hanchor arialabel=Anchor># </span><strong>内存分配的两种方式</strong> （补充内容，需要掌握）：</h4></a><ul><li><p>指针碰撞 ：</p><ul><li><p>适用场合 ：堆内存规整（即没有内存碎片）的情况下。</p></li><li><p>原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</p></li><li><p>使用该分配方式的 GC 收集器：Serial, ParNew</p></li></ul></li><li><p>空闲列表 ：</p><ul><li><p>适用场合 ： 堆内存不规整的情况下。</p></li><li><p>原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</p></li><li><p>使用该分配方式的 GC 收集器：CMS</p></li></ul></li></ul><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的。</p><a href=#内存分配并发问题补充内容需要掌握堆发生了抢占><h4 id=内存分配并发问题补充内容需要掌握堆发生了抢占><span class=hanchor arialabel=Anchor># </span><strong>内存分配并发问题（补充内容，需要掌握），堆发生了抢占</strong></h4></a><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><p><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></p></li><li><p><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</p></li></ul><a href=#step3初始化零值><h3 id=step3初始化零值><span class=hanchor arialabel=Anchor># </span>Step3:初始化零值</h3></a><p>内存分配完成后，虚拟机需要将<strong>分配到的内存空间都初始化为零值（不包括对象头</strong>），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><a href=#step4设置对象头><h3 id=step4设置对象头><span class=hanchor arialabel=Anchor># </span>Step4:设置对象头</h3></a><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><a href=#step5执行-init-方法><h3 id=step5执行-init-方法><span class=hanchor arialabel=Anchor># </span>Step5:执行 init 方法</h3></a><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init></code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init></code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-202.png width=auto alt></p><a href=#对象的内存布局><h1 id=对象的内存布局><span class=hanchor arialabel=Anchor># </span>对象的内存布局</h1></a><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，</p><ul><li><p><strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p></li><li><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p></li><li><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> <strong>因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍</strong>，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p></li></ul><p><img src=https://googoo-s.github.io//statistic/asynccode-201.png width=auto alt></p><a href=#对象的访问定位><h1 id=对象的访问定位><span class=hanchor arialabel=Anchor># </span>对象的访问定位</h1></a><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p><a href=#句柄><h3 id=句柄><span class=hanchor arialabel=Anchor># </span>句柄</h3></a><p>如果使用句柄的话，那<strong>么 Java 堆中将会划分出一块内存来作为句柄池</strong>，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-205.png width=auto alt></p><a href=#直接指针><h3 id=直接指针><span class=hanchor arialabel=Anchor># </span>直接指针</h3></a><p>如果使用直接指针访问，reference 中存储的直接就是对象的地址。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-199.png width=auto alt></p><p>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p><p>HotSpot 虚拟机主要使用的就是这种方式来进行对象访问。</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://googoo-s.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by googoo-s using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://googoo-s.github.io/>Home</a></li><li><a href=https://github.com/googoo-s>GitHub</a></li></ul></footer></div></div></body></html>