<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="HashMap 和 HashTable 的区别   线程是否安全： HashMap 是非线程安全的，****Hashtable 是线程安全的,因为 Hashtable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；
  效率： 因为线程安全的问题，HashMap 要比 Hashtable 效率高一点。另外，Hashtable 基本被淘汰，不要在代码中使用它；"><meta property="og:title" content><meta property="og:description" content="HashMap 和 HashTable 的区别   线程是否安全： HashMap 是非线程安全的，****Hashtable 是线程安全的,因为 Hashtable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；
  效率： 因为线程安全的问题，HashMap 要比 Hashtable 效率高一点。另外，Hashtable 基本被淘汰，不要在代码中使用它；"><meta property="og:type" content="website"><meta property="og:image" content="https://googoo-s.github.io/icon.png"><meta property="og:url" content="https://googoo-s.github.io/Java/%E9%9B%86%E5%90%88/Map/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="HashMap 和 HashTable 的区别   线程是否安全： HashMap 是非线程安全的，****Hashtable 是线程安全的,因为 Hashtable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；
  效率： 因为线程安全的问题，HashMap 要比 Hashtable 效率高一点。另外，Hashtable 基本被淘汰，不要在代码中使用它；"><meta name=twitter:image content="https://googoo-s.github.io/icon.png"><title>googoo-s</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://googoo-s.github.io//icon.png><link href=https://googoo-s.github.io/styles.19109a40042e9f0e72e952fda4442a34.min.css rel=stylesheet><link href=https://googoo-s.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://googoo-s.github.io/js/darkmode.953af745b0f9342644d632fc167f3727.min.js></script>
<script src=https://googoo-s.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://googoo-s.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://googoo-s.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://googoo-s.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://googoo-s.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://googoo-s.github.io/",fetchData=Promise.all([fetch("https://googoo-s.github.io/indices/linkIndex.26897e4d1acf67c094aa607e8f2e6316.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://googoo-s.github.io/indices/contentIndex.e28f5017d281c891a2707fe8349fdf86.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://googoo-s.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://googoo-s.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/googoo-s.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=googoo-s.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://googoo-s.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://googoo-s.github.io/>googoo-s</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Unknown
<a href=/Java/%e9%9b%86%e5%90%88/Map.md rel=noopener>Edit Source</a></p><ul class=tags><li><a href=https://googoo-s.github.io/tags/Java/>Java</a></li><li><a href=https://googoo-s.github.io/tags/%E9%9B%86%E5%90%88/>集合</a></li><li><a href=https://googoo-s.github.io/tags/Map/>Map</a></li></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#为啥不用二叉树>为啥不用二叉树</a></li><li><a href=#为啥不用平衡二叉树>为啥不用平衡二叉树</a></li></ol><ol><li><a href=#正好解释了为什么-hashmap-的数组长度要取-2-的整数幂>正好解释了为什么 HashMap 的数组长度要取 2 的整数幂。</a></li><li><a href=#低位有规律冲突依然会很大如何解决的>低位有规律，冲突依然会很大，如何解决的</a></li></ol><ol><li><a href=#红黑树转回链表的阈值为什么是6而不是8>红黑树转回链表的阈值为什么是6，而不是8？</a></li></ol><ol><li><a href=#为什么选择了075作为hashmap的默认加载因子>为什么选择了0.75作为HashMap的默认加载因子</a></li></ol><ol><li><a href=#17-分段锁>1.7 分段锁</a></li><li><a href=#18-cassynchronized><strong>1.8 CAS+synchronized</strong></a></li></ol><ol><li><a href=#hashtable>HashTable</a></li><li><a href=#17-的concurrenthashmap>1.7 的ConcurrentHashMap</a></li><li><a href=#18-的concurrenthashmap><strong>1.8 的ConcurrentHashMap</strong></a></li></ol></nav></details></aside><a href=#hashmap-和-hashtable-的区别><h1 id=hashmap-和-hashtable-的区别><span class=hanchor arialabel=Anchor># </span>HashMap 和 HashTable 的区别</h1></a><ul><li><p><strong>线程是否安全：</strong> <strong><code>HashMap</code></strong> <strong>是非线程安全的，****<code>Hashtable</code></strong> <strong>是线程安全的</strong>,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</p></li><li><p><strong>效率：</strong> 因为线程安全的问题，<strong><code>HashMap</code></strong> <strong>要比</strong> <strong><code>Hashtable</code></strong> <strong>效率高一点</strong>。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</p></li><li><p><strong>对 Null key 和 Null value 的支持：</strong> <code>H</code><strong><code>ashMap</code></strong> <strong>可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值</strong>，否则会抛出 <code>NullPointerException</code>。</p></li><li><p><strong>初始容量大小和每次扩充容量大小的不同 ：</strong></p><ul><li><p>① 创建时如果不指定容量初始值，<strong><code>Hashtable</code></strong> <strong>默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1</strong>。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</p></li><li><p>② 创建时如果给定了容量初始值，那<strong>么</strong> <strong><code>Hashtable</code></strong> <strong>会直接使用你给定的大小</strong>，而 <code>HashMap</code> <strong>会将其扩充为 2 的幂次方大小（****<code>HashMap</code></strong> <strong>中的</strong>**<code>tableSizeFor()</code>**<strong>方法保证，下面给出了源代码）。也就是说</strong> <strong><code>HashMap</code></strong> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</p></li></ul></li><li><p><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。<code>Hashtable</code> 没有这样的机制。</p></li></ul><a href=#hashmap-和-hashset-区别><h1 id=hashmap-和-hashset-区别><span class=hanchor arialabel=Anchor># </span>HashMap 和 HashSet 区别</h1></a><p><code>HashSet</code> 源码的话就应该知道：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p><table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>实现了 Map 接口</td><td>实现 Set 接口</td></tr><tr><td>存储键值对</td><td>仅存储对象</td></tr><tr><td>调用 put()向 map 中添加元素</td><td>调用 add()方法向 Set 中添加元素</td></tr><tr><td>HashMap 使用键（Key）计算 hashcode</td><td>HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相同，所以equals()方法用来判断对象的相等性</td></tr></tbody></table><a href=#hashmap-和-treemap-区别><h1 id=hashmap-和-treemap-区别><span class=hanchor arialabel=Anchor># </span>HashMap 和 TreeMap 区别</h1></a><ul><li><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p><ul><li><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力</p></li><li><p>实现 <code>SortedMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力</p></li></ul></li></ul><a href=#hashset-如何实现检查重复><h1 id=hashset-如何实现检查重复><span class=hanchor arialabel=Anchor># </span>HashSet 如何实现检查重复</h1></a><ul><li>在 JDK1.8 中，<code>HashSet</code>的<code>add()</code>方法只是简单的调用了<code>HashMap</code>的<code>put()</code>方法，并且判断了一下返回值以确保是否有重复元素。直接看一下<code>HashSet</code>中的源码：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=c1>// Returns: true if this set did not already contain the specified element
</span></span></span><span class=line><span class=cl><span class=c1>// 返回值：当 set 中没有包含 add 的元素时返回真
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>public</span> <span class=nx>boolean</span> <span class=nf>add</span><span class=p>(</span><span class=nx>E</span> <span class=nx>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kd>map</span><span class=p>.</span><span class=nf>put</span><span class=p>(</span><span class=nx>e</span><span class=p>,</span> <span class=nx>PRESENT</span><span class=p>)</span><span class=o>==</span><span class=nx>null</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>实际上无论<code>HashSet</code>中是否已经存在了某元素，<code>HashSet</code>都会直接插入，只是会在<code>add()</code>方法的返回值处告诉我们插入前是否存在相同元素</p><a href=#能说一下hashmap的数据结构吗><h1 id=能说一下hashmap的数据结构吗><span class=hanchor arialabel=Anchor># </span>能说一下HashMap的数据结构吗</h1></a><p>JDK1.7的数据结构是 数组 + 链表</p><p>JDK1.8的数据结构是 数组 + 链表 + 红黑树 。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-51.png width=auto alt></p><p>桶数组是用来存储数据元素，链表是用来解决冲突，红黑树是为了提高查询 的效率。</p><ul><li><p>数据元素通过映射关系，也就是散列函数，映射到桶数组对应索引的位置</p></li><li><p>如果发生冲突，从冲突的位置拉一个链表，插入冲突的元素</p></li><li><p>如果链表长度>8&数组大小>=64，链表转为红黑树</p></li><li><p>如果红黑树节点个数&lt;6 ，转为链表</p></li></ul><a href=#对红黑树了解多少为什么不用二叉树平衡树呢><h1 id=对红黑树了解多少为什么不用二叉树平衡树呢><span class=hanchor arialabel=Anchor># </span>对红黑树了解多少？为什么不用二叉树平衡树呢？</h1></a><p>红黑树本质上是一种二叉查找树，为了保持平衡，它又在二叉查找树的基础上增加</p><p>了一些规则：</p><ol><li><p>每个节点要么是红色，要么是黑色；</p></li><li><p>根节点永远是黑色的；</p></li><li><p>所有的叶子节点都是是黑色的（注意这里说叶子节点其实是图中的 NULL 节点）；</p></li><li><p>每个红色节点的两个子节点一定都是黑色；</p></li><li><p>从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；</p></li></ol><p><img src=https://googoo-s.github.io//statistic/asynccode-47.png width=auto alt></p><a href=#为啥不用二叉树><h2 id=为啥不用二叉树><span class=hanchor arialabel=Anchor># </span>为啥不用二叉树</h2></a><p>红黑树是一种平衡的二叉树，插入、删除、查找的最坏时间复杂度都为 O(logn)，避 免了二叉树最坏情况下的O(n)时间复杂度。</p><a href=#为啥不用平衡二叉树><h2 id=为啥不用平衡二叉树><span class=hanchor arialabel=Anchor># </span>为啥不用平衡二叉树</h2></a><p>平衡二叉树是比红黑树更严格的平衡树，为了保持保持平衡，需要旋转的次数更 多，也就是说平衡二叉树保持平衡的效率更低，所以平衡二叉树插入和删除的效率 比红黑树要低</p><a href=#红黑树怎么保持平衡的知道吗><h1 id=红黑树怎么保持平衡的知道吗><span class=hanchor arialabel=Anchor># </span>红黑树怎么保持平衡的知道吗</h1></a><p>红黑树有两种方式保持平衡： 旋转 和 染色 。</p><ul><li>旋转：旋转分为两种，左旋和右旋</li></ul><p><img src=https://googoo-s.github.io//statistic/asynccode-46.png width=auto alt></p><p><img src=https://googoo-s.github.io//statistic/asynccode-47.png width=auto alt></p><ul><li>染色</li></ul><p><img src=https://googoo-s.github.io//statistic/asynccode-50.png width=auto alt></p><a href=#hashmap的put流程知道吗><h1 id=hashmap的put流程知道吗><span class=hanchor arialabel=Anchor># </span><strong>HashMap</strong>的<strong>put</strong>流程知道吗？</h1></a><p><img src=https://googoo-s.github.io//statistic/asynccode-48.png width=auto alt></p><ol><li>首先进行哈希值的扰动，获取一个新的哈希值。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl>  <span class=p>(</span><span class=nx>key</span> <span class=o>==</span> <span class=nx>null</span><span class=p>)</span> <span class=err>?</span> <span class=mi>0</span> <span class=p>:</span> <span class=p>(</span><span class=nx>h</span> <span class=p>=</span> <span class=nx>key</span><span class=p>.</span><span class=nf>hashCode</span><span class=p>())</span> <span class=p>^</span> <span class=p>(</span><span class=nx>h</span> <span class=o>&gt;&gt;</span><span class=p>&gt;</span> <span class=mi>16</span><span class=p>);</span> 
</span></span></code></pre></td></tr></table></div></div><ol start=2><li><p>判断tab是否位空或者长度为0，如果是则进行扩容操作。</p></li><li><p>根据哈希值计算下标，如果对应小标正好没有存放数据，则直接插入即可否则需要覆盖。</p></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=nx>tab</span><span class=p>[</span><span class=nx>i</span> <span class=p>=</span> <span class=p>(</span><span class=nx>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&amp;</span> <span class=nx>hash</span><span class=p>]</span> 
</span></span></code></pre></td></tr></table></div></div><ol start=4><li><p>判断tab[i]是否为树节点，否则向链表中插入数据，是则向树中插入节点。</p></li><li><p>如果链表中插入节点的时候，链表长度大于等于8，则需要把链表转换为红黑树。</p></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=nf>treeifyBin</span><span class=p>(</span><span class=nx>tab</span><span class=p>,</span> <span class=nx>hash</span><span class=p>);</span> 
</span></span></code></pre></td></tr></table></div></div><ol start=6><li>最后所有元素处理完成后，判断是否超过阈值； threshold ，超过则扩容。</li></ol><a href=#hashmap怎么查找元素的呢><h1 id=hashmap怎么查找元素的呢><span class=hanchor arialabel=Anchor># </span><strong>HashMap</strong>怎么查找元素的呢？</h1></a><p><img src=https://googoo-s.github.io//statistic/asynccode-48.png width=auto alt></p><p>HashMap的查找就简单很多：</p><ol><li><p>使用扰动函数，获取新的哈希值</p></li><li><p>计算数组下标，获取节点</p></li><li><p>当前节点和key匹配，直接返回</p></li><li><p>否则，当前节点是否为树节点，查找红黑树</p></li><li><p>否则，遍历链表查找</p></li></ol><a href=#hashmap的哈希扰动函数是怎么设计的><h1 id=hashmap的哈希扰动函数是怎么设计的><span class=hanchor arialabel=Anchor># </span><strong>HashMap</strong>的哈希扰动函数是怎么设计的?</h1></a><p>HashMap的哈希函数是先拿到 key 的hashcode，<strong>是一个32位的int类型的数值</strong>，然后<strong>让 hashcode的高16位和低16位进行异或操作</strong>。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-51.png width=auto alt></p><a href=#为什么哈希扰动函数能降hash碰撞><h1 id=为什么哈希扰动函数能降hash碰撞><span class=hanchor arialabel=Anchor># </span>为什么哈希扰动函数能降<strong>hash</strong>碰撞</h1></a><p>因为 key.hashCode() 函数调用的是 key 键值类型自带的哈希函数，返回 int 型散列 值。int 值范围为 <strong>-2147483648~2147483647</strong>，加起来大概 40 亿的映射空间</p><p>源码中模运算就是把散列值和数组长度 - 1 做一个 " 与& " 操作，<strong>位运算比取余 % 运 算要快</strong>。</p><a href=#正好解释了为什么-hashmap-的数组长度要取-2-的整数幂><h2 id=正好解释了为什么-hashmap-的数组长度要取-2-的整数幂><span class=hanchor arialabel=Anchor># </span>正好解释了为什么 HashMap 的数组长度要取 2 的整数幂。</h2></a><ul><li><p>方便取余：因为这样（数组长度 - 1）正好相当于一个 “低位掩码”。 与操作的结果就是散列值的<strong>高位全部归零</strong>，只保留低位值，用来做数组下标访问。</p></li><li><p>在扩容时，利用扩容后的大小也是2的倍数，将已经产生hash碰撞 的元素完美的转移到新的table中去</p></li></ul><a href=#低位有规律冲突依然会很大如何解决的><h2 id=低位有规律冲突依然会很大如何解决的><span class=hanchor arialabel=Anchor># </span>低位有规律，冲突依然会很大，如何解决的</h2></a><p>新的问题来了，就算散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。如果散列本身做得不好，分布上成等差数列的漏洞，如果正好让最后几个低位呈现规律性重复,</p><p>自己的高半区和低半区做异或，就是为了<strong>混合原始哈希码的高位和低位，以此来加大低位的随机性</strong></p><a href=#如果初始化hashmap传一个17的值-new-hashmap-它会-怎么处理><h1 id=如果初始化hashmap传一个17的值-new-hashmap-它会-怎么处理><span class=hanchor arialabel=Anchor># </span>如果初始化<strong>HashMap</strong>，传一个<strong>17</strong>的值 <strong>new HashMap&lt;></strong> ，它会 怎么处理</h1></a><p>HashMap会向上寻找 <strong>离得最近的2的倍数</strong> ，所以传入17，但HashMap的实际容量是32</p><a href=#hash函数的构造方法><h1 id=hash函数的构造方法><span class=hanchor arialabel=Anchor># </span>Hash函数的构造方法</h1></a><p>HashMap里哈希构造函数的方法叫</p><ul><li>除留取余法 ：H（key)=key%p（p&lt;=N）,关键字除以一个不大于哈希表长度的正 整数p，所得余数为地址，当然HashMap里进行了优化改造，效率更高，散列也 更均衡。</li></ul><p>其他的hash函数</p><ul><li><p>直接定址法 ：直接根据 key 来映射到对应的数组位置，例如1232放到下标1232的位置。</p></li><li><p>数字分析法 ：取 key 的某些数字（例如十位和百位）作为映射的位置</p></li><li><p>平方取中法 ：取 key 平方的中间几位作为映射的位置</p></li><li><p>折叠法 ：将 key 分割成位数相同的几段，然后把它们的叠加和作为映射的位置</p></li></ul><a href=#解决hash冲突的方法><h1 id=解决hash冲突的方法><span class=hanchor arialabel=Anchor># </span>解决hash冲突的方法</h1></a><p>HashMap使用<strong>链表的原因</strong>为了处理哈希冲突，这种方法就是 所谓的：</p><ul><li>链地址法 ：在冲突的位置拉一个链表，把冲突的元素放进去</li></ul><p>其他方法：</p><ul><li><p>开放定址法：开放定址法就是从冲突的位置再接着往下找，给冲突元素找个空位。</p><ul><li><p>线行探查法: 从冲突的位置开始，依次判断下一个位置是否空闲，直至找到 空闲位置</p></li><li><p>平方探查法: 从冲突的位置x开始，第一次增加 1^2 个位置，第二次增加 2^2 …，直至找到空闲的位置</p></li><li><p>再哈希法 ：换种哈希函数，重新计算冲突元素的地址</p></li><li><p>建立公共溢出区 ：再建一个数组，把冲突的元素放进去。</p></li></ul></li></ul><a href=#hashmap链表转红黑树的阈值为8呢><h1 id=hashmap链表转红黑树的阈值为8呢><span class=hanchor arialabel=Anchor># </span><strong>HashMap</strong>链表转红黑树的阈值为<strong>8</strong>呢</h1></a><p>和统计学有关。理想情况下，使用<strong>随机哈希码，链表里的节点符合泊松分布</strong>，出现节点个数的概率是递减的，节点个数为8的情况，发生概率仅为 0.00000006</p><a href=#红黑树转回链表的阈值为什么是6而不是8><h2 id=红黑树转回链表的阈值为什么是6而不是8><span class=hanchor arialabel=Anchor># </span>红黑树转回链表的阈值为什么是6，而不是8？</h2></a><p>是因为如果这个阈值也设置成8， 假如发生碰撞，<strong>节点增减刚好在8附近，会发生链表和红黑树的不断转换</strong>，导致资源浪费</p><a href=#扩容在什么时候呢为什么扩容因子是075><h1 id=扩容在什么时候呢为什么扩容因子是075><span class=hanchor arialabel=Anchor># </span>扩容在什么时候呢？为什么扩容因子是<strong>0.75</strong>？</h1></a><p>当前HashMap的元素个数<strong>达到一个临界值的时候，就会触发扩容，把所有元素rehash</strong>之后再放在扩容后的容器中，这是一个相当耗时的操作</p><p>个 临界值<strong>threshold 就是由加载因子和当前容器的容量大小来确定的</strong>，假如采用默认的构造方法：</p><blockquote><p>临界值（threshold ）= 默认容量（DEFAULT_INITIAL_CAPACITY） * 默认扩容因子（DEFAULT_LOAD_FACTOR）</p></blockquote><p>那就是大于 16x0.75=12 时，就会触发扩容操作</p><a href=#为什么选择了075作为hashmap的默认加载因子><h2 id=为什么选择了075作为hashmap的默认加载因子><span class=hanchor arialabel=Anchor># </span>为什么选择了0.75作为HashMap的默认加载因子</h2></a><p>简单来说，这是对 空间 成本和 时间 成本平衡的考虑</p><ul><li><p>HashMap的散列构造方式是Hash取余，负载因子决定元素个数达到多少时候扩容</p><ul><li><p>多了哈希冲突变多</p></li><li><p>少了需要更多的空间</p></li></ul></li></ul><a href=#扩容机制了解><h1 id=扩容机制了解><span class=hanchor arialabel=Anchor># </span>扩容机制了解</h1></a><ul><li><p>HashMap是基于数组+链表和红黑树实现的，但用于存放key值的桶数组的长度是固定的，由初始化参数确定。</p></li><li><p>扩容中有一个非常重要的点，就是jdk1.8中的优化操作，可以不需要再重新 计算每一个元素的哈希值。</p></li><li><p>因为HashMap的初始容量是2的次幂，扩容之后的长度是原来的二倍，<strong>新的容量也是2的次幂</strong>，所以，元素，要么在原位置，要么在原位置再移动2的次幂</p></li><li><p>只需要看原来的hash值新增的那一位是0还是1就行了，是0的话索引 没变，是1的化变成 原索引+oldCap</p></li></ul><p><img src=https://googoo-s.github.io//statistic/asynccode-49.png width=auto alt></p><a href=#jdk18对hashmap主要做了哪些优化><h1 id=jdk18对hashmap主要做了哪些优化><span class=hanchor arialabel=Anchor># </span><strong>jdk1.8</strong>对<strong>HashMap</strong>主要做了哪些优化</h1></a><ol><li><p>数据结构：数组 + 链表改成了数组 + 链表或红黑树</p><ol><li>原因 ：发生 hash 冲突，元素会存入链表，链表过长转为红黑树，将时间复杂度 由 O(n) 降为 O(logn)</li></ol></li><li><p>链表插入方式：链表的插入方式从头插法改成了尾插法</p><ol><li>原因 ：因为 1.7 头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环。</li></ol></li><li><p>扩容<strong>rehash</strong>：扩容的时候 1.7 需要对原数组中的元素进行重新 hash 定位在新数组的位置，1.8 采用更简单的判断逻辑，不需要重新通过哈希函数计算位置，新的位置不变或索引 + 旧的数组容量大小。</p><ol><li>原因： 提高扩容的效率，更快地扩容。</li></ol></li><li><p>扩容时机：在插入时，1.7 先判断是否需要扩容，再插入，1.8 先进行插入，插入完成再判断是否需要扩容；</p></li><li><p>散列函数：1.7 做了四次移位和四次异或，jdk1.8只做一次。</p><ol><li>原因 ：做 4 次的话，边际效用也不大，改为一次，提升效率</li></ol></li></ol><a href=#hashmap-是线程安全的吗多线程下会有什么问题><h1 id=hashmap-是线程安全的吗多线程下会有什么问题><span class=hanchor arialabel=Anchor># </span><strong>HashMap</strong> 是线程安全的吗？多线程下会有什么问题？</h1></a><p>HashMap<strong>不是线程安全的</strong>，可能会发生这些问题：</p><ul><li><p>多线程下扩容死循环。</p><ul><li><p>1.7 头插法，多线程会出现环</p></li><li><p>1.8 使用尾插法，不会出现</p></li></ul></li><li><p>多线程的 put 可能导致元素的丢失。</p></li><li><p>多线程的 put 可能导致元素的丢失。</p></li></ul><a href=#有什么办法能解决hashmap线程不安全的问题呢><h1 id=有什么办法能解决hashmap线程不安全的问题呢><span class=hanchor arialabel=Anchor># </span>有什么办法能解决<strong>HashMap</strong>线程不安全的问题呢</h1></a><p>HashTable、Collections.synchronizedMap、以及 ConcurrentHashMap 可以实现线程安全的 Map</p><ul><li><p>HashTable ：是直接在操作方法上加 synchronized 关键字，锁住整个table数组，粒 度比较大；</p></li><li><p>Collections.synchronizedMap 是使用 Collections 集合工具的内部类，通过传入Map 封装出一个 SynchronizedMap 对象，内部定义了一个对象锁，方法内通过对象锁实现；</p></li><li><p>ConcurrentHashMap 在jdk1.7中使用分段锁，在jdk1.8中使用CAS+synchronized。</p></li></ul><a href=#能具体说一下concurrenthashmap的实现><h1 id=能具体说一下concurrenthashmap的实现><span class=hanchor arialabel=Anchor># </span>能具体说一下<strong>ConcurrentHashmap</strong>的实现</h1></a><ul><li>jdk1.7版本是基于 分段锁 实现，在jdk1.8是基于 CAS+synchronized 实现。</li></ul><a href=#17-分段锁><h2 id=17-分段锁><span class=hanchor arialabel=Anchor># </span>1.7 分段锁</h2></a><p>包含一个Segment数组，Segment继承于ReentrantLock，Segment则包含HashEntry的数组，HashEntry本</p><p>身就是一个链表的结构，具有保存key、value的能力能指向下一个节点的指针。</p><p>实际上就是<strong>相当于每个Segment都是一个HashMap，默认的Segment长度是16，也就</strong></p><p><strong>是支持16个线程的并发写</strong>，Segment之间相互不会受到影响。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-48.png width=auto alt></p><p><strong>put</strong>流程</p><p>整个流程和HashMap非常类似，只不过是先定位到具体的Segment，然后通过</p><p>ReentrantLock去操作而已，后面的流程，就和HashMap基本上是一样的。</p><ol><li><p>计算hash，定位到segment，segment如果是空就先初始化</p></li><li><p>使用ReentrantLock加锁，如果获取锁失败则尝试自旋，自旋超过次数就阻塞获</p></li></ol><p>取，保证一定获取锁成功</p><ol start=3><li>遍历HashEntry，就是和HashMap一样，数组中key和hash一样就直接替换，不存</li></ol><p>在就再插入链表，链表同样操作</p><p>get也很简单，key通过hash定位到segment，再遍历链表定位到具体的元素上，需要</p><p>注意的是value是volatile的，所以get是不需要加锁的</p><a href=#18-cassynchronized><h2 id=18-cassynchronized><span class=hanchor arialabel=Anchor># </span><strong>1.8 CAS+synchronized</strong></h2></a><p>它的数据结构和HashMap是一样的，数组+链表+红黑树。它实现线程安全的关键点在于put流程。</p><p><strong>Put 查询</strong></p><ul><li><p>首先计算hash，遍历node数组，如果node是空的话，就通过CAS+自旋的方式初始化</p></li><li><p>如果当前数组位置是空则直接通过CAS自旋写入数据</p></li><li><p>如果hash==MOVED，说明需要扩容，执行扩容</p></li><li><p>如果都不满足，就使用synchronized写入数据，写入数据同样判断链表、红黑 树，链表写入和HashMap的方式一样，key hash一样就覆盖，反之就尾插法，链表长度超过8就转换成红黑树</p></li></ul><p><img src=https://googoo-s.github.io//statistic/asynccode-53.png width=auto alt></p><a href=#concurrenthashmap-和-hashtable-的区别><h1 id=concurrenthashmap-和-hashtable-的区别><span class=hanchor arialabel=Anchor># </span>ConcurrentHashMap 和 Hashtable 的区别</h1></a><ul><li><p><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样**，数组+链表/红黑二叉树**。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p></li><li><p><strong>实现线程安全的方式（重要）：</strong></p><ul><li><p>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</p></li><li><p>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p></li><li><p><strong><code>Hashtable</code>****(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p></li></ul></li></ul><p>下面，我们再来看看两者底层数据结构的对比图。</p><a href=#hashtable><h2 id=hashtable><span class=hanchor arialabel=Anchor># </span>HashTable</h2></a><p><img src=https://googoo-s.github.io//statistic/asynccode-52.png width=auto alt></p><a href=#17-的concurrenthashmap><h2 id=17-的concurrenthashmap><span class=hanchor arialabel=Anchor># </span>1.7 的ConcurrentHashMap</h2></a><p><img src=https://googoo-s.github.io//statistic/asynccode-49.png width=auto alt></p><p><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。</p><p><code>Segment</code> 数组中的每个元素包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 数组属于链表结构。</p><a href=#18-的concurrenthashmap><h2 id=18-的concurrenthashmap><span class=hanchor arialabel=Anchor># </span><strong>1.8 的ConcurrentHashMap</strong></h2></a><p><strong>Node 数组 + 链表 / 红黑树</strong>。不过，Node 只能用于链表的情况，红黑树的情况需要使用 <strong><code>TreeNode</code></strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p><p><code>TreeNode</code>是存储红黑树节点，被<code>TreeBin</code>包装。<code>TreeBin</code>通过<code>root</code>属性维护红黑树的根结点，因为红黑树在旋转的时候，根结点可能会被它原来的子节点替换掉，在这个时间点**，如果有其他线程要写这棵红黑树就会发生线程不安全问题**，所以在 <code>ConcurrentHashMap</code> 中<code>TreeBin</code>通过<code>waiter</code>属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Go data-lang=Go><span class=line><span class=cl><span class=nx>static</span> <span class=nx>final</span> <span class=nx>class</span> <span class=nx>TreeBin</span><span class=p>&lt;</span><span class=nx>K</span><span class=p>,</span><span class=nx>V</span><span class=p>&gt;</span> <span class=nx>extends</span> <span class=nx>Node</span><span class=p>&lt;</span><span class=nx>K</span><span class=p>,</span><span class=nx>V</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>TreeNode</span><span class=p>&lt;</span><span class=nx>K</span><span class=p>,</span><span class=nx>V</span><span class=p>&gt;</span> <span class=nx>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nx>volatile</span> <span class=nx>TreeNode</span><span class=p>&lt;</span><span class=nx>K</span><span class=p>,</span><span class=nx>V</span><span class=p>&gt;</span> <span class=nx>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nx>volatile</span> <span class=nx>Thread</span> <span class=nx>waiter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nx>volatile</span> <span class=kt>int</span> <span class=nx>lockState</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// values for lockState
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>static</span> <span class=nx>final</span> <span class=kt>int</span> <span class=nx>WRITER</span> <span class=p>=</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// set while holding write lock
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>static</span> <span class=nx>final</span> <span class=kt>int</span> <span class=nx>WAITER</span> <span class=p>=</span> <span class=mi>2</span><span class=p>;</span> <span class=c1>// set when waiting for write lock
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>static</span> <span class=nx>final</span> <span class=kt>int</span> <span class=nx>READER</span> <span class=p>=</span> <span class=mi>4</span><span class=p>;</span> <span class=c1>// increment value for setting read lock
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://googoo-s.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by googoo-s using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://googoo-s.github.io/>Home</a></li><li><a href=https://github.com/googoo-s>GitHub</a></li></ul></footer></div></div></body></html>