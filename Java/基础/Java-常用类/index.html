<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Object Object 类的常见方法有哪些？ Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  /** * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。 */public final native Class<?"><meta property="og:title" content><meta property="og:description" content="Object Object 类的常见方法有哪些？ Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  /** * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。 */public final native Class<?"><meta property="og:type" content="website"><meta property="og:image" content="https://googoo-s.github.io/icon.png"><meta property="og:url" content="https://googoo-s.github.io/Java/%E5%9F%BA%E7%A1%80/Java-%E5%B8%B8%E7%94%A8%E7%B1%BB/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Object Object 类的常见方法有哪些？ Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  /** * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。 */public final native Class<?"><meta name=twitter:image content="https://googoo-s.github.io/icon.png"><title>googoo-s</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://googoo-s.github.io//icon.png><link href=https://googoo-s.github.io/styles.19109a40042e9f0e72e952fda4442a34.min.css rel=stylesheet><link href=https://googoo-s.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://googoo-s.github.io/js/darkmode.953af745b0f9342644d632fc167f3727.min.js></script>
<script src=https://googoo-s.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://googoo-s.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://googoo-s.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://googoo-s.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://googoo-s.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://googoo-s.github.io/",fetchData=Promise.all([fetch("https://googoo-s.github.io/indices/linkIndex.26897e4d1acf67c094aa607e8f2e6316.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://googoo-s.github.io/indices/contentIndex.1d89a6617ef2b03b3f0bc7e04109f3d7.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://googoo-s.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://googoo-s.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/googoo-s.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=googoo-s.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://googoo-s.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://googoo-s.github.io/>googoo-s</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Unknown</p><ul class=tags><li><a href=https://googoo-s.github.io/tags/Java/>Java</a></li><li><a href=https://googoo-s.github.io/tags/%E6%A0%87%E5%87%86%E5%BA%93/>标准库</a></li></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#object-类的常见方法有哪些>Object 类的常见方法有哪些？</a></li><li><a href=#-和-equals-的区别>== 和 equals() 的区别</a></li><li><a href=#hashcode-有什么用>hashCode() 有什么用？</a></li><li><a href=#为什么要有-hashcode>为什么要有 hashCode？</a></li><li><a href=#为什么重写-equals-时必须重写-hashcode-方法>为什么重写 equals() 时必须重写 hashCode() 方法？</a></li></ol><ol><li><a href=#string-是javaa基本数据类型吗可以被继承吗>String 是javaa基本数据类型吗？可以被继承吗？</a></li><li><a href=#stringstringbufferstringbuilder-的区别>String、StringBuffer、StringBuilder 的区别？</a></li><li><a href=#string-为什么是不可变的>String 为什么是不可变的?</a></li><li><a href=#字符串拼接用-还是-stringbuilder>字符串拼接用“+” 还是 StringBuilder?</a></li><li><a href=#string-str1--new-stringabc--和-string-str2-abc-的区别>String str1 = new String(&ldquo;abc&rdquo; ) 和 String str2 =&ldquo;abc&rdquo; 的区别</a></li><li><a href=#string-s--new-stringabc创建了几个对象>String s = new String(&ldquo;abc&rdquo;)创建了几个对象</a></li><li><a href=#stringequals-和-objectequals-有何区别>String#equals() 和 Object#equals() 有何区别？</a></li><li><a href=#字符串常量池的作用了解吗>字符串常量池的作用了解吗？</a></li><li><a href=#string-s1--new-stringabc这句话创建了几个字符串对象>String s1 = new String(&ldquo;abc&rdquo;);这句话创建了几个字符串对象？</a></li><li><a href=#intern-方法有什么作用>intern 方法有什么作用?</a></li><li><a href=#string-类型的变量和常量做运算时发生了什么>String 类型的变量和常量做“+”运算时发生了什么？</a></li><li><a href=#string-怎么转化成integer-原理>String 怎么转化成Integer ？原理？</a></li></ol></nav></details></aside><a href=#object><h1 id=object><span class=hanchor arialabel=Anchor># </span>Object</h1></a><a href=#object-类的常见方法有哪些><h2 id=object-类的常见方法有哪些><span class=hanchor arialabel=Anchor># </span>Object 类的常见方法有哪些？</h2></a><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=kd>public</span> <span class=kd>final</span> <span class=kd>native</span> <span class=n>Class</span><span class=o>&lt;?&gt;</span> <span class=n>getClass</span><span class=o>()</span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=kd>public</span> <span class=kd>native</span> <span class=kt>int</span> <span class=nf>hashCode</span><span class=o>()</span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>equals</span><span class=o>(</span><span class=n>Object</span> <span class=n>obj</span><span class=o>)</span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * naitive 方法，用于创建并返回当前对象的一份拷贝。
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=kd>protected</span> <span class=kd>native</span> <span class=n>Object</span> <span class=nf>clone</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>CloneNotSupportedException</span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=kd>public</span> <span class=n>String</span> <span class=nf>toString</span><span class=o>()</span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=kd>public</span> <span class=kd>final</span> <span class=kd>native</span> <span class=kt>void</span> <span class=nf>notify</span><span class=o>()</span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=kd>public</span> <span class=kd>final</span> <span class=kd>native</span> <span class=kt>void</span> <span class=nf>notifyAll</span><span class=o>()</span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=kd>public</span> <span class=kd>final</span> <span class=kd>native</span> <span class=kt>void</span> <span class=nf>wait</span><span class=o>(</span><span class=kt>long</span> <span class=n>timeout</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>InterruptedException</span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=kd>public</span> <span class=kd>final</span> <span class=kt>void</span> <span class=nf>wait</span><span class=o>(</span><span class=kt>long</span> <span class=n>timeout</span><span class=o>,</span> <span class=kt>int</span> <span class=n>nanos</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>InterruptedException</span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=kd>public</span> <span class=kd>final</span> <span class=kt>void</span> <span class=nf>wait</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>InterruptedException</span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 实例被垃圾回收器回收的时候触发的操作
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=kd>protected</span> <span class=kt>void</span> <span class=nf>finalize</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>Throwable</span> <span class=o>{</span> <span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p><img src=https://googoo-s.github.io//statistic/asynccode-5.png width=auto alt></p><a href=#-和-equals-的区别><h2 id=-和-equals-的区别><span class=hanchor arialabel=Anchor># </span>== 和 equals() 的区别</h2></a><p><strong>==</strong> 对于基本类型和引用类型的作用效果是不同的：</p><ul><li><p>对于基本数据类型来说，== 比较的是值。</p></li><li><p>对于引用数据类型来说，== 比较的是对象的内存地址。</p></li></ul><blockquote><p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p></blockquote><p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p><p><code>Object</code> 类 <code>equals()</code> 方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>equals</span><span class=o>(</span><span class=n>Object</span> <span class=n>obj</span><span class=o>)</span> <span class=o>{</span><span class=k>return</span> <span class=o>(</span><span class=k>this</span> <span class=o>==</span> <span class=n>obj</span><span class=o>);}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>equals()</code> 方法存在两种使用情况：</p><ul><li><p><strong>类没有重写</strong> **<code>equals()</code>**<strong>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</p></li><li><p><strong>类重写了</strong> **<code>equals()</code>**<strong>方法</strong> ：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</p></li></ul><p>举个例子（这里只是为了举例。实际上，你按照下面这种写法的话，像 IDEA 这种比较智能的 IDE 都会提示你将 <code>==</code> 换成 <code>equals()</code> ）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=n>String</span> <span class=n>a</span> <span class=o>=</span> <span class=k>new</span> <span class=n>String</span><span class=o>(</span><span class=s>&#34;ab&#34;</span><span class=o>);</span> <span class=c1>// a 为一个引用String b = new String(&#34;ab&#34;); // b为另一个引用,对象的内容一样String aa = &#34;ab&#34;; // 放在常量池中String bb = &#34;ab&#34;; // 从常量池中查找System.out.println(aa <mark> bb);// trueSystem.out.println(a </mark> b);// falseSystem.out.println(a.equals(b));// trueSystem.out.println(42 == 42.0);// true
</span></span></span></code></pre></td></tr></table></div></div><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p><p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p><p><code>String</code>类<code>equals()</code>方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>equals</span><span class=o>(</span><span class=n>Object</span> <span class=n>anObject</span><span class=o>)</span> <span class=o>{</span><span class=k>if</span> <span class=o>(</span><span class=k>this</span> <span class=o>==</span> <span class=n>anObject</span><span class=o>)</span> <span class=o>{</span><span class=k>return</span> <span class=kc>true</span><span class=o>;}</span><span class=k>if</span> <span class=o>(</span><span class=n>anObject</span> <span class=k>instanceof</span> <span class=n>String</span><span class=o>)</span> <span class=o>{</span><span class=n>String</span> <span class=n>anotherString</span> <span class=o>=</span> <span class=o>(</span><span class=n>String</span><span class=o>)</span><span class=n>anObject</span><span class=o>;</span><span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>value</span><span class=o>.</span><span class=na>length</span><span class=o>;</span><span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>==</span> <span class=n>anotherString</span><span class=o>.</span><span class=na>value</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>{</span><span class=kt>char</span> <span class=n>v1</span><span class=o>[]</span> <span class=o>=</span> <span class=n>value</span><span class=o>;</span><span class=kt>char</span> <span class=n>v2</span><span class=o>[]</span> <span class=o>=</span> <span class=n>anotherString</span><span class=o>.</span><span class=na>value</span><span class=o>;</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span><span class=k>while</span> <span class=o>(</span><span class=n>n</span><span class=o>--</span> <span class=o>!=</span> <span class=n>0</span><span class=o>)</span> <span class=o>{</span><span class=k>if</span> <span class=o>(</span><span class=n>v1</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>!=</span> <span class=n>v2</span><span class=o>[</span><span class=n>i</span><span class=o>])</span><span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=n>i</span><span class=o>++;}</span><span class=k>return</span> <span class=kc>true</span><span class=o>;}}</span><span class=k>return</span> <span class=kc>false</span><span class=o>;}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#hashcode-有什么用><h2 id=hashcode-有什么用><span class=hanchor arialabel=Anchor># </span>hashCode() 有什么用？</h2></a><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p><p><code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>native</span> <span class=kt>int</span> <span class=nf>hashCode</span><span class=o>();</span>
</span></span></code></pre></td></tr></table></div></div><p>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p><a href=#为什么要有-hashcode><h2 id=为什么要有-hashcode><span class=hanchor arialabel=Anchor># </span>为什么要有 hashCode？</h2></a><p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 <code>hashCode</code>？</p><p>下面这段内容摘自我的 Java 启蒙书《Head First Java》:</p><blockquote><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p></blockquote><p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p><p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong></p><p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HashSet</code>的过程）！</p><p>我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p><p><strong>那为什么不只提供</strong> <strong><code>hashCode()</code></strong> <strong>方法呢？</strong></p><p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p><p><strong>那为什么两个对象有相同的</strong> <strong><code>hashCode</code></strong> <strong>值，它们也不一定是相等的？</strong></p><p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p><p>总结下来就是 ：</p><ul><li><p>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</p></li><li><p>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</p></li><li><p>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</p></li></ul><p>相信大家看了我前面对 <code>hashCode()</code> 和 <code>equals()</code> 的介绍之后，下面这个问题已经难不倒你们了。</p><a href=#为什么重写-equals-时必须重写-hashcode-方法><h2 id=为什么重写-equals-时必须重写-hashcode-方法><span class=hanchor arialabel=Anchor># </span>为什么重写 equals() 时必须重写 hashCode() 方法？</h2></a><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p><strong>思考</strong> ：重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 可能会出现什么问题。</p><p><strong>总结</strong> ：</p><ul><li><p><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p></li><li><p>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</p></li></ul><p>更多关于 <code>hashCode()</code> 和 <code>equals()</code> 的内容可以查看：
<a href=https://www.cnblogs.com/skywang12345/p/3324958.html rel=noopener>Java hashCode() 和 equals()的若干问题解答open in new window</a></p><a href=#string><h1 id=string><span class=hanchor arialabel=Anchor># </span>String</h1></a><a href=#string-是javaa基本数据类型吗可以被继承吗><h2 id=string-是javaa基本数据类型吗可以被继承吗><span class=hanchor arialabel=Anchor># </span>String 是javaa基本数据类型吗？可以被继承吗？</h2></a><p>String 不是基本类型</p><p>String 使用final 修饰，是不可变类</p><a href=#stringstringbufferstringbuilder-的区别><h2 id=stringstringbufferstringbuilder-的区别><span class=hanchor arialabel=Anchor># </span>String、StringBuffer、StringBuilder 的区别？</h2></a><p><strong>可变性</strong></p><p><code>String</code> 是不可变的（后面会详细分析原因）。</p><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>abstract</span> <span class=kd>class</span> <span class=nc>AbstractStringBuilder</span> <span class=kd>implements</span> <span class=n>Appendable</span><span class=o>,</span> <span class=n>CharSequence</span> <span class=o>{</span><span class=kt>char</span><span class=o>[]</span> <span class=n>value</span><span class=o>;</span><span class=kd>public</span> <span class=n>AbstractStringBuilder</span> <span class=nf>append</span><span class=o>(</span><span class=n>String</span> <span class=n>str</span><span class=o>)</span> <span class=o>{</span><span class=k>if</span> <span class=o>(</span><span class=n>str</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span><span class=k>return</span> <span class=n>appendNull</span><span class=o>();</span><span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=n>str</span><span class=o>.</span><span class=na>length</span><span class=o>();</span><span class=n>ensureCapacityInternal</span><span class=o>(</span><span class=n>count</span> <span class=o>+</span> <span class=n>len</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>str</span><span class=o>.</span><span class=na>getChars</span><span class=o>(</span><span class=n>0</span><span class=o>,</span> <span class=n>len</span><span class=o>,</span> <span class=n>value</span><span class=o>,</span> <span class=n>count</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>count</span> <span class=o>+=</span> <span class=n>len</span><span class=o>;</span><span class=k>return</span> <span class=k>this</span><span class=o>;}</span><span class=c1>//...}
</span></span></span></code></pre></td></tr></table></div></div><p><strong>线程安全性</strong></p><p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能</strong></p><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><strong>对于三者使用的总结：</strong></p><ol><li><p><strong>操作少量的数据: 适用</strong> <strong><code>String</code></strong></p></li><li><p><strong>单线程操作字符串缓冲区下操作大量数据: 适用</strong> <strong><code>StringBuilder</code></strong></p></li><li><p><strong>多线程操作字符串缓冲区下操作大量数据: 适用</strong> <strong><code>StringBuffer</code></strong></p></li></ol><a href=#string-为什么是不可变的><h2 id=string-为什么是不可变的><span class=hanchor arialabel=Anchor># </span>String 为什么是不可变的?</h2></a><p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，<del>所以</del>~~<code>String</code>~~ <del>对象是不可变的。</del></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>final</span> <span class=kd>class</span> <span class=nc>String</span> <span class=kd>implements</span> <span class=n>java</span><span class=o>.</span><span class=na>io</span><span class=o>.</span><span class=na>Serializable</span><span class=o>,</span> <span class=n>Comparable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;,</span> <span class=n>CharSequence</span> <span class=o>{</span><span class=kd>private</span> <span class=kd>final</span> <span class=kt>char</span> <span class=n>value</span><span class=o>[];</span><span class=c1>//...}
</span></span></span></code></pre></td></tr></table></div></div><blockquote><p>🐛 修正 ： 我们知道被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）。</p><p><code>String</code> 真正不可变有下面几点原因：</p><ol><li><p>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</p></li><li><p><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</p></li></ol><p>相关阅读：
<a href=https://www.zhihu.com/question/20618891/answer/114125846 rel=noopener>如何理解 String 类型值的不可变？ - 知乎提问open in new window</a></p><p>补充（来自
<a href=https://github.com/Snailclimb/JavaGuide/issues/675 rel=noopener>issue 675open in new window</a>）：在 Java 9 之后，<code>String</code> 、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 <code>byte</code> 数组存储字符串。</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>public final class String implements java.io.Serializable,Comparable&lt;String&gt;, CharSequence {// @Stable 注解表示变量最多被修改一次，称为“稳定的”。@Stableprivate final byte[] value;}abstract class AbstractStringBuilder implements Appendable, CharSequence {byte[] value;}
</span></span></code></pre></td></tr></table></div></div><blockquote><p><strong>Java 9 为何要将</strong> <strong><code>String</code></strong> <strong>的底层实现由</strong> <strong><code>char[]</code></strong> <strong>改成了</strong> <strong><code>byte[]</code></strong> <strong>?</strong></p><p>新版的 String 其实支持两个编码方案： Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p><p>JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-2.png width=auto alt></p><p>如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，<code>byte</code> 和 <code>char</code> 所占用的空间是一样的。</p><p>这是官方的介绍：https://openjdk.java.net/jeps/254 。</p></blockquote><a href=#字符串拼接用-还是-stringbuilder><h2 id=字符串拼接用-还是-stringbuilder><span class=hanchor arialabel=Anchor># </span>字符串拼接用“+” 还是 StringBuilder?</h2></a><p>Java 语言本身并不支持运算符重载**，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。**</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=n>String</span> <span class=n>str1</span> <span class=o>=</span> <span class=s>&#34;he&#34;</span><span class=o>;</span><span class=n>String</span> <span class=n>str2</span> <span class=o>=</span> <span class=s>&#34;llo&#34;</span><span class=o>;</span><span class=n>String</span> <span class=n>str3</span> <span class=o>=</span> <span class=s>&#34;world&#34;</span><span class=o>;</span><span class=n>String</span> <span class=n>str4</span> <span class=o>=</span> <span class=n>str1</span> <span class=o>+</span> <span class=n>str2</span> <span class=o>+</span> <span class=n>str3</span><span class=o>;</span>
</span></span></code></pre></td></tr></table></div></div><p>上面的代码对应的字节码如下：</p><p><img src=https://googoo-s.github.io//statistic/asynccode-6.png width=auto alt></p><p>可以看出，字符串对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p><p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个</strong> <strong><code>StringBuilder</code></strong> <strong>以复用，会导致创建过多的</strong> <strong><code>StringBuilder</code></strong> <strong>对象</strong>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=n>String</span><span class=o>[]</span> <span class=n>arr</span> <span class=o>=</span> <span class=o>{</span><span class=s>&#34;he&#34;</span><span class=o>,</span> <span class=s>&#34;llo&#34;</span><span class=o>,</span> <span class=s>&#34;world&#34;</span><span class=o>};</span><span class=n>String</span> <span class=n>s</span> <span class=o>=</span> <span class=s>&#34;&#34;</span><span class=o>;</span><span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>arr</span><span class=o>.</span><span class=na>length</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>+=</span> <span class=n>arr</span><span class=o>[</span><span class=n>i</span><span class=o>];}</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>s</span><span class=o>);</span>
</span></span></code></pre></td></tr></table></div></div><p><code>StringBuilder</code> 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 <code>StringBuilder</code> 对象。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-4.png width=auto alt></p><p>如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=n>String</span><span class=o>[]</span> <span class=n>arr</span> <span class=o>=</span> <span class=o>{</span><span class=s>&#34;he&#34;</span><span class=o>,</span> <span class=s>&#34;llo&#34;</span><span class=o>,</span> <span class=s>&#34;world&#34;</span><span class=o>};</span><span class=n>StringBuilder</span> <span class=n>s</span> <span class=o>=</span> <span class=k>new</span> <span class=n>StringBuilder</span><span class=o>();</span><span class=k>for</span> <span class=o>(</span><span class=n>String</span> <span class=n>value</span> <span class=o>:</span> <span class=n>arr</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=o>.</span><span class=na>append</span><span class=o>(</span><span class=n>value</span><span class=o>);}</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>s</span><span class=o>);</span>
</span></span></code></pre></td></tr></table></div></div><p><img src=https://googoo-s.github.io//statistic/asynccode-3.png width=auto alt></p><p>如果你使用 IDEA 的话，IDEA 自带的代码检查机制也会提示你修改代码。</p><a href=#string-str1--new-stringabc--和-string-str2-abc-的区别><h2 id=string-str1--new-stringabc--和-string-str2-abc-的区别><span class=hanchor arialabel=Anchor># </span>String str1 = new String(&ldquo;abc&rdquo; ) 和 String str2 =&ldquo;abc&rdquo; 的区别</h2></a><p>相同：两个语句都会去字符串常量池中检查是否已经存在 “abc”，如果有则直接使用，如果没有则会在常量池中创建 “abc” 对象。</p><p>不同： String str1 = new String(&ldquo;abc&rdquo;) 还会通过 new String() 在堆里创建一个 &ldquo;abc&rdquo; 字符串对象实例。所以后者可以理解为被前者包含</p><p><img src=https://googoo-s.github.io//statistic/asynccode-4.png width=auto alt></p><a href=#string-s--new-stringabc创建了几个对象><h2 id=string-s--new-stringabc创建了几个对象><span class=hanchor arialabel=Anchor># </span>String s = new String(&ldquo;abc&rdquo;)创建了几个对象</h2></a><p>一个或者两个</p><p>如果字符串常量池已经有“abc”，则是一个；否则，两个。 当字符创常量池没有 “abc”</p><ul><li><p>一个是字符串字面量 &ldquo;abc&rdquo; 所对应的、字符串常量池中的实例</p></li><li><p>另一个是通过 new String() 创建并初始化的，内容与"abc"相同的实例，在堆中。</p></li></ul><a href=#stringequals-和-objectequals-有何区别><h2 id=stringequals-和-objectequals-有何区别><span class=hanchor arialabel=Anchor># </span>String#equals() 和 Object#equals() 有何区别？</h2></a><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 String 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</p><a href=#字符串常量池的作用了解吗><h2 id=字符串常量池的作用了解吗><span class=hanchor arialabel=Anchor># </span>字符串常量池的作用了解吗？</h2></a><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=c1>// 在堆中创建字符串对象”ab“
</span></span></span><span class=line><span class=cl><span class=c1>// 将字符串对象”ab“的引用保存在字符串常量池中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>String</span> <span class=n>aa</span> <span class=o>=</span> <span class=s>&#34;ab&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 直接返回字符串常量池中字符串对象”ab“的引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>String</span> <span class=n>bb</span> <span class=o>=</span> <span class=s>&#34;ab&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>aa</span><span class=o>==</span><span class=n>bb</span><span class=o>);</span><span class=c1>// true
</span></span></span></code></pre></td></tr></table></div></div><p>更多关于字符串常量池的介绍可以看一下
<a href=https://javaguide.cn/java/jvm/memory-area.html rel=noopener>Java 内存区域详解open in new window</a> 这篇文章。</p><a href=#string-s1--new-stringabc这句话创建了几个字符串对象><h2 id=string-s1--new-stringabc这句话创建了几个字符串对象><span class=hanchor arialabel=Anchor># </span>String s1 = new String(&ldquo;abc&rdquo;);这句话创建了几个字符串对象？</h2></a><p>会创建 1 或 2 个字符串对象。</p><p>1、如果字符串常量池中不存在字符串对象“abc”的引用，那么会在堆中创建 2 个字符串对象“abc”。</p><p>示例代码（JDK 1.8）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=n>String</span> <span class=n>s1</span> <span class=o>=</span> <span class=k>new</span> <span class=n>String</span><span class=o>(</span><span class=s>&#34;abc&#34;</span><span class=o>);</span>
</span></span></code></pre></td></tr></table></div></div><p>对应的字节码：</p><p><img src=https://googoo-s.github.io//statistic/asynccode-4.png width=auto alt></p><p><code>ldc</code> 命令用于判断字符串常量池中是否保存了对应的字符串对象的引用，如果保存了的话直接返回，如果没有保存的话，会在堆中创建对应的字符串对象并将该字符串对象的引用保存到字符串常量池中。</p><p>2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p><p>示例代码（JDK 1.8）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=c1>// 字符串常量池中已存在字符串对象“abc”的引用String s1 = &#34;abc&#34;;// 下面这段代码只会在堆中创建 1 个字符串对象“abc”String s2 = new String(&#34;abc&#34;);
</span></span></span></code></pre></td></tr></table></div></div><p>对应的字节码：</p><p><img src=https://googoo-s.github.io//statistic/asynccode-4.png width=auto alt></p><p>这里就不对上面的字节码进行详细注释了，7 这个位置的 <code>ldc</code> 命令不会在堆中创建新的字符串对象“abc”，这是因为 0 这个位置已经执行了一次 <code>ldc</code> 命令，已经在堆中创建过一次字符串对象“abc”了。7 这个位置执行 <code>ldc</code> 命令会直接返回字符串常量池中字符串对象“abc”对应的引用。</p><a href=#intern-方法有什么作用><h2 id=intern-方法有什么作用><span class=hanchor arialabel=Anchor># </span>intern 方法有什么作用?</h2></a><p><code>String.intern()</code> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p><ul><li><p>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</p></li><li><p>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</p></li></ul><p>示例代码（JDK 1.8） :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=c1>// 在堆中创建字符串对象”Java“
</span></span></span><span class=line><span class=cl><span class=c1>// 将字符串对象”Java“的引用保存在字符串常量池中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>String</span> <span class=n>s1</span> <span class=o>=</span> <span class=s>&#34;Java&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 直接返回字符串常量池中字符串对象”Java“对应的引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>String</span> <span class=n>s2</span> <span class=o>=</span> <span class=n>s1</span><span class=o>.</span><span class=na>intern</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=c1>// 会在堆中在单独创建一个字符串对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>String</span> <span class=n>s3</span> <span class=o>=</span> <span class=k>new</span> <span class=n>String</span><span class=o>(</span><span class=s>&#34;Java&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 直接返回字符串常量池中字符串对象”Java“对应的引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>String</span> <span class=n>s4</span> <span class=o>=</span> <span class=n>s3</span><span class=o>.</span><span class=na>intern</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=c1>// s1 和 s2 指向的是堆中的同一个对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>s1</span> <span class=o>==</span> <span class=n>s2</span><span class=o>);</span> <span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1>// s3 和 s4 指向的是堆中不同的对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>s3</span> <span class=o>==</span> <span class=n>s4</span><span class=o>);</span> <span class=c1>// false
</span></span></span><span class=line><span class=cl><span class=c1>// s1 和 s4 指向的是堆中的同一个对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>s1</span> <span class=o>==</span> <span class=n>s4</span><span class=o>);</span> <span class=c1>//true
</span></span></span></code></pre></td></tr></table></div></div><a href=#string-类型的变量和常量做运算时发生了什么><h2 id=string-类型的变量和常量做运算时发生了什么><span class=hanchor arialabel=Anchor># </span>String 类型的变量和常量做“+”运算时发生了什么？</h2></a><p>先来看字符串不加 <code>final</code> 关键字拼接的情况（JDK1.8）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=n>String</span> <span class=n>str1</span> <span class=o>=</span> <span class=s>&#34;str&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=n>String</span> <span class=n>str2</span> <span class=o>=</span> <span class=s>&#34;ing&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=n>String</span> <span class=n>str3</span> <span class=o>=</span> <span class=s>&#34;str&#34;</span> <span class=o>+</span> <span class=s>&#34;ing&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=n>String</span> <span class=n>str4</span> <span class=o>=</span> <span class=n>str1</span> <span class=o>+</span> <span class=n>str2</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=n>String</span> <span class=n>str5</span> <span class=o>=</span> <span class=s>&#34;string&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>str3</span> <span class=o>==</span> <span class=n>str4</span><span class=o>);</span><span class=c1>//false
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>str3</span> <span class=o>==</span> <span class=n>str5</span><span class=o>);</span><span class=c1>//true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>str4</span> <span class=o>==</span> <span class=n>str5</span><span class=o>);</span><span class=c1>//false
</span></span></span></code></pre></td></tr></table></div></div><blockquote><p><strong>注意</strong> ：比较 String 字符串的值是否相等，可以使用 <code>equals()</code> 方法。 <code>String</code> 中的 <code>equals</code> 方法是被重写过的。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是字符串的值是否相等。如果你使用 <code>==</code> 比较两个字符串是否相等的话，IDEA 还是提示你使用 <code>equals()</code> 方法替换。</p></blockquote><p><img src=https://googoo-s.github.io//statistic/asynccode-7.png width=auto alt></p><p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p><p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。《深入理解 Java 虚拟机》中是也有介绍到：</p><p><a class="internal-link broken">Pasted image 20230726233943.png</a></p><p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p><p><strong>对于</strong> <strong><code>String str3 = "str" + "ing";</code></strong> <strong>编译器会给你优化成</strong> <strong><code>String str3 = "string";</code></strong> 。</p><p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p><ul><li><p>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串常量。</p></li><li><p><code>final</code> 修饰的基本数据类型和字符串变量</p></li><li><p>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&#171;、&#187;、&#187;> ）</p></li></ul><p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p><p><strong>对象引用和“+”的字符串拼接方式，实际上是通过</strong> <strong><code>StringBuilder</code></strong> <strong>调用</strong> <strong><code>append()</code></strong> <strong>方法实现的，拼接完成之后调用</strong> <strong><code>toString()</code></strong> <strong>得到一个</strong> <strong><code>String</code></strong> <strong>对象</strong> 。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=n>String</span> <span class=n>str4</span> <span class=o>=</span> <span class=k>new</span> <span class=n>StringBuilder</span><span class=o>().</span><span class=na>append</span><span class=o>(</span><span class=n>str1</span><span class=o>).</span><span class=na>append</span><span class=o>(</span><span class=n>str2</span><span class=o>).</span><span class=na>toString</span><span class=o>();</span>
</span></span></code></pre></td></tr></table></div></div><p>我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code>。</p><p>不过，字符串使用 <code>final</code> 关键字声明之后，可以让编译器当做常量来处理。</p><p>示例代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>final</span> <span class=n>String</span> <span class=n>str1</span> <span class=o>=</span> <span class=s>&#34;str&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>final</span> <span class=n>String</span> <span class=n>str2</span> <span class=o>=</span> <span class=s>&#34;ing&#34;</span><span class=o>;</span><span class=c1>// 下面两个表达式其实是等价的String c = &#34;str&#34; + &#34;ing&#34;;// 常量池中的对象String d = str1 + str2; // 常量池中的对象System.out.println(c == d);// true
</span></span></span></code></pre></td></tr></table></div></div><p>被 <code>final</code> 关键字修改之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</p><p>如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。</p><p>示例代码（<code>str2</code> 在运行时才能确定其值）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>final</span> <span class=n>String</span> <span class=n>str1</span> <span class=o>=</span> <span class=s>&#34;str&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>final</span> <span class=n>String</span> <span class=n>str2</span> <span class=o>=</span> <span class=n>getStr</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=n>String</span> <span class=n>c</span> <span class=o>=</span> <span class=s>&#34;str&#34;</span> <span class=o>+</span> <span class=s>&#34;ing&#34;</span><span class=o>;</span><span class=c1>// 常量池中的对象String d = str1 + str2; // 在堆上创建的新的对象System.out.println(c == d);// falsepublic static String getStr() {return &#34;ing&#34;;}
</span></span></span></code></pre></td></tr></table></div></div><a href=#string-怎么转化成integer-原理><h2 id=string-怎么转化成integer-原理><span class=hanchor arialabel=Anchor># </span>String 怎么转化成Integer ？原理？</h2></a><ul><li><p>Integer.parseInt(String s)</p></li><li><p>Integer.valueOf(String s)</p></li></ul><p>不管哪一种，最终还是会调用<strong>Integer类内中的 parseInt(String s, int radix) 方法</strong>。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-8.png width=auto alt></p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://googoo-s.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by googoo-s using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://googoo-s.github.io/>Home</a></li><li><a href=https://github.com/googoo-s>GitHub</a></li></ul></footer></div></div></body></html>