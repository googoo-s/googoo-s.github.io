{"/":{"title":"_index","content":"\n# 分类\n\n\n[[大数据和数仓/☆大数据和数仓|☆大数据和数仓]]\n\n[[消息队列/☆消息队列|☆消息队列]]\n\n[[lua/★lua|★lua]]\n\n[[Redis/★Redis|★Redis]]\n\n[[obsidian/★Obsidian|★Obsidian]]\n\n[[maven/★Maven|★Maven]]\n\n\n\n\n\n\n```dataview\ntable file.path  from \"/\" sort file.path\n```","lastmodified":"2023-07-31T07:39:55.998212337Z","tags":["/"]},"/MySQL/%E5%AE%9E%E8%B7%B5/8.%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E6%98%BE%E7%A4%BA%E9%9A%8F%E6%9C%BA%E6%B6%88%E6%81%AF":{"title":"8.如何正确显示随机消息","content":"英语学习 App 首页有一个随机显示单词的功能，也就是根据每个用户的级别有一个单词表，然后这个用户每次访问首页的时候，都会随机滚动显示三个单词。他们发现随着单词表变大，选单词这个逻辑变得越来越慢，甚至影响到了首页的打开速度。\n\n```Go\n\nmysql\u003e CREATE TABLE `words` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `word` varchar(64) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB;\n\ndelimiter ;;\ncreate procedure idata()\nbegin\n  declare i int;\n  set i=0;\n  while i\u003c10000 do\n    insert into words(word) values(concat(char(97+(i div 1000)), char(97+(i % 1000 div 100)), char(97+(i % 100 div 10)), char(97+(i % 10))));\n    set i=i+1;\n  end while;\nend;;\ndelimiter ;\n\ncall idata();\n```\n\n接下来，我们就一起看看要随机选择 3 个单词，有什么方法实现，存在什么问题以及如何改进\n\n# 内存临时表\n\n首先，你会想到用 order by rand() 来实现这个逻辑\n\n```Go\n\nmysql\u003e select word from words order by rand() limit 3;\n```\n\n**对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘。**优化器没有了这一层顾虑，那么它会优先考虑的，就是用于排序的行越小越好了，所以，MySQL 这时就会选择 rowid 排序。\n\n  \n\n这条语句的执行流程是这样的\n\n1. 创建一个临时表。这个临时表使用的是 memory 引擎，表里有两个字段，第一个字段是 double 类型，为了后面描述方便，记为字段 R，第二个字段是 varchar(64) 类型，记为字段 W。并且，这个表没有建索引。\n    \n2. 从 words 表中，按主键顺序取出所有的 word 值。对于每一个 word 值，调用 rand() 函数生成一个大于 0 小于 1 的随机小数，并把这个随机小数和 word 分别存入临时表的 R 和 W 字段中，到此，扫描行数是 10000。\n    \n3. 现在临时表有 10000 行数据了，接下来你要在这个没有索引的内存临时表上，按照字段 R 排序。\n    \n4. 初始化 sort_buffer。sort_buffer 中有两个字段，一个是 double 类型，另一个是整型。\n    \n5. **从内存临时表中一行一行地取出 R 值和位置信息（我后面会和你解释这里为什么是“位置信息”），分别存入 sort_buffer 中的两个字段里**。**这个过程要对内存临时表做全表扫描，此时扫描行数增加 10000，变成了 20000**。\n    \n6. 在 sort_buffer 中根据 R 的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。（**rowid 排序方法，I**nnoDB 会自己生成一个长度为 6 字节的 rowid 来作为主键）\n    \n7. 排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出 word 值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了 20003。\n    \n\n  \n\n![](statistic/asynccode-382.png)\n\n  \n\n  \n\n**order by rand() 使用了内存临时表，内存临时表排序的时候使用了 rowid 排序方法。**\n\n# 磁盘临时表\n\n  \n\ntmp_table_size 这个配置限制了内存临时表的大小，默认值是 16M。**如果临时表大小超过了 tmp_table_size，那么内存临时表就会转成磁盘临时表。**\n\n  \n\n磁盘临时表使用的引擎默认是 InnoDB，是由参数 internal_tmp_disk_storage_engine 控制的。\n\n  \n\n当使用磁盘临时表的时候，对应的就是一个没有显式索引的 InnoDB 表的排序过程\n\n  \n\n这个 SQL 语句的排序确实没有用到临时文件，采用是 MySQL 5.6 版本引入的一个新的排序算法，即：**优先队列排序算法**\n\n  \n\n优先队列算法，就可以精确地只得到三个最小值，执行流程如下\n\n1. 对于这 10000 个准备排序的 (R,rowid)，先取前三行，构造成一个堆\n    \n2. 取下一个行 (R’,rowid’)，跟当前堆里面最大的 R 比较，如果 R’小于 R，把这个 (R,rowid) 从堆中去掉，换成 (R’,rowid’)；\n    \n3. 重复第 2 步，直到第 10000 个 (R’,rowid’) 完成比较。\n    \n\n  \n\n![](statistic/asynccode-383.png)\n\n  \n\n# 总结\n\n如果你直接使用 **order by rand()**，这个语句需要 **Using temporary 和 Using filesort**，查询的执行代价往往是比较大的。所以，在设计的时候你要尽量避开这种写法","lastmodified":"2023-07-31T07:39:55.994212278Z","tags":[]}}