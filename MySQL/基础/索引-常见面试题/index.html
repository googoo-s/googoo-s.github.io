<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="什么是索引 那换到数据库中，索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。
索引的分类。 我们可以按照四个角度来分类索引。
  按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。
  按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。
  按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。
  按「字段个数」分类：单列索引、联合索引。
  接下来，按照这些角度来说说各类索引的特点
按数据结构分类 每一种存储引擎支持的索引类型不一定相同，我在表中总结了 MySQL 常见的存储引擎 InnoDB、MyISAM 和 Memory 分别支持的索引类型。"><meta property="og:title" content><meta property="og:description" content="什么是索引 那换到数据库中，索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。
索引的分类。 我们可以按照四个角度来分类索引。
  按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。
  按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。
  按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。
  按「字段个数」分类：单列索引、联合索引。
  接下来，按照这些角度来说说各类索引的特点
按数据结构分类 每一种存储引擎支持的索引类型不一定相同，我在表中总结了 MySQL 常见的存储引擎 InnoDB、MyISAM 和 Memory 分别支持的索引类型。"><meta property="og:type" content="website"><meta property="og:image" content="https://googoo-s.github.io/icon.png"><meta property="og:url" content="https://googoo-s.github.io/MySQL/%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="什么是索引 那换到数据库中，索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。
索引的分类。 我们可以按照四个角度来分类索引。
  按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。
  按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。
  按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。
  按「字段个数」分类：单列索引、联合索引。
  接下来，按照这些角度来说说各类索引的特点
按数据结构分类 每一种存储引擎支持的索引类型不一定相同，我在表中总结了 MySQL 常见的存储引擎 InnoDB、MyISAM 和 Memory 分别支持的索引类型。"><meta name=twitter:image content="https://googoo-s.github.io/icon.png"><title>googoo-s</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://googoo-s.github.io//icon.png><link href=https://googoo-s.github.io/styles.19109a40042e9f0e72e952fda4442a34.min.css rel=stylesheet><link href=https://googoo-s.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://googoo-s.github.io/js/darkmode.953af745b0f9342644d632fc167f3727.min.js></script>
<script src=https://googoo-s.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://googoo-s.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://googoo-s.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://googoo-s.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://googoo-s.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://googoo-s.github.io/",fetchData=Promise.all([fetch("https://googoo-s.github.io/indices/linkIndex.26897e4d1acf67c094aa607e8f2e6316.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://googoo-s.github.io/indices/contentIndex.7ccf062caa0fa22fe68c424684cb355a.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://googoo-s.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://googoo-s.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/googoo-s.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=googoo-s.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://googoo-s.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://googoo-s.github.io/>googoo-s</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Unknown
<a href=/MySQL/%e5%9f%ba%e7%a1%80/%e7%b4%a2%e5%bc%95-%e5%b8%b8%e8%a7%81%e9%9d%a2%e8%af%95%e9%a2%98.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#按数据结构分类>按数据结构分类</a><ol><li><a href=#通过主键查询商品数据的过程>通过主键查询商品数据的过程</a></li><li><a href=#通过二级索引查询商品数据的过程>通过二级索引查询商品数据的过程</a></li><li><a href=#为什么-mysql-innodb-选择-btree-作为索引的数据结构>为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？</a></li></ol></li><li><a href=#按物理存储分类>按物理存储分类</a></li><li><a href=#按字段特性分类>按字段特性分类</a><ol><li></li></ol></li><li><a href=#按字段个数分类>按字段个数分类</a><ol><li><a href=#联合索引>联合索引</a></li></ol></li></ol><ol><li><a href=#什么时候适用索引>什么时候适用索引？</a></li><li><a href=#什么时候不需要创建索引>什么时候不需要创建索引？</a></li></ol><ol><li><a href=#前缀索引优化>前缀索引优化</a></li><li><a href=#覆盖索引优化>覆盖索引优化</a></li><li><a href=#主键索引最好是自增的>主键索引最好是自增的</a></li><li><a href=#防止索引失效>防止索引失效</a></li></ol><ol><li><a href=#执行计划参数>执行计划参数</a></li><li><a href=#type-字段>type 字段</a></li><li><a href=#extra字段>extra字段</a></li></ol></nav></details></aside><a href=#什么是索引><h1 id=什么是索引><span class=hanchor arialabel=Anchor># </span>什么是索引</h1></a><p>那换到数据库中，索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就<strong>是索引是数据的目录</strong>。</p><a href=#索引的分类><h1 id=索引的分类><span class=hanchor arialabel=Anchor># </span>索引的分类。</h1></a><p>我们可以按照四个角度来分类索引。</p><ul><li><p>按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。</p></li><li><p>按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。</p></li><li><p>按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。</p></li><li><p>按「字段个数」分类：单列索引、联合索引。</p></li></ul><p>接下来，按照这些角度来说说各类索引的特点</p><a href=#按数据结构分类><h2 id=按数据结构分类><span class=hanchor arialabel=Anchor># </span>按数据结构分类</h2></a><p>每一种存储引擎支持的索引类型不一定相同，我在表中总结了 MySQL 常见的存储引擎 InnoDB、MyISAM 和 Memory 分别支持的索引类型。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-254.png width=auto alt></p><p>InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。</p><p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p><ul><li><p>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</p></li><li><p>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</p></li><li><p>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</p></li></ul><p>其它索引都属于辅助索引（Secondary Index），也被称为<strong>二级索引或非聚簇索引</strong>。创建的主键索引和二级索引默认使用的是 B+Tree 索引。</p><p>B+Tree 是一种多叉树，<strong>叶子节点才存放数据，非叶子节点只存放索引</strong>，而且每个节点里的数据是按主键顺序存放的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点<strong>中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。</strong></p><a href=#通过主键查询商品数据的过程><h3 id=通过主键查询商品数据的过程><span class=hanchor arialabel=Anchor># </span>通过主键查询商品数据的过程</h3></a><p>比如，我们执行了下面这条查询语句：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-SQL data-lang=SQL><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>product</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>id</span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这条语句使用了主键索引查询 id 号为 5 的商品。查询过程是这样的，B+Tree 会自顶向下逐层进行查找：</p><ul><li><p>将 5 与根节点的索引数据 (1，10，20) 比较，5 在 1 和 10 之间，所以根据 B+Tree的搜索逻辑，找到第二层的索引数据 (1，4，7)；</p></li><li><p>在第二层的索引数据 (1，4，7)中进行查找，因为 5 在 4 和 7 之间，所以找到第三层的索引数据（4，5，6）；</p></li><li><p>在叶子节点的索引数据（4，5，6）中进行查找，然后我们找到了索引值为 5 的行数据。</p></li></ul><p>数据库的索引和数据都是存储在硬盘的，我们可以把读取一个节点当作一次磁盘 I/O 操作。那么上面的整个查询过程一共经历了 3 个节点，也就是进行了 3 次 I/O 操作。</p><p>B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，<strong>因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。</strong></p><a href=#通过二级索引查询商品数据的过程><h3 id=通过二级索引查询商品数据的过程><span class=hanchor arialabel=Anchor># </span>通过二级索引查询商品数据的过程</h3></a><p>主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：</p><ul><li><p>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</p></li><li><p>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</p></li></ul><p>我这里将前面的商品表中的 product_no （商品编码）字段设置为二级索引，那么二级索引的 B+Tree 如下图（图中叶子节点之间我画了单向链表，但是实际上是双向链表，原图我找不到了，修改不了，偷个懒我不重画了，大家脑补成双向链表就行）。</p><p>其中非叶子的 key 值是 product_no（图中橙色部分），叶子节点存储的数据是主键值（图中绿色部分）。</p><p>如果我用 product_no 二级索引查询商品，如下查询语句：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-SQL data-lang=SQL><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>product</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>product_no</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;0002&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>会先检二级索引中的 B+Tree 的索引值（商品编码，product_no），找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。这<strong>个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据</strong>。如下图（图中叶子节点之间我画了单向链表，但是实际上是双向链表，原图我找不到了，修改不了，偷个懒我不重画了，大家脑补成双向链表就行）：</p><p><img src=https://googoo-s.github.io//statistic/asynccode-258.png width=auto alt></p><p>不过，当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查，比如下面这条查询语句：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-SQL data-lang=SQL><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>product</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>product_no</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;0002&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这种在二级索引的 B+Tree 就能查询到结果的过程就叫作「<strong>覆盖索引」</strong>，也就是只需要查一个 B+Tree 就能找到数据。</p><p>这种在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据。</p><a href=#为什么-mysql-innodb-选择-btree-作为索引的数据结构><h3 id=为什么-mysql-innodb-选择-btree-作为索引的数据结构><span class=hanchor arialabel=Anchor># </span>为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？</h3></a><p>前面已经讲了 B+Tree 的索引原理，现在就来回答一下 B+Tree 相比于 B 树、二叉树或 Hash 索引结构的优势在哪儿？</p><p>之前我也专门写过一篇文章，想详细了解的可以看这篇：「
<a href=https://mp.weixin.qq.com/s/w1ZFOug8-Sa7ThtMnlaUtQ rel=noopener>女朋友问我：为什么 MySQL 喜欢 B+ 树？我笑着画了 20 张图 (opens new window)</a>」，这里就简单做个比对。</p><p><em>1、B+Tree vs B Tree</em></p><p>B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。</p><p>另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</p><p><em>2、B+Tree vs 二叉树</em></p><p>对于有 N 个叶子节点的 B+Tree，其搜索复杂度为<code>O(logdN)</code>，其中 d 表示节点允许的最大子节点个数为 d 个。</p><p>在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据。</p><p>而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 <code>O(logN)</code>，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。</p><p><em>3、B+Tree vs Hash</em></p><p>Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。</p><p>但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因</p><a href=#按物理存储分类><h2 id=按物理存储分类><span class=hanchor arialabel=Anchor># </span>按物理存储分类</h2></a><p>从物理存储的角度来看，索引分为<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</p><p>这两个区别在前面也提到了：</p><ul><li><p>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</p></li><li><p>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</p></li></ul><p>所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是覆盖索引。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是回表。</p><a href=#按字段特性分类><h2 id=按字段特性分类><span class=hanchor arialabel=Anchor># </span>按字段特性分类</h2></a><p>从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。</p><a href=#主键索引><h4 id=主键索引><span class=hanchor arialabel=Anchor># </span>主键索引</h4></a><p>主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。</p><p>在创建表时，创建主键索引的方式如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-SQL data-lang=SQL><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=k>table_name</span><span class=w>  </span><span class=p>(....</span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=n>index_column_1</span><span class=p>)</span><span class=w> </span><span class=k>USING</span><span class=w> </span><span class=n>BTREE</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><a href=#唯一索引><h4 id=唯一索引><span class=hanchor arialabel=Anchor># </span>唯一索引</h4></a><p>唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。</p><p>在创建表时，创建唯一索引的方式如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-SQL data-lang=SQL><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=k>table_name</span><span class=w>  </span><span class=p>(....</span><span class=k>UNIQUE</span><span class=w> </span><span class=k>KEY</span><span class=p>(</span><span class=n>index_column_1</span><span class=p>,</span><span class=n>index_column_2</span><span class=p>,...)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>建表后，如果要创建唯一索引，可以使用这面这条命令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-SQL data-lang=SQL><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>UNIQUE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>index_name</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ON</span><span class=w> </span><span class=k>table_name</span><span class=p>(</span><span class=n>index_column_1</span><span class=p>,</span><span class=n>index_column_2</span><span class=p>,...);</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><a href=#普通索引><h4 id=普通索引><span class=hanchor arialabel=Anchor># </span>普通索引</h4></a><p>普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。</p><p>在创建表时，创建普通索引的方式如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-SQL data-lang=SQL><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=k>table_name</span><span class=w>  </span><span class=p>(....</span><span class=k>INDEX</span><span class=p>(</span><span class=n>index_column_1</span><span class=p>,</span><span class=n>index_column_2</span><span class=p>,...)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>建表后，如果要创建普通索引，可以使用这面这条命令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-SQL data-lang=SQL><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>index_name</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ON</span><span class=w> </span><span class=k>table_name</span><span class=p>(</span><span class=n>index_column_1</span><span class=p>,</span><span class=n>index_column_2</span><span class=p>,...);</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><a href=#前缀索引><h4 id=前缀索引><span class=hanchor arialabel=Anchor># </span>前缀索引</h4></a><p>前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。</p><p>使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</p><p>在创建表时，创建前缀索引的方式如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-SQL data-lang=SQL><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=k>table_name</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>column_list</span><span class=p>,</span><span class=k>INDEX</span><span class=p>(</span><span class=k>column_name</span><span class=p>(</span><span class=k>length</span><span class=p>)));</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><p>建表后，如果要创建前缀索引，可以使用这面这条命令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-SQL data-lang=SQL><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>index_name</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ON</span><span class=w> </span><span class=k>table_name</span><span class=p>(</span><span class=k>column_name</span><span class=p>(</span><span class=k>length</span><span class=p>));</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><a href=#按字段个数分类><h2 id=按字段个数分类><span class=hanchor arialabel=Anchor># </span>按字段个数分类</h2></a><p>从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。</p><ul><li><p>建立在单列上的索引称为单列索引，比如主键索引；</p></li><li><p>建立在多列上的索引称为联合索引；</p></li></ul><a href=#联合索引><h3 id=联合索引><span class=hanchor arialabel=Anchor># </span>联合索引</h3></a><p>通过将<strong>多个字段组合成一个索引，该索引就被称为联合索引</strong>。</p><p>比如，将商品表中的 product_no 和 name 字段组合成联合索引<code>(product_no, name)</code>，创建联合索引的方式如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-SQL data-lang=SQL><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>index_product_no_name</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>product</span><span class=p>(</span><span class=n>product_no</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>联合索引<code>(product_no, name)</code> 的 B+Tree 示意图如下（图中叶子节点之间我画了单向链表，但是实际上是双向链表，原图我找不到了，修改不了，偷个懒我不重画了，大家脑补成双向链表就行）。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-257.png width=auto alt></p><p>可以看到，联合索引的非叶子节点用两个字段的值作为 B+Tree 的 key 值。当在联合索引查询数据时，先按 product_no 字段比较，在 product_no 相同的情况下再按 name 字段比较。</p><p>也就是说，<strong>联合索引查询的 B+Tree 是先按 product_no 进行排序，然后再 product_no 相同的情况再按 name 字段排序。</strong></p><p>因此，<strong>使用联合索引时，存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。<strong>在使用联合索引进行查询的时候，如果</strong>不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性</strong>了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-SQL data-lang=SQL><span class=line><span class=cl><span class=err>如果创建了一个</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=k>c</span><span class=p>)</span><span class=w> </span><span class=err>联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w> </span><span class=n>a</span><span class=o>=</span><span class=mi>1</span><span class=err>；</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w> </span><span class=n>a</span><span class=o>=</span><span class=mi>1</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>b</span><span class=o>=</span><span class=mi>2</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=k>c</span><span class=o>=</span><span class=mi>3</span><span class=err>；</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w> </span><span class=n>a</span><span class=o>=</span><span class=mi>1</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>b</span><span class=o>=</span><span class=mi>2</span><span class=err>；</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>需要注意的是，因为有查询优化器，所以</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=err>字段在</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=err>子句的顺序并不重要。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w> </span><span class=n>b</span><span class=o>=</span><span class=mi>2</span><span class=err>；</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w> </span><span class=k>c</span><span class=o>=</span><span class=mi>3</span><span class=err>；</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w> </span><span class=n>b</span><span class=o>=</span><span class=mi>2</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=k>c</span><span class=o>=</span><span class=mi>3</span><span class=err>；</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>上面这些查询条件之所以会失效，是因为</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=k>c</span><span class=p>)</span><span class=w> </span><span class=err>联合索引，是先按</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=err>排序，在</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=err>相同的情况再按</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=err>排序，在</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=err>相同的情况再按</span><span class=w> </span><span class=k>c</span><span class=w> </span><span class=err>排序。所以，</span><span class=n>b</span><span class=w> </span><span class=err>和</span><span class=w> </span><span class=k>c</span><span class=w> </span><span class=err>是全局无序，局部相对有序的，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>我这里举联合索引（a，b）的例子，该联合索引的 B+ Tree 如下</p><p><img src=https://googoo-s.github.io//statistic/asynccode-255.png width=auto alt></p><p>可以看到，a 是全局有序的（1, 2, 2, 3, 4, 5, 6, 7 ,8），而 b 是全局是无序的（12，7，8，2，3，8，10，5，2）。因此，直接执行<code>where b = 2</code>这种查询条件没有办法利用联合索引的，利用索引的前提是索引里的 key 是有序的。</p><p>**只有在 a 相同，b 才是有序的，**比如 a 等于 2 的时候，b 的值为（7，8），这时就是有序的，这个有序状态是局部的，因此，执行<code>where a = 2 and b = 7</code>是 a 和 b 字段能用到联合索引的，也就是联合索引生效了。</p><a href=#联合索引范围查询><h4 id=联合索引范围查询><span class=hanchor arialabel=Anchor># </span>联合索引范围查询</h4></a><p>联合索引有一些特殊情况，<strong>并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询，也就是可能存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况。</strong></p><p>这种特殊情况就发生在<strong>范围查询</strong>。联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。</p><blockquote><p>Q1: <code>select * from t_table where a > 1 and b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p><p>由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 a > 1 条件的二级索引记录肯定是相邻，于是在进行索引扫描的时候，可以定位到符合 a > 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 a > 1 条件位置。<strong>所以 a 字段可以在联合索引的 B+Tree 中进行索引查询</strong>。</p><p>但是在符合 a > 1 条件的二级索引记录的范围里，b 字段的值是无序的。比如前面图的联合索引的 B+ Tree 里，下面这三条记录的 <strong>a 字段的值都符合 a > 1 查询条件，而 b 字段的值是无序的</strong>：</p><p>因此，Q<strong>1 这条查询语句只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引</strong>。</p></blockquote><p>我们也可以<strong>在执行计划中的 key_len 知道这一点，<strong>在使用联合索引进行查询的时候，通过 k</strong>ey_len 我们可以知道优化器具体使用了多少个字段的搜索条件来形成扫描区间的边界条</strong>件。</p><p>举例个例子 ，a 和 b 都是 int 类型且不为 NULL 的字段，那么 Q1 这条查询语句执行计划如下，可以看到 key_len 为 4 字节（如果字段允许为 NULL，就在字段类型占用的字节数上加 1，也就是 5 字节），说明只<strong>有 a 字段用到了联合索引进行索引查询，而且可以看到，即使 b 字段没用到联合索引，key 为 idx_a_b，说明 Q1 查询语句使用了 idx_a_b 联合索引。</strong></p><p><img src=https://googoo-s.github.io//statistic/asynccode-261.png width=auto alt></p><blockquote><p>Q2: <code>select * from t_table where a >= 1 and b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p><p>Q2 和 Q1 的查询语句很像，<strong>唯一的区别就是 a 字段的查询条件「大于等于」。</strong></p><p>由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 >= 1 条件的二级索引记录肯定是相邻，于是在进行索引扫描的时候，可以定位到符合 >= 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 a>= 1 条件位置。<strong>所以 a 字段可以在联合索引的 B+Tree 中进行索引查询</strong>。</p><p>虽然在符合 a>= 1 条件的二级索引记录的范围里，<strong>b 字段的值是「无序」的，但是对于符合 a = 1 的二级索引记录的范围里，b 字段的值是「有序」的（因为对于联合索引，是先按照 a 字段的值排序，然后在 a 字段的值相同的情况下，再按照 b 字段的值进行排序）</strong>。</p><p>于是，在确定需要扫描的二级索引的范围时，当二级索引记录的 a 字段值为 1 时，可以通过 b = 2 条件减少需要扫描的二级索引记录范围（b 字段可以利用联合索引进行索引查询的意思）。<strong>也就是说，从符合 a = 1 and b = 2 条件的第一条记录开始扫描，而不需要从第一个 a 字段值为 1 的记录开始扫描。</strong></p><p><strong>所以在执行 Q1 这条查询语句的时候，对应的扫描区间是 (2, + ∞)，形成该扫描区间的边界条件是 a > 1，与 b = 2 无关。</strong></p><p>所以，<strong>Q2 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询。</strong></p></blockquote><blockquote><p>Q3: <code>SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p><p>Q3 查询条件中 <code>a BETWEEN 2 AND 8</code> 的意思是查询 a 字段的值在 2 和 8 之间的记录。不同的数据库对 BETWEEN &mldr; AND 处理方式是有差异的。<strong>在 MySQL 中，BETWEEN 包含了 value1 和 value2 边界值，类似于 >= and =&lt;</strong>。而有的数据库则不包含 value1 和 value2 边界值（类似于 > and &lt;）。</p><p>这里我们只讨论 MySQL。由于 MySQL 的 BETWEEN 包含 value1 和 value2 边界值，所以类似于 Q2 查询语句，因此 <strong>Q3 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</p></blockquote><blockquote><p>Q4: <code>SELECT * FROM t_user WHERE name like 'j%' and age = 22</code>，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？</p><p>由于联合索引（二级索引）是先按照 name 字段的值排序的，所以前缀为 ‘j’ 的 name 字段的二级索引记录都是相邻的， 于是在进行索引扫描的时候，可以定位到符合前缀为 ‘j’ 的 name 字段的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录的 name 前缀不为 ‘j’ 为止。</p><p>所以 a 字段可以在联合索引的 B+Tree 中进行索引查询，形成的扫描区间是[&lsquo;j&rsquo;,&lsquo;k&rsquo;)。注意， j 是闭区间。如下图：</p><p><img src=https://googoo-s.github.io//statistic/asynccode-260.png width=auto alt></p><p>虽然在符合前缀为 ‘j’ 的 name 字段的二级索引记录的范围里，age 字段的值是「无序」的，但是对于符合 name = j 的二级索引记录的范围里，age字段的值是「有序」的（因为对于联合索引，是先按照 name 字段的值排序，然后在 name 字段的值相同的情况下，再按照 age 字段的值进行排序）。</p><p>于是，在确定需要扫描的二级索引的范围时，<strong>当二级索引记录的 name 字段值为 ‘j’ 时，可以通过 age = 22 条件减少需要扫描的二级索引记录范围（age 字段可以利用联合索引进行索引查询的意思</strong>）。也就是说，从符合 <code>name = 'j' and age = 22</code> 条件的第一条记录时开始扫描，而不需要从第一个 name 为 j 的记录开始扫描 。如下图的右边：</p><p><img src=https://googoo-s.github.io//statistic/asynccode-263.png width=auto alt></p><p>所以**，Q4 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询。**</p></blockquote><p>综上所示，<strong>联合索引的最左匹配原则，在遇到范围查询（如 >、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</strong>。注意，<strong>对于 >=、&lt;=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配</strong></p><a href=#索引下推><h4 id=索引下推><span class=hanchor arialabel=Anchor># </span>索引下推</h4></a><p>现在我们知道，对于联合索引（a, b），在执行 <code>select * from table where a > 1 and b = 2</code> 语句的时候，<strong>只有 a 字段能用到索引</strong>，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？</p><ul><li><p>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。</p></li><li><p>而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</strong></p></li></ul><p>当你的查询语句的执行计划里，出现了 Extra 为 <code>Using index condition</code>，那么说明使用了索引下推的优化。</p><a href=#联合索引进行排序><h4 id=联合索引进行排序><span class=hanchor arialabel=Anchor># </span>联合索引进行排序</h4></a><p>这里出一个题目，针对针对下面这条 SQL，你怎么通过索引来提高查询效率呢？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-SQL data-lang=SQL><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>order</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>status</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>create_time</span><span class=w> </span><span class=k>asc</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>有的同学会认为，单独给 status 建立一个索引就可以了。</p><p>但是更好的方式给 status 和 create_time 列建立一个联合索引，因为这样<strong>可以避免 MySQL 数据库发生文件排序</strong>。</p><blockquote><p>文件排序：
<a href=https://zhuanlan.zhihu.com/p/311933050 rel=noopener>MySQL filesort原理及优化</a></p></blockquote><a href=#索引区分度><h1 id=索引区分度><span class=hanchor arialabel=Anchor># </span>索引区分度</h1></a><p>区分度就是某个字段 column 不同值的个数「除以」表的总行数，计算公式如下：</p><p><img src=https://googoo-s.github.io//statistic/asynccode-256.png width=auto alt></p><p>区分度越小，越不适合建立索引；</p><a href=#什么时候需要--不需要创建索引><h1 id=什么时候需要--不需要创建索引><span class=hanchor arialabel=Anchor># </span>什么时候需要 / 不需要创建索引？</h1></a><a href=#什么时候适用索引><h2 id=什么时候适用索引><span class=hanchor arialabel=Anchor># </span>什么时候适用索引？</h2></a><ul><li><p><strong>字段有唯一性限制的</strong>，比如商品编码；</p></li><li><p>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</p></li><li><p>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，<strong>这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</strong></p></li></ul><a href=#什么时候不需要创建索引><h2 id=什么时候不需要创建索引><span class=hanchor arialabel=Anchor># </span>什么时候不需要创建索引？</h2></a><ul><li><p><strong><code>WHERE</code></strong> <strong>条件，<strong><strong><code>GROUP BY</code></strong></strong>，****<code>ORDER BY</code></strong> <strong>里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的</strong>，因为索引是会占用物理空间的。</p></li><li><p>字段中存在大量重复数据，不需要创建索引，比如性<strong>别字段，只有男女</strong>，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因<strong>为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候</strong>，它一般会忽略索引，进行全表扫描。</p></li><li><p>表数据太少的时候，不需要创建索引；</p></li><li><p>经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的</p></li></ul><a href=#优化索引><h1 id=优化索引><span class=hanchor arialabel=Anchor># </span>优化索引</h1></a><p>这里说一下几种常见优化索引的方法：</p><ul><li><p>前缀索引优化；</p></li><li><p>覆盖索引优化；</p></li><li><p>主键索引最好是自增的；</p></li><li><p>防止索引失效；</p></li></ul><a href=#前缀索引优化><h2 id=前缀索引优化><span class=hanchor arialabel=Anchor># </span>前缀索引优化</h2></a><p>前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引</p><p>使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。</p><ul><li><p>order by 就无法使用前缀索引；</p></li><li><p>无法把前缀索引用作覆盖索引；</p></li></ul><a href=#覆盖索引优化><h2 id=覆盖索引优化><span class=hanchor arialabel=Anchor># </span>覆盖索引优化</h2></a><p>覆盖索引是指 SQL 中 query 的所有字段，在索引 <strong>B+Tree 的叶子节点上都能找得到</strong>的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作</p><a href=#主键索引最好是自增的><h2 id=主键索引最好是自增的><span class=hanchor arialabel=Anchor># </span>主键索引最好是自增的</h2></a><p>同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。</p><p>**如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，**当页面写满，就会自动开辟一个新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高。</p><p><strong>如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入</strong>，<strong>甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂</strong>。</p><p>主键字段的长度不要太大，因为主<strong>键字段长度越小，意味着二级索引的叶子节点越小</strong>（二级索引的叶子节点存放的数据是主键值）</p><a href=#防止索引失效><h2 id=防止索引失效><span class=hanchor arialabel=Anchor># </span>防止索引失效</h2></a><blockquote><p><a href=https://mp.weixin.qq.com/s/lEx6iRRP3MbwJ82Xwp675w rel=noopener>谁还没碰过索引失效呢</a></p></blockquote><ul><li><p>当我们使用左或者<strong>左右模糊匹配</strong>的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效；</p></li><li><p>当我们在查询条件中对索引列<strong>使用函数</strong>，就会导致索引失效。</p></li><li><p>当我们在查询条件中对索引列进行<strong>表达式计算</strong>，也是无法走索引的。</p></li><li><p>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于<strong>隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数</strong>，所以就会导致索引失效。</p></li><li><p>联合索引要能正确使用需要遵循最左匹配原则，也就是按<strong>照最左优先的方式进行索引的匹配</strong>，否则就会导致索引失效。</p></li><li><p>在 WHERE 子句中，如果在 <strong>OR 前的条件列是索引列，而在 OR 后的条件列不是索引列</strong>，那么索引会失效。</p></li></ul><a href=#执行计划><h1 id=执行计划><span class=hanchor arialabel=Anchor># </span>执行计划</h1></a><p>就是一个没有使用索引，并且是一个全表扫描的查询语句。</p><p><img src=https://googoo-s.github.io//statistic/asynccode-259.png width=auto alt></p><a href=#执行计划参数><h2 id=执行计划参数><span class=hanchor arialabel=Anchor># </span>执行计划参数</h2></a><ul><li><p>possible_keys 字段表示可能用到的索引；</p></li><li><p>key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；</p></li><li><p>key_len 表示<strong>索引的长度</strong>；</p></li><li><p>rows 表示扫描的<strong>数据行数</strong>。</p></li><li><p>type 表示数据<strong>扫描类型</strong>，我们需要重点看这个。</p></li><li><p>extra:其他</p></li></ul><a href=#type-字段><h2 id=type-字段><span class=hanchor arialabel=Anchor># </span>type 字段</h2></a><p>type 字段就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的执行效率从低到高的顺序为：</p><ul><li><p>All（全表扫描）；</p><ul><li>all 是最坏的情况，因为采用了全表扫描的方式</li></ul></li><li><p>index（全索引扫描）；</p><ul><li>index 和 all 差不多，只不过 index 对索引表进行全扫描，这样做的好处是不再需要对数据进行排序，但是开销依然很大</li></ul></li><li><p>range（索引范围扫描）；</p><ul><li>range 表示采用了索引范围扫描，一般在 where 子句中使用 &lt; 、>、in、between 等关键词，只检索给定范围的行，属于范围查找</li></ul></li><li><p>ref（非唯一索引扫描）；</p><ul><li>ref 类型表示采用了非唯一索引，或者是唯一索引的非唯一性前缀，返回数据返回可能是多条。因为虽然使用了索引，但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描。</li></ul></li><li><p>eq_ref（唯一索引扫描）；</p><ul><li>eq_ref 类型是使用主键或唯一索引时产生的访问方式，通常使用在<strong>多表联查</strong>中。比如，对两张表进行联查，</li></ul></li><li><p>const（结果只有一条的主键或唯一索引扫描）。</p><ul><li>const 类型表示使用了主键或者唯一索引与常量值进行比较，比如 select name from product where id=1。</li></ul></li></ul><a href=#extra字段><h2 id=extra字段><span class=hanchor arialabel=Anchor># </span>extra字段</h2></a><p>关注 extra 显示的结果，这里说几个重要的参考指标：</p><ul><li><p>Using filesort ：当查询语句中包含 group by 操作，而且<strong>无法利用索引完成排序操作的时候</strong>， 这时不得不选择相应的排序算法进行，<strong>甚至可能会通过文件排序</strong>，效率是很低的，所以要避免这种问题的出现。</p></li><li><p>Using temporary：<strong>使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by</strong>。效率低，要避免这种问题的出现。</p></li><li><p>Using index：<strong>所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作</strong>，效率不错。</p></li></ul><p><img src=https://googoo-s.github.io//statistic/asynccode-262.png width=auto alt></p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://googoo-s.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by googoo-s using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://googoo-s.github.io/>Home</a></li><li><a href=https://github.com/googoo-s>GitHub</a></li></ul></footer></div></div></body></html>