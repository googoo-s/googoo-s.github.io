<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>集合 on</title><link>https://googoo-s.github.io/tags/%E9%9B%86%E5%90%88/</link><description>Recent content in 集合 on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://googoo-s.github.io/tags/%E9%9B%86%E5%90%88/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://googoo-s.github.io/Java/%E9%9B%86%E5%90%88/List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E9%9B%86%E5%90%88/List/</guid><description>ArrayList 和 Vector 的区别 ArrayList 是 List 的主要实现类，底层使用 Object[]存储，适用于频繁的查找工作，线程不安全 ；
Vector 是 List 的古老实现类，底层使用Object[] 存储，线程安全的。
ArrayList和LinkedList有什么区别？ 是否线程安全</description></item><item><title/><link>https://googoo-s.github.io/Java/%E9%9B%86%E5%90%88/Map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E9%9B%86%E5%90%88/Map/</guid><description>HashMap 和 HashTable 的区别 线程是否安全： HashMap 是非线程安全的，****Hashtable 是线程安全的,因为 Hashtable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；
效率： 因为线程安全的问题，HashMap 要比 Hashtable 效率高一点。另外，Hashtable 基本被淘汰，不要在代码中使用它；</description></item><item><title/><link>https://googoo-s.github.io/Java/%E9%9B%86%E5%90%88/Queue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E9%9B%86%E5%90%88/Queue/</guid><description>Queue 与 Deque 的区别 Queue
Queue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO） 规
Queue 扩展了 Collection 的接口，根据 因为容量问题而导致操作失败后处理方式的不同 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</description></item><item><title/><link>https://googoo-s.github.io/Java/%E9%9B%86%E5%90%88/Set/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/Java/%E9%9B%86%E5%90%88/Set/</guid><description>comparable 和 Comparator 的区别 comparable 接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序
comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序
一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo()方法和使用自制的Comparator方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 Collections.</description></item></channel></rss>