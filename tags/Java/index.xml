<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on</title><link>https://quartz.jzhao.xyz/tags/Java/</link><description>Recent content in Java on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://quartz.jzhao.xyz/tags/Java/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-overview/</guid><description>什么是 Java Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里 难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。 Java语言作为静态面向对象编程语言的优秀代表，极好地实现了面向对象理论，允许 程序员以优雅的思维方式进行复杂的编程 Java 语言有哪些特点?
简单易学； 面向对象（封装，继承，多态）； 平台无关性（ Java 虚拟机实现平台无关性）； 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）； 可靠性； 安全性； 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）； 编译与解释并存； 🐛 修正（参见： issue#544open in new window） ：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用std::thread和std::async来创建线程。参考链接：http://www.</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-SPI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-SPI/</guid><description>何谓 SPI? SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。
SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。
很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。
SPI 和 API 有什么区别？ 那 SPI 和 API 有啥区别？</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E5%8F%8D%E5%B0%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E5%8F%8D%E5%B0%84/</guid><description>关于反射的详细解读，请看这篇文章 Java 反射机制详解。
何谓反射？ 主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。
反射的优缺点？ 优点：反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。
缺点：反射让我们在运行时有了分析操作类的能力的同时，也增加了安全题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。
相关阅读： Java Reflection: Why is it so slow?open in new window 。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid><description>注释有哪几种形式？ Java 中的注释有三种：
单行注释 ：通常用于解释方法内某单行代码的作用。
多行注释 ：通常用于解释一段代码的作用。
文档注释 ：通常用于生成 Java 开发文档。
用的比较多的还是单行注释和文档注释，多行注释在实际开发中使用的相对较少。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E5%B8%B8%E7%94%A8%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E5%B8%B8%E7%94%A8%E7%B1%BB/</guid><description>Object Object 类的常见方法有哪些？ Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。 */public final native Class&amp;lt;?</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E5%BC%82%E5%B8%B8/</guid><description>Java 异常类层次结构图概览 ：
Exception 和 Error 有什么区别？ 在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类:
Exception :程序本身可以处理的异常，可以通过 catch 来进行捕获。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E6%B3%9B%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E6%B3%9B%E5%9E%8B/</guid><description>什么是泛型？有什么作用？ Java 泛型（Generics） 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。
编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 ArrayList&amp;lt;Person&amp;gt; persons = new ArrayList&amp;lt;Person&amp;gt;() 这行代码就指明了该 ArrayList 对象只能传入 Person 对象，如果传入其他类型的对象就会报错。
1 ArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt; 并且，原生 List 返回类型是 Object ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E6%B3%A8%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E6%B3%A8%E8%A7%A3/</guid><description>注解 何谓注解？ Annotation （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。
注解本质是一个继承了Annotation 的特殊接口：
1 2 3 4 5 6 7 8 9 @Target(ElementType.METHOD) @Retention(RetentionPolicy.</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>Java 的数据类型 定义：Java 语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。 Java 语言数据类型分为两种：基本数据类型和引用数据类型 ![[Pasted image 20230726230002.png]]
基本数据类型 Ava 中有 8 种基本数据类型，分别为：
6 种数字类型： 4 种整数型：byte、short、int、long 2 种浮点型：float、double 1 种字符类型：char 1 种布尔型：boolean 这 8 种基本数据类型的默认值以及所占空间的大小如下： 基本类型 位数 字节 默认值 取值范围 byte 8 1 0 -128 ~ 127 short 16 2 0 -32768 ~ 32767 int 32 4 0 -2147483648 ~ 2147483647 long 64 8 0 L -9223372036854775808 ~ 9223372036854775807 char 16 2 &amp;lsquo;u 0000&amp;rsquo; 0 ~ 65535 float 32 4 0 f 1.</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid><description>面向对象和面向过程的区别 两者的主要区别在于解决问题的方式不同：
面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。
面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。
另外，面向对象开发的程序一般更易维护、易复用、易扩展。
相关 issue : 面向过程 ：面向过程性能比面向对象高？？open in new window
创建一个对象用什么运算符?对象实体与对象引用有何不同? new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E5%9F%BA%E7%A1%80/Java-%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>![[Java面试题、面经.pdf]]
![[Java 面试知识点总结.pdf]]
![[Java 面试知识点总结(1).pdf]]
![[Java面试题、面经(1).pdf]]
![[阿里大佬总结的Java面试资料.pdf]]</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E9%9B%86%E5%90%88/List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E9%9B%86%E5%90%88/List/</guid><description>ArrayList 和 Vector 的区别 ArrayList 是 List 的主要实现类，底层使用 Object[]存储，适用于频繁的查找工作，线程不安全 ；
Vector 是 List 的古老实现类，底层使用Object[] 存储，线程安全的。
ArrayList和LinkedList有什么区别？ 是否线程安全</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E9%9B%86%E5%90%88/Map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E9%9B%86%E5%90%88/Map/</guid><description>HashMap 和 HashTable 的区别 线程是否安全： HashMap 是非线程安全的，****Hashtable 是线程安全的,因为 Hashtable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；
效率： 因为线程安全的问题，HashMap 要比 Hashtable 效率高一点。另外，Hashtable 基本被淘汰，不要在代码中使用它；</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E9%9B%86%E5%90%88/Queue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E9%9B%86%E5%90%88/Queue/</guid><description>Queue 与 Deque 的区别 Queue
Queue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO） 规
Queue 扩展了 Collection 的接口，根据 因为容量问题而导致操作失败后处理方式的不同 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</description></item><item><title/><link>https://quartz.jzhao.xyz/Java/%E9%9B%86%E5%90%88/Set/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Java/%E9%9B%86%E5%90%88/Set/</guid><description>comparable 和 Comparator 的区别 comparable 接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序
comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序
一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo()方法和使用自制的Comparator方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 Collections.</description></item></channel></rss>