<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GO/八股文 on</title><link>https://googoo-s.github.io/tags/GO/%E5%85%AB%E8%82%A1%E6%96%87/</link><description>Recent content in GO/八股文 on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://googoo-s.github.io/tags/GO/%E5%85%AB%E8%82%A1%E6%96%87/index.xml" rel="self" type="application/rss+xml"/><item><title>Map</title><link>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/Map-%E5%92%8CSync.map/</link><pubDate>Mon, 26 Feb 2024 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/Map-%E5%92%8CSync.map/</guid><description>参考 Golang map 实现原理 Golang sync.Map 实现原理
Map 概述 map 又称字典，是一种常用的数据结构，核心特征包含下述三点：
（1）存储基于 key-value 对映射的模式；
（2）基于 key 维度实现存储数据的去重；
（3）读、写、删操作控制，时间复杂度 O(1).</description></item><item><title>内存管理</title><link>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8CGC/</link><pubDate>Mon, 26 Feb 2024 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8CGC/</guid><description>内存管理 Golang 的内存模型，为什么小对象多了会造成 gc 压力。 通常小对象过多会导致 GC 三色法消耗过多的 GPU。优化思路是，减少对象分配。
Go 语言什么时候垃圾回收，写代码的时候如何减少对象分配 当 goroutine 申请新的内存管理单元时触发垃圾回收。
写代码的时候如何减少对象分配，这是一个关于性能的问题，
例如如果需要把数字转换成字符串，使用 strconv.Itoa () 比 fmt.</description></item><item><title>并发</title><link>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/%E5%B9%B6%E5%8F%91/</link><pubDate>Mon, 26 Feb 2024 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/%E5%B9%B6%E5%8F%91/</guid><description>下面哪个不是 Go 语言中的并发原语? Channel Mutex WaitGroup Semaphore 什么是 sync. Once Once 可以用来执行且仅仅执行一次动作，常常用于单例对象的初始化场景。
Once 常常用来初始化单例资源，或者并发访问只需初始化⼀次的共享资源，或者在测试的时候初始化⼀次测试资源。
Sync. Once 只暴露了⼀个⽅法 Do，你可以多次调⽤ Do ⽅法，但是只有第⼀次调⽤ Do 方法时 f 参数才会执行，这⾥的 f 是⼀个无参数无返回值的函数。</description></item><item><title>Golang基础</title><link>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/Golang%E5%9F%BA%E7%A1%80/</link><pubDate>Sun, 25 Feb 2024 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/Golang%E5%9F%BA%E7%A1%80/</guid><description>init 和 main 函数相关特点 init 函数 （没有输入参数、返回值）的主要作用 初始化不能采用初始化表达式初始化的变量。 程序运行前的注册。 实现sync.Once功能。 其他 init 顺序 在同一个 package 中，可以多个文件中定义 init 方法 在同一个 go 文件中，可以重复定义 init 方法 在同一个 package 中，不同文件中的 init 方法的执行按照文件名先后执行各个文件中的 init 方法 在同一个文件中的多个 init 方法，按照在代码中编写的顺序依次执行不同的 init 方法 对于不同的 package，如果不相互依赖的话，按照 main 包中 import 的顺序调用其包中的 init() 函数 如果 package 存在依赖，调用顺序为最后被依赖的最先被初始化，例如：导入顺序 main –&amp;gt; A –&amp;gt; B –&amp;gt; C，则初始化顺序为 C –&amp;gt; B –&amp;gt; A –&amp;gt; main，一次执行对应的 init 方法。 所有 init 函数都在同⼀个 goroutine 内执行。 所有 init 函数结束后才会执行 main.</description></item><item><title>Slice</title><link>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/Slice/</link><pubDate>Sun, 25 Feb 2024 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/Slice/</guid><description>参考 你真的了解go语言中的切片吗
基本介绍 go 语言中的切片对标于其他编程语言中通俗意义上的“数组”. 切片中的元素存放在一块内存地址连续的区域，使用索引可以快速检索到指定位置的元素；切片长度和容量是可变的，在使用过程中可以根据需要进行扩容.
Go slice 的底层实现原理? 切片是基于数组实现的，它的底层是数组，可以理解为对底层数组的抽象。
源码包中 src/runtime/slice. Go 定义了 slice 的数据结构：
1 2 3 4 5 6 7 8 type slice struct { // 指向起点的地址 array unsafe.</description></item></channel></rss>