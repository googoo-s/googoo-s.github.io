<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="在一个健康的开发周期中，代码风格，API 设计和自动化是非常关键的。同样的，对于工程的 架构 ,仓库的结构也是关键的一部分。
当一个潜在的用户和贡献者登录到您的仓库页面时，他们会看到这些:
  工程的名字
  工程的描述
  一系列的文件
  只有当他们滚动到目录下方时才会看到您工程的README。
如果您的仓库的目录是一团糟，没有清晰的结构，他们可能要到处寻找才能找到您写的漂亮的文档。
 为您的渴望的事业而奋斗，而不是仅仅只为您现在的工作而工作。"><meta property="og:title" content><meta property="og:description" content="在一个健康的开发周期中，代码风格，API 设计和自动化是非常关键的。同样的，对于工程的 架构 ,仓库的结构也是关键的一部分。
当一个潜在的用户和贡献者登录到您的仓库页面时，他们会看到这些:
  工程的名字
  工程的描述
  一系列的文件
  只有当他们滚动到目录下方时才会看到您工程的README。
如果您的仓库的目录是一团糟，没有清晰的结构，他们可能要到处寻找才能找到您写的漂亮的文档。
 为您的渴望的事业而奋斗，而不是仅仅只为您现在的工作而工作。"><meta property="og:type" content="website"><meta property="og:image" content="https://googoo-s.github.io/icon.png"><meta property="og:url" content="https://googoo-s.github.io/Python/2.%E5%B7%A5%E7%A8%8B%E7%9A%84%E7%BB%93%E6%9E%84/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="在一个健康的开发周期中，代码风格，API 设计和自动化是非常关键的。同样的，对于工程的 架构 ,仓库的结构也是关键的一部分。
当一个潜在的用户和贡献者登录到您的仓库页面时，他们会看到这些:
  工程的名字
  工程的描述
  一系列的文件
  只有当他们滚动到目录下方时才会看到您工程的README。
如果您的仓库的目录是一团糟，没有清晰的结构，他们可能要到处寻找才能找到您写的漂亮的文档。
 为您的渴望的事业而奋斗，而不是仅仅只为您现在的工作而工作。"><meta name=twitter:image content="https://googoo-s.github.io/icon.png"><title>googoo-s</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://googoo-s.github.io//icon.png><link href=https://googoo-s.github.io/styles.19109a40042e9f0e72e952fda4442a34.min.css rel=stylesheet><link href=https://googoo-s.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://googoo-s.github.io/js/darkmode.953af745b0f9342644d632fc167f3727.min.js></script>
<script src=https://googoo-s.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://googoo-s.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://googoo-s.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://googoo-s.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://googoo-s.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://googoo-s.github.io/",fetchData=Promise.all([fetch("https://googoo-s.github.io/indices/linkIndex.26897e4d1acf67c094aa607e8f2e6316.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://googoo-s.github.io/indices/contentIndex.a0226c1814e978de8ff7d664095a4050.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://googoo-s.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://googoo-s.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/googoo-s.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=googoo-s.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://googoo-s.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://googoo-s.github.io/>googoo-s</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Unknown
<a href=/Python/2.%e5%b7%a5%e7%a8%8b%e7%9a%84%e7%bb%93%e6%9e%84.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#真正的模块>真正的模块</a></li><li><a href=#license>License</a></li><li><a href=#setuppy>Setup.py</a></li><li><a href=#requirements-file>Requirements File</a></li><li><a href=#documentation>Documentation</a></li><li><a href=#test-suite>Test Suite</a></li><li><a href=#makefile>Makefile</a></li></ol></nav></details></aside><p>在一个健康的开发周期中，代码风格，API 设计和自动化是非常关键的。同样的，对于工程的
<a href="http://www.amazon.com/gp/product/1257638017/ref=as_li_ss_tl?ie=UTF8&tag=bookforkind-20&linkCode=as2&camp=1789&creative=39095&creativeASIN=1257638017" rel=noopener>架构</a> ,仓库的结构也是关键的一部分。</p><p>当一个潜在的用户和贡献者登录到您的仓库页面时，他们会看到这些:</p><ul><li><p>工程的名字</p></li><li><p>工程的描述</p></li><li><p>一系列的文件</p></li></ul><p>只有当他们滚动到目录下方时才会看到您工程的README。</p><p>如果您的仓库的目录是一团糟，没有清晰的结构，他们可能要到处寻找才能找到您写的漂亮的文档。</p><blockquote><p>为您的渴望的事业而奋斗，而不是仅仅只为您现在的工作而工作。</p></blockquote><p>当然，第一印象并不是一切。但是，您和您的同事会和这个仓库并肩战斗很长时间，会熟悉它的每一个角落和细节。拥有良好的布局，事半功倍。</p><a href=#仓库样例><h1 id=仓库样例><span class=hanchor arialabel=Anchor># </span>仓库样例</h1></a><p><strong>请看这里</strong>: 这是
<a href=http://kennethreitz.org/ rel=noopener>Kenneth Reitz</a> 推荐的。</p><p>这个仓库
<a href=https://github.com/kennethreitz/samplemod rel=noopener>可以在GitHub上找到</a> 。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>README.rst</span>
</span></span><span class=line><span class=cl><span class=err>LICENSE</span>
</span></span><span class=line><span class=cl><span class=err>setup.py</span>
</span></span><span class=line><span class=cl><span class=err>requirements.txt</span>
</span></span><span class=line><span class=cl><span class=err>sample/__init__.py</span>
</span></span><span class=line><span class=cl><span class=err>sample/core.py</span>
</span></span><span class=line><span class=cl><span class=err>sample/helpers.py</span>
</span></span><span class=line><span class=cl><span class=err>docs/conf.py</span>
</span></span><span class=line><span class=cl><span class=err>docs/index.rst</span>
</span></span><span class=line><span class=cl><span class=err>tests/test_basic.py</span>
</span></span><span class=line><span class=cl><span class=err>tests/test_advanced.py</span>
</span></span></code></pre></td></tr></table></div></div><p>让我们看一下细节。</p><a href=#真正的模块><h2 id=真正的模块><span class=hanchor arialabel=Anchor># </span>真正的模块</h2></a><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>布局</td><td>./sample/ or ./sample.py</td></tr><tr><td>作用</td><td>核心代码</td></tr></tbody></table><p>您的模块包是这个仓库的核心，它不应该隐藏起来:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>./sample/</span>
</span></span></code></pre></td></tr></table></div></div><p>如果您的模块只有一个文件，那么您可以直接将这个文件放在仓库的根目录下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>./sample.py</span>
</span></span></code></pre></td></tr></table></div></div><p>这个模块文件不应该属于任何一个模棱两可的src或者python子目录。</p><a href=#license><h2 id=license><span class=hanchor arialabel=Anchor># </span>License</h2></a><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>布局</td><td>./LICENSE</td></tr><tr><td>作用</td><td>许可证.</td></tr></tbody></table><p>除了源代码本身以外，这个毫无疑问是您仓库最重要的一部分。在这个文件中要有完整的许可说明和授权。</p><p>如果您不太清楚您应该使用哪种许可方式，请查看
<a href=http://choosealicense.com/ rel=noopener>choosealicense.com</a>.</p><p>当然，您也可以在发布您的代码时不做任何许可说明，但是这显然阻碍潜在的用户使用您的代码。</p><a href=#setuppy><h2 id=setuppy><span class=hanchor arialabel=Anchor># </span>Setup.py</h2></a><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>布局</td><td>./setup.py</td></tr><tr><td>作用</td><td>打包和发布管理</td></tr></tbody></table><p>如果您的模块包在您的根目录下，显然这个文件也应该在根目录下。</p><a href=#requirements-file><h2 id=requirements-file><span class=hanchor arialabel=Anchor># </span>Requirements File</h2></a><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>布局</td><td>./requirements.txt</td></tr><tr><td>作用</td><td>开发依赖.</td></tr></tbody></table><p>一个
<a href=https://pip.pypa.io/en/stable/user_guide/#requirements-files rel=noopener>pip requirements file</a> 应该放在仓库的根目录。它应该指明完整工程的所有依赖包: 测试, 编译和文档生成。</p><p>如果您的工程没有任何开发依赖，或者您喜欢通过 <code>setup.py</code> 来设置，那么这个文件不是必须的。</p><a href=#documentation><h2 id=documentation><span class=hanchor arialabel=Anchor># </span>Documentation</h2></a><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>布局</td><td>./docs/</td></tr><tr><td>作用</td><td>包的参考文档</td></tr></tbody></table><p>没有任何理由把这个放到别的地方。</p><a href=#test-suite><h2 id=test-suite><span class=hanchor arialabel=Anchor># </span>Test Suite</h2></a><p><em>想了解关于编写测试的建议，请查阅 :doc:<code>/writing/tests</code>。</em></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>布局</td><td>./test_sample.py or ./tests</td></tr><tr><td>作用</td><td>包的集合和单元测试</td></tr></tbody></table><p>最开始，一组测试例子只是放在一个文件当中:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>./test_sample.py</span>
</span></span></code></pre></td></tr></table></div></div><p>当测试例子逐步增加时，您会把它放到一个目录里面，像下面这样:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>tests/test_basic.pytests/test_advanced.py</span>
</span></span></code></pre></td></tr></table></div></div><p>当然，这些测试例子需要导入您的包来进行测试，有几种方式来处理:</p><ul><li><p>将您的包安装到site-packages中。</p></li><li><p>通过简单直接的路径设置来解决导入的问题。</p></li></ul><p>我极力推荐后者。如果使用 <code>setup.py develop</code> 来测试一个持续更新的代码库，需要为每一个版本的代码库设置一个独立的测试环境.太麻烦了。</p><p>可以先创建一个包含上下文环境的文件 <code>tests/context.py</code>。 file:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>import</span> <span class=err>os</span>
</span></span><span class=line><span class=cl><span class=err>import</span> <span class=err>sys</span>
</span></span><span class=line><span class=cl><span class=err>sys.path.insert(</span><span class=mi>0</span><span class=err>,</span> <span class=err>os.path.abspath(os.path.join(os.path.dirname(__file__),</span> <span class=err>&#39;..&#39;)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>import</span> <span class=err>sample</span>
</span></span></code></pre></td></tr></table></div></div><p>然后，在每一个测试文件中，导入:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>from</span> <span class=err>.context</span> <span class=err>import</span> <span class=err>sample</span>
</span></span></code></pre></td></tr></table></div></div><p>这样就能够像期待的那样工作，而不用采用安装的方式。</p><p>一些人会说应该把您的测试例子放到您的模块里面 &ndash; 我不同意。这样会增加您用户使用的复杂度；而且添加测试模块将导致需要额外的依赖和运行环境。</p><a href=#makefile><h2 id=makefile><span class=hanchor arialabel=Anchor># </span>Makefile</h2></a><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>布局</td><td>./Makefile</td></tr><tr><td>作用</td><td>常规的管理任务</td></tr></tbody></table><p>如果您看看我的项目或者其他开源项目，您都会发现有一个Makefile。为什么？这些项目也不是用C写的啊。。。简而言之，make对于定义常规的管理任务是非常有用的工具。</p><p>** 样例 Makefile:**</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>init:</span>
</span></span><span class=line><span class=cl>    <span class=err>pip</span> <span class=err>install</span> <span class=err>-r</span> <span class=err>requirements.txt</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=err>test:</span>
</span></span><span class=line><span class=cl>    <span class=err>py.test</span> <span class=err>tests</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>PHONY:</span> 
</span></span><span class=line><span class=cl>    <span class=err>init</span> <span class=err>test</span>
</span></span></code></pre></td></tr></table></div></div><p>init**:<strong>pip install -r requirements.txttest</strong>:<strong>py.test testsPHONY</strong>:** init test</p><p>一些其他的常规管理脚本（比如 <code>manage.py</code> 或者 <code>fabfile.py</code>），也放在仓库的根目录下。</p><a href=#关于-django-applications><h1 id=关于-django-applications><span class=hanchor arialabel=Anchor># </span>关于 Django Applications</h1></a><p>从Django 1.4开始，我发现有这样一个现象：很多开发者错误地使用Django自带的应用模板创建项目，导致他们的仓库结构非常糟糕。</p><p>这是怎么回事儿? 是的, 他们在进入一个新的仓库后，通常都这样操作：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>$</span> <span class=err>django-admin.py</span> <span class=err>startproject</span> <span class=err>samplesite</span>
</span></span></code></pre></td></tr></table></div></div><p>这样的操作生成的仓库结构是这样的:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>README.rst</span>
</span></span><span class=line><span class=cl><span class=err>samplesite/manage.py</span>
</span></span><span class=line><span class=cl><span class=err>samplesite/samplesite/settings.py</span>
</span></span><span class=line><span class=cl><span class=err>samplesite/samplesite/wsgi.py</span>
</span></span><span class=line><span class=cl><span class=err>samplesite/samplesite/sampleapp/models.py</span>
</span></span></code></pre></td></tr></table></div></div><p>亲，不要这样做。</p><p>相对路径会让您的工具和您的开发者都很疑惑。没有必要的嵌套对任何人都没有好处（除非您怀念庞大的SVN仓库）。</p><p>让我们这样来做:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>$</span> <span class=err>django-admin.py</span> <span class=err>startproject</span> <span class=err>samplesite</span> <span class=err>.</span>
</span></span></code></pre></td></tr></table></div></div><p>注意末尾的 &ldquo;<code>.</code>"。</p><p>生成的结构是这样的:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>README.rst</span>
</span></span><span class=line><span class=cl><span class=err>manage.py</span>
</span></span><span class=line><span class=cl><span class=err>samplesite/settings.py</span>
</span></span><span class=line><span class=cl><span class=err>samplesite/wsgi.py</span>
</span></span><span class=line><span class=cl><span class=err>samplesite/sampleapp/models.py</span>
</span></span></code></pre></td></tr></table></div></div><a href=#结构是一把钥匙><h1 id=结构是一把钥匙><span class=hanchor arialabel=Anchor># </span>结构是一把钥匙</h1></a><p>得益于Python提供的导入与管理模块的方式，结构化Python项目变得相对简单。 这里说的简单，指的是结构化过程没有太多约束限制而且模块导入功能容易掌握。 因而您只剩下架构性的工作，包括设计、实现项目各个模块，并整理清他们之间 的交互关系。</p><p>容易结构化的项目同样意味着它的结构化容易做得糟糕。糟糕结构的特征包括：</p><ul><li><p>多重且混乱的循环依赖关系：假如在 <code>furn.py</code> 内的Table与Chair类需要 导入 <code>workers.py</code> 中的Carpenter类以回答类似 <code>table.isdoneby()</code> 的问题，并且Carpenter类需要引入Table和Chair类以回答 <code>carpenter.whatdo()</code> 这类问题，这就是一种循环依赖的情况。在这种情况下,您得借助一些不怎么靠谱的 小技巧，比如在方法或函数内部使用import语句。</p></li><li><p>隐含耦合：Table类实现代码中每一个改变都会打破20个不相关的测试用例，由于它 影响了Carpenter类的代码，这要求谨慎地操作以适应改变。这样的情况意味着 Carpenter类代码中包含了太多关于Table类的假设关联（或相反）。</p></li><li><p>大量使用全局变量或上下文：如果Table和Carpenter类使用不仅能被修改而且能被 不同引用修改的全局变量，而不是明确地传递 <code>(height, width, type, wood)</code> 变量。您就需要彻底检查全局变量的所有入口，来理解到为什么一个长方形桌子变 成了正方形，最后发现远程的模板代码修改了这份上下文，弄错了桌子尺寸规格的 定义。</p></li><li><p>面条式代码 (Spaghetti code) ：多页嵌套的if语句与for循环，包含大量复制-粘贴 的过程代码，且没有合适的分割——这样的代码被称为面条式代码。Python中有意思 的缩进排版(最具争议的特性之一)使面条式代码很难维持。所以好消息是您也许不 会经常看到这种面条式代码。</p></li><li><p>Python中更可能出现混沌代码：这类代码包含上百段相似的逻辑碎片，通常是缺乏 合适结构的类或对象，如果您始终弄不清手头上的任务应该使用FurnitureTable， AssetTable还是Table，甚至TableNew，也许您已经陷入了混沌代码中。</p></li></ul><a href=#模块><h1 id=模块><span class=hanchor arialabel=Anchor># </span>模块</h1></a><p>Python模块是最主要的抽象层之一，并且很可能是最自然的一个。</p><p>抽象层允许将代码分为 不同部分，每个部分包含相关的数据与功能。</p><p>为遵守风格指南中的规定</p><ul><li><p><strong>模块名称要短、使用小写，并避免使用特殊符号</strong>，比如点(.) 和问号(?)。如 <code>my.spam.py</code> 这样的名字是必须不能用的！该方式命名将妨碍 Python的模块查找功能。就 my.spam.py 来说，Python 认为需要在 <code>my</code> 文件夹 中找到 <code>spam.py</code> 文件，实际并不是这样。这个例子
<a href=http://docs.python.org/tutorial/modules.html#packages rel=noopener>example</a> 展示了点表示 法应该如何在Python文件中使用。如果愿意您可以将模块命名为 <code>my_spam.py</code>，</p></li><li><p><strong>不过并不推荐在模块名中使用下划线。但是，在模块名称中使用其他字符（空格或连字号） 将阻止导入（-是减法运算符），因此请尽量保持模块名称简单，以无需分开单词</strong>。 最重要的是，不要使用下划线命名空间，而是使用子模块。</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>#</span> <span class=err>OK</span>
</span></span><span class=line><span class=cl><span class=err>import</span> <span class=err>library.plugin.foo</span>
</span></span><span class=line><span class=cl><span class=err>#</span> <span class=err>not</span> <span class=err>OK</span>
</span></span><span class=line><span class=cl><span class=err>import</span> <span class=err>library.foo_plugin</span>
</span></span></code></pre></td></tr></table></div></div><p>除了以上的命名限制外，Python文件成为模块没有其他特殊的要求，但为了合理地使用这 个观念并避免问题，您需要理解import的原理机制。</p><ul><li><p><code>import modu</code> 语句将 寻找合适的文件，即调用目录下的 <code>modu.py</code> 文件（如果该文件存在）。</p></li><li><p>如果没有 找到这份文件，Python解释器递归地在 &ldquo;PYTHONPATH&rdquo; 环境变量中查找该文件，如果仍没 有找到，将抛出ImportError异常。</p></li><li><p>一旦找到 <code>modu.py</code>，**Python解释器将在隔离的作用域内执行这个模块。所有顶层 语句都会被执行，包括其他的引用。方法与类的定义将会存储到模块的字典中。**然后，这个 模块的变量、方法和类通过命名空间暴露给调用方，这是Python中特别有用和强大的核心概念。</p></li><li><p>在很多其他语言中，<code>include file</code> 指令被预处理器用来获取文件里的所有代码并‘复制’ 到调用方的代码中。Python则不一样：<strong>include代码被独立放在模块命名空间里，这意味着您 一般不需要担心include的代码可能造成不好的影响，例如重载同名方法。</strong></p></li></ul><p>也可以使用import语句的特殊形式 <code>from modu import *</code> 模拟更标准的行为。但 <code>import *</code> 通常 被认为是不好的做法。<strong>使用</strong> <code>from modu import *</code> <strong>的代码较难阅读而且依赖独立性不足</strong>。 <strong>使用</strong> <strong><code>from modu import func</code></strong> <strong>能精确定位您想导入的方法并将其放到全局命名空间中</strong>。 比 <code>from modu import *</code> 要好些，因为它明确地指明往全局命名空间中导入了什么方法，它和 <code>import modu</code> 相比唯一的优点是之后使用方法时可以少打点儿字。</p><p><strong>差</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=p>[</span><span class=err>...</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>from</span> <span class=err>modu</span> <span class=err>import</span> <span class=err>*</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=err>...</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>x</span> <span class=err>=</span> <span class=err>sqrt(</span><span class=mi>4</span><span class=err>)</span>  <span class=err>#</span> <span class=err>sqrt是模块modu的一部分么？或是内建函数么？上文定义了么？</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>稍好</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>from</span> <span class=err>modu</span> <span class=err>import</span> <span class=err>sqrt</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=err>...</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=err>x</span> <span class=err>=</span> <span class=err>sqrt(</span><span class=mi>4</span><span class=err>)</span>  <span class=err>#</span> <span class=err>如果在import语句与这条语句之间，sqrt没有被重复定义，它也许是模块modu的一部分。</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>最好的做法</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>import</span> <span class=err>modu</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=err>...</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=err>x</span> <span class=err>=</span> <span class=err>modu.sqrt(</span><span class=mi>4</span><span class=err>)</span>  <span class=err>#</span> <span class=err>sqrt显然是属于模块modu的。</span>
</span></span></code></pre></td></tr></table></div></div><p>在
<a href=https://pythonguidecn.readthedocs.io/zh/latest/writing/style.html#code-style rel=noopener>代码风格</a> 章节中提到，可读性是Python最主要的特性之一。可读性意味着避免 无用且重复的文本和混乱的结构，因而需要花费一些努力以实现一定程度的简洁。但不能 过份简洁而导致简短晦涩。除了简单的单文件项目外，<strong>其他项目需要能够明确指出类和方法 的出处</strong>，</p><a href=#包><h1 id=包><span class=hanchor arialabel=Anchor># </span>包</h1></a><p><strong>Python提供非常简单的包管理系统，即简单地将模块管理机制扩展到一个目录上(目录扩 展为包)。</strong></p><p><strong>任意包含</strong> <strong><code>__init__.py</code></strong> <strong>文件的目录都被认为是一个Python包</strong>。导入一个包里不同 模块的方式和普通的导入模块方式相似，特别的地方是 <code>__init__.py</code> 文件将集合 所有包范围内的定义。</p><ul><li><p><code>pack/</code> 目录下的 <code>modu.py</code> 文件通过 <code>import pack.modu</code> 语句导入。</p><ul><li><p>该语句会在 <code>pack</code> 目录下寻找 <code>__init__.py</code> 文件，并执行其中所有顶层 语句。</p></li><li><p>以上操作之后，<code>modu.py</code> 内定义的所有变量、方法和类在pack.modu命名空 间中均可看到。</p></li></ul></li></ul><p>一个常见的问题是往 <code>__init__.py</code> 中加了过多代码，随着项目的复杂度增长， 目录结构越来越深，子包和更深嵌套的子包可能会出现。在这种情况下，导入多层嵌套 的子包中的某个部件需要执行所有通过路径里碰到的 <code>__init__.py</code> 文件。<strong>如果 包内的模块和子包没有代码共享的需求，使用空白的</strong> <strong><code>__init__.py</code></strong> <strong>文件是正常 甚至好的做法</strong>。</p><p>最后，导入深层嵌套的包可用这个方便的语法：<code>import very.deep.module as mod</code>。 该语法允许使用 mod 替代冗长的 <code>very.deep.module</code>。</p><a href=#面向对象编程><h1 id=面向对象编程><span class=hanchor arialabel=Anchor># </span>面向对象编程</h1></a><p><strong>在Python中 一切都是对象，并且能按对象的方式处理</strong>。这么说的意思是，例如函数是一等对象。 函数、类、字符串乃至类型都是Python对象：与其他对象一样，他们有类型，能作为 函数参数传递，并且还可能有自己的方法和属性。这样理解的话，Python是一种面向对象语言。</p><p>然而，与Java不同的是，Python并没有将面向对象编程作为最主要的编程范式。非面向 对象的Python项目(比如，使用较少甚至不使用类定义，类继承，或其它面向对象编程的 机制)也是完全可行的。</p><p><strong>此外在</strong> <strong><a href=https://pythonguidecn.readthedocs.io/zh/latest/writing/structure.html#id8 rel=noopener>模块</a></strong> <strong>章节里曾提到，Python管理模块与命名空间的方式提供给开发者一个自然 的方式以实现抽象层的封装和分离</strong>，这是使用面向对象最常见的原因。因而，如果业务逻辑 没有要求，Python开发者有更多自由去选择不使用面向对象。</p><p><strong>在一些情况下，需要避免不必要的面向对象。当我们想要将状态与功能结合起来，使用 标准类定义是有效的</strong>。但正如函数式编程所讨论的那个问题，函数式的“变量”状态与类的 状态并不相同。</p><p>在某些架构中，典型代表是web应用，大量Python进程实例被产生以响应可能同时到达的 外部请求。在这种情况下，在实例化对象内保持某些状态，即保持某些环境静态信息， 容易出现并发问题或竞态条件。有时候在对象状态的初始化(通常通过 <code>__init__()</code> 方法实现)和在其方法中使用该状态之间，环境发生了变化，保留的状态可能已经过时。 举个例子，某个请求将对象加载到内存中并标记它为已读。如果同时另一个请求要删除 这个对象，删除操作可能刚好发生在第一个请求加载完该对象之后，结果就是第一个请 求标记了一个已经被删除的对象为已读。</p><p>这些问题使我们产生一个想法：<strong>使用无状态的函数是一种更好的编程范式</strong>。<strong>另一种建议 是尽量使用隐式上下文和副作用较小的函数与程序。函数的隐式上下文由函数内部访问 到的所有全局变量与持久层对象组成</strong>。副作用即函数可能使其隐式上下文发生改变。如 果函数保存或删除全局变量或持久层中数据，这种行为称为副作用。</p><p>把有隐式上下文和副作用的函数与仅包含逻辑的函数(纯函数)谨慎地区分开来，会带来 以下好处：</p><ul><li><p>纯函数的结果是确定的：给定一个输入，输出总是固定相同。</p></li><li><p>当需要重构或优化时，纯函数更易于更改或替换。</p></li><li><p>纯函数更容易做单元测试：很少需要复杂的上下文配置和之后的数据清除工作。</p></li><li><p>纯函数更容易操作、修饰和分发。</p></li></ul><p>总之，对于某些架构而言，纯函数比类和对象在构建模块时更有效率，<strong>因为他们没有任何 上下文和副作用。但显然在很多情况下，面向对象编程是有用甚至必要的</strong>。例如图形桌面 应用或游戏的开发过程中，操作的元素(窗口、按钮、角色、车辆)在计算机内存里拥有相 对较长的生命周期。</p><a href=#装饰器><h1 id=装饰器><span class=hanchor arialabel=Anchor># </span>装饰器</h1></a><p>Python语言提供一个简单而强大的语法: &lsquo;装饰器&rsquo;。<strong>装饰器是一个函数或类，它可以 包装(或装饰)一个函数或方法</strong>。<strong>被 &lsquo;装饰&rsquo; 的函数或方法会替换原来的函数或方法</strong>。 <strong>由于在Python中函数是一等对象，它也可以被 &lsquo;手动操作&rsquo;，但是使用@decorators 语法更清晰，因此首选这种方式</strong>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>def</span> <span class=err>foo():</span>
</span></span><span class=line><span class=cl>    <span class=err>#</span> <span class=err>实现语句</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=err>def</span> <span class=err>decorator(func):</span>
</span></span><span class=line><span class=cl>    <span class=err>#</span> <span class=err>操作func语句</span>
</span></span><span class=line><span class=cl>    <span class=err>return</span> <span class=err>func</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=err>foo</span> <span class=err>=</span> <span class=err>decorator(foo)</span>  <span class=err>#</span> <span class=err>手动装饰</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>@decorator</span>
</span></span><span class=line><span class=cl><span class=err>def</span> <span class=err>bar():#</span> <span class=err>实现语句</span>
</span></span><span class=line><span class=cl><span class=err>#</span> <span class=err>bar()被装饰了</span>
</span></span></code></pre></td></tr></table></div></div><p>这个机制对于分离概念和避免外部不相关逻辑“污染”主要逻辑很有用处。 记忆化
<a href=https://en.wikipedia.org/wiki/Memoization#Overview rel=noopener>https://en.wikipedia.org/wiki/Memoization#Overview</a> 或缓存就是一个很 好的使用装饰器的例子：您需要在table中储存一个耗时函数的结果，并且下次能直接 使用该结果，而不是再计算一次。这显然不属于函数的逻辑部分。</p><a href=#上下文管理器><h1 id=上下文管理器><span class=hanchor arialabel=Anchor># </span>上下文管理器</h1></a><p>上下文管理器是一个Python对象，为操作提供了额外的上下文信息。 这种额外的信息， 在使用 <code>with</code> 语句初始化上下文，以及完成 <code>with</code> 块中的所有代码时，采用可调用的形式。 这里展示了使用上下文管理器的为人熟知的示例，打开文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>with</span> <span class=err>open(&#39;file.txt&#39;)</span> <span class=err>as</span> <span class=err>f:</span>
</span></span><span class=line><span class=cl>    <span class=err>contents</span> <span class=err>=</span> <span class=err>f.read()</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>任何熟悉这种模式的人都知道以这种形式调用</strong> <strong><code>open</code></strong> <strong>能确保</strong> <strong><code>f` 的 ``close</code></strong> <strong>方法会在某个时候被调用</strong>。 这样可以减少开发人员的认知负担，并使代码更容易阅读。</p><p>实现这个功能有两种简单的方法：使用类或使用生成器。 让我们自己实现上面的功能，</p><ul><li>以使用类方式开始：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>class</span> <span class=err>CustomOpen(object):</span>
</span></span><span class=line><span class=cl>    <span class=err>def</span> <span class=err>__init__(self,</span> <span class=err>filename):</span>
</span></span><span class=line><span class=cl>        <span class=err>self.file</span> <span class=err>=</span> <span class=err>open(filename)\</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=err>def</span> <span class=err>__enter__(self):</span>
</span></span><span class=line><span class=cl>        <span class=err>return</span> <span class=err>self.file</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=err>def</span> <span class=err>__exit__(self,</span> <span class=err>ctx_type,</span> <span class=err>ctx_value,</span> <span class=err>ctx_traceback):</span>
</span></span><span class=line><span class=cl>        <span class=err>self.file.close()</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> <span class=err>with</span> <span class=err>CustomOpen(&#39;file&#39;)</span> <span class=err>as</span> <span class=err>f:contents</span> <span class=err>=</span> <span class=err>f.read()</span>
</span></span></code></pre></td></tr></table></div></div><p>这只是一个常规的Python对象，它有两个由 <code>with</code> 语句使用的额外方法。 CustomOpen 首先被实例化，然后调用它的<code>__enter__</code>方法，而且 <code>__enter__</code> 的返回值在 <code>as f</code> 语句中被赋给 <code>f</code> 。 当 <code>with</code> 块中的内容执行完后，会调用 <code>__exit__</code> 方法。</p><p>而生成器方式使用了Python自带的
<a href=https://docs.python.org/2/library/contextlib.html rel=noopener>contextlib</a>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>from</span> <span class=err>contextlib</span> <span class=err>import</span> <span class=err>contextmanager</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>@contextmanager</span>
</span></span><span class=line><span class=cl><span class=err>def</span> <span class=err>custom_open(filename):</span>
</span></span><span class=line><span class=cl>    <span class=err>f</span> <span class=err>=</span> <span class=err>open(filename)</span>
</span></span><span class=line><span class=cl>    <span class=err>try:</span>
</span></span><span class=line><span class=cl>        <span class=err>yield</span> <span class=err>f</span>
</span></span><span class=line><span class=cl>    <span class=err>finally:</span>
</span></span><span class=line><span class=cl>        <span class=err>f.close()</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl><span class=err>with</span> <span class=err>custom_open(&#39;file&#39;)</span> <span class=err>as</span> <span class=err>f:contents</span> <span class=err>=</span> <span class=err>f.read()</span>
</span></span></code></pre></td></tr></table></div></div><p>这与上面的类示例道理相通，尽管它更简洁。<strong><code>custom_open</code></strong> <strong>函数一直运行到</strong> <strong><code>yield</code></strong> <strong>语句。 然后它将控制权返回给</strong> <strong><code>with</code></strong> <strong>语句，然后在</strong> <strong><code>as f</code></strong> <strong>部分将yield的 f 赋值给f。</strong> <strong><code>finally</code></strong> <strong>确保不论</strong> <strong><code>with</code></strong> <strong>中是否发生异常，</strong> <strong><code>close()</code></strong> <strong>都会被调用。</strong></p><a href=#动态类型><h1 id=动态类型><span class=hanchor arialabel=Anchor># </span>动态类型</h1></a><p><strong>Python是动态类型语言，这意味着变量并没有固定的类型</strong>。实际上，Python 中的变量和其他 语言有很大的不同，特别是静态类型语言。变量并不是计算机内存中被写入的某个值，它们 只是指向内存的 ‘标签’ 或 ‘名称’ 。因此可能存在这样的情况，变量 &lsquo;a&rsquo; 先代表值1，然后变成 字符串 &lsquo;a string&rsquo; , 然后又变为指向一个函数。</p><p>Python 的动态类型常被认为是它的缺点，的确这个特性会导致复杂度提升和难以调试的代码。 命名为 &lsquo;a&rsquo; 的变量可能是各种类型，开发人员或维护人员需要在代码中追踪命名，以保证它 没有被设置到毫不相关的对象上。</p><p>这里有些避免发生类似问题的参考方法：</p><ul><li>避免对不同类型的对象使用同一个变量名</li></ul><p><strong>差</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>a</span> <span class=err>=</span> <span class=mi>1</span><span class=err>a</span> <span class=err>=</span> <span class=err>&#39;a</span> <span class=err>string&#39;def</span> <span class=err>a():pass</span>  <span class=err>#</span> <span class=err>实现代码</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>好</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>count</span> <span class=err>=</span> <span class=mi>1</span><span class=err>msg</span> <span class=err>=</span> <span class=err>&#39;a</span> <span class=err>string&#39;def</span> <span class=err>func():pass</span>  <span class=err>#</span> <span class=err>实现代码</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>使用简短的函数或方法能降低对不相关对象使用同一个名称的风险。即使是相关的不同 类型的对象，也更建议使用不同命名：</li></ul><p><strong>差</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>items</span> <span class=err>=</span> <span class=err>&#39;a</span> <span class=err>b</span> <span class=err>c</span> <span class=err>d&#39;</span>  <span class=err>#</span> <span class=err>首先指向字符串...</span>
</span></span><span class=line><span class=cl><span class=err>items</span> <span class=err>=</span> <span class=err>items.split(&#39;</span> <span class=err>&#39;)</span>  <span class=err>#</span> <span class=err>...变为列表</span>
</span></span><span class=line><span class=cl><span class=err>items</span> <span class=err>=</span> <span class=err>set(items)</span>  <span class=err>#</span> <span class=err>...再变为集合</span>
</span></span></code></pre></td></tr></table></div></div><p>重复使用命名对效率并没有提升：赋值时无论如何都要创建新的对象。然而随着复杂度的 提升，赋值语句被其他代码包括 &lsquo;if&rsquo; 分支和循环分开，使得更难查明指定变量的类型。 在某些代码的做法中，例如函数编程，推荐的是从不重复对同一个变量命名赋值。Java 内的实现方式是使用 &lsquo;final&rsquo; 关键字。Python并没有 &lsquo;final&rsquo; 关键字而且这与它的哲学 相悖。尽管如此，避免给同一个变量命名重复赋值仍是是个好的做法，并且有助于掌握 可变与不可变类型的概念。</p><a href=#可变和不可变类型><h1 id=可变和不可变类型><span class=hanchor arialabel=Anchor># </span>可变和不可变类型</h1></a><p>Python提供两种内置或用户定义的类型。</p><ul><li><p>可变类型允许内容的内部修改。典型的动态类型 包括列表与字典：列表都有可变方法，如 <strong><code>list.append()</code></strong> 和 <strong><code>list.pop()</code></strong>， 并且能就地修改。字典也是一样。</p></li><li><p>不可变类型没有修改自身内容的方法。比如，赋值为整数 6的变量 x 并没有 &ldquo;自增&rdquo; 方法，如果需要计算 x + 1，必须创建另一个整数变量并给其命名。</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>my_list</span> <span class=err>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=err>my_list</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=err>=</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl><span class=err>print</span> <span class=err>my_list</span>  <span class=err>#</span> <span class=p>[</span><span class=mi>4</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>]</span> <span class=err>&lt;-</span> <span class=err>原列表改变了</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>x</span> <span class=err>=</span> <span class=mi>6</span>
</span></span><span class=line><span class=cl><span class=err>x</span> <span class=err>=</span> <span class=err>x</span> <span class=err>+</span> <span class=mi>1</span>  <span class=err>#</span> <span class=err>x</span> <span class=err>变量是一个新的变量</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>这种差异导致的一个后果就是，可变类型是不 &lsquo;稳定 &lsquo;的，因而不能作为字典的键使用</strong>。合理地 使用可变类型与不可变类型有助于阐明代码的意图。例如与列表相似的不可变类型是元组， <strong>创建方式为</strong> <strong><code>(1, 2)</code>****。元组是不可修改的，并能作为字典的键使用。</strong></p><p>Python 中一个可能会让初学者惊讶的特性是：<strong>字符串是不可变类型。这意味着当需要组合一个 字符串时，将每一部分放到一个可变列表里，使用字符串时再组合 (&lsquo;join&rsquo;) 起来的做法更高效</strong>。 值得注意的是，使用列表推导的构造方式比在循环中调用 <code>append()</code> 来构造列表更好也更快。</p><p><strong>差</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>#</span> <span class=err>创建将</span><span class=mi>0</span><span class=err>到</span><span class=mi>19</span><span class=err>连接起来的字符串</span> <span class=err>(例</span> <span class=s2>&#34;012..1819&#34;</span><span class=err>)</span>
</span></span><span class=line><span class=cl><span class=err>nums</span> <span class=err>=</span> <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=err>for</span> <span class=err>n</span> <span class=err>in</span> <span class=err>range(</span><span class=mi>20</span><span class=err>):</span>
</span></span><span class=line><span class=cl>    <span class=err>nums</span> <span class=err>+=</span> <span class=err>str(n)</span>   <span class=err>#</span> <span class=err>慢且低效</span>
</span></span><span class=line><span class=cl><span class=err>print</span> <span class=err>nums</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>好</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>#</span> <span class=err>创建将</span><span class=mi>0</span><span class=err>到</span><span class=mi>19</span><span class=err>连接起来的字符串</span> <span class=err>(例</span> <span class=s2>&#34;012..1819&#34;</span><span class=err>)</span>
</span></span><span class=line><span class=cl><span class=err>nums</span> <span class=err>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=err>for</span> <span class=err>n</span> <span class=err>in</span> <span class=err>range(</span><span class=mi>20</span><span class=err>):</span>
</span></span><span class=line><span class=cl>    <span class=err>nums.append(str(n))</span>
</span></span><span class=line><span class=cl><span class=err>print</span> <span class=s2>&#34;&#34;</span><span class=err>.join(nums)</span>  <span class=err>#</span> <span class=err>更高效</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>更好</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>#</span> <span class=err>创建将</span><span class=mi>0</span><span class=err>到</span><span class=mi>19</span><span class=err>连接起来的字符串</span> <span class=err>(例</span> <span class=s2>&#34;012..1819&#34;</span><span class=err>)</span>
</span></span><span class=line><span class=cl><span class=err>nums</span> <span class=err>=</span> <span class=p>[</span><span class=err>str(n)</span> <span class=err>for</span> <span class=err>n</span> <span class=err>in</span> <span class=err>range(</span><span class=mi>20</span><span class=err>)</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=err>print</span> <span class=s2>&#34;&#34;</span><span class=err>.join(nums)</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>最好Best</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>#</span> <span class=err>创建将</span><span class=mi>0</span><span class=err>到</span><span class=mi>19</span><span class=err>连接起来的字符串</span> <span class=err>(例</span> <span class=s2>&#34;012..1819&#34;</span><span class=err>)</span>
</span></span><span class=line><span class=cl><span class=err>nums</span> <span class=err>=</span> <span class=err>map(str,</span> <span class=err>range(</span><span class=mi>20</span><span class=err>))</span>
</span></span><span class=line><span class=cl><span class=err>print</span> <span class=s2>&#34;&#34;</span><span class=err>.join(nums)</span>
</span></span></code></pre></td></tr></table></div></div><p>最后关于字符串的说明的一点是，使用 <code>join()</code> 并不总是最好的选择。比如当用预先 确定数量的字符串创建一个新的字符串时，使用加法操作符确实更快，但在上文提到的情况 下或添加到已存在字符串的情况下，使用 <code>join()</code> 是更好的选择。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>foo</span> <span class=err>=</span> <span class=err>&#39;foo&#39;</span>
</span></span><span class=line><span class=cl><span class=err>bar</span> <span class=err>=</span> <span class=err>&#39;bar&#39;</span>
</span></span><span class=line><span class=cl><span class=err>foobar</span> <span class=err>=</span> <span class=err>foo</span> <span class=err>+</span> <span class=err>bar</span>  <span class=err>#</span> <span class=err>好的做法</span>
</span></span><span class=line><span class=cl><span class=err>foo</span> <span class=err>+=</span> <span class=err>&#39;ooo&#39;</span>  <span class=err>#</span> <span class=err>不好的做法,</span> <span class=err>应该这么做:</span>
</span></span><span class=line><span class=cl><span class=err>foo</span> <span class=err>=</span> <span class=err>&#39;&#39;.join(</span><span class=p>[</span><span class=err>foo</span><span class=p>,</span> <span class=err>&#39;ooo&#39;</span><span class=p>]</span><span class=err>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=err>foo</span> <span class=err>=</span> <span class=err>&#39;foo&#39;</span> 
</span></span><span class=line><span class=cl><span class=err>bar</span> <span class=err>=</span> <span class=err>&#39;bar&#39;</span>
</span></span><span class=line><span class=cl><span class=err>foobar</span> <span class=err>=</span> <span class=err>&#39;%s%s&#39;</span> <span class=err>%</span> <span class=err>(foo,</span> <span class=err>bar)</span> <span class=err>#</span> <span class=err>可行</span>
</span></span><span class=line><span class=cl><span class=err>foobar</span> <span class=err>=</span> <span class=err>&#39;</span><span class=p>{</span><span class=err>0</span><span class=p>}{</span><span class=err>1</span><span class=p>}</span><span class=err>&#39;.format(foo,</span> <span class=err>bar)</span> <span class=err>#</span> <span class=err>更好</span>
</span></span><span class=line><span class=cl><span class=err>foobar</span> <span class=err>=</span> <span class=err>&#39;</span><span class=p>{</span><span class=err>foo</span><span class=p>}{</span><span class=err>bar</span><span class=p>}</span><span class=err>&#39;.format(foo=foo,</span> <span class=err>bar=bar)</span> <span class=err>#</span> <span class=err>最好</span>
</span></span></code></pre></td></tr></table></div></div></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://googoo-s.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by googoo-s using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://googoo-s.github.io/>Home</a></li><li><a href=https://github.com/googoo-s>GitHub</a></li></ul></footer></div></div></body></html>