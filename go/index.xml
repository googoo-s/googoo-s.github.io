<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Goes on</title><link>https://googoo-s.github.io/go/</link><description>Recent content in Goes on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://googoo-s.github.io/go/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/Channel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/Channel/</guid><description>Channel 的大小是否对性能有影响 Channel 的大小对性能会产生一定的影响。Channel 的大小是指 Channel 可以容纳的元素数量，可以通过在创建 Channel 时指定容量大小来控制。当 Channel 的容量较小时，可能会导致发送和接收操作的阻塞，从而影响程序的性能。而当 Channel 的容量较大时，可能会增加系统的内存开销，也可能会导致 Channel 中的元素被占用的时间较长，从而影响程序的响应性。
Channel 的内存模型是什么 在 Go 语言中，Channel 的内存模型是基于通信顺序进程（Communicating Sequential Processes，CSP）模型的。CSP 模型是一种并发计算模型，它将并发程序看作是一组顺序进程，这些进程通过 Channel 进行通信和同步。</description></item><item><title/><link>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/GMP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/GMP/</guid><description>P 和 M 的数量一定是 1：1 吗？如果一个 G 阻塞了会怎么样？ 不一定，M 必须持有 P 才可以执行代码，跟系统中的其他线程一样，M 也会被系统调用阻塞。P 的个数在启动程序时决定，默认情况下等于 CPU 的核数，可以使用环境变量 GOMAXPROCS 或在程序中使用 runtime.GOMAXPROCS ()方法指定 P 的个数。</description></item><item><title/><link>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/goroutine/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/goroutine/</guid><description>Go goroutine 的底层实现原理？ 概念 Goroutine 可以理解为一种 Go 语言的协程（轻量级线程），是 Go 支持高并发的基础，属于用户态的线程，由 Go runtime 管理而不是操作系统。
底层数据结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 type g struct { goid int64 // 唯一的goroutine的ID sched gobuf // goroutine切换时，用于保存g的上下文 stack stack // 栈 gopc // pc of go statement that created this goroutine startpc uintptr // pc of goroutine function .</description></item><item><title/><link>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/Map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/Map/</guid><description>Go Map 的查询复杂度 空间复杂度: 先我们不考虑因删除大量元素导致的空间浪费情况（这种情况现在 go 是留给程序员自己解决），只考虑一个持续增长状态的 map 的一个空间使用率：
由于溢出桶数量超过 hash 桶数量时会触发缩容，所以最坏的情况是数据被集中在一条链上，hash 表基本是空的，这时空间浪费 O (n)。
最好的情况下，数据均匀散列在 hash 表上，没有元素溢出，这时最好的空间复杂度就是扩散因子决定了，当前 go 的扩散因子由全局变量决定，即 loadFactorNum/loadFactorDen = 6.</description></item><item><title/><link>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/Mutex/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/Mutex/</guid><description>Mutex 几种状态 RWMutex 实现，RWMutex 注意事项 通过记录 readerCount 读锁的数量来进⾏控制，当有⼀个写锁的时候，会将读锁数量设置为负数 1&amp;laquo;30。⽬的是让新进⼊的读锁等待写锁之后释放通知读锁。同样的写锁也会等等待之前的读锁都释放完毕，才会开始进⾏后续的操作。而等写锁释放完之后，会将值重新加上 1&amp;laquo;30, 并通知刚才新进⼊的读锁 (rw. ReaderSem)，两者互相限制。
Go 当中同步锁有什么特点？作用是什么 当⼀个 Goroutine（协程）获得了 Mutex 后，其他 Goroutine（协程）就只能乖乖的等待，除非该 goroutine 释放了该 Mutex RWMutex 在读锁占⽤的情况下，会阻止写，但不阻止读 RWMutex 在写锁占用情况下，会阻止任何其他 goroutine（⽆论读和写）进来，整个锁相当于由该 goroutine 独占同步锁的作用是保证资源在使用时的独有性，不会因为并发而导致数据错乱，保证系统的稳定性。</description></item><item><title/><link>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid><description>内存管理 Golang 的内存模型，为什么小对象多了会造成 gc 压力。 通常小对象过多会导致 GC 三色法消耗过多的 GPU。优化思路是，减少对象分配。
Go 语言什么时候垃圾回收，写代码的时候如何减少对象分配 当 goroutine 申请新的内存管理单元时触发垃圾回收。写代码的时候如何减少对象分配，这是一个关于性能的问题，例如如果需要把数字转换成字符串，使用 strconv.Itoa () 比 fmt.Sprintf () 要快一倍左右。如果需要把数字转换成字符串，使用 strconv.</description></item><item><title/><link>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/%E5%B9%B6%E5%8F%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%85%AB%E8%82%A1%E6%96%87/%E5%B9%B6%E5%8F%91/</guid><description>下面哪个不是 Go 语言中的并发原语? Channel Mutex WaitGroup Semaphore 什么是 sync. Once Once 可以用来执行且仅仅执行一次动作，常常用于单例对象的初始化场景。
Once 常常用来初始化单例资源，或者并发访问只需初始化⼀次的共享资源，或者在测试的时候初始化⼀次测试资源。
Sync. Once 只暴露了⼀个⽅法 Do，你可以多次调⽤ Do ⽅法，但是只有第⼀次调⽤ Do 方法时 f 参数才会执行，这⾥的 f 是⼀个无参数无返回值的函数。</description></item><item><title/><link>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Channel/channel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Channel/channel/</guid><description/></item><item><title/><link>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/Leader%E9%80%89%E4%B8%BE%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E8%AF%BB%E5%86%99%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/Leader%E9%80%89%E4%B8%BE%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E8%AF%BB%E5%86%99%E9%94%81/</guid><description/></item><item><title/><link>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/%E9%98%9F%E5%88%97%E6%A0%85%E6%A0%8F%E5%92%8CSTM/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/%E9%98%9F%E5%88%97%E6%A0%85%E6%A0%8F%E5%92%8CSTM/</guid><description/></item><item><title/><link>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/atomic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/atomic/</guid><description/></item><item><title/><link>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/Cond/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/Cond/</guid><description/></item><item><title/><link>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/Context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/Context/</guid><description/></item><item><title/><link>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/map/</guid><description/></item><item><title/><link>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/Mutex/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/Mutex/</guid><description/></item><item><title/><link>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/Once/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/Once/</guid><description/></item><item><title/><link>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/Pool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/Pool/</guid><description/></item><item><title/><link>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/RWMutex/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/RWMutex/</guid><description/></item><item><title/><link>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/WaitGroup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/WaitGroup/</guid><description/></item><item><title/><link>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%BC%80%E7%AF%87%E8%AF%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%BC%80%E7%AF%87%E8%AF%8D/</guid><description>参考 https://time.geekbang.org/column/article/294849
为啥选择 Go Go 的简单高效 并发编程的便利性 GO 生态圈微服务框架的发展 学习 Go 并发编程的困难 无从下手 最优解选择困难 并发任务编排困难 程序 panic 或者死锁排查困难 负责并发问题处理困难 提升 GO 并发编程能力 知识主线 基础并发原语 Mutex RWMutex WaitGroup Cond Once map Pool Context 原子操作 atomic Channel channel 扩展并发原语 Semaphore-信号量 SingleFlight 和 CyclicBarrier-请求合并和循环栅栏 分布式并发原语 Leader选举互斥锁和读写锁 队列、栅栏和STM 学习主线 基础用法 Go 中有一个大的方向，就是任务编排用 Channel，共享资源保护用传统并发原语。 实现原理 易错场景 知名项目中的 bug 掌握武器 建立丰富的并发原语库 熟系每一种并发原语的实现机制和适用场景 创造自己需要的并发原语</description></item><item><title/><link>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%89%A9%E5%B1%95%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/Semaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%89%A9%E5%B1%95%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/Semaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F/</guid><description/></item><item><title/><link>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%89%A9%E5%B1%95%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/SingleFlight-%E5%92%8C-CyclicBarrier-%E8%AF%B7%E6%B1%82%E5%90%88%E5%B9%B6%E5%92%8C%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%89%A9%E5%B1%95%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/SingleFlight-%E5%92%8C-CyclicBarrier-%E8%AF%B7%E6%B1%82%E5%90%88%E5%B9%B6%E5%92%8C%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F/</guid><description/></item><item><title/><link>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%89%A9%E5%B1%95%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/GO/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%89%A9%E5%B1%95%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C/</guid><description/></item></channel></rss>