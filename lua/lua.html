<!DOCTYPE html>
<html lang="zh"><head><title>lua基础</title><meta charset="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Schibsted Grotesk:wght@400;700&amp;family=Source Sans Pro:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="lua基础"/><meta property="og:description" content="Lua 简介 Lua 是一个小巧的脚本语言。是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组并于 1993 年开发。其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。Lua 由标准 C 编写而成，几乎在所有操作系统和平台上都可以编译、运行。Lua ..."/><meta property="og:image" content="https://googoo-s.github.io/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../static/icon.png"/><meta name="description" content="Lua 简介 Lua 是一个小巧的脚本语言。是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组并于 1993 年开发。其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。Lua 由标准 C 编写而成，几乎在所有操作系统和平台上都可以编译、运行。Lua ..."/><meta name="generator" content="Quartz"/><link href="../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><script src="../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch("../static/contentIndex.json").then(data => data.json())</script></head><body data-slug="lua/lua"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title"><a href="..">googoo-s</a></h1><div class="darkmode"><input class="toggle" id="darkmode-toggle" type="checkbox" tabindex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35" xml:space="preserve"><title>暗色模式</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100" xml:space="preserve"><title>亮色模式</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div><div class="spacer mobile-only"></div><div class="search"><div id="search-icon"><p>搜索</p><div></div><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="搜索些什么" placeholder="搜索些什么"/><div id="search-layout" data-preview="true"></div></div></div></div><div class="explorer desktop-only"><button type="button" id="explorer" data-behavior="collapse" data-collapsed="collapsed" data-savestate="true" data-tree="[{&quot;path&quot;:&quot;docker&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;ElasticSearch&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;GO&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;GO/八股文&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;linux&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;lua&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Obsidian&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;工具&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;工具/emacs&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;工具/git&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;工具/maven&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;工具/msys2&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;资源&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;高可用&quot;,&quot;collapsed&quot;:true}]"><h1>探索</h1><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="explorer-content"><ul class="overflow" id="explorer-ul"><li><div class="folder-outer open"><ul style="padding-left:0;" class="content" data-folderul><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="docker"><button class="folder-button"><span class="folder-title">docker</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="docker"><li><a href="../docker/docker" data-for="docker/docker">docker</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="ElasticSearch"><button class="folder-button"><span class="folder-title">ElasticSearch</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="ElasticSearch"><li><a href="../ElasticSearch/KQL" data-for="ElasticSearch/KQL">KQL</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="GO"><button class="folder-button"><span class="folder-title">GO</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="GO"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="GO/八股文"><button class="folder-button"><span class="folder-title">八股文</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="GO/八股文"><li><a href="../GO/八股文/Context" data-for="GO/八股文/Context">Context</a></li><li><a href="../GO/八股文/Golang基础" data-for="GO/八股文/Golang基础">Golang基础</a></li><li><a href="../GO/八股文/Map-和Sync.map" data-for="GO/八股文/Map-和Sync.map">Map</a></li><li><a href="../GO/八股文/Slice" data-for="GO/八股文/Slice">Slice</a></li><li><a href="../GO/八股文/内存管理和GC" data-for="GO/八股文/内存管理和GC">内存管理</a></li><li><a href="../GO/八股文/并发" data-for="GO/八股文/并发">并发</a></li></ul></div></li></ul></div></li><li><div class="folder-outer "><ul style="padding-left:0;" class="content" data-folderul></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="linux"><button class="folder-button"><span class="folder-title">linux</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="linux"><li><a href="../linux/Linux-基础知识总结" data-for="linux/Linux-基础知识总结">Linux 基础知识总结</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="lua"><button class="folder-button"><span class="folder-title">lua</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="lua"><li><a href="../lua/lua" data-for="lua/lua">lua基础</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="Obsidian"><button class="folder-button"><span class="folder-title">Obsidian</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="Obsidian"><li><a href="../Obsidian/dataview" data-for="Obsidian/dataview">dataview</a></li><li><a href="../Obsidian/excalidraw" data-for="Obsidian/excalidraw">excalidraw</a></li><li><a href="../Obsidian/Front-Matter" data-for="Obsidian/Front-Matter">Front Matter</a></li><li><a href="../Obsidian/obsidian-overview" data-for="Obsidian/obsidian-overview">obsidian overview</a></li><li><a href="../Obsidian/Obsidian-plugin" data-for="Obsidian/Obsidian-plugin">Obsidian-plugin</a></li><li><a href="../Obsidian/publish" data-for="Obsidian/publish">publish</a></li><li><a href="../Obsidian/template" data-for="Obsidian/template">template</a></li><li><a href="../Obsidian/使用quartz发布obsidian--vault" data-for="Obsidian/使用quartz发布obsidian--vault">使用quartz发布obsidian  vault</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="工具"><button class="folder-button"><span class="folder-title">工具</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="工具"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="工具/emacs"><button class="folder-button"><span class="folder-title">emacs</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="工具/emacs"><li><a href="../工具/emacs/安装" data-for="工具/emacs/安装">安装</a></li><li><a href="../工具/emacs/快捷键" data-for="工具/emacs/快捷键">快捷键</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="工具/git"><button class="folder-button"><span class="folder-title">git</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="工具/git"><li><a href="../工具/git/git" data-for="工具/git/git">git</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="工具/maven"><button class="folder-button"><span class="folder-title">maven</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="工具/maven"><li><a href="../工具/maven/maven基础" data-for="工具/maven/maven基础">maven基础</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="工具/msys2"><button class="folder-button"><span class="folder-title">msys2</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="工具/msys2"><li><a href="../工具/msys2/pacman" data-for="工具/msys2/pacman">pacman</a></li><li><a href="../工具/msys2/再-msys-中使用fish" data-for="工具/msys2/再-msys-中使用fish">再 msys 中使用fish</a></li></ul></div></li><li><a href="../工具/工具" data-for="工具/工具">工具</a></li><li><a href="../工具/环境搭建" data-for="工具/环境搭建">环境搭建</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="资源"><button class="folder-button"><span class="folder-title">资源</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="资源"><li><a href="../资源/资源汇总" data-for="资源/资源汇总">资源汇总</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="高可用"><button class="folder-button"><span class="folder-title">高可用</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="高可用"><li><a href="../高可用/高可用" data-for="高可用/高可用">高可用</a></li></ul></div></li></ul></div></li><li id="explorer-end"></li></ul></div></div></div><div class="center"><div class="page-header"><div class="popover-hint"><nav class="breadcrumb-container" aria-label="breadcrumbs"><div class="breadcrumb-element"><a href="../">Home</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../lua/">lua</a><p> ❯ </p></div><div class="breadcrumb-element"><a href>lua基础</a></div></nav><h1 class="article-title">lua基础</h1><p show-comma="true" class="content-meta"><span>2023年7月31日</span><span>92分钟阅读</span></p><ul class="tags"><li><a href="../tags/lua" class="internal tag-link">lua</a></li><li><a href="../tags/NAME" class="internal tag-link">NAME</a></li></ul></div></div><article class="popover-hint"><h1 id="lua-简介">Lua 简介<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#lua-简介" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>Lua 是一个小巧的脚本语言。是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组并于 1993 年开发。<strong>其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能</strong>。Lua 由标准 C 编写而成，几乎在所有操作系统和平台上都可以编译、运行。Lua 并没有提供强大的库，这是由它的定位决定的。所以 Lua 不适合作为开发独立应用程序的语言。<strong>Lua 有一个同时进行的 JIT 项目，提供在特定平台上的即时编译功能</strong>。</p>
<ul>
<li>
<p><strong>Lua 脚本可以很容易的被 C/C++ 代码调用，也可以反过来调用 C/C++ 的函数，这使得 Lua 在应用程序中可以被广泛应用</strong>。</p>
</li>
<li>
<p><strong>不仅仅作为扩展脚本，也可以作为普通的配置文件，代替 XML、ini 等文件格式，并且更容易理解和维护</strong>。</p>
</li>
<li>
<p>标准 Lua 5.1 解释器由标准 C 编写而成，代码简洁优美，几乎在所有操作系统和平台上都可以编译和运行；</p>
</li>
<li>
<p>一个完整的标准 Lua 5.1 解释器不足 200 KB。而本书推荐使用的 LuaJIT 2 的代码大小也只有不足 500 KB</p>
</li>
<li>
<p>同时也支持大部分常见的体系结构。在目前所有脚本语言引擎中，LuaJIT 2 实现的速度应该算是最快的之一。这一切都决定了 Lua 是作为嵌入式脚本的最佳选择。</p>
</li>
</ul>
<p>Lua 语言的各个版本是不相兼容的。因此本书只介绍 Lua 5.1 语言，这是为标准 Lua 5.1 解释器和 LuaJIT 2 所共同支持的。LuaJIT 支持的对 Lua 5.1 向后兼容的 Lua 5.2 和 Lua 5.3 的特性，我们也会在方便的时候予以介绍。</p>
<h1 id="lua-环境搭建">Lua 环境搭建<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#lua-环境搭建" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p><a href="http://openresty.org/" class="external">http://openresty.org<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></p>
<h2 id="helloworld">Helloworld<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#helloworld" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Go" data-theme="github-light github-dark"><code data-language="Go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span># cat hello.lua</span></span>
<span data-line><span>print(&quot;hello world&quot;)</span></span>
<span data-line><span># luajit hello.lua</span></span>
<span data-line><span>hello world</span></span></code></pre></figure>
<h1 id="基本数据类型">基本数据类型<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#基本数据类型" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Go" data-theme="github-light github-dark"><code data-language="Go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>print(type(&quot;helloworld&quot;))</span></span>
<span data-line><span>print(type('helloworld'))</span></span>
<span data-line><span>print(type('true'))</span></span>
<span data-line><span>print(type(1))</span></span>
<span data-line><span>print(type(2.1))</span></span>
<span data-line><span>print(type(nil))</span></span>
<span data-line><span>function hello()</span></span>
<span data-line><span>    print(&quot;hello&quot;)</span></span>
<span data-line><span>end</span></span>
<span data-line><span>print(type(hello))</span></span></code></pre></figure>
<p>输出</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Go" data-theme="github-light github-dark"><code data-language="Go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>string</span></span>
<span data-line><span>string</span></span>
<span data-line><span>string</span></span>
<span data-line><span>number</span></span>
<span data-line><span>number</span></span>
<span data-line><span>nil</span></span>
<span data-line><span>function</span></span></code></pre></figure>
<h2 id="nil">Nil<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#nil" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Nil 是一种类型，Lua 将 nil 用于表示“无效值”。</p>
<ul>
<li>
<p>一个变量在第一次赋值前的默认值是 nil，</p>
</li>
<li>
<p>将 nil 赋予给一个全局变量就等同于删除它。</p>
</li>
</ul>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Go" data-theme="github-light github-dark"><code data-language="Go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local num</span></span>
<span data-line><span>print(num)        -->output:nil</span></span>
<span data-line> </span>
<span data-line><span>num = 100</span></span>
<span data-line><span>print(num)        -->output:100</span></span></code></pre></figure>
<h2 id="boolean-布尔">Boolean (布尔)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#boolean-布尔" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>布尔类型，可选值 true/false；</p>
<ul>
<li>
<p>Lua 中 nil 和 false 为“假”</p>
</li>
<li>
<p>其它所有值均为“真”。比如 0 和空字符串就是“真”；</p>
</li>
</ul>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Go" data-theme="github-light github-dark"><code data-language="Go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local a = true</span></span>
<span data-line><span>local b = 0</span></span>
<span data-line><span>local c = nil</span></span>
<span data-line><span>if a then</span></span>
<span data-line><span>    print(&quot;a&quot;)        -->output:a</span></span>
<span data-line><span>else</span></span>
<span data-line><span>    print(&quot;not a&quot;)    --这个没有执行</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>if b then</span></span>
<span data-line><span>    print(&quot;b&quot;)        -->output:b</span></span>
<span data-line><span>else</span></span>
<span data-line><span>    print(&quot;not b&quot;)    --这个没有执行</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>if c then</span></span>
<span data-line><span>    print(&quot;c&quot;)        --这个没有执行</span></span>
<span data-line><span>else</span></span>
<span data-line><span>    print(&quot;not c&quot;)    -->output:not c</span></span>
<span data-line><span>end</span></span></code></pre></figure>
<h2 id="number数字"><strong>number（数字）</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#number数字" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Number 类型用于表示实数，和 C/C++ 里面的 double 类型很类似。可以使用数学函数 math. Floor（向下取整）和 math. Ceil（向上取整）进行取整操作。</p>
<p>一般地，Lua 的 number 类型就是用双精度浮点数来实现的。值得一提的是，LuaJIT 支持所谓的“dual-number”（双数）模式，</p>
<ul>
<li>即 <strong>LuaJIT 会根据上下文用整型来存储整数，而用双精度浮点数来存放浮点数。</strong></li>
</ul>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Go" data-theme="github-light github-dark"><code data-language="Go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local order = 3.99</span></span>
<span data-line><span>local score = 98.01</span></span>
<span data-line><span>print(math.floor(order))   -->output:3</span></span>
<span data-line><span>print(math.ceil(score))    -->output:99</span></span>
<span data-line><span>print(9223372036854775807LL - 1)  -->output:9223372036854775806LL</span></span></code></pre></figure>
<h2 id="string字符串">String（字符串）<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#string字符串" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Lua 中有三种方式表示字符串:</p>
<ol>
<li>
<p>使用一对匹配的单引号。例：‘hello’。</p>
</li>
<li>
<p>使用一对匹配的双引号。例：“abclua”。</p>
</li>
<li>
<p>字符串还可以用一种长括号（即 <a href=".." class="internal" data-slug="index"></a>）括起来的方式定义</p>
<ol>
<li>
<p>我们把两个正的方括号（即[[）间插入 n 个等号定义为第 n 级正长括号。</p>
</li>
<li>
<p>0 级正的长括号写作 [[ ，一级正的长括号写作 [=[</p>
</li>
<li>
<p>反的长括号也作类似定义；举个例子，4 级反的长括号写作 ]====]</p>
</li>
<li>
<p><strong>一个长字符串可以由任何一级的正的长括号开始，而由第一个碰到的同级反的长括号结束</strong>。整个词法分析过程将<strong>不受分行限制，不处理任何转义符，并且忽略掉任何不同级别的长括号</strong></p>
</li>
</ol>
</li>
</ol>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local str1 = 'hello world'</span></span>
<span data-line><span>local str2 = &quot;hello lua&quot;</span></span>
<span data-line><span>local str3 = [[&quot;add\name&quot;,'hello']]</span></span>
<span data-line><span>local str4 = [=[string have a [[]].]=]</span></span>
<span data-line><span>local str5 = [=[asdfasd]=]</span></span>
<span data-line> </span>
<span data-line><span>print(str1)    -->output:hello world</span></span>
<span data-line><span>print(str2)    -->output:hello lua</span></span>
<span data-line><span>print(str3)    -->output:&quot;add\name&quot;,'hello'</span></span>
<span data-line><span>print(str4)    -->output:string have a [[]].</span></span>
<span data-line><span>print(str5)    -->output:asdfasd</span></span></code></pre></figure>
<p>在 Lua 实现中，Lua 字符串一般都会经历一个“内化”（intern）的过程，<strong>即两个完全一样的 Lua 字符串在 Lua 虚拟机中只会存储一份</strong>。每一个 Lua 字符串在创建时都会<strong>插入到 Lua 虚拟机内部的一个全局的哈希表</strong>中</p>
<ol>
<li>
<p>创建相同的 Lua 字符串并不会引入新的动态内存分配操作，所以相对便宜（但仍有全局哈希表查询的开销），</p>
</li>
<li>
<p>内容相同的 Lua 字符串不会占用多份存储空间，</p>
</li>
<li>
<p>已经创建好的 Lua 字符串之间进行相等性比较时是 <code>O(1)</code> 时间度的开销，而不是通常见到的 <code>O(n)</code>.</p>
</li>
</ol>
<h2 id="table-表">Table (表)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#table-表" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Table 类型实现了一种抽象的“关联数组”。“关联数组”是一种具有特殊索引方式的数组，</p>
<ul>
<li>索引通常是<strong>字符串（string）或者 number 类型，但也可以是除</strong> <strong><code>nil</code></strong> <strong>以外的任意类型的值</strong></li>
</ul>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Go" data-theme="github-light github-dark"><code data-language="Go" data-theme="github-light github-dark" style="display:grid;"><span data-line> </span>
<span data-line><span>local corp = {</span></span>
<span data-line><span>    web = &quot;www.google.com&quot;,   --索引为字符串，key = &quot;web&quot;,</span></span>
<span data-line><span>    --            value = &quot;www.google.com&quot;</span></span>
<span data-line><span>    telephone = &quot;12345678&quot;,   --索引为字符串</span></span>
<span data-line><span>    staff = {&quot;Jack&quot;, &quot;Scott&quot;, &quot;Gary&quot;}, --索引为字符串，值也是一个表</span></span>
<span data-line><span>    100876,              --相当于 [1] = 100876，此时索引为数字</span></span>
<span data-line><span>    --      key = 1, value = 100876</span></span>
<span data-line><span>    100191,              --相当于 [2] = 100191，此时索引为数字</span></span>
<span data-line><span>    [10] = 360,          --直接把数字索引给出</span></span>
<span data-line><span>    [&quot;city&quot;] = &quot;Beijing&quot; --索引为字符串</span></span>
<span data-line><span>}</span></span>
<span data-line> </span>
<span data-line><span>print(corp.web)               -->output:www.google.com</span></span>
<span data-line><span>print(corp[&quot;web&quot;])               -->output:www.google.com</span></span>
<span data-line><span>print(corp[&quot;telephone&quot;])      -->output:12345678</span></span>
<span data-line><span>print(corp[2])                -->output:100191</span></span>
<span data-line><span>print(corp[&quot;city&quot;])           -->output:&quot;Beijing&quot;</span></span>
<span data-line><span>print(corp.staff[1])          -->output:Jack</span></span>
<span data-line><span>print(corp[&quot;staff&quot;][1])          -->output:Jack</span></span>
<span data-line><span>print(corp[10])               -->output:360</span></span></code></pre></figure>
<p>在内部实现上，table 通常实现为一个哈希表、一个数组、或者两者的混合。具体的实现为何种形式，动态依赖于具体的 table 的键分布特点。</p>
<h2 id="function-函数">Function (函数)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#function-函数" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>在 Lua 中，<strong>函数</strong> 也是一种数据类型，函数可以存储在变量中，可以通过参数传递给其他函数，还可以作为其他函数的返回值</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Go" data-theme="github-light github-dark"><code data-language="Go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local function foo()</span></span>
<span data-line><span>    print(&quot;in the function&quot;)</span></span>
<span data-line><span>    --dosomething()</span></span>
<span data-line><span>    local x = 10</span></span>
<span data-line><span>    local y = 20</span></span>
<span data-line><span>    return x + y</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>local a = foo    --把函数赋给变量</span></span>
<span data-line> </span>
<span data-line><span>print(a())</span></span>
<span data-line> </span>
<span data-line><span>--output:</span></span>
<span data-line><span>--in the function</span></span>
<span data-line><span>--30</span></span>
<span data-line> </span>
<span data-line><span>function foo()</span></span>
<span data-line><span>end</span></span>
<span data-line><span>--等价于</span></span>
<span data-line> </span>
<span data-line><span>foo = function ()</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>local function foo()</span></span>
<span data-line><span>end</span></span>
<span data-line><span>-- 等价于</span></span>
<span data-line> </span>
<span data-line><span>local foo = function ()</span></span>
<span data-line><span>end</span></span></code></pre></figure>
<h1 id="表达式">表达式<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#表达式" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<h2 id="算术运算符">算术运算符<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#算术运算符" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>





































<div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>算术运算符</td><td>说明</td></tr><tr><td>+</td><td>加法</td></tr><tr><td>-</td><td>减法</td></tr><tr><td>*</td><td>乘法</td></tr><tr><td>/</td><td>除法</td></tr><tr><td>^</td><td>指数</td></tr><tr><td>%</td><td>取模</td></tr></tbody></table></div>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Go" data-theme="github-light github-dark"><code data-language="Go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>print(1 + 2)       -->打印 3</span></span>
<span data-line><span>print(5 / 10)      -->打印 0.5。 这是Lua不同于c语言的</span></span>
<span data-line><span>print(5.0 / 10)    -->打印 0.5。 浮点数相除的结果是浮点数</span></span>
<span data-line><span>-- print(10 / 0)   -->注意除数不能为0，计算的结果会出错</span></span>
<span data-line><span>print(2 ^ 10)      -->打印 1024。 求2的10次方</span></span>
<span data-line> </span>
<span data-line><span>local num = 1357</span></span>
<span data-line><span>print(num % 2)       -->打印 1</span></span>
<span data-line><span>print((num % 2) == 1) -->打印 true。 判断num是否为奇数</span></span></code></pre></figure>
<h2 id="关系运算符">关系运算符<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#关系运算符" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>





































<div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>关系运算符</td><td>说明</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>></td><td>大于</td></tr><tr><td><span>⇐</span></td><td>小于等于</td></tr><tr><td>>=</td><td>大于等于</td></tr><tr><td>==</td><td>等于</td></tr><tr><td>~=</td><td>不等于</td></tr></tbody></table></div>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Go" data-theme="github-light github-dark"><code data-language="Go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>print(1 &lt; 2)    -->打印 true</span></span>
<span data-line><span>print(1 == 2)   -->打印 false</span></span>
<span data-line><span>print(1 ~= 2)   -->打印 true</span></span>
<span data-line><span>local a, b = true, false</span></span>
<span data-line><span>print(a == b)  -->打印 false</span></span></code></pre></figure>
<ul>
<li>在使用“==”做等于判断时，要注意对于 table, userdate 和函数， Lua 是作引用比较的。也就是说，只有当两个变量引用同一个对象时，才认为它们相等</li>
</ul>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Go" data-theme="github-light github-dark"><code data-language="Go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local a = { x = 1, y = 0}</span></span>
<span data-line><span>local b = { x = 1, y = 0}</span></span>
<span data-line><span>if a == b then</span></span>
<span data-line><span>    print(&quot;a==b&quot;)</span></span>
<span data-line><span>else</span></span>
<span data-line><span>    print(&quot;a~=b&quot;)</span></span>
<span data-line><span>end</span></span>
<span data-line><span>---output:</span></span>
<span data-line><span>a~=b</span></span></code></pre></figure>
<ul>
<li>
<p>Lua 字符串总是会被“内化”，即相同内容的字符串只会被保存一份，因此 Lua 字符串之间的相等性比较可以简化为其内部存储地址的比较。</p>
</li>
<li>
<p>这意味着 Lua 字符串的相等性比较总是为 O (1)</p>
</li>
</ul>
<h2 id="逻辑运算符">逻辑运算符<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#逻辑运算符" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>

























<div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>逻辑运算符</td><td>说明</td></tr><tr><td>and</td><td>逻辑与</td></tr><tr><td>or</td><td>逻辑或</td></tr><tr><td>not</td><td>逻辑非</td></tr></tbody></table></div>
<p>在 c 语言中，and 和 or 只得到两个值 1 和 0，其中 1 表示真，0 表示假。而 Lua 中 and 的执行过程是这样的：</p>
<ul>
<li>
<p><code>a and b</code> 如果 a 为 nil，则返回 a，否则返回 b;</p>
</li>
<li>
<p><code>a or b</code> 如果 a 为 nil，则返回 b，否则返回 a。</p>
</li>
<li>
<p><strong>所有逻辑操作符将 false 和 nil 视作假，其他任何值视作真，对于 and 和 or，“短路求值”，对于 not，永远只返回 true 或者 false。</strong></p>
</li>
</ul>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Go" data-theme="github-light github-dark"><code data-language="Go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local c = nil</span></span>
<span data-line><span>local d = 0</span></span>
<span data-line><span>local e = 100</span></span>
<span data-line><span>print(c and d)  -->打印 nil</span></span>
<span data-line><span>print(c and e)  -->打印 nil</span></span>
<span data-line><span>print(d and e)  -->打印 100</span></span>
<span data-line><span>print(c or d)   -->打印 0</span></span>
<span data-line><span>print(c or e)   -->打印 100</span></span>
<span data-line><span>print(not c)    -->打印 true</span></span>
<span data-line><span>print(not d)    -->打印 false</span></span></code></pre></figure>
<h2 id="字符串连接">字符串连接<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#字符串连接" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Lua 中连接两个字符串，可以使用操作符“..”（两个点）</p>
<ul>
<li>
<p>如果其任意一个操作数是数字的话，Lua 会将这个数字转换成字符串。</p>
</li>
<li>
<p>注意，连接操作符只会创建一个新字符串，而不会改变原操作数</p>
</li>
<li>
<p>也可以使用 string 库函数 <code>string.format</code> 连接字符串</p>
</li>
</ul>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Go" data-theme="github-light github-dark"><code data-language="Go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>print(&quot;Hello &quot; .. &quot;World&quot;)    -->打印 Hello Worldprint(0 .. 1)                 -->打印 01</span></span>
<span data-line> </span>
<span data-line><span>str1 = string.format(&quot;%s-%s&quot;,&quot;hello&quot;,&quot;world&quot;)</span></span>
<span data-line><span>print(str1)              -->打印 hello-world</span></span>
<span data-line> </span>
<span data-line><span>str2 = string.format(&quot;%d-%s-%.2f&quot;,123,&quot;world&quot;,1.21)</span></span>
<span data-line><span>print(str2)              -->打印 123-world-1.21</span></span></code></pre></figure>
<p>于 Lua 字符串本质上是只读的，<strong>因此字符串连接运算符几乎总会创建一个新的（更大的）字符串</strong>。这意味着如果有很多这样的连接操作（比如在循环中使用 .. 来拼接最终结果），则性能损耗会非常大。在这种情况下，推荐使用 table 和 <code>table.concat()</code> 来进行很多字符串的拼接</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Go" data-theme="github-light github-dark"><code data-language="Go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local pieces = {}</span></span>
<span data-line><span>for i, elem in ipairs(my_list) do</span></span>
<span data-line><span>    pieces[i] = my_process(elem)</span></span>
<span data-line><span>end</span></span>
<span data-line><span>local res = table.concat(pieces)</span></span></code></pre></figure>
<p>上面的例子还可以使用 LuaJIT 独有的 <code>table.new</code> 来恰当地初始化 <code>pieces</code> 表的空间，以避免该表的动态生长。</p>
<h2 id="优先级">优先级<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#优先级" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>









































<div class="table-container"><table><thead><tr><th>f</th><th></th></tr></thead><tbody><tr><td>^</td><td></td></tr><tr><td>not # -</td><td></td></tr><tr><td>* / %</td><td></td></tr><tr><td>+ -</td><td></td></tr><tr><td>..</td><td></td></tr><tr><td>&lt; > <span>⇐</span> >= == ~=</td><td></td></tr><tr><td>and</td><td></td></tr><tr><td>or</td><td></td></tr></tbody></table></div>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Go" data-theme="github-light github-dark"><code data-language="Go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local a, b = 1, 2</span></span>
<span data-line><span>local x, y = 3, 4</span></span>
<span data-line><span>local i = 10</span></span>
<span data-line><span>local res = 0</span></span>
<span data-line><span>res = a + i &lt; b/2 + 1  -->等价于res =  (a + i) &lt; ((b/2) + 1)</span></span>
<span data-line><span>res = 5 + x^2*8        -->等价于res =  5 + ((x^2) * 8)</span></span>
<span data-line><span>res = a &lt; y and y &lt;=x  -->等价于res =  (a &lt; y) and (y &lt;= x)</span></span></code></pre></figure>
<h1 id="控制结构">控制结构<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#控制结构" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<h2 id="if-else">If-else<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#if-else" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<h3 id="单个-if-分支型"><strong>单个 if 分支型</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#单个-if-分支型" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Go" data-theme="github-light github-dark"><code data-language="Go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>x = 10</span></span>
<span data-line><span>if x > 0 then</span></span>
<span data-line><span>    print(&quot;x is a positive number&quot;)</span></span>
<span data-line><span>end</span></span></code></pre></figure>
<h3 id="两个分支-if-else-型"><strong>两个分支 if-else 型</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#两个分支-if-else-型" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Go" data-theme="github-light github-dark"><code data-language="Go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>x = 10</span></span>
<span data-line><span>if x > 0 then</span></span>
<span data-line><span>    print(&quot;x is a positive number&quot;)</span></span>
<span data-line><span>else</span></span>
<span data-line><span>    print(&quot;x is a non-positive number&quot;)</span></span>
<span data-line><span>end</span></span></code></pre></figure>
<h3 id="多个分支的-if-elseif-else">多个分支的 if-elseif-else<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#多个分支的-if-elseif-else" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Go" data-theme="github-light github-dark"><code data-language="Go" data-theme="github-light github-dark" style="display:grid;"><span data-line> </span>
<span data-line><span>score = 90</span></span>
<span data-line><span>if score == 100 then</span></span>
<span data-line><span>    print(&quot;Very good!Your score is 100&quot;)</span></span>
<span data-line><span>elseif score >= 60 then</span></span>
<span data-line><span>    print(&quot;Congratulations, you have passed it,your score greater or equal to 60&quot;)</span></span>
<span data-line><span>    --此处可以添加多个elseif</span></span>
<span data-line><span>else</span></span>
<span data-line><span>    print(&quot;Sorry, you do not pass the exam! &quot;)</span></span>
<span data-line><span>end</span></span></code></pre></figure>
<p>与 C 语言的不同之处是 else 与 if 是连在一起的，若将 else 与 if 写成 “else if” 则相当于在 else 里嵌套另一个 if 语句，如下代码：</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Go" data-theme="github-light github-dark"><code data-language="Go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>score = 0</span></span>
<span data-line><span>if score == 100 then</span></span>
<span data-line><span>    print(&quot;Very good!Your score is 100&quot;)</span></span>
<span data-line><span>elseif score >= 60 then</span></span>
<span data-line><span>    print(&quot;Congratulations, you have passed it,your score greater or equal to 60&quot;)</span></span>
<span data-line><span>else</span></span>
<span data-line><span>    if score > 0 then</span></span>
<span data-line><span>        print(&quot;Your score is better than 0&quot;)</span></span>
<span data-line><span>    else</span></span>
<span data-line><span>        print(&quot;My God, your score turned out to be 0&quot;)</span></span>
<span data-line><span>    end --与上一示例代码不同的是，此处要添加一个end</span></span>
<span data-line><span>end</span></span></code></pre></figure>
<h2 id="while">While<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#while" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Go" data-theme="github-light github-dark"><code data-language="Go" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>while 表达式 do</span></span>
<span data-line><span>    --body</span></span>
<span data-line><span>end</span></span></code></pre></figure>
<h2 id="repeat">Repeat<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#repeat" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Lua 中的 repeat 控制结构类似于其他语言（如：C++ 语言）中的 do-while，但是控制方式是刚好相反的。简单点说，<strong>执行 repeat 循环体后，直到 until 的条件为真时才结束</strong></p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>-- 以下代码会死循环</span></span>
<span data-line><span>x = 10</span></span>
<span data-line><span>repeat</span></span>
<span data-line><span>    print(x)</span></span>
<span data-line><span>until false</span></span></code></pre></figure>
<h2 id="for">For<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#for" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<h3 id="for-数字型"><strong>for 数字型</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#for-数字型" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>for var = begin, finish, step do</span></span>
<span data-line><span>    --body</span></span>
<span data-line><span>end</span></span></code></pre></figure>
<ol>
<li>
<p>Var 从 begin 变化到 finish，每次变化都以 step 作为步长递增 var</p>
</li>
<li>
<p>Begin、finish、step 三个表达式只会在循环开始时执行一次</p>
</li>
<li>
<p>第三个表达式 step 是可选的，默认为 1</p>
</li>
<li>
<p>控制变量 var 的作用域仅在 for 循环内，需要在外面控制，则需将值赋给一个新的变量</p>
</li>
<li>
<p>循环过程中不要改变控制变量的值，那样会带来不可预知的影响</p>
</li>
</ol>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>for i = 1, 5 do</span></span>
<span data-line><span>    print(i)</span></span>
<span data-line><span>end</span></span>
<span data-line><span>-- output:</span></span>
<span data-line><span>1</span></span>
<span data-line><span>2</span></span>
<span data-line><span>3</span></span>
<span data-line><span>4</span></span>
<span data-line><span>5</span></span>
<span data-line> </span>
<span data-line><span>for i = 1, 10, 2 do</span></span>
<span data-line><span>    print(i)</span></span>
<span data-line><span>end</span></span>
<span data-line><span>-- output:</span></span>
<span data-line><span>1</span></span>
<span data-line><span>3</span></span>
<span data-line><span>5</span></span>
<span data-line><span>7</span></span>
<span data-line><span>9</span></span></code></pre></figure>
<h2 id="for-泛型">For 泛型<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#for-泛型" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>泛型 for 循环通过一个迭代器（iterator）函数来遍历所有值：</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>-- 打印数组a的所有值local a = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;}</span></span>
<span data-line><span>for i, v in ipairs(a) do</span></span>
<span data-line><span>    print(&quot;index:&quot;, i, &quot; value:&quot;, v)</span></span>
<span data-line><span>end</span></span>
<span data-line><span>-- output:</span></span>
<span data-line><span>index:  1  value: a</span></span>
<span data-line><span>index:  2  value: b</span></span>
<span data-line><span>index:  3  value: c</span></span>
<span data-line><span>index:  4  value: d</span></span></code></pre></figure>
<p>Lua 的基础库提供了 <strong>ipairs，这是一个用于遍历数组的迭代器函数</strong>。在每次循环中，i 会被赋予一个索引值，同时 v 被赋予一个对应于该索引的数组元素值。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>-- 打印table t中所有的</span></span>
<span data-line><span>keyfor k in pairs(t) do</span></span>
<span data-line><span>    print(k)</span></span>
<span data-line><span>end</span></span></code></pre></figure>
<p>通过不同的迭代器，几乎可以遍历所有的东西，而且写出的代码极具可读性。标准库提供了几种迭代器，包括用于迭代文件中每行的（io. Lines）、迭代 table 元素的（pairs）、迭代数组元素的（ipairs）、迭代字符串中单词的（string. Gmatch）</p>
<p>泛型 for 循环与数字型 for 循环有两个相同点：</p>
<ol>
<li>
<p>循环变量是循环体的局部变量；</p>
</li>
<li>
<p>决不应该对循环变量作任何赋值。</p>
</li>
</ol>
<p>在 LuaJIT 2.1 中，<strong><code>ipairs()</code></strong> <strong>内建函数是可以被 JIT 编译的，而</strong> <strong><code>pairs()</code></strong> <strong>则只能被解释执行。因此在性能敏感的场景，应当合理安排数据结构，避免对哈希表进行遍历</strong></p>
<h2 id="break">Break<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#break" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>语句 <code>break</code> 用来终止 <code>while</code>、<code>repeat</code> 和 <code>for</code> 三种循环的执行，并跳出当前循环体，继续执行当前循环之后的语句</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>-- 计算最小的x,使从1到x的所有数相加和大于100</span></span>
<span data-line><span>sum = 0</span></span>
<span data-line><span>i = 1while true do</span></span>
<span data-line><span>    sum = sum + i</span></span>
<span data-line><span>    if sum > 100 then</span></span>
<span data-line><span>        break</span></span>
<span data-line><span>    end</span></span>
<span data-line><span>    i = i + 1</span></span>
<span data-line><span>end</span></span>
<span data-line><span>print(&quot;The result is &quot; .. i)  </span></span>
<span data-line><span>-->output:The result is 14</span></span></code></pre></figure>
<h2 id="return">Return<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#return" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><code>return</code> 主要用于从函数中返回结果，或者用于简单的结束一个函数的执行。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local function add(x, y)</span></span>
<span data-line><span>    return x + y</span></span>
<span data-line><span>    --print(&quot;add: I will return the result &quot; .. (x + y))</span></span>
<span data-line><span>    --因为前面有个return，若不注释该语句，则会报错</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>local function is_positive(x)</span></span>
<span data-line><span>    if x > 0 then</span></span>
<span data-line><span>        return x .. &quot; is positive&quot;</span></span>
<span data-line><span>    else</span></span>
<span data-line><span>        return x .. &quot; is non-positive&quot;</span></span>
<span data-line><span>    end</span></span>
<span data-line> </span>
<span data-line><span>    --由于return只出现在前面显式的语句块，所以此语句不注释也不会报错</span></span>
<span data-line><span>    --，但是不会被执行，此处不会产生输出</span></span>
<span data-line><span>    print(&quot;function end!&quot;)</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>local sum = add(10, 20)</span></span>
<span data-line><span>print(&quot;The sum is &quot; .. sum)  -->output:The sum is 30</span></span>
<span data-line><span>local answer = is_positive(-10)</span></span>
<span data-line><span>print(answer)                -->output:-10 is non-positive</span></span></code></pre></figure>
<h2 id="goto">Goto<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#goto" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>有了 <code>goto</code>，我们可以实现 <code>continue</code> 的功能：</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>for i=1, 3 do</span></span>
<span data-line><span>    if i &lt;= 2 then</span></span>
<span data-line><span>        print(i, &quot;yes continue&quot;)</span></span>
<span data-line><span>        goto continue</span></span>
<span data-line><span>    end</span></span>
<span data-line><span>    print(i, &quot; no continue&quot;)</span></span>
<span data-line> </span>
<span data-line><span>    ::continue::</span></span>
<span data-line><span>    print([[i'm end]])</span></span>
<span data-line><span>end</span></span></code></pre></figure>
<p>输出结果</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>$ luajit test.lua</span></span>
<span data-line><span>1   yes continue</span></span>
<span data-line><span>i'm end</span></span>
<span data-line><span>2   yes continue</span></span>
<span data-line><span>i'm end</span></span>
<span data-line><span>3    no continue</span></span>
<span data-line><span>i'm end</span></span></code></pre></figure>
<h1 id="函数">函数<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#函数" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<h2 id="定义">定义<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#定义" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>function function_name (arc)  -- arc 表示参数列表，函数的参数列表可以为空</span></span>
<span data-line><span>    -- body</span></span>
<span data-line><span>end</span></span></code></pre></figure>
<p>上面的语法定义了一个全局函数，名为 <code>function_name</code>. 全局函数本质上就是函数类型的值赋给了一个全局变量，即上面的语法等价于</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>function_name = function (arc)</span></span>
<span data-line><span>     -- body</span></span>
<span data-line><span>end</span></span></code></pre></figure>
<p>由于全局变量一般会污染全局名字空间，同时也有性能损耗（即查询全局环境表的开销），因此我们应当尽量使用“局部函数”，其记法是类似的，只是开头加上 <code>local</code> 修饰符：</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local function function_name (arc)</span></span>
<span data-line><span>    -- body</span></span>
<span data-line><span>end</span></span></code></pre></figure>
<p>定义函数</p>
<ol>
<li>
<p>利用名字来解释函数、变量的目的，使人通过名字就能看出来函数、变量的作用。</p>
</li>
<li>
<p>每个函数的长度要尽量控制在一个屏幕内，一眼可以看明白。</p>
</li>
<li>
<p>让代码自己说话，不需要注释最好。</p>
</li>
</ol>
<p>由于函数定义等价于变量赋值，我们也可以把函数名替换为某个 Lua 表的某个字段，例如</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local foo = {}</span></span>
<span data-line><span>function foo.pr()</span></span>
<span data-line><span>    print(&quot;ssss&quot;)</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>foo.pr()</span></span></code></pre></figure>
<h2 id="参数">参数<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#参数" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<h3 id="按值传递">按值传递<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#按值传递" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><strong>Lua 函数的参数大部分是按值传递的</strong>。<strong>当函数参数是 table 类型时，传递进来的是实际参数的引用</strong></p>
<p>值传递就是调用函数时，实参把它的值通过赋值运算传递给形参，然后形参的改变和实参就没有关系了。在这个过程中，实参是通过它在参数表中的位置与形参匹配起来的。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local function swap(a, b) --定义函数swap,函数内部进行交换两个变量的值</span></span>
<span data-line><span>    local temp = a</span></span>
<span data-line><span>    a = b</span></span>
<span data-line><span>    b = temp</span></span>
<span data-line><span>    print(a, b)</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>local x = &quot;hello&quot;</span></span>
<span data-line><span>local y = 20</span></span>
<span data-line><span>print(x, y)</span></span>
<span data-line><span>swap(x, y)    --调用swap函数</span></span>
<span data-line><span>print(x, y)   --调用swap函数后，x和y的值并没有交换</span></span>
<span data-line> </span>
<span data-line><span>-->output</span></span>
<span data-line><span>hello 20</span></span>
<span data-line><span>20  hello</span></span>
<span data-line><span>hello 20</span></span></code></pre></figure>
<p>在调用函数的时候，<strong>若形参个数和实参个数不同时，Lua 会自动调整实参个数</strong>。调整规则：</p>
<ul>
<li>
<p>若实参个数大于形参个数，从左向右，多余的实参被忽略；</p>
</li>
<li>
<p>若实参个数小于形参个数，从左向右，<strong>没有被实参初始化的形参会被初始化为 nil</strong></p>
</li>
</ul>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local function fun1(a, b)       --两个形参，多余的实参被忽略掉</span></span>
<span data-line><span>    print(a, b)</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>local function fun2(a, b, c, d) --四个形参，没有被实参初始化的形参，用nil初始化</span></span>
<span data-line><span>    print(a, b, c, d)</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>local x = 1</span></span>
<span data-line><span>local y = 2</span></span>
<span data-line><span>local z = 3</span></span>
<span data-line> </span>
<span data-line><span>fun1(x, y, z)         -- z被函数fun1忽略掉了，参数变成 x, y</span></span>
<span data-line><span>fun2(x, y, z)         -- 后面自动加上一个nil，参数变成 x, y, z, nil</span></span>
<span data-line> </span>
<span data-line><span>-->output</span></span>
<span data-line><span>1   2</span></span>
<span data-line><span>1   2   3   nil</span></span></code></pre></figure>
<h3 id="变长参数">变长参数<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#变长参数" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>其实 Lua 还支持变长参数。若形参为 <code>...</code>，表示该函数可以接收不同长度的参数。访问参数的时候也要使用 <code>...</code></p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line> </span>
<span data-line><span>local function func( ... )                -- 形参为 ... ,表示函数采用变长参数</span></span>
<span data-line> </span>
<span data-line><span>    local temp = {...}                     -- 访问的时候也要使用 ...</span></span>
<span data-line><span>    local ans = table.concat(temp, &quot; &quot;)    -- 使用 table.concat 库函数对数</span></span>
<span data-line><span>    -- 组内容使用 &quot; &quot; 拼接成字符串。</span></span>
<span data-line><span>    print(ans)</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>func(1, 2)        -- 传递了两个参数</span></span>
<span data-line><span>func(1, 2, 3, 4)  -- 传递了四个参数</span></span>
<span data-line> </span>
<span data-line><span>-->output</span></span>
<span data-line><span>1 2</span></span>
<span data-line> </span>
<span data-line><span>1 2 3 4</span></span></code></pre></figure>
<h3 id="具名参数"><strong>具名参数</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#具名参数" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>Lua 还支持通过名称来指定实参，这时候要把所有的实参组织到一个 table 中，并将这个 table 作为唯一的实参传给函数。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local function change(arg) -- change 函数，改变长方形的长和宽，使其各增长一倍</span></span>
<span data-line><span>  arg.width = arg.width * 2</span></span>
<span data-line><span>  arg.height = arg.height * 2return arg</span></span>
<span data-line><span>endlocal rectangle = { width = 20, height = 15 }</span></span>
<span data-line><span>print(&quot;before change:&quot;, &quot;width  =&quot;, rectangle.width,</span></span>
<span data-line><span>                        &quot;height =&quot;, rectangle.height)</span></span>
<span data-line><span>rectangle = change(rectangle)</span></span>
<span data-line><span>print(&quot;after  change:&quot;, &quot;width  =&quot;, rectangle.width,</span></span>
<span data-line><span>                        &quot;height =&quot;, rectangle.height)</span></span>
<span data-line> </span>
<span data-line><span>-->output</span></span>
<span data-line><span>before change: width = 20  height =  15</span></span>
<span data-line><span>after  change: width = 40  height =  30</span></span></code></pre></figure>
<h3 id="按引用传递">按引用传递<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#按引用传递" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><strong>当函数参数是 table 类型时，传递进来的是实际参数的引用</strong>，此时在函数内部对该 table 所做的修改，会直接对调用者所传递的实际参数生效，而无需自己返回结果和让调用者进行赋值</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>function change(arg) --change函数，改变长方形的长和宽，使其各增长一倍</span></span>
<span data-line><span>  arg.width = arg.width * 2  --表arg不是表rectangle的拷贝，他们是同一个表</span></span>
<span data-line><span>  arg.height = arg.height * 2end                  -- 没有return语句了local rectangle = { width = 20, height = 15 }</span></span>
<span data-line><span>print(&quot;before change:&quot;, &quot;width = &quot;, rectangle.width,</span></span>
<span data-line><span>                        &quot; height = &quot;, rectangle.height)</span></span>
<span data-line><span>change(rectangle)</span></span>
<span data-line><span>print(&quot;after change:&quot;, &quot;width = &quot;, rectangle.width,</span></span>
<span data-line><span>                       &quot; height =&quot;, rectangle.height)</span></span>
<span data-line> </span>
<span data-line><span>--> output</span></span>
<span data-line><span>before change: width = 20  height = 15</span></span>
<span data-line><span>after  change: width = 40  height = 30</span></span></code></pre></figure>
<h2 id="函数返回值">函数返回值<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#函数返回值" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Lua 具有一项与众不同的特性，允许函数返回多个值。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local function swap(a, b)   </span></span>
<span data-line><span>    -- 定义函数 swap，实现两个变量交换值</span></span>
<span data-line><span>    return b, a              </span></span>
<span data-line><span>    -- 按相反顺序返回变量的值</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>local x = 1</span></span>
<span data-line><span>local y = 20</span></span>
<span data-line><span>x, y = swap(x, y)           -- 调用 swap 函数</span></span>
<span data-line><span>print(x, y)                 --> output   20     1</span></span></code></pre></figure>
<p>当函数返回值的个数和接收返回值的变量的个数不一致时，Lua 也会自动调整参数个数调整规则：</p>
<ul>
<li>
<p>若返回值个数大于接收变量的个数，多余的返回值会被忽略掉；</p>
</li>
<li>
<p>若返回值个数小于参数个数，从左向右，没有被返回值初始化的变量会被初始化为 nil。</p>
</li>
</ul>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>function init()             </span></span>
<span data-line><span>    --init 函数 返回两个值 1 和 &quot;lua&quot;</span></span>
<span data-line><span>    return 1, &quot;lua&quot;</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>x = init()</span></span>
<span data-line><span>print(x)</span></span>
<span data-line> </span>
<span data-line><span>x, y, z = init()</span></span>
<span data-line><span>print(x, y, z)</span></span>
<span data-line> </span>
<span data-line><span>--output</span></span>
<span data-line><span>1</span></span>
<span data-line><span>1 lua nil</span></span></code></pre></figure>
<p>当一个函数有一个以上返回值，且函数调用不是一个列表表达式的最后一个元素，那么函数调用只会产生一个返回值, 也就是第一个返回值。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local function init()       -- init 函数 返回两个值 1 和 &quot;lua&quot;</span></span>
<span data-line><span>    return 1, &quot;lua&quot;</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>local x, y, z = init(), 2   -- init 函数的位置不在最后，此时只返回 1</span></span>
<span data-line><span>print(x, y, z)              -->output  1  2  nil</span></span>
<span data-line> </span>
<span data-line><span>local a, b, c = 2, init()   -- init 函数的位置在最后，此时返回 1 和 &quot;lua&quot;</span></span>
<span data-line><span>print(a, b, c)              -->output  2  1  lua</span></span></code></pre></figure>
<p>函数调用的实参列表也是一个列表表达式。考虑下面的例子：</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local function init()</span></span>
<span data-line><span>    return 1, &quot;lua&quot;</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>print(init(), 2)   -->output  1  2</span></span>
<span data-line><span>print(2, init())   -->output  2  1  lua</span></span></code></pre></figure>
<p>如果你确保只取函数返回值的第一个值，可以使用括号运算符</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local function init()</span></span>
<span data-line><span>    return 1, &quot;lua&quot;</span></span>
<span data-line><span>end</span></span>
<span data-line><span>print((init()), 2)   -->output  1  2</span></span>
<span data-line><span>print(2, (init()))   -->output  2  1</span></span></code></pre></figure>
<p><strong>值得一提的是，如果实参列表中某个函数会返回多个值，同时调用者又没有显式地使用括号运算符来筛选和过滤，则这样的表达式是不能被 LuaJIT 2 所 JIT 编译的，而只能被解释执行。</strong></p>
<h1 id="全动态函数调用">全动态函数调用<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#全动态函数调用" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>调用回调函数，并把一个数组参数作为回调函数的参数。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local args = {...} or {}</span></span>
<span data-line><span>method_name(unpack(args, 1, table.maxn(args)))</span></span></code></pre></figure>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local function run(x, y)</span></span>
<span data-line><span>    print('run', x, y)</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>local function attack(targetId)</span></span>
<span data-line><span>    print('targetId', targetId)</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>local function do_action(method, ...)</span></span>
<span data-line><span>    local args = {...} or {}</span></span>
<span data-line><span>    method(unpack(args, 1, table.maxn(args)))</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>do_action(run, 1, 2)         -- output: run 1 2</span></span>
<span data-line><span>do_action(attack, 1111)      -- output: targetId    1111</span></span></code></pre></figure>
<h1 id="模块">模块<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#模块" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>从 Lua 5.1 语言添加了对模块和包的支持。一<strong>个 Lua 模块的数据结构是用一个 Lua 值（通常是一个 Lua 表或者 Lua 函数）</strong>。<strong>一个 Lua 模块代码就是一个会返回这个 Lua 值的代码块</strong></p>
<ul>
<li>
<p>可以使用内建函数 <code>require()</code> 来加载和缓存模块。</p>
</li>
<li>
<p>简单的说，一个代码模块就是一个程序库，可以通过 <code>require</code> 来加载。<strong>模块加载后的结果通过是一个 Lua table</strong></p>
</li>
<li>
<p><strong>这个表就像是一个命名空间</strong>，其内容就是模块中导出的所有东西，<strong>比如函数和变量</strong>。<code>require</code> 函数会返回 Lua 模块加载后的结果，即用于表示该 Lua 模块的 Lua 值。</p>
</li>
</ul>
<p>Lua 提供了一个名为 <code>require</code> 的函数用来加载模块。<strong>要加载一个模块，只需要简单地调用</strong> <strong><code>require</code></strong> <strong>“file” 就可以了，file 指模块所在的文件名</strong>。这个调用会返回一个由模块函数组成的 table，并且还会定义一个包含该 table 的全局变量。</p>
<p>在 Lua 中创建一个模块最简单的方法是：<strong>创建一个 table，并将所有需要导出的函数放入其中，最后返回这个 table 就可以了。相当于将导出的函数作为 table 的一个字段，在 Lua 中函数是第一类值，提供了天然的优势。</strong></p>
<ul>
<li>创建 my. Lua</li>
</ul>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local _M = {}</span></span>
<span data-line> </span>
<span data-line><span>local function get_name()</span></span>
<span data-line><span>    return &quot;Lucy&quot;</span></span>
<span data-line><span>    end</span></span>
<span data-line><span>function _M.greeting()</span></span>
<span data-line><span>    print(&quot;hello &quot; .. get_name())</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>return _M</span></span></code></pre></figure>
<ul>
<li>把下面代码保存在文件 main. Lua 中，然后执行 main. Lua，调用上述模块。</li>
</ul>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local my_module = require(&quot;my&quot;)</span></span>
<span data-line><span>my_module.greeting()     -->output: hello Lucy</span></span></code></pre></figure>
<blockquote>
<ul>
<li>
<p>对于需要导出给外部使用的公共模块，处于安全考虑，<strong>是要避免全局变量的出现</strong>。我们可以使用 lj-releng 或 luacheck 工具完成全局变量的检测。至于如何做，到后面再讲。</p>
</li>
<li>
<p>另一个要注意的是，由于在 LuaJIT 中，<strong>require 函数内不能进行上下文切换</strong>，<strong>所以不能够在模块的顶级上下文中调用 cosocket 一类的 API</strong>。否则会报 <code>attempt to yield across C-call boundary</code> 错误。</p>
</li>
</ul>
</blockquote>
<h1 id="string">String<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#string" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>Lua 字符串总是由字节构成的。Lua 核心并不尝试理解具体的字符集编码（比如 GBK 和 UTF-8 这样的多字节字符编码）</p>
<p>Lua 字符串内部用来标识各个组成字节的下标是从 1 开始的，这不同于像 C 和 Perl 这样的编程语言。这样数字符串位置的时候再也不用调整，对于非专业的开发者来说可能也是一个好事情，<strong>string.Sub (str, 3, 7) 直接表示从第三个字符开始到第七个字符（含）为止的子串。</strong></p>
<h2 id="stringbyte-s--i--j-"><strong>string.Byte (s [, i [, j ]])</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#stringbyte-s--i--j-" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>返回字符 s[i]、s[i + 1]、s[i + 2]、······、s[j] 所对应的 ASCII 码</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>print(string.byte(&quot;abc&quot;, 1, 3))</span></span>
<span data-line><span>print(string.byte(&quot;abc&quot;, 3)) -- 缺少第三个参数，第三个参数默认与第二个相同，此时为 3</span></span>
<span data-line><span>print(string.byte(&quot;abc&quot;))    -- 缺少第二个和第三个参数，此时这两个参数都默认为 1</span></span>
<span data-line> </span>
<span data-line><span>-->output</span></span>
<span data-line><span>97    98    99</span></span>
<span data-line><span>99</span></span>
<span data-line><span>97</span></span></code></pre></figure>
<h2 id="string-char-"><strong>string. Char (…)</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#string-char-" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>接收 0 个或更多的整数（整数范围：0~255），返回这些整数所对应的 ASCII 码字符组成的字符串。当参数为空时，默认是一个 0。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>print(string.char(96, 97, 98))</span></span>
<span data-line><span>print(string.char())        -- 参数为空，默认是一个0，-- 你可以用string.byte(string.char())测试一下print(string.char(65, 66))</span></span>
<span data-line> </span>
<span data-line><span>--> output</span></span>
<span data-line><span>`ab</span></span>
<span data-line> </span>
<span data-line><span>AB</span></span></code></pre></figure>
<h2 id="stringupper-s"><strong>string.Upper (s)</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#stringupper-s" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>接收一个字符串 s，返回一个把所有小写字母变成大写字母的字符串。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>print(string.upper(&quot;Hello Lua&quot;))  -->output  HELLO LUA</span></span></code></pre></figure>
<h2 id="stringlower-s"><strong>string.Lower (s)</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#stringlower-s" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>接收一个字符串 s，返回一个把所有大写字母变成小写字母的字符串。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>print(string.lower(&quot;Hello Lua&quot;))  -->output   hello lua</span></span></code></pre></figure>
<h2 id="stringlen-s"><strong>string.Len (s)</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#stringlen-s" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>接收一个字符串，返回它的长度。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>print(string.len(&quot;hello lua&quot;)) -->output  9</span></span></code></pre></figure>
<p>使用此函数是不推荐的。应当总是使用 <code>#</code> 运算符来获取 Lua 字符串的长度</p>
<h2 id="stringfind-s-p--init--plain"><strong>string.Find (s, p [, init [, plain]])</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#stringfind-s-p--init--plain" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>在 s 字符串中第一次匹配 p 字符串。若匹配成功，则返回 p 字符串在 s 字符串中出现的开始位置和结束位置；若匹配失败，则返回 nil,</p>
<p>第三个参数第三个参数 init 默认为 1，并且可以为负整数，</p>
<p>当 init 为负数时，表示从 s 字符串的 string.Len (s) + init + 1 索引处开始向后匹配字符串 p 。</p>
<p>第四个参数默认为 false，当其为 true 时，只会把 p 看成一个字符串对待。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local find = string.find</span></span>
<span data-line><span>print(find(&quot;abc cba&quot;, &quot;ab&quot;))</span></span>
<span data-line><span>print(find(&quot;abc cba&quot;, &quot;ab&quot;, 2))     -- 从索引为2的位置开始匹配字符串：ab</span></span>
<span data-line><span>print(find(&quot;abc cba&quot;, &quot;ba&quot;, -1))    -- 从索引为7的位置开始匹配字符串：ba</span></span>
<span data-line><span>print(find(&quot;abc cba&quot;, &quot;ba&quot;, -3))    -- 从索引为5的位置开始匹配字符串：ba</span></span>
<span data-line><span>print(find(&quot;abc cba&quot;, &quot;(%a+)&quot;, 1))  -- 从索引为1处匹配最长连续且只含字母的字符串</span></span>
<span data-line><span>print(find(&quot;abc cba&quot;, &quot;(%a+)&quot;, 1, true)) --从索引为1的位置开始匹配字符串：(%a+)</span></span>
<span data-line> </span>
<span data-line><span>-->output</span></span>
<span data-line><span>1   2</span></span>
<span data-line><span>nil</span></span>
<span data-line><span>nil</span></span>
<span data-line><span>6   7</span></span>
<span data-line><span>1   3   abc</span></span>
<span data-line><span>nil</span></span></code></pre></figure>
<h2 id="stringformat-formatstring-"><strong>string.Format (formatstring, …)</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#stringformat-formatstring-" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>按照格式化参数 formatstring，返回后面 <code>...</code> 内容的格式化版本</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>print(string.format(&quot;%.4f&quot;, 3.1415926))     -- 保留4位小数</span></span>
<span data-line><span>print(string.format(&quot;%d %x %o&quot;, 31, 31, 31))-- 十进制数31转换成不同进制</span></span>
<span data-line><span>d = 29; m = 7; y = 2015                     -- 一行包含几个语句，用；分开</span></span>
<span data-line><span>print(string.format(&quot;%s %02d/%02d/%d&quot;, &quot;today is:&quot;, d, m, y))</span></span>
<span data-line> </span>
<span data-line><span>-->output</span></span>
<span data-line><span>3.1416</span></span>
<span data-line><span>31 1f 37</span></span>
<span data-line><span>today is: 29/07/2015</span></span></code></pre></figure>
<h2 id="stringmatch-s-p--init"><strong>string.Match (s, p [, init])</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#stringmatch-s-p--init" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>在字符串 s 中匹配（模式）字符串 p，若匹配成功，则返回目标字符串中与模式匹配的子串；否则返回 nil。第三个参数 init 默认为 1，并且可以为负整数，当 init 为负数时，表示从 s 字符串的 string.Len (s) + init + 1 索引处开始向后匹配字符串 p。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>print(string.match(&quot;hello lua&quot;, &quot;lua&quot;))</span></span>
<span data-line><span>print(string.match(&quot;lua lua&quot;, &quot;lua&quot;, 2))  --匹配后面那个luaprint(string.match(&quot;lua lua&quot;, &quot;hello&quot;))</span></span>
<span data-line><span>print(string.match(&quot;today is 27/7/2015&quot;, &quot;%d+/%d+/%d+&quot;))</span></span>
<span data-line> </span>
<span data-line><span>-->output</span></span>
<span data-line><span>lua</span></span>
<span data-line><span>lua</span></span>
<span data-line><span>nil27/7/2015</span></span></code></pre></figure>
<h2 id="stringgmatch-s-p"><strong>string.Gmatch (s, p)</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#stringgmatch-s-p" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>返回一个迭代器函数，通过这个迭代器函数可以遍历到在字符串 s 中出现模式串 p 的所有地方。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>s = &quot;hello world from Lua&quot;</span></span>
<span data-line><span>for w in string.gmatch(s, &quot;%a+&quot;) do  --匹配最长连续且只含字母的字符串</span></span>
<span data-line><span>    print(w)</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>-->output</span></span>
<span data-line><span>hello</span></span>
<span data-line><span>world</span></span>
<span data-line><span>from</span></span>
<span data-line><span>Lua</span></span>
<span data-line> </span>
<span data-line> </span>
<span data-line><span>t = {}</span></span>
<span data-line><span>s = &quot;from=world, to=Lua&quot;</span></span>
<span data-line><span>for k, v in string.gmatch(s, &quot;(%a+)=(%a+)&quot;) do  --匹配两个最长连续且只含字母的</span></span>
<span data-line><span>    t[k] = v                                    --字符串，它们之间用等号连接</span></span>
<span data-line><span>end</span></span>
<span data-line><span>for k, v in pairs(t) do</span></span>
<span data-line><span>    print (k,v)</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>-->output</span></span>
<span data-line><span>to      Lua</span></span>
<span data-line><span>from    worl</span></span></code></pre></figure>
<h2 id="stringrep-s-n"><strong>string.Rep (s, n)</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#stringrep-s-n" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>返回字符串 s 的 n 次拷贝。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>print(string.rep(&quot;abc&quot;, 3)) </span></span>
<span data-line> </span>
<span data-line><span>--拷贝3次&quot;abc&quot;-->output  abcabcabc</span></span></code></pre></figure>
<h2 id="stringsub-s-i--j"><strong>string.Sub (s, i [, j])</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#stringsub-s-i--j" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>返回字符串 s 中，索引 i 到索引 j 之间的子字符串。当 j 缺省时，默认为 -1，也就是字符串 s 的最后位置。I 可以为负数。当索引 i 在字符串 s 的位置在索引 j 的后面时，将返回一个空字符串。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>print(string.sub(&quot;Hello Lua&quot;, 4, 7))</span></span>
<span data-line><span>print(string.sub(&quot;Hello Lua&quot;, 2))</span></span>
<span data-line><span>print(string.sub(&quot;Hello Lua&quot;, 2, 1))    --看到返回什么了吗print(string.sub(&quot;Hello Lua&quot;, -3, -1))</span></span>
<span data-line> </span>
<span data-line><span>-->output</span></span>
<span data-line><span>lo L</span></span>
<span data-line><span>ello Lua</span></span>
<span data-line> </span>
<span data-line><span>Lua</span></span></code></pre></figure>
<h2 id="stringgsub-s-p-r--n"><strong>string.Gsub (s, p, r [, n])</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#stringgsub-s-p-r--n" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>将目标字符串 s 中所有的子串 p 替换成字符串 r。可选参数 n，表示限制替换次数。返回值有两个，第一个是被替换后的字符串，第二个是替换了多少次。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>print(string.gsub(&quot;Lua Lua Lua&quot;, &quot;Lua&quot;, &quot;hello&quot;))</span></span>
<span data-line><span>print(string.gsub(&quot;Lua Lua Lua&quot;, &quot;Lua&quot;, &quot;hello&quot;, 2)) --指明第四个参数-->output</span></span>
<span data-line><span>hello hello hello   3</span></span>
<span data-line><span>hello hello Lua     2</span></span></code></pre></figure>
<h2 id="string-reverse-s"><strong>string. Reverse (s)</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#string-reverse-s" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>接收一个字符串 s，返回这个字符串的反转</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>print(string.reverse(&quot;Hello Lua&quot;))  --> output: auL olleH</span></span></code></pre></figure>
<h1 id="table">Table<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#table" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<h2 id="下标从-1-开始"><strong>下标从 1 开始</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#下标从-1-开始" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>数组下标从 1 开始计数。</p>
<p>而 Lua 最初设计是一种类似 XML 的数据描述语言，所以索引（index）反应的是数据在里面的位置，而不是偏移量。</p>
<p>在初始化一个数组的时候，<strong>若不显式地用键值对方式赋值，则会默认用数字作为下标</strong>，从 1 开始。由于在 <em>Lua</em> 内部实际采用哈希表和数组分别保存键值对、普通值，所以不推荐混合使用这两种赋值方式</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local color={first=&quot;red&quot;, &quot;blue&quot;, third=&quot;green&quot;, &quot;yellow&quot;}</span></span>
<span data-line><span>print(color[&quot;first&quot;])                 --> output: red</span></span>
<span data-line><span>print(color[1])                       --> output: blue</span></span>
<span data-line><span>print(color[&quot;third&quot;])                 --> output: green</span></span>
<span data-line><span>print(color[2])                       --> output: yellow</span></span>
<span data-line><span>print(color[3])                       --> output: nil</span></span></code></pre></figure>
<ul>
<li>
<p><strong>当我们把 table 当作栈或者队列使用的时候，容易犯错，追加到 table 的末尾用的是</strong> <strong><code>s[#s+1] = something</code>****, 而不是</strong> <strong><code>s[#s] = something</code></strong></p>
</li>
<li>
<p>而且如果这个 something 是一个 nil 的话**，会导致这一次压栈（或者入队列）没有存入任何东西**， s 的值没有变</p>
</li>
<li>
<p>如果 <code>s = { 1, 2, 3, 4, 5, 6 }</code>，你令 <code>s[4] = nil</code>， s 会令你“匪夷所思”地变成 3。</p>
</li>
</ul>
<h2 id="table-getn-获取长度"><strong>table. Getn 获取长度</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#table-getn-获取长度" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>取长度操作符写作一元操作 。字符串的长度是它的字节数（就是以一个字符一个字节计算的字符串长度）</p>
<ul>
<li>
<p>对于常规的数组，里面从 1 到 n 放着一些非空的值的时候，它的长度就精确的为 n，即最后一个值的下标</p>
</li>
<li>
<p>如果数组有一个“空洞”（<strong>就是说，nil 值被夹在非空值之间</strong>），<strong>那么 t 可能是指向任何一个是 nil 值的前一个位置的下标</strong></p>
</li>
<li>
<p>这也就说明对于有“空洞”的情况，table 的长度存在一定的 <strong>不可确定性</strong></p>
</li>
</ul>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local tblTest1 = { 1, a = 2, 3 }</span></span>
<span data-line><span>print(&quot;Test1 &quot; .. table.getn(tblTest1))</span></span>
<span data-line> </span>
<span data-line><span>local tblTest2 = { 1, nil }</span></span>
<span data-line><span>print(&quot;Test2 &quot; .. table.getn(tblTest2))</span></span>
<span data-line> </span>
<span data-line><span>local tblTest3 = { 1, nil, 2 }</span></span>
<span data-line><span>print(&quot;Test3 &quot; .. table.getn(tblTest3))</span></span>
<span data-line> </span>
<span data-line><span>local tblTest4 = { 1, nil, 2, nil }</span></span>
<span data-line><span>print(&quot;Test4 &quot; .. table.getn(tblTest4))</span></span>
<span data-line> </span>
<span data-line><span>local tblTest5 = { 1, nil, 2, nil, 3, nil }</span></span>
<span data-line><span>print(&quot;Test5 &quot; .. table.getn(tblTest5))</span></span>
<span data-line> </span>
<span data-line><span>local tblTest6 = { 1, nil, 2, nil, 3, nil, 4, nil }</span></span>
<span data-line><span>print(&quot;Test6 &quot; .. table.getn(tblTest6))</span></span></code></pre></figure>
<p>我们使用 Lua 5.1 和 LuaJIT 2.1 分别执行这个用例，结果如下：</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span># lua test.lua</span></span>
<span data-line><span>Test1 2</span></span>
<span data-line><span>Test2 1</span></span>
<span data-line><span>Test3 3</span></span>
<span data-line><span>Test4 1</span></span>
<span data-line><span>Test5 3</span></span>
<span data-line><span>Test6 1</span></span>
<span data-line><span># luajit test.lua</span></span>
<span data-line><span>Test1 2</span></span>
<span data-line><span>Test2 1</span></span>
<span data-line><span>Test3 1</span></span>
<span data-line><span>Test4 1</span></span>
<span data-line><span>Test5 1</span></span>
<span data-line><span>Test6 1</span></span></code></pre></figure>
<p>不要在 Lua 的 table 中使用 nil 值，<strong>如果一个元素要删除，直接 remove，不要用 nil 去代替</strong>。</p>
<h2 id="table-concat-table--sep--i--j---"><strong>table. Concat (table [, sep [, i [, j ] ] ])</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#table-concat-table--sep--i--j---" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>对于元素是 string 或者 number 类型的表 table，返回 <code>table[i]..sep..table[i+1] ··· sep..table[j]</code> 连接成的字符串。填充字符串 sep 默认为空白字符串。起始索引位置 i 默认为 1，结束索引位置 j 默认是 table 的长度。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local a = {1, 3, 5, &quot;hello&quot; }</span></span>
<span data-line><span>print(table.concat(a))              -- output: 135hello</span></span>
<span data-line><span>print(table.concat(a, &quot;|&quot;))         -- output: 1|3|5|hello</span></span>
<span data-line><span>print(table.concat(a, &quot; &quot;, 4, 2))   -- output:</span></span>
<span data-line><span>print(table.concat(a, &quot; &quot;, 2, 4))   -- output: 3 5 hello</span></span></code></pre></figure>
<h2 id="table-insert-table-pos--value"><strong>table. Insert (table, [pos ,] value)</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#table-insert-table-pos--value" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>在（数组型）表 table 的 pos 索引位置插入 value，其它元素向后移动到空的地方。Pos 的默认值是表的长度加一，即默认是插在表的最后</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local a = {1, 8}             --a[1] = 1,a[2] = 8</span></span>
<span data-line><span>table.insert(a, 1, 3)   --在表索引为1处插入3</span></span>
<span data-line><span>print(a[1], a[2], a[3])</span></span>
<span data-line><span>table.insert(a, 10)    --在表的最后插入10</span></span>
<span data-line><span>print(a[1], a[2], a[3], a[4])</span></span>
<span data-line> </span>
<span data-line><span>-->output</span></span>
<span data-line><span>3    1    8</span></span>
<span data-line><span>3    1    8    10</span></span></code></pre></figure>
<h2 id="table-maxn-table"><strong>table. Maxn (table)</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#table-maxn-table" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>返回（数组型）表 table 的最大索引编号；如果此表没有正的索引编号，返回 0。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local a = {}</span></span>
<span data-line><span>a[-1] = 10</span></span>
<span data-line><span>print(table.maxn(a))</span></span>
<span data-line><span>a[5] = 10</span></span>
<span data-line><span>print(table.maxn(a))</span></span>
<span data-line> </span>
<span data-line><span>-->output05</span></span></code></pre></figure>
<h2 id="table-remove-table--pos"><strong>table. Remove (table [, pos])</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#table-remove-table--pos" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>在表 table 中删除索引为 pos（pos 只能是 number 型）的元素，并返回这个被删除的元素，它后面所有元素的索引值都会减一。Pos 的默认值是表的长度，即默认是删除表的最后一个元素。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local a = { 1, 2, 3, 4}</span></span>
<span data-line><span>print(table.remove(a, 1)) --删除速索引为1的元素print(a[1], a[2], a[3], a[4])</span></span>
<span data-line> </span>
<span data-line><span>print(table.remove(a))   --删除最后一个元素print(a[1], a[2], a[3], a[4])</span></span>
<span data-line> </span>
<span data-line><span>-->output12    3    4    nil42    3    nil    nil</span></span></code></pre></figure>
<h2 id="table-sort-table--comp"><strong>table. Sort (table [, comp])</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#table-sort-table--comp" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>按照给定的比较函数 comp 给表 table 排序，也就是从 table[1] 到 table[n]，这里 n 表示 table 的长度。比较函数有两个参数，如果希望第一个参数排在第二个的前面，就应该返回 true，否则返回 false。如果比较函数 comp 没有给出，默认从小到大排序。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line> </span>
<span data-line><span>local function compare(x, y) --从大到小排序</span></span>
<span data-line><span>    return x > y         --如果第一个参数大于第二个就返回true，否则返回false</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>local a = { 1, 7, 3, 4, 25}</span></span>
<span data-line><span>table.sort(a)           --默认从小到大排序</span></span>
<span data-line><span>print(a[1], a[2], a[3], a[4], a[5])</span></span>
<span data-line><span>table.sort(a, compare) --使用比较函数进行排序</span></span>
<span data-line><span>print(a[1], a[2], a[3], a[4], a[5])</span></span>
<span data-line> </span>
<span data-line><span>-->output</span></span>
<span data-line><span>1    3    4    7    25</span></span>
<span data-line><span>25    7    4    3    1</span></span></code></pre></figure>
<h2 id="其他">其他<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#其他" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>LuaJIT 2.1 新增加的 <code>table.new</code> 和 <code>table.clear</code> 函数是非常有用的。前者主要用来预分配 Lua table 空间，后者主要用来高效的释放 table 空间，并且它们都是可以被 JIT 编译的</p>
<h1 id="日期时间">日期时间<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#日期时间" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>函数 time、date 和 difftime 提供了所有的日期和时间功能。</p>
<p>在 OpenResty 的世界里，不推荐使用这里的标准时间函数，因为这些函数通常会引发不止一个昂贵的系统调用，同时无法为 LuaJIT JIT 编译，对性能造成较大影响。推荐使用 ngx_lua 模块提供的带缓存的时间接口，如 <code>ngx.today</code>, <code>ngx.time</code>, <code>ngx.utctime</code>, <code>ngx.localtime</code>, <code>ngx.now</code>, <code>ngx.http_time</code>，以及 <code>ngx.cookie_time</code> 等。</p>
<h2 id="os-time-table"><strong>os. Time ([table])</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#os-time-table" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>如果不使用参数 table 调用 time 函数，</p>
<ul>
<li>
<p>它会返回当前的时间和日期（它表示从某一时刻到现在的秒数）。</p>
</li>
<li>
<p>如果用 table 参数，它会返回一个数字，表示该 table 中所描述的日期和时间（它表示从某一时刻到 table 中描述日期和时间的秒数）。Table 的字段如下：</p>
</li>
</ul>









































<div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>字段名称</td><td>取值范围</td></tr><tr><td>year</td><td>四位数字</td></tr><tr><td>month</td><td>1—12</td></tr><tr><td>day</td><td>1—31</td></tr><tr><td>hour</td><td>0—23</td></tr><tr><td>min</td><td>0—59</td></tr><tr><td>sec</td><td>0—61</td></tr><tr><td>isdst</td><td>boolean（true 表示夏令时）</td></tr></tbody></table></div>
<p>对于 time 函数，如果参数为 table，那么 table 中必须含有 year、month、day 字段。其他字缺省时段默认为中午（12:00:00）。</p>
<blockquote>
<p>示例代码：（地点为北京）</p>
</blockquote>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>print(os.time())    -->output  1438243393</span></span>
<span data-line><span>a = { year = 1970, month = 1, day = 1, hour = 8, min = 1 }</span></span>
<span data-line><span>print(os.time(a))   -->output  60</span></span></code></pre></figure>
<h2 id="os-difftime-t-2-t-1"><strong>os. Difftime (t 2, t 1)</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#os-difftime-t-2-t-1" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>返回 t 1 到 t 2 的时间差，单位为秒。</p>
<blockquote>
<p>示例代码:</p>
</blockquote>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local day1 = { year = 2015, month = 7, day = 30 }</span></span>
<span data-line><span>local t1 = os.time(day1)</span></span>
<span data-line> </span>
<span data-line><span>local day2 = { year = 2015, month = 7, day = 31 }</span></span>
<span data-line><span>local t2 = os.time(day2)</span></span>
<span data-line><span>print(os.difftime(t2, t1))   -->output  86400</span></span></code></pre></figure>
<h2 id="os-date-format--time"><strong>os. Date ([format [, time]])</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#os-date-format--time" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>把一个表示日期和时间的数值，转换成更高级的表现形式。</p>
<ul>
<li>
<p>其第一个参数 format 是一个格式化字符串，描述了要返回的时间形式。</p>
</li>
<li>
<p>第二个参数 time 就是日期和时间的数字表示，缺省时默认为当前的时间。</p>
</li>
<li>
<p>使用格式字符 “*t”，创建一个时间表。</p>
</li>
</ul>
<blockquote>
<p>示例代码：</p>
</blockquote>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local tab1 = os.date(&quot;*t&quot;)  --返回一个描述当前日期和时间的表</span></span>
<span data-line><span>local ans1 = &quot;{&quot;</span></span>
<span data-line><span>for k, v in pairs(tab1) do  --把tab1转换成一个字符串</span></span>
<span data-line><span>    ans1 = string.format(&quot;%s %s = %s,&quot;, ans1, k, tostring(v))</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>ans1 = ans1 .. &quot;}&quot;</span></span>
<span data-line><span>print(&quot;tab1 = &quot;, ans1)</span></span>
<span data-line> </span>
<span data-line> </span>
<span data-line><span>local tab2 = os.date(&quot;*t&quot;, 360)  --返回一个描述日期和时间数为360秒的表</span></span>
<span data-line><span>local ans2 = &quot;{&quot;</span></span>
<span data-line><span>for k, v in pairs(tab2) do      --把tab2转换成一个字符串</span></span>
<span data-line><span>    ans2 = string.format(&quot;%s %s = %s,&quot;, ans2, k, tostring(v))</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>ans2 = ans2 .. &quot;}&quot;</span></span>
<span data-line><span>print(&quot;tab2 = &quot;, ans2)</span></span>
<span data-line> </span>
<span data-line><span>-->output</span></span>
<span data-line><span>tab1 = { hour = 17, min = 28, wday = 5, day = 30, month = 7, year = 2015, sec = 10, yday = 211, isdst = false,}</span></span>
<span data-line><span>tab2 = { hour = 8, min = 6, wday = 5, day = 1, month = 1, year = 1970, sec = 0, yday = 1, isdst = false,}</span></span></code></pre></figure>
<p>该表中除了使用到了 time 函数参数 table 的字段外，这还提供了星期（wday，星期天为 1）和一年中的第几天（yday，一月一日为 1）。除了使用 “*t” 格式字符串外，如果使用带标记（见下表）的特殊字符串，os. Date 函数会将相应的标记位以时间信息进行填充，得到一个包含时间的字符串。表如下：</p>

























































































<div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>格式字符</td><td>含义</td></tr><tr><td>%a</td><td>一星期中天数的简写（例如：Wed）</td></tr><tr><td>%A</td><td>一星期中天数的全称（例如：Wednesday）</td></tr><tr><td>%b</td><td>月份的简写（例如：Sep）</td></tr><tr><td>%B</td><td>月份的全称（例如：September）</td></tr><tr><td>%c</td><td>日期和时间（例如：07/30/15 16:57:24）</td></tr><tr><td>%d</td><td>一个月中的第几天[01 ~ 31]</td></tr><tr><td>%H</td><td>24 小时制中的小时数[00 ~ 23]</td></tr><tr><td>%I</td><td>12 小时制中的小时数[01 ~ 12]</td></tr><tr><td>%j</td><td>一年中的第几天[001 ~ 366]</td></tr><tr><td>%M</td><td>分钟数[00 ~ 59]</td></tr><tr><td>%m</td><td>月份数[01 ~ 12]</td></tr><tr><td>%p</td><td>“上午（am）”或“下午（pm）”</td></tr><tr><td>%S</td><td>秒数[00 ~ 59]</td></tr><tr><td>%w</td><td>一星期中的第几天[1 ~ 7 = 星期天 ~ 星期六]</td></tr><tr><td>%x</td><td>日期（例如：07/30/15）</td></tr><tr><td>%X</td><td>时间（例如：16:57:24）</td></tr><tr><td>%y</td><td>两位数的年份[00 ~ 99]</td></tr><tr><td>%Y</td><td>完整的年份（例如：2015）</td></tr><tr><td>%%</td><td>字符’%‘</td></tr></tbody></table></div>
<blockquote>
<p>示例代码：</p>
</blockquote>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>print(os.date(&quot;today is %A, in %B&quot;))</span></span>
<span data-line><span>print(os.date(&quot;now is %x %X&quot;))</span></span>
<span data-line> </span>
<span data-line><span>-->output</span></span>
<span data-line><span>today is Thursday, in July</span></span>
<span data-line><span>now is 07/30/15 17:39:22</span></span></code></pre></figure>
<h1 id="数学库">数学库<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#数学库" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>Ua 数学库由一组标准的数学函数构成。数学库的引入丰富了 Lua 编程语言的功能，同时也方便了程序的编写。常用数学函数见下表：</p>





































































































<div class="table-container"><table><thead><tr><th>asd</th><th>sdfa</th></tr></thead><tbody><tr><td>函数名</td><td>函数功能</td></tr><tr><td>math.Rad (x)</td><td>角度 x 转换成弧度</td></tr><tr><td>math.Deg (x)</td><td>弧度 x 转换成角度</td></tr><tr><td>math.Max (x, …)</td><td>返回参数中值最大的那个数，参数必须是 number 型</td></tr><tr><td>math.Min (x, …)</td><td>返回参数中值最小的那个数，参数必须是 number 型</td></tr><tr><td>math. Random ([m [, n]])</td><td>不传入参数时，返回一个在区间[0,1)内均匀分布的伪随机实数；只使用一个整数参数 m 时，返回一个在区间[1, m]内均匀分布的伪随机整数；使用两个整数参数时，返回一个在区间[m, n]内均匀分布的伪随机整数</td></tr><tr><td>math. Randomseed (x)</td><td>为伪随机数生成器设置一个种子 x，相同的种子将会生成相同的数字序列</td></tr><tr><td>math.Abs (x)</td><td>返回 x 的绝对值</td></tr><tr><td>math.Fmod (x, y)</td><td>返回 x 对 y 取余数</td></tr><tr><td>math.Pow (x, y)</td><td>返回 x 的 y 次方</td></tr><tr><td>math.Sqrt (x)</td><td>返回 x 的算术平方根</td></tr><tr><td>math.Exp (x)</td><td>返回自然数 e 的 x 次方</td></tr><tr><td>math.Log (x)</td><td>返回 x 的自然对数</td></tr><tr><td>math. Log 10 (x)</td><td>返回以 10 为底，x 的对数</td></tr><tr><td>math.Floor (x)</td><td>返回最大且不大于 x 的整数</td></tr><tr><td>math.Ceil (x)</td><td>返回最小且不小于 x 的整数</td></tr><tr><td>math. Pi</td><td>圆周率</td></tr><tr><td>math.Sin (x)</td><td>求弧度 x 的正弦值</td></tr><tr><td>math.Cos (x)</td><td>求弧度 x 的余弦值</td></tr><tr><td>math.Tan (x)</td><td>求弧度 x 的正切值</td></tr><tr><td>math.Asin (x)</td><td>求 x 的反正弦值</td></tr><tr><td>math.Acos (x)</td><td>求 x 的反余弦值</td></tr><tr><td>math.Atan (x)</td><td>求 x 的反正切值</td></tr></tbody></table></div>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>print(math.pi)           -->output  3.1415926535898</span></span>
<span data-line><span>print(math.rad(180))     -->output  3.1415926535898</span></span>
<span data-line><span>print(math.deg(math.pi)) -->output  180</span></span>
<span data-line> </span>
<span data-line><span>print(math.sin(1))       -->output  0.8414709848079</span></span>
<span data-line><span>print(math.cos(math.pi)) -->output  -1</span></span>
<span data-line><span>print(math.tan(math.pi / 4))  -->output  1</span></span>
<span data-line> </span>
<span data-line><span>print(math.atan(1))      -->output  0.78539816339745</span></span>
<span data-line><span>print(math.asin(0))      -->output  0</span></span>
<span data-line> </span>
<span data-line><span>print(math.max(-1, 2, 0, 3.6, 9.1))     -->output  9.1</span></span>
<span data-line><span>print(math.min(-1, 2, 0, 3.6, 9.1))     -->output  -1</span></span>
<span data-line> </span>
<span data-line><span>print(math.fmod(10.1, 3))   -->output  1.1</span></span>
<span data-line><span>print(math.sqrt(360))      -->output  18.97366596101</span></span>
<span data-line> </span>
<span data-line><span>print(math.exp(1))         -->output  2.718281828459</span></span>
<span data-line><span>print(math.log(10))        -->output  2.302585092994</span></span>
<span data-line><span>print(math.log10(10))      -->output  1</span></span>
<span data-line> </span>
<span data-line><span>print(math.floor(3.1415))  -->output  3</span></span>
<span data-line><span>print(math.ceil(7.998))    -->output  8</span></span></code></pre></figure>
<p>使用 <code>math.random()</code> 函数获得伪随机数时，如果不使用 <code>math.randomseed()</code> 设置伪随机数生成种子或者设置相同的伪随机数生成种子，那么得得到的伪随机数序列是一样的。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>math.randomseed (100) --把种子设置为100</span></span>
<span data-line><span>print(math.random())         -->output  0.0012512588885159</span></span>
<span data-line><span>print(math.random(100))      -->output  57</span></span>
<span data-line><span>print(math.random(100, 360)) -->output  150</span></span></code></pre></figure>
<p>稍等片刻，再次运行上面的代码。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>math.randomseed (100) --把种子设置为100</span></span>
<span data-line><span>print(math.random())         -->output  0.0012512588885159</span></span>
<span data-line><span>print(math.random(100))      -->output  57</span></span>
<span data-line><span>print(math.random(100, 360)) -->output  150</span></span></code></pre></figure>
<p>两次运行的结果一样。为了避免每次程序启动时得到的都是相同的伪随机数序列，通常是使用当前时间作为种子。</p>
<blockquote>
<p>修改上例中的代码：</p>
</blockquote>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>math.randomseed (os.time())   --把100换成os.time()</span></span>
<span data-line><span>print(math.random())          -->output 0.88369396038697</span></span>
<span data-line><span>print(math.random(100))       -->output 66</span></span>
<span data-line><span>print(math.random(100, 360))  -->output 228</span></span></code></pre></figure>
<p>稍等片刻，再次运行上面的代码。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>math.randomseed (os.time())   --把100换成os.time()</span></span>
<span data-line><span>print(math.random())          -->output 0.88946195867794</span></span>
<span data-line><span>print(math.random(100))       -->output 68</span></span>
<span data-line><span>print(math.random(100, 360))  -->output 129</span></span></code></pre></figure>
<h1 id="文件">文件<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#文件" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>Lua I/O 库提供两种不同的方式处理文件：隐式文件描述，显式文件描述。</p>
<p>这些文件 I/O 操作，<strong>在 OpenResty 的上下文中对事件循环是会产生阻塞效应</strong>。OpenResty 比较擅长的是高并发网络处理，在这个环境中，任何文件的操作，都将阻塞其他并行执行的请求。<strong>实际中的应用，在 OpenResty 项目中应尽可能让网络处理部分、文件 I/0 操作部分相互独立，不要揉和在一起</strong>。</p>
<h2 id="隐式文件描述"><strong>隐式文件描述</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#隐式文件描述" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>设置一个默认的输入或输出文件，然后在这个文件上进行所有的输入或输出操作。所有的操作函数由 io 表提供。</p>
<blockquote>
<p>打开已经存在的 <code>test1.txt</code> 文件，并读取里面的内容</p>
</blockquote>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>file = io.input(&quot;test1.txt&quot;)    -- 使用 io.input() 函数打开文件repeat</span></span>
<span data-line><span>    line = io.read()            -- 逐行读取内容，文件结束时返回nil</span></span>
<span data-line><span>    if nil == line then</span></span>
<span data-line><span>        break</span></span>
<span data-line><span>    end</span></span>
<span data-line><span>    print(line)</span></span>
<span data-line><span>until (false)</span></span>
<span data-line> </span>
<span data-line><span>io.close(file)                  -- 关闭文件--> output</span></span>
<span data-line><span>my test file</span></span>
<span data-line><span>hello</span></span>
<span data-line><span>lua</span></span></code></pre></figure>
<blockquote>
<p>在 <code>test1.txt</code> 文件的最后添加一行 “hello world”</p>
</blockquote>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>file = io.open(&quot;test1.txt&quot;, &quot;a+&quot;)   -- 使用 io.open() 函数，以添加模式打开文件</span></span>
<span data-line><span>io.output(file)                     -- 使用 io.output() 函数，设置默认输出文件</span></span>
<span data-line><span>io.write(&quot;\nhello world&quot;)           -- 使用 io.write() 函数，把内容写到文件</span></span>
<span data-line><span>io.close(file)</span></span></code></pre></figure>
<p>在相应目录下打开 <code>test1.txt</code> 文件，查看文件内容发生的变化。</p>
<h2 id="显式文件描述"><strong>显式文件描述</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#显式文件描述" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>使用 file: XXX () 函数方式进行操作, 其中 file 为 io.Open () 返回的文件句柄。</p>
<blockquote>
<p>打开已经存在的 test 2. Txt 文件，并读取里面的内容</p>
</blockquote>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>file = io.open(&quot;test2.txt&quot;, &quot;r&quot;)    -- 使用 io.open() 函数，以只读模式打开文件</span></span>
<span data-line> </span>
<span data-line><span>for line in file:lines() do         -- 使用 file:lines() 函数逐行读取文件</span></span>
<span data-line><span>    print(line)</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>file:close()</span></span>
<span data-line> </span>
<span data-line><span>-->output</span></span>
<span data-line><span>my test2</span></span>
<span data-line><span>hello lua</span></span></code></pre></figure>
<blockquote>
<p>在 test 2. Txt 文件的最后添加一行 “hello world”</p>
</blockquote>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>file = io.open(&quot;test2.txt&quot;, &quot;a&quot;)  -- 使用 io.open() 函数，以添加模式打开文件</span></span>
<span data-line><span>file:write(&quot;\nhello world&quot;)       -- 使用 file:write() 函数，在文件末尾追加内容</span></span>
<span data-line><span>file:close()</span></span></code></pre></figure>
<p>在相应目录下打开 <code>test2.txt</code> 文件，查看文件内容发生的变化。</p>
<h2 id="文件操作函数"><strong>文件操作函数</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#文件操作函数" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<h4 id="io-open-filename--mode"><strong>io. Open (filename [, mode])</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#io-open-filename--mode" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>按指定的模式 mode，打开一个文件名为 <code>filename</code> 的文件，成功则返回文件句柄，失败则返回 nil 加错误信息。模式：</p>













































<div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>模式</td><td>含义</td><td>文件不存在时</td></tr><tr><td>”r”</td><td>读模式 (默认)</td><td>返回 nil 加错误信息</td></tr><tr><td>”w”</td><td>写模式</td><td>创建文件</td></tr><tr><td>”a”</td><td>添加模式</td><td>创建文件</td></tr><tr><td>”r+“</td><td>更新模式，保存之前的数据</td><td>返回 nil 加错误信息</td></tr><tr><td>”w+“</td><td>更新模式，清除之前的数据</td><td>创建文件</td></tr><tr><td>”a+“</td><td>添加更新模式，保存之前的数据, 在文件尾进行添加</td><td>创建文件</td></tr></tbody></table></div>
<p>模式字符串后面可以有一个 ‘b’，用于在某些系统中打开二进制文件。</p>
<p>注意 “w” 和 “wb” 的区别</p>
<ul>
<li>
<p>”w” 表示文本文件。某些文件系统 (如 Linux 的文件系统)认为 0 x 0 A 为文本文件的换行符，Windows 的文件系统认为 0 x 0 D 0 A 为文本文件的换行符。为了兼容其他文件系统（如从 Linux 拷贝来的文件），Windows 的文件系统在写文件时，会在文件中 0 x 0 A 的前面加上 0 x 0 D。使用 “w”，其属性要看所在的平台。</p>
</li>
<li>
<p>“wb” 表示二进制文件。文件系统会按纯粹的二进制格式进行写操作，因此也就不存在格式转换的问题。（Linux 文件系统下 “w” 和 “wb” 没有区别）</p>
</li>
</ul>
<h4 id="file-close-"><strong>file: close ()</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#file-close-" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>关闭文件。注意：当文件句柄被垃圾收集后，文件将自动关闭。句柄将变为一个不可预知的值。</p>
<h4 id="io-close-file"><strong>io. Close ([file])</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#io-close-file" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>关闭文件，和 file: close () 的作用相同。没有参数 file 时，关闭默认输出文件。</p>
<h4 id="file-flush-"><strong>file: flush ()</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#file-flush-" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>把写入缓冲区的所有数据写入到文件 file 中。</p>
<h4 id="io-flush-"><strong>io. Flush ()</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#io-flush-" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>相当于 file: flush ()，把写入缓冲区的所有数据写入到默认输出文件。</p>
<h4 id="io-input-file"><strong>io. Input ([file])</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#io-input-file" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>当使用一个文件名调用时，打开这个文件（以文本模式），并设置文件句柄为默认输入文件；当使用一个文件句柄调用时，设置此文件句柄为默认输入文件；当不使用参数调用时，返回默认输入文件句柄。</p>
<h4 id="file-lines-"><strong>file: lines ()</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#file-lines-" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>返回一个迭代函数, 每次调用将获得文件中的一行内容, 当到文件尾时，将返回 nil，但不关闭文件。</p>
<h4 id="io-lines-filename"><strong>io. Lines ([filename])</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#io-lines-filename" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>打开指定的文件 filename 为读模式并返回一个迭代函数, 每次调用将获得文件中的一行内容, 当到文件尾时，将返回 nil，并自动关闭文件。若不带参数时 io.Lines () 等价于 io.Input (): lines () 读取默认输入设备的内容，结束时不关闭文件。</p>
<h4 id="io-output-file"><strong>io. Output ([file])</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#io-output-file" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>类似于 io. Input，但操作在默认输出文件上。</p>
<h4 id="file-read-"><strong>file: read (…)</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#file-read-" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>按指定的格式读取一个文件。按每个格式将返回一个字符串或数字, 如果不能正确读取将返回 nil，若没有指定格式将指默认按行方式进行读取。格式：</p>





























<div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>格式</td><td>含义</td></tr><tr><td>”*n”</td><td>读取一个数字</td></tr><tr><td>”*a”</td><td>从当前位置读取整个文件。若当前位置为文件尾，则返回空字符串</td></tr><tr><td>”*l”</td><td>读取下一行的内容。若为文件尾，则返回 nil。(默认)</td></tr><tr><td>number</td><td>读取指定字节数的字符。若为文件尾，则返回 nil。如果 number 为 0, 则返回空字符串，若为文件尾, 则返回 nil</td></tr></tbody></table></div>
<h4 id="io-read-"><strong>io. Read (…)</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#io-read-" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>相当于 io.Input ():read</p>
<h4 id="io-type-obj"><strong>io. Type (obj)</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#io-type-obj" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>检测 obj 是否一个可用的文件句柄。如果 obj 是一个打开的文件句柄，则返回 “file” 如果 obj 是一个已关闭的文件句柄，则返回 “closed file” 如果 obj 不是一个文件句柄，则返回 nil。</p>
<h4 id="file-write-"><strong>file: write (…)</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#file-write-" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>把每一个参数的值写入文件。参数必须为字符串或数字，若要输出其它值，则需通过 tostring 或 string. Format 进行转换。</p>
<h4 id="io-write-"><strong>io. Write (…)</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#io-write-" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>相当于 io.Output (): write。</p>
<h4 id="file-seek-whence--offset"><strong>file: seek ([whence] [, offset])</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#file-seek-whence--offset" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>设置和获取当前文件位置，成功则返回最终的文件位置 (按字节，相对于文件开头), 失败则返回 nil 加错误信息。缺省时，whence 默认为 “cur”，offset 默认为 0 。参数 whence：</p>

























<div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>whence</td><td>含义</td></tr><tr><td>”set”</td><td>文件开始</td></tr><tr><td>”cur”</td><td>文件当前位置 (默认)</td></tr><tr><td>“end”</td><td>文件结束</td></tr></tbody></table></div>
<h4 id="file-setvbuf-mode--size"><strong>file: setvbuf (mode [, size])</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#file-setvbuf-mode--size" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>设置输出文件的缓冲模式。模式：</p>

























<div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>模式</td><td>含义</td></tr><tr><td>”no”</td><td>没有缓冲，即直接输出</td></tr><tr><td>”full”</td><td>全缓冲，即当缓冲满后才进行输出操作 (也可调用 flush 马上输出)</td></tr><tr><td>“line”</td><td>以行为单位，进行输出</td></tr></tbody></table></div>
<p>最后两种模式，size 可以指定缓冲的大小（按字节），忽略 size 将自动调整为最佳的大小。</p>
<h1 id="元表">元表<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#元表" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>元表 <em>(metatable)</em> 的<strong>表现行为类似于 C++ 语言中的操作符重载</strong>，例如我们可以重载 “__add” 元方法 <em>(metamethod)</em>，来计算两个 Lua 数组的并集；或者重载 “__index” 方法，来定义我们自己的 Hash 函数。Lua 提供了两个十分重要的用来处理元表的方法</p>
<ul>
<li>
<p>Setmetatable (table, metatable)：此方法用于为一个表设置元表。</p>
</li>
<li>
<p>Getmetatable (table)：此方法用于获取表的元表对象</p>
</li>
</ul>
<p>设置元表</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local mytable = {}</span></span>
<span data-line><span>local mymetatable = {}</span></span>
<span data-line><span>setmetatable(mytable, mymetatable)</span></span></code></pre></figure>
<h2 id="修改表的操作符行为"><strong>修改表的操作符行为</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#修改表的操作符行为" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>通过重载 “__add” 元方法来计算集合的并集实例</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local set1 = {10, 20, 30}   -- 集合</span></span>
<span data-line><span>local set2 = {20, 40, 50}   -- 集合</span></span>
<span data-line> </span>
<span data-line><span>-- 将用于重载__add的函数，注意第一个参数是self</span></span>
<span data-line><span>local union = function (self, another)</span></span>
<span data-line><span>    local set = {}</span></span>
<span data-line><span>    local result = {}</span></span>
<span data-line> </span>
<span data-line><span>    -- 利用数组来确保集合的互异性</span></span>
<span data-line><span>    for i, j in pairs(self) do set[j] = true end</span></span>
<span data-line><span>    for i, j in pairs(another) do set[j] = true end</span></span>
<span data-line> </span>
<span data-line><span>    -- 加入结果集合</span></span>
<span data-line><span>    for i, j in pairs(set) do table.insert(result, i) end</span></span>
<span data-line><span>    return result</span></span>
<span data-line><span>end</span></span>
<span data-line><span>setmetatable(set1, {__add = union}) -- 重载 set1 表的 __add 元方法</span></span>
<span data-line> </span>
<span data-line><span>local set3 = set1 + set2</span></span>
<span data-line><span>for _, j in pairs(set3) do</span></span>
<span data-line><span>    io.write(j..&quot; &quot;)               -->output：30 50 20 40 10</span></span>
<span data-line><span>end</span></span></code></pre></figure>
<p>除了加法可以被重载之外，Lua 提供的所有操作符都可以被重载：</p>

























































<div class="table-container"><table><thead><tr><th>元方法</th><th>含义</th></tr></thead><tbody><tr><td>”__add</td><td><a href=".././tags/NAME" class="tag-link internal alias" data-slug="tags/NAME">NAME</a> ?</td></tr><tr><td>”__sub</td><td>- 操作其行为类似于 “add” 操作</td></tr><tr><td>”__mul</td><td>* 操作其行为类似于 “add” 操作</td></tr><tr><td>”__div</td><td>/ 操作其行为类似于 “add” 操作</td></tr><tr><td>”__mod</td><td>% 操作其行为类似于 “add” 操作</td></tr><tr><td>”__pow</td><td>^ （幂）操作其行为类似于 “add” 操作</td></tr><tr><td>”__unm”</td><td>一元 - 操作</td></tr><tr><td>”__concat”</td><td>.. （字符串连接）操作</td></tr><tr><td>”__len”</td><td># 操作</td></tr><tr><td>”__eq”</td><td>== 操作函数 getcomphandler 定义了 Lua 怎样选择一个处理器来作比较操作仅在两个对象类型相同且有对应操作相同的元方法时才起效</td></tr><tr><td>”__lt”</td><td>&lt; 操作</td></tr><tr><td>”__le”</td><td><span>⇐</span> 操作</td></tr></tbody></table></div>
<p>除了操作符之外，如下元方法也可以被重载，下面会依次解释使用方法：</p>





































<div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>元方法</td><td>含义</td></tr><tr><td>”__index”</td><td>取下标操作用于访问 table[key]</td></tr><tr><td>“__newindex”</td><td>赋值给指定下标 table[key] = value</td></tr><tr><td>”__tostring”</td><td>转换成字符串</td></tr><tr><td>”__call”</td><td>当 Lua 调用一个值时调用</td></tr><tr><td>”__mode”</td><td>用于弱表 (week table)</td></tr><tr><td>“__metatable”</td><td>用于保护 metatable 不被访问</td></tr></tbody></table></div>
<h2 id="__index-元方法"><strong>__index 元方法</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#__index-元方法" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>mytable = setmetatable({key1 = &quot;value1&quot;},   --原始表</span></span>
<span data-line><span>{__index = function(self, key)            --重载函数</span></span>
<span data-line><span>    if key == &quot;key2&quot; then</span></span>
<span data-line><span>        return &quot;metatablevalue&quot;</span></span>
<span data-line><span>    end</span></span>
<span data-line><span>end</span></span>
<span data-line><span>})</span></span>
<span data-line> </span>
<span data-line><span>print(mytable.key1,mytable.key2)  --> output：value1 metatablevalue</span></span></code></pre></figure>
<p>关于 __index 元方法，有很多比较高阶的技巧，例如：__index 的元方法不需要非是一个函数，他也可以是一个表。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>t = setmetatable({[1] = &quot;hello&quot;}, {__index = {[2] = &quot;world&quot;}})</span></span>
<span data-line><span>print(t[1], t[2])   -->hello wor</span></span></code></pre></figure>
<h2 id="__tostring-元方法"><strong>__tostring 元方法</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#__tostring-元方法" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>与 Java 中的 toString () 函数类似，可以实现自定义的字符串转换。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>arr = {1, 2, 3, 4}</span></span>
<span data-line><span>arr = setmetatable(arr, {__tostring = function (self)</span></span>
<span data-line><span>    local result = '{'</span></span>
<span data-line><span>    local sep = ''</span></span>
<span data-line><span>    for _, i in pairs(self) do</span></span>
<span data-line><span>        result = result ..sep .. i</span></span>
<span data-line><span>        sep = ', '</span></span>
<span data-line><span>    end</span></span>
<span data-line><span>    result = result .. '}'</span></span>
<span data-line><span>    return result</span></span>
<span data-line><span>end})</span></span>
<span data-line><span>print(arr)  --> {1, 2, 3, 4}</span></span></code></pre></figure>
<h2 id="__call-元方法"><strong>__call 元方法</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#__call-元方法" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>__call 元方法的功能类似于 C++ 中的仿函数，使得普通的表也可以被调用。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>functor = {}</span></span>
<span data-line><span>function func1(self, arg)</span></span>
<span data-line><span>    print (&quot;called from&quot;, arg)</span></span>
<span data-line><span>end</span></span>
<span data-line><span>setmetatable(functor, {__call = func1})</span></span>
<span data-line> </span>
<span data-line><span>functor(&quot;functor&quot;)  --> called from functor</span></span>
<span data-line><span>print(functor)      --> output：0x00076fc8 （后面这串数字可能不一样）</span></span></code></pre></figure>
<h2 id="__metatable-元方法"><strong>__metatable 元方法</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#__metatable-元方法" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>假如我们想保护我们的对象使其使用者既看不到也不能修改 metatables。我<strong>们可以对 metatable 设置了 __metatable 的值，getmetatable 将返回这个域的值，而调用 setmetatable 将会出错</strong>：</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>bject = setmetatable({}, {__metatable = &quot;You cannot access here&quot;})</span></span>
<span data-line> </span>
<span data-line><span>print(getmetatable(Object)) --> You cannot access heresetmetatable(Object, {})    --> 引发编译器报错</span></span></code></pre></figure>
<h1 id="面向对象">面向对象<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#面向对象" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<h2 id="类">类<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#类" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>在 Lua 中，我们可以使用表和函数实现面向对象。<strong>将函数和相关的数据放置于同一个表中就形成了一个对象。</strong></p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local _M = {}</span></span>
<span data-line> </span>
<span data-line><span>local mt = { __index = _M }</span></span>
<span data-line> </span>
<span data-line><span>function _M.deposit (self, v)</span></span>
<span data-line><span>    self.balance = self.balance + v</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>function _M.withdraw (self, v)</span></span>
<span data-line><span>    if self.balance > v then</span></span>
<span data-line><span>        self.balance = self.balance - v</span></span>
<span data-line><span>    else</span></span>
<span data-line><span>        error(&quot;insufficient funds&quot;)</span></span>
<span data-line><span>    end</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>function _M.new (self, balance)</span></span>
<span data-line><span>    balance = balance or 0</span></span>
<span data-line><span>    return setmetatable({balance = balance}, mt)</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>return _M</span></span></code></pre></figure>
<p>引用</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local account = require(&quot;account&quot;)</span></span>
<span data-line> </span>
<span data-line><span>local a = account:new()</span></span>
<span data-line><span>a:deposit(100)</span></span>
<span data-line> </span>
<span data-line><span>local b = account:new()</span></span>
<span data-line><span>b:deposit(50)</span></span>
<span data-line> </span>
<span data-line><span>print(a.balance)  --> output: 100</span></span>
<span data-line><span>print(b.balance)  --> output: 50</span></span></code></pre></figure>
<p>上面这段代码 “setmetatable ({balance = balance}, mt)“，其中 mt 代表 <code>{ __index = _M }</code> ，这句话值得注意。根据我们在元表这一章学到的知识，我们明白，setmetatable 将 <code>_M</code> 作为新建表的原型，所以在自己的表内找不到 ‘deposit’、‘withdraw’ 这些方法和变量的时候，便会到 __index 所指定的 _M 类型中去寻找。</p>
<h2 id="继承">继承<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#继承" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>继承可以用元表实现，它提供了在父类中查找存在的方法和变量的机制。在 Lua 中是不推荐使用继承方式完成构造的，这样做引入的问题可能比解决的问题要多，下面一个是字符串操作类库，给大家演示一下。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>---------- s_base.lualocal _M = {}</span></span>
<span data-line> </span>
<span data-line><span>local mt = { __index = _M }</span></span>
<span data-line> </span>
<span data-line><span>function _M.upper (s)return string.upper(s)</span></span>
<span data-line><span>endreturn _M</span></span>
<span data-line> </span>
<span data-line><span>---------- s_more.lualocal s_base = require(&quot;s_base&quot;)</span></span>
<span data-line> </span>
<span data-line><span>local _M = {}</span></span>
<span data-line><span>_M = setmetatable(_M, { __index = s_base })</span></span>
<span data-line> </span>
<span data-line> </span>
<span data-line><span>function _M.lower (s)return string.lower(s)</span></span>
<span data-line><span>endreturn _M</span></span>
<span data-line> </span>
<span data-line><span>---------- test.lualocal s_more = require(&quot;s_more&quot;)</span></span>
<span data-line> </span>
<span data-line><span>print(s_more.upper(&quot;Hello&quot;))   -- output: HELLOprint(s_more.lower(&quot;Hello&quot;))   -- output: hello</span></span></code></pre></figure>
<h2 id="成员私有性">成员私有性<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#成员私有性" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>在动态语言中引入成员私有性并没有太大的必要，反而会显著增加运行时的开销，毕竟这种检查无法像许多静态语言那样在编译期完成。下面的技巧把对象作为各方法的 upvalue，本身是很巧妙的，但会让子类继承变得困难，同时构造函数动态创建了函数，会导致构造函数无法被 JIT 编译。</p>
<p>在 Lua 中，成员的私有性，使用类似于函数闭包的形式来实现。在我们之前的银行账户的例子中，我们使用一个工厂方法来创建新的账户实例，通过工厂方法对外提供的闭包来暴露对外接口。而不想暴露在外的例如 balance 成员变量，则被很好的隐藏起来。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>function newAccount (initialBalance)</span></span>
<span data-line><span>    local self = {balance = initialBalance}</span></span>
<span data-line><span>    local withdraw = function (v)</span></span>
<span data-line><span>        self.balance = self.balance - v</span></span>
<span data-line><span>    end</span></span>
<span data-line><span>    local deposit = function (v)</span></span>
<span data-line><span>        self.balance = self.balance + v</span></span>
<span data-line><span>    end</span></span>
<span data-line><span>    local getBalance = function () </span></span>
<span data-line><span>        return self.balance </span></span>
<span data-line><span>    end</span></span>
<span data-line><span>    </span></span>
<span data-line><span>    return {</span></span>
<span data-line><span>        withdraw = withdraw,</span></span>
<span data-line><span>        deposit = deposit,</span></span>
<span data-line><span>        getBalance = getBalance</span></span>
<span data-line><span>    }</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>a = newAccount(100)</span></span>
<span data-line><span>a.deposit(100)</span></span>
<span data-line><span>print(a.getBalance()) --> 200print(a.balance)      --> nil</span></span></code></pre></figure>
<h1 id="局部变量">局部变量<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#局部变量" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>Lua 的设计有一点很奇怪，<strong>在一个 block 中的变量，如果之前没有定义过，那么认为它是一个全局变量</strong>，<strong>而不是这个 block 的局部变量</strong>。这一点和别的语言不同。<strong>容易造成不小心覆盖了全局同名变量的错误</strong>。</p>
<h2 id="定义-1"><strong>定义</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#定义-1" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Lua 中的局部变量要用 local 关键字来显式定义，不使用 local 显式定义的变量就是全局变量</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>g_var = 1         -- global var</span></span>
<span data-line><span>local l_var = 2   -- local var</span></span></code></pre></figure>
<h2 id="作用域"><strong>作用域</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#作用域" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><strong>局部变量的生命周期是有限的，它的作用域仅限于声明它的块（block）</strong>。一个块是一个控制结构的执行体、或者是一个函数的执行体再或者是一个程序块（chunk）。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>x = 10</span></span>
<span data-line><span>local i = 1         -- 程序块中的局部变量 i</span></span>
<span data-line> </span>
<span data-line><span>while i &lt;=x do</span></span>
<span data-line><span>    local x = i * 2   -- while 循环体中的局部变量 x</span></span>
<span data-line><span>    print(x)          -- output： 2, 4, 6, 8, ...</span></span>
<span data-line><span>    i = i + 1</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>if i > 20 then</span></span>
<span data-line><span>    local x           -- then 中的局部变量 x</span></span>
<span data-line><span>    x = 20</span></span>
<span data-line><span>    print(x + 2)      -- 如果i > 20 将会打印 22，此处的 x 是局部变量</span></span>
<span data-line><span>else</span></span>
<span data-line><span>    print(x)          -- 打印 10，这里 x 是全局变量</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>print(x)            -- 打印 10</span></span></code></pre></figure>
<h2 id="使用局部变量的好处">使用局部变量的好处<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#使用局部变量的好处" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<ol>
<li>
<p>局部变量可以避免因为命名问题污染了全局环境</p>
</li>
<li>
<p>Local 变量的访问比全局变量更快</p>
</li>
<li>
<p>由于局部变量出了作用域之后生命周期结束，这样可以被垃圾回收器及时释放</p>
</li>
</ol>
<h2 id="检测模块的函数使用局部变量">检测模块的函数使用局部变量<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#检测模块的函数使用局部变量" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Foo. Lua</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local _M = { _VERSION = '0.01' }</span></span>
<span data-line> </span>
<span data-line><span>function _M.add(a, b)     --两个number型变量相加</span></span>
<span data-line><span>    return a + b</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>function _M.update_A()    --更新变量值</span></span>
<span data-line><span>    A = 365               -- A 是全局变量</span></span>
<span data-line><span>end</span></span>
<span data-line> </span>
<span data-line><span>return _M</span></span></code></pre></figure>
<p>Use_foo. Lua</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>A = 360     --定义全局变量</span></span>
<span data-line> </span>
<span data-line><span>local foo = require(&quot;foo&quot;)</span></span>
<span data-line> </span>
<span data-line><span>local b = foo.add(A, A)</span></span>
<span data-line><span>print(&quot;b = &quot;, b)</span></span>
<span data-line> </span>
<span data-line><span>foo.update_A()</span></span>
<span data-line><span>print(&quot;A = &quot;, A)</span></span></code></pre></figure>
<p>因为 A 是全局变量，改变了 A 的值</p>
<p>Lua 上下文中应当严格避免使用自己定义的全局变量。<strong>可以使用一个 lj-releng 工具来扫描 Lua 代码，定位使用 Lua 全局变量的地方</strong>。Lj-releng 的相关链接：<a href="https://github.com/openresty/openresty-devel-utils/blob/master/lj-releng" class="external">https://github.com/openresty/openresty-devel-utils/blob/master/lj-releng<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></p>
<p>Windows 用户把 lj-releng 文件所在的目录的绝对路径添加进 PATH 环境变量。然后进入你自己的 Lua 文件所在的工作目录，得到如下结果：</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>#  lj-releng</span></span>
<span data-line><span>foo.lua: 0.01 (0.01)</span></span>
<span data-line><span>Checking use of Lua global variables in file foo.lua...</span></span>
<span data-line><span>op no.  line  instruction args  ; code</span></span>
<span data-line><span>2  [8] SETGLOBAL 0 -1  ; A</span></span>
<span data-line><span>Checking line length exceeding 80...</span></span>
<span data-line><span>WARNING: No &quot;_VERSION&quot; or &quot;version&quot; field found in `use_foo.lua`.</span></span>
<span data-line><span>Checking use of Lua global variables in file use_foo.lua...</span></span>
<span data-line><span>op no.  line  instruction args  ; code</span></span>
<span data-line><span>2  [1] SETGLOBAL 0 -1  ; A</span></span>
<span data-line><span>7  [4] GETGLOBAL 2 -1  ; A</span></span>
<span data-line><span>8  [4] GETGLOBAL 3 -1  ; A</span></span>
<span data-line><span>18 [8] GETGLOBAL 4 -1  ; A</span></span></code></pre></figure>
<p>当然，更推荐采用 <strong>luacheck 来检查项目中全局变量，之后的“代码静态分析”一节，我们还会讲到如何使用 luacheck</strong>。</p>
<h1 id="判断数组的大小">判断数组的大小<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#判断数组的大小" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<ul>
<li>
<p>Table.Getn (t) 等价于 t 但<strong>计算的是数组元素，不包括 hash 键值</strong>。而且数组是以第一个 nil 元素来判断数组结束。</p>
</li>
<li>
<p><code>#</code> 只计算 array 的元素个数，它实际上调用了对象的 metatable 的 <code>__len</code> 函数。对于有 <code>__len</code> 方法的函数返回函数返回值，不然就返回数组成员数目</p>
</li>
<li>
<p><em>Lua</em> 内部实际采用哈希表和数组分别保存键值对、普通值，所以不推荐混合使用这两种赋值方式。</p>
</li>
<li>
<p>Lua 数组中允许 nil 值的存在，但是数组默认结束标志却是 nil。这类比于 C 语言中的字符串，字符串中允许 ‘\0’ 存在，但当读到 ‘\0’ 时，就认为字符串已经结束了。</p>
</li>
<li>
<p>初始化是例外，在 Lua 相关源码中，初始化数组时首先判断数组的长度，若长度大于 0 ，并且最后一个值不为 nil，返回包括 nil 的长度；若最后一个值为 nil，则返回截至第一个非 nil 值的长度。</p>
</li>
<li>
<p><strong>如果你要删除一个数组中的元素，请使用 remove 函数，而不是用 nil 赋值</strong></p>
</li>
</ul>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>-- test.lua</span></span>
<span data-line><span>local tblTest1 = { 1, a = 2, 3 }</span></span>
<span data-line><span>print(&quot;Test1 &quot; .. #(tblTest1))</span></span>
<span data-line> </span>
<span data-line><span>local tblTest2 = { 1, nil }</span></span>
<span data-line><span>print(&quot;Test2 &quot; .. #(tblTest2))</span></span>
<span data-line> </span>
<span data-line><span>local tblTest3 = { 1, nil, 2 }</span></span>
<span data-line><span>print(&quot;Test3 &quot; .. #(tblTest3))</span></span>
<span data-line> </span>
<span data-line><span>local tblTest4 = { 1, nil, 2, nil }</span></span>
<span data-line><span>print(&quot;Test4 &quot; .. #(tblTest4))</span></span>
<span data-line> </span>
<span data-line><span>local tblTest5 = { 1, nil, 2, nil, 3, nil }</span></span>
<span data-line><span>print(&quot;Test5 &quot; .. #(tblTest5))</span></span>
<span data-line> </span>
<span data-line><span>local tblTest6 = { 1, nil, 2, nil, 3, nil, 4, nil }</span></span>
<span data-line><span>print(&quot;Test6 &quot; .. #(tblTest6))</span></span></code></pre></figure>
<p>我们分别使用 Lua 和 LuaJIT 来执行一下：</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>➜ luajit test.lua</span></span>
<span data-line><span>Test1 2</span></span>
<span data-line><span>Test2 1</span></span>
<span data-line><span>Test3 1</span></span>
<span data-line><span>Test4 1</span></span>
<span data-line><span>Test5 1</span></span>
<span data-line><span>Test6 1</span></span>
<span data-line> </span>
<span data-line><span>➜ lua test.lua</span></span>
<span data-line><span>Test1 2</span></span>
<span data-line><span>Test2 1</span></span>
<span data-line><span>Test3 3</span></span>
<span data-line><span>Test4 1</span></span>
<span data-line><span>Test5 3</span></span>
<span data-line><span>Test6 1</span></span></code></pre></figure>
<p>这一段的输出结果，就是这么 <strong>匪夷所思</strong>。不要在 Lua 的 table 中使用 nil 值，<strong>如果一个元素要删除，直接 remove，不要用 nil 去代替</strong>。</p>
<h1 id="非空判断">非空判断<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#非空判断" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>有时候不小心引用了一个没有赋值的变量，这时它的值默认为 nil。如果对一个 nil 进行索引的话，会导致异常。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local person = {name = &quot;Bob&quot;, sex = &quot;M&quot;}</span></span>
<span data-line> </span>
<span data-line><span>-- do something</span></span>
<span data-line><span>person = nil</span></span>
<span data-line><span>-- do something</span></span>
<span data-line><span>print(person.name)</span></span></code></pre></figure>
<p>会报错</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>stdin:1:attempt to index global 'person' (a nil value)</span></span>
<span data-line><span>stack traceback:</span></span>
<span data-line><span>   stdin:1: in main chunk</span></span>
<span data-line><span>   [C]: ?</span></span></code></pre></figure>
<p>在实际的工程代码中，我们很难这么轻易地发现我们引用了 nil 变量。因此，在很多情况下我们在访问一些 table 型变量时，需要先判断该变量是否为 nil，例如将上面的代码改成</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local person = {name = &quot;Bob&quot;, sex = &quot;M&quot;}</span></span>
<span data-line> </span>
<span data-line><span>-- do something</span></span>
<span data-line><span>person = nil</span></span>
<span data-line><span>-- do something</span></span>
<span data-line><span>if person ~= nil and person.name ~= nil then</span></span>
<span data-line><span>    print(person.name)</span></span>
<span data-line><span>else</span></span>
<span data-line><span>-- do somethingend</span></span></code></pre></figure>
<p>对于简单类型的变量，我们可以用 <em>if (var == nil) then</em> 这样的简单句子来判断。<strong>但是对于 table 型的 Lua 对象，就不能这么简单判断它是否为空了。一个 table 型变量的值可能是</strong> <strong><code>{}</code></strong>，这时它不等于 nil。我们来看下面这段代码：</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>local next = next</span></span>
<span data-line><span>local a = {}</span></span>
<span data-line><span>local b = {name = &quot;Bob&quot;, sex = &quot;Male&quot;}</span></span>
<span data-line><span>local c = {&quot;Male&quot;, &quot;Female&quot;}</span></span>
<span data-line><span>local d = nil</span></span>
<span data-line> </span>
<span data-line><span>print(#a)</span></span>
<span data-line><span>print(#b)</span></span>
<span data-line><span>print(#c)</span></span>
<span data-line><span>--print(#d)    -- error</span></span>
<span data-line> </span>
<span data-line><span>if a == nil then</span></span>
<span data-line><span>    Print (&quot;a == nil&quot;)</span></span>
<span data-line><span>End</span></span>
<span data-line> </span>
<span data-line><span>If b == nil then</span></span>
<span data-line><span>    Print (&quot;b == nil&quot;)</span></span>
<span data-line><span>End</span></span>
<span data-line> </span>
<span data-line><span>If c == nil then</span></span>
<span data-line><span>    Print (&quot;c == nil&quot;)</span></span>
<span data-line><span>End</span></span>
<span data-line> </span>
<span data-line><span>If d== nil then</span></span>
<span data-line><span>    Print (&quot;d == nil&quot;)</span></span>
<span data-line><span>End</span></span>
<span data-line> </span>
<span data-line><span>If next (a) == nil then</span></span>
<span data-line><span>    Print (&quot;next (a) == nil&quot;)</span></span>
<span data-line><span>End</span></span>
<span data-line> </span>
<span data-line><span>If next (b) == nil then</span></span>
<span data-line><span>    Print (&quot;next (b) == nil&quot;)</span></span>
<span data-line><span>End</span></span>
<span data-line> </span>
<span data-line><span>If next (c) == nil then</span></span>
<span data-line><span>    Print (&quot;next (c) == nil&quot;)</span></span>
<span data-line><span>End</span></span></code></pre></figure>
<p>输出</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>0</span></span>
<span data-line><span>0</span></span>
<span data-line><span>2</span></span>
<span data-line><span>D == nil</span></span>
<span data-line><span>Next (a) == nil</span></span></code></pre></figure>
<p>因此，我们要判断一个 table 是否为 <code>{}</code>，不能采用 <code> #table == 0</code> 的方式来判断。可以用下面这样的方法来判断：</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>Function isTableEmpty (t)</span></span>
<span data-line><span>    Return t == nil or next (t) == nil</span></span>
<span data-line><span>End</span></span></code></pre></figure>
<p>注意：<strong><code>next</code></strong> <strong>指令是不能被 LuaJIT 的 JIT 编译优化，并且 LuaJIT 貌似没有明确计划支持这个指令优化，在不是必须的情况下，尽量少用。</strong></p>
<h1 id="正则表达式">正则表达式<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#正则表达式" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>同时存在两套正则表达式规范：<em>Lua</em> 语言的规范和 <code>ngx. Re.*</code> 的规范，即使您对 <em>Lua</em> 语言中的规范非常熟悉，我们仍不建议使用 <em>Lua</em> 中的正则表达式。</p>
<ul>
<li>
<p>一是因为 <em>Lua</em> 中正则表达式的性能并不如 <code>ngx. Re.*</code> 中的正则表达式优秀；</p>
</li>
<li>
<p>二是 <em>Lua</em> 中的正则表达式并不符合 <em>POSIX</em> 规范，而 <code>ngx. Re.*</code> 中实现的是标准的 <em>POSIX</em> 规范，后者明显更具备通用性。</p>
</li>
</ul>
<p><code>ngx. Re.*</code> 中的 <code>o</code> 选项，指明该参数，被编译的 Pattern 将会在工作进程中缓存，并且被当前工作进程的每次请求所共享。Pattern 缓存的上限值通过 <code>lua_regex_cache_max_entries</code> 来修改，它的默认值为 1024。</p>
<p><code>ngx. Re.*</code> 中的 <code>j</code> 选项，指明该参数，如果使用的 PCRE 库支持 JIT，OpenResty 会在编译 Pattern 时启用 JIT。启用 JIT 后正则匹配会有明显的性能提升。较新的平台，自带的 PCRE 库均支持 JIT。如果系统自带的 PCRE 库不支持 JIT，出于性能考虑，最好自己编译一份 libpcre. So，然后在编译 OpenResty 时链接过去。要想验证当前 PCRE 库是否支持 JIT，可以这么做</p>
<ol>
<li>
<p>编译 OpenResty 时在 <code>./configure</code> 中指定 <code>--with-debug</code> 选项</p>
</li>
<li>
<p>在 <code>error_log</code> 指令中指定日志级别为 <code>debug</code></p>
</li>
<li>
<p>运行正则匹配代码，查看日志中是否有 <code>pcre JIT compiling result: 1</code></p>
</li>
</ol>
<p>即使运行在不支持 JIT 的 OpenResty 上，加上 <code>j</code> 选项也不会带来坏的影响。在 OpenResty 官方的 Lua 库中，正则匹配至少都会带上 <code>jo</code> 这两个选项。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>Location /test {</span></span>
<span data-line><span>    Content_by_lua_block {</span></span>
<span data-line><span>        local regex = [[\d+]]</span></span>
<span data-line> </span>
<span data-line><span>        -- 参数 &quot;j&quot; 启用 JIT 编译，参数 &quot;o&quot; 是开启缓存必须的</span></span>
<span data-line><span>        Local m = ngx.Re.Match (&quot;hello, 1234&quot;, regex, &quot;jo&quot;)</span></span>
<span data-line><span>        If m then</span></span>
<span data-line><span>            Ngx.Say (m[0])</span></span>
<span data-line><span>        Else</span></span>
<span data-line><span>            Ngx.Say (&quot;not matched!&quot;)</span></span>
<span data-line><span>        End</span></span>
<span data-line><span>    }</span></span>
<span data-line><span>}</span></span></code></pre></figure>
<h4 id="lua-正则简单汇总"><strong>Lua 正则简单汇总</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#lua-正则简单汇总" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p><em>Lua</em> 中正则表达式语法上最大的区别，<em>Lua</em> 使用 <em>’%’</em> 来进行转义，而其他语言的正则表达式使用 <em>”</em> 符号来进行转义。其次，<em>Lua</em> 中并不使用 <em>’?’</em> 来表示非贪婪匹配，而是定义了不同的字符来表示是否是贪婪匹配。定义如下：</p>






























<div class="table-container"><table><thead><tr><th>符号</th><th>匹配次数</th><th>匹配模式</th></tr></thead><tbody><tr><td>+</td><td>匹配前一字符 1 次或多次</td><td>非贪婪</td></tr><tr><td><code>*</code></td><td>匹配前一字符 0 次或多次</td><td>贪婪</td></tr><tr><td>-</td><td>匹配前一字符 0 次或多次</td><td>非贪婪</td></tr><tr><td>?</td><td>匹配前一字符 0 次或 1 次</td><td>仅用于此，不用于标识是否贪婪</td></tr></tbody></table></div>





















































<div class="table-container"><table><thead><tr><th>符号</th><th>匹配模式</th></tr></thead><tbody><tr><td>.</td><td>任意字符</td></tr><tr><td>%a</td><td>字母</td></tr><tr><td>%c</td><td>控制字符</td></tr><tr><td>%d</td><td>数字</td></tr><tr><td>%l</td><td>小写字母</td></tr><tr><td>%p</td><td>标点字符</td></tr><tr><td>%s</td><td>空白符</td></tr><tr><td>%u</td><td>大写字母</td></tr><tr><td>%w</td><td>字母和数字</td></tr><tr><td>%x</td><td>十六进制数字</td></tr><tr><td>%z</td><td>代表 0 的字符</td></tr></tbody></table></div>
<h1 id="虚变量">虚变量<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#虚变量" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>当一个方法返回多个值时，有些返回值有时候用不到，要是声明很多变量来一一接收，显然不太合适（不是不能）。<strong>Lua 提供了一个虚变量 (dummy variable)的概念，按照</strong>**<a href="https://www.lua.org/pil/1.3.html" class="external">惯例<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>**<strong>以一个下划线（“_”）来命名，用它来表示丢弃不需要的数值，仅仅起到占位的作用。</strong></p>
<h2 id="返回值">返回值<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#返回值" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>-- string. Find (s, p) 从 string 变量 s 的开头向后匹配 string</span></span>
<span data-line><span>-- p，若匹配不成功，返回 nil，若匹配成功，返回第一次匹配成功</span></span>
<span data-line><span>-- 的起止下标。</span></span>
<span data-line> </span>
<span data-line><span>Local start, finish = string.Find (&quot;hello&quot;, &quot;he&quot;) --start 值为起始下标，finish</span></span>
<span data-line><span>--值为结束下标</span></span>
<span data-line><span>Print ( start, finish )                          --输出 1   2</span></span>
<span data-line> </span>
<span data-line><span>Local start = string.Find (&quot;hello&quot;, &quot;he&quot;)      -- start 值为起始下标</span></span>
<span data-line><span>Print ( start )                               -- 输出 1</span></span>
<span data-line> </span>
<span data-line> </span>
<span data-line><span>Local _, finish = string.Find (&quot;hello&quot;, &quot;he&quot;)   --采用虚变量（即下划线），接收起</span></span>
<span data-line><span>--始下标值，然后丢弃，finish 接收</span></span>
<span data-line><span>--结束下标值</span></span>
<span data-line><span>Print ( finish )                              --输出 2</span></span>
<span data-line><span>Print ( _ )    </span></span></code></pre></figure>
<h2 id="迭代">迭代<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#迭代" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>-- test. Lua 文件</span></span>
<span data-line><span>Local t = {1, 3, 5}</span></span>
<span data-line> </span>
<span data-line><span>Print (&quot;all  data: &quot;)</span></span>
<span data-line><span>For i, v in ipairs (t) do</span></span>
<span data-line><span>    Print (i, v)</span></span>
<span data-line><span>End</span></span>
<span data-line> </span>
<span data-line><span>Print (&quot;&quot;)</span></span>
<span data-line><span>Print (&quot;part data: &quot;)</span></span>
<span data-line><span>For _, v in ipairs (t) do</span></span>
<span data-line><span>    Print (v)</span></span>
<span data-line><span>End</span></span></code></pre></figure>
<p>输出</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span># Luajit test. Lua</span></span>
<span data-line><span>All  data:</span></span>
<span data-line><span>1   1</span></span>
<span data-line><span>2   3</span></span>
<span data-line><span>3   5</span></span>
<span data-line> </span>
<span data-line><span>Part data:</span></span>
<span data-line><span>1</span></span>
<span data-line><span>3</span></span>
<span data-line><span>5</span></span></code></pre></figure>
<h1 id="抵制使用-module--定义模块"><strong>抵制使用 module () 定义模块</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#抵制使用-module--定义模块" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>旧式的模块定义方式是通过 <code>module (&quot;filename&quot;[, package. Seeall])*</code> 来显式声明一个包，现在官方不推荐再使用这种方式</p>
<p>这种方式将会返回一个由 <code>filename</code> 模块函数组成的 <code>table</code>，并且还会定义一个包含该 <code>table</code> 的全局变量。</p>
<ol>
<li>
<p><code>package. Seeall</code> 这种方式破坏了模块的高内聚，原本引入 “filename” 模块只想调用它的 <em>foobar ()</em> 函数，但是它却可以读写全局属性，例如 <code>&quot;filename. Os&quot;</code>。</p>
</li>
<li>
<p><code>module</code> 函数压栈操作引发的副作用，污染了全局环境变量。例如 <code>module (&quot;filename&quot;)</code> 会创建一个 <code>filename</code> 的 <code>table</code>，并将这个 <code>table</code> 注入全局环境变量中，这样使得没有引用它的文件也能调用 <code>filename</code> 模块的方法。</p>
</li>
</ol>
<p>推荐的模块定义</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>-- square. Lua 长方形模块</span></span>
<span data-line><span>Local _M = {}           -- 局部的变量</span></span>
<span data-line><span>_M._VERSION = '1.0'     -- 模块版本</span></span>
<span data-line> </span>
<span data-line><span>Local mt = { __index = _M }</span></span>
<span data-line> </span>
<span data-line><span>function _M.new (self, width, height)</span></span>
<span data-line><span>    Return setmetatable ({ width=width, height=height }, mt)</span></span>
<span data-line><span>End</span></span>
<span data-line> </span>
<span data-line><span>function _M.get_square (self)</span></span>
<span data-line><span>    Return self. Width * self. Height</span></span>
<span data-line><span>End</span></span>
<span data-line> </span>
<span data-line><span>function _M.get_circumference (self)</span></span>
<span data-line><span>    Return (self. Width + self. Height) * 2</span></span>
<span data-line><span>End</span></span>
<span data-line> </span>
<span data-line><span>Return _M</span></span></code></pre></figure>
<p>使用</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>Local square = require &quot;square&quot;</span></span>
<span data-line><span>Local s 1 = square: new (1, 2)</span></span>
<span data-line><span>Print (s 1: get_square ())          --output: 2</span></span>
<span data-line><span>Print (s 1: get_circumference ())   --output: 6</span></span></code></pre></figure>
<p>另一个跟 Lua 的 module 模块相关需要注意的点是，当 lua_code_cache on 开启时，require 加载的模块是会被缓存下来的，这样我们的模块就会以最高效的方式运行，直到被显式地调用如下语句（这里有点像模块卸载）：</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>Package. Loaded[&quot;square&quot;] = nil</span></span></code></pre></figure>
<h2 id="调用函数前先定义函数">调用函数前先定义函数<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#调用函数前先定义函数" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Lua 里面的函数必须放在调用的代码之前，下面的代码是一个常见的错误：</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>-- test. Lua 文件 local i = 100</span></span>
<span data-line><span>I = add_one (i)</span></span>
<span data-line> </span>
<span data-line><span>Function add_one (i)</span></span>
<span data-line><span>    Return i + 1</span></span>
<span data-line><span>End</span></span></code></pre></figure>
<p>因此在函数定义之前使用函数相当于在变量赋值之前使用变量，Lua 世界对于没有赋值的变量，默认都是 nil，所以这里也就产生了一个 nil 的错误。</p>
<h1 id="点号操作符和冒号操作符的区别">点号操作符和冒号操作符的区别<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#点号操作符和冒号操作符的区别" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>Local str = &quot;abcde&quot;</span></span>
<span data-line> </span>
<span data-line><span>Print (&quot;case 1: &quot;, str: sub (1, 2))</span></span>
<span data-line><span>Print (&quot;case 2: &quot;, str.Sub (str, 1, 2))</span></span></code></pre></figure>
<p>输出</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Lua" data-theme="github-light github-dark"><code data-language="Lua" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>Case 1: ab</span></span>
<span data-line><span>Case 2: ab</span></span></code></pre></figure>
<ul>
<li>
<p><strong>冒号操作会带入一个</strong> <strong><code>self</code></strong> <strong>参数，用来代表</strong> <strong><code>自己</code>****。</strong></p>
</li>
<li>
<p>而点号操作，只是 <code>内容</code> 的展开。</p>
</li>
</ul>
<p>在函数定义时，使用冒号将默认接收一个 <code>self</code> 参数，而使用点号则需要显式传入 <code>self</code> 参数</p>
<p>示例代码：</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>Obj = { x = 20 }</span></span>
<span data-line> </span>
<span data-line><span>Function obj: fun 1 ()</span></span>
<span data-line><span>    Print (self. X)</span></span>
<span data-line><span>End</span></span></code></pre></figure>
<p>等价于</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>Obj = { x = 20 }</span></span>
<span data-line> </span>
<span data-line><span>Function obj. Fun 1 (self)</span></span>
<span data-line><span>    Print (self. X)</span></span>
<span data-line><span>End</span></span></code></pre></figure>
<h1 id="module-的缺点">Module 的缺点<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#module-的缺点" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>由于 <code>lua_code_cache off</code> 情况下，缓存的代码会伴随请求完结而释放。Module 的最大好处缓存这时候是无法发挥的，所以本章的内容都是基于 <code>lua_code_cache on</code> 的情况下。</p>
<p>先看看下面代码：</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>Local ngx_socket_tcp = ngx. Socket. Tcp           -- ①</span></span>
<span data-line> </span>
<span data-line><span>Local _M = { _VERSION = '0.06' }                -- ②</span></span>
<span data-line><span>Local mt = { __index = _M }                     -- ③</span></span>
<span data-line> </span>
<span data-line><span>function _M.new (self)</span></span>
<span data-line><span>    Local sock, err = ngx_socket_tcp ()          -- ④</span></span>
<span data-line><span>    If not sock then</span></span>
<span data-line><span>        Return nil, err</span></span>
<span data-line><span>    End</span></span>
<span data-line><span>    Return setmetatable ({ sock = sock }, mt)    -- ⑤</span></span>
<span data-line><span>End</span></span>
<span data-line> </span>
<span data-line><span>function _M.set_timeout (self, timeout)</span></span>
<span data-line><span>    Local sock = self. Sock</span></span>
<span data-line><span>    If not sock then</span></span>
<span data-line><span>        Return nil, &quot;not initialized&quot;</span></span>
<span data-line><span>    End</span></span>
<span data-line> </span>
<span data-line><span>    Return sock: settimeout (timeout)</span></span>
<span data-line><span>End</span></span>
<span data-line> </span>
<span data-line><span>-- ... 其他功能代码，这里简略</span></span>
<span data-line> </span>
<span data-line><span>Return _M</span></span></code></pre></figure>
<ol>
<li>
<p>对于比较底层的模块，内部使用到的非本地函数，都需要 local 本地化，这样做的好处：</p>
<ol>
<li>
<p>避免命名冲突：防止外部是 <code>require (...)</code> 的方法调用造成全局变量污染</p>
</li>
<li>
<p>访问局部变量的速度比全局变量更快、更快、更快（重要事情说三遍）</p>
</li>
</ol>
</li>
<li>
<p>每个基础模块最好有自己 <code>_VERSION</code> 标识，方便后期利用 <code>_VERSION</code> 完成热代码部署等高级特性，也便于使用者对版本有整体意识。</p>
</li>
<li>
<p>其实 <code>_M</code> 和 <code>mt</code> 对于不同的请求实例（require 方法得到的对象）是相同的，因为 module 会被缓存到全局环境中。所以在这个位置千万不要放单请求内个性信息，例如 ngx. Ctx 等变量。</p>
</li>
<li>
<p><strong>这里需要实现的是给每个实例绑定不同的 tcp 对象</strong>，后<strong>面 setmetatable 确保了每个实例拥有自己的 socket 对象，所以必须放在 new 函数中</strong>。如果放在 ③ 的下面，那么这时候所有的不同实例内部将绑定了同一个 socket 对象。</p>
</li>
</ol>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>Local mt = { __index = _M }                     -- ③</span></span>
<span data-line><span>Local sock = ngx_socket_tcp ()                   -- ④ 错误的</span></span>
<span data-line> </span>
<span data-line><span>function _M.new (self)</span></span>
<span data-line><span>    Return setmetatable ({ sock = sock }, mt)    -- ⑤</span></span>
<span data-line><span>End</span></span></code></pre></figure>
<ol start="5">
<li>
<p>Lua 的 module 有两种类型：</p>
<ol>
<li>
<p>支持面向对象痕迹可以保留私有属性；静态方法提供者，没有任何私有属性。</p>
</li>
<li>
<p>真正起到区别作用的就是 setmetatable 函数，是否有自己的个性元表，最终导致两种不同的形态。</p>
</li>
</ol>
</li>
</ol>
<h1 id="ffi">FFI<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#ffi" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p><a href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/lua/FFI.html" class="external">https://moonbingbing.gitbooks.io/openresty-best-practices/content/lua/FFI.html<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></p>
<p>FFI 库，是 LuaJIT 中最重要的一个扩展库。它允许从纯 Lua 代码调用外部 C 函数，使用 C 数据结构。</p>
<p>FFI 库最大限度的省去了使用 C 手工编写繁重的 <code>Lua/C</code> 绑定的需要。不需要学习一门独立/额外的绑定语言——它解析普通 C 声明。这样可以从 C 头文件或参考手册中，直接剪切，粘贴。它的任务就是绑定很大的库，但不需要捣鼓脆弱的绑定生成器。</p>
<p>FFI 紧紧的整合进了 LuaJIT（几乎不可能作为一个独立的模块）。<code>JIT</code> 编译器在 C 数据结构上所产生的代码，等同于一个 C 编译器应该生产的代码。在 <code>JIT</code> 编译过的代码中，调用 C 函数，可以被内连处理，不同于基于 <code>Lua/C API</code> 函数调用。</p>
<h2 id="ffi-库词汇"><strong>ffi 库词汇</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#ffi-库词汇" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>









































<div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>noun</td><td>Explanation</td></tr><tr><td>cdecl</td><td>A definition of an abstract C type (actually, is a lua string)</td></tr><tr><td>ctype</td><td>C type object</td></tr><tr><td>cdata</td><td>C data object</td></tr><tr><td>ct</td><td>C type format, is a template object, may be cdecl, cdata, ctype</td></tr><tr><td>cb</td><td>callback object</td></tr><tr><td>VLA</td><td>An array of variable length</td></tr><tr><td>VLS</td><td>A structure of variable length</td></tr></tbody></table></div>
<h2 id="ffi-api"><em><em>ffi.</em> API</em>*<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#ffi-api" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><strong>功能：</strong> <em>Lua ffi 库的 API，与 LuaJIT 不可分割。</em></p>
<p>毫无疑问，在 <code>lua</code> 文件中使用 <code>ffi</code> 库的时候，必须要有下面的一行。</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>Local ffi = require &quot;ffi&quot;</span></span></code></pre></figure>
<h1 id="jit">JIT<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#jit" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>看一下 LuaJIT 官方的解释：LuaJIT is a Just-In-Time Compilerfor the Lua programming language。</p>
<p><strong>LuaJIT 的运行时环境包括一个用手写汇编实现的 Lua 解释器和一个可以直接生成机器代码的 JIT 编译器</strong></p>
<ul>
<li>
<p>一开始的时候，Lua 字节码总是被 LuaJIT 的解释器解释执行。LuaJIT 的解释器会在执行字节码时同时记录一些运行时的统计信息，比如每个 Lua 函数调用入口的实际运行次数，还有每个 Lua 循环的实际执行次数。</p>
</li>
<li>
<p>当这些次数超过某个预设的阈值时，便认为对应的 Lua 函数入口或者对应的 Lua 循环足够的“热”，这时便会触发 JIT 编译器开始工作。</p>
</li>
<li>
<p>JIT 编译器会从热函数的入口或者热循环的某个位置开始尝试编译对应的 Lua 代码路径。编译的过程是把 LuaJIT 字节码先转换成 LuaJIT 自己定义的中间码（IR），然后再生成针对目标体系结构的机器码（比如 x 86_64 指令组成的机器码）</p>
</li>
<li>
<p>如果当前 Lua 代码路径上的所有的操作都可以被 JIT 编译器顺利编译，则这条编译过的代码路径便被称为一个“trace”，在物理上对应一个 <code>trace</code> 类型的 GC 对象（即参与 Lua GC 的对象）。</p>
</li>
</ul>
<p>JIT 编译器不支持的原语被称为 <strong>NYI（Not Yet Implemented）原语</strong>。比较完整的 NYI 列表在这篇文档里面：</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="Plaintext" data-theme="github-light github-dark"><code data-language="Plaintext" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>http://wiki.luajit.org/NYI</span></span></code></pre></figure>
<p>所谓“让更多的 Lua 代码被 JIT 编译”，其实就是帮助更多的 Lua 代码路径能为 JIT 编译器所接受。这一般通过两种途径来实现：</p>
<ol>
<li>
<p>调整对应的 Lua 代码，<strong>避免使用 NYI 原语</strong>。</p>
</li>
<li>
<p>增强 JIT 编译器，让越来越多的 NYI 原语能够被编译。</p>
</li>
</ol>
<h2 id="可以被-jit-编译的元操作"><strong>可以被 JIT 编译的元操作</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#可以被-jit-编译的元操作" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>下面给大家列一下截止到目前已经可以被 JIT 编译的元操作。其他还有 IO、Bit、FFI、Coroutine、OS、Package、Debug、JIT 等分类，使用频率相对较低，这里就不罗列了，可以参考官网：<a href="http://wiki.luajit.org/NYI" class="external">http://wiki.luajit.org/NYI<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>。</p>
<h3 id="基础库的支持情况"><strong>基础库的支持情况</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#基础库的支持情况" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>

















































































































































<div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>函数</td><td>编译?</td><td>备注</td></tr><tr><td>assert</td><td>yes</td><td></td></tr><tr><td>collectgarbage</td><td>no</td><td></td></tr><tr><td>dofile</td><td>never</td><td></td></tr><tr><td>error</td><td>never</td><td></td></tr><tr><td>getfenv</td><td>2.1 partial</td><td>只有 getfenv (0) 能编译</td></tr><tr><td>getmetatable</td><td>yes</td><td></td></tr><tr><td>ipairs</td><td>yes</td><td></td></tr><tr><td>load</td><td>never</td><td></td></tr><tr><td>loadfile</td><td>never</td><td></td></tr><tr><td>loadstring</td><td>never</td><td></td></tr><tr><td>next</td><td>no</td><td></td></tr><tr><td>pairs</td><td>no</td><td></td></tr><tr><td>pcall</td><td>yes</td><td></td></tr><tr><td>print</td><td>no</td><td></td></tr><tr><td>rawequal</td><td>yes</td><td></td></tr><tr><td>rawget</td><td>yes</td><td></td></tr><tr><td>rawlen (5.2)</td><td>yes</td><td></td></tr><tr><td>rawset</td><td>yes</td><td></td></tr><tr><td>select</td><td>partial</td><td>第一个参数是静态变量的时候可以编译</td></tr><tr><td>setfenv</td><td>no</td><td></td></tr><tr><td>setmetatable</td><td>yes</td><td></td></tr><tr><td>tonumber</td><td>partial</td><td>不能编译非 10 进制，非预期的异常输入</td></tr><tr><td>tostring</td><td>partial</td><td>只能编译：字符串、数字、布尔、nil 以及支持 __tostring 元方法的类型</td></tr><tr><td>type</td><td>yes</td><td></td></tr><tr><td>unpack</td><td>no</td><td></td></tr><tr><td>xpcall</td><td>yes</td><td></td></tr></tbody></table></div>
<h3 id="字符串库"><strong>字符串库</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#字符串库" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>





















































































<div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>函数</td><td>编译?</td><td>备注</td></tr><tr><td>string. Byte</td><td>yes</td><td></td></tr><tr><td>string. Char</td><td>2.1</td><td></td></tr><tr><td>string. Dump</td><td>never</td><td></td></tr><tr><td>string. Find</td><td>2.1 partial</td><td>只有字符串样式查找（没有样式）</td></tr><tr><td>string. Format</td><td>2.1 partial</td><td>不支持 %p 或非字符串参数的 %s</td></tr><tr><td>string. Gmatch</td><td>no</td><td></td></tr><tr><td>string. Gsub</td><td>no</td><td></td></tr><tr><td>string. Len</td><td>yes</td><td></td></tr><tr><td>string. Lower</td><td>2.1</td><td></td></tr><tr><td>string. Match</td><td>no</td><td></td></tr><tr><td>string. Rep</td><td>2.1</td><td></td></tr><tr><td>string. Reverse</td><td>2.1</td><td></td></tr><tr><td>string. Sub</td><td>yes</td><td></td></tr><tr><td>string. Upper</td><td>2.1</td><td></td></tr></tbody></table></div>
<h3 id="表"><strong>表</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#表" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>

































































<div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>函数</td><td>编译?</td><td>备注</td></tr><tr><td>table. Concat</td><td>2.1</td><td></td></tr><tr><td>table. Foreach</td><td>no</td><td>2.1: 内部编译，但还没有外放</td></tr><tr><td>table. Foreachi</td><td>2.1</td><td></td></tr><tr><td>table. Getn</td><td>yes</td><td></td></tr><tr><td>table. Insert</td><td>partial</td><td>只有 push 操作</td></tr><tr><td>table. Maxn</td><td>no</td><td></td></tr><tr><td>table. Pack (5.2)</td><td>no</td><td></td></tr><tr><td>table. Remove</td><td>2.1</td><td>部分，只有 pop 操作</td></tr><tr><td>table. Sort</td><td>no</td><td></td></tr><tr><td>table. Unpack (5.2)</td><td>no</td><td></td></tr></tbody></table></div>
<h3 id="math-库"><strong>math 库</strong><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#math-库" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>



























































































































































<div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>函数</td><td>编译?</td><td>备注</td></tr><tr><td>math. Abs</td><td>yes</td><td></td></tr><tr><td>math. Acos</td><td>yes</td><td></td></tr><tr><td>math. Asin</td><td>yes</td><td></td></tr><tr><td>math. Atan</td><td>yes</td><td></td></tr><tr><td>math. Atan 2</td><td>yes</td><td></td></tr><tr><td>math. Ceil</td><td>yes</td><td></td></tr><tr><td>math. Cos</td><td>yes</td><td></td></tr><tr><td>math. Cosh</td><td>yes</td><td></td></tr><tr><td>math. Deg</td><td>yes</td><td></td></tr><tr><td>math. Exp</td><td>yes</td><td></td></tr><tr><td>math. Floor</td><td>yes</td><td></td></tr><tr><td>math. Fmod</td><td>no</td><td></td></tr><tr><td>math. Frexp</td><td>no</td><td></td></tr><tr><td>math. Ldexp</td><td>yes</td><td></td></tr><tr><td>math. Log</td><td>yes</td><td></td></tr><tr><td>math. Log 10</td><td>yes</td><td></td></tr><tr><td>math. Max</td><td>yes</td><td></td></tr><tr><td>math. Min</td><td>yes</td><td></td></tr><tr><td>math. Modf</td><td>yes</td><td></td></tr><tr><td>math. Pow</td><td>yes</td><td></td></tr><tr><td>math. Rad</td><td>yes</td><td></td></tr><tr><td>math. Random</td><td>yes</td><td></td></tr><tr><td>math. Randomseed</td><td>no</td><td></td></tr><tr><td>math. Sin</td><td>yes</td><td></td></tr><tr><td>math. Sinh</td><td>yes</td><td></td></tr><tr><td>math. Sqrt</td><td>yes</td><td></td></tr><tr><td>math. Tan</td><td>yes</td><td></td></tr><tr><td>math. Tanh</td><td>yes</td><td></td></tr></tbody></table></div></article></div><div class="right sidebar"><div class="toc desktop-only"><button type="button" id="toc" class><h3>目录</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#lua-简介" data-for="lua-简介">Lua 简介</a></li><li class="depth-0"><a href="#lua-环境搭建" data-for="lua-环境搭建">Lua 环境搭建</a></li><li class="depth-1"><a href="#helloworld" data-for="helloworld">Helloworld</a></li><li class="depth-0"><a href="#基本数据类型" data-for="基本数据类型">基本数据类型</a></li><li class="depth-1"><a href="#nil" data-for="nil">Nil</a></li><li class="depth-1"><a href="#boolean-布尔" data-for="boolean-布尔">Boolean (布尔)</a></li><li class="depth-1"><a href="#number数字" data-for="number数字">number（数字）</a></li><li class="depth-1"><a href="#string字符串" data-for="string字符串">String（字符串）</a></li><li class="depth-1"><a href="#table-表" data-for="table-表">Table (表)</a></li><li class="depth-1"><a href="#function-函数" data-for="function-函数">Function (函数)</a></li><li class="depth-0"><a href="#表达式" data-for="表达式">表达式</a></li><li class="depth-1"><a href="#算术运算符" data-for="算术运算符">算术运算符</a></li><li class="depth-1"><a href="#关系运算符" data-for="关系运算符">关系运算符</a></li><li class="depth-1"><a href="#逻辑运算符" data-for="逻辑运算符">逻辑运算符</a></li><li class="depth-1"><a href="#字符串连接" data-for="字符串连接">字符串连接</a></li><li class="depth-1"><a href="#优先级" data-for="优先级">优先级</a></li><li class="depth-0"><a href="#控制结构" data-for="控制结构">控制结构</a></li><li class="depth-1"><a href="#if-else" data-for="if-else">If-else</a></li><li class="depth-2"><a href="#单个-if-分支型" data-for="单个-if-分支型">单个 if 分支型</a></li><li class="depth-2"><a href="#两个分支-if-else-型" data-for="两个分支-if-else-型">两个分支 if-else 型</a></li><li class="depth-2"><a href="#多个分支的-if-elseif-else" data-for="多个分支的-if-elseif-else">多个分支的 if-elseif-else</a></li><li class="depth-1"><a href="#while" data-for="while">While</a></li><li class="depth-1"><a href="#repeat" data-for="repeat">Repeat</a></li><li class="depth-1"><a href="#for" data-for="for">For</a></li><li class="depth-2"><a href="#for-数字型" data-for="for-数字型">for 数字型</a></li><li class="depth-1"><a href="#for-泛型" data-for="for-泛型">For 泛型</a></li><li class="depth-1"><a href="#break" data-for="break">Break</a></li><li class="depth-1"><a href="#return" data-for="return">Return</a></li><li class="depth-1"><a href="#goto" data-for="goto">Goto</a></li><li class="depth-0"><a href="#函数" data-for="函数">函数</a></li><li class="depth-1"><a href="#定义" data-for="定义">定义</a></li><li class="depth-1"><a href="#参数" data-for="参数">参数</a></li><li class="depth-2"><a href="#按值传递" data-for="按值传递">按值传递</a></li><li class="depth-2"><a href="#变长参数" data-for="变长参数">变长参数</a></li><li class="depth-2"><a href="#具名参数" data-for="具名参数">具名参数</a></li><li class="depth-2"><a href="#按引用传递" data-for="按引用传递">按引用传递</a></li><li class="depth-1"><a href="#函数返回值" data-for="函数返回值">函数返回值</a></li><li class="depth-0"><a href="#全动态函数调用" data-for="全动态函数调用">全动态函数调用</a></li><li class="depth-0"><a href="#模块" data-for="模块">模块</a></li><li class="depth-0"><a href="#string" data-for="string">String</a></li><li class="depth-1"><a href="#stringbyte-s--i--j-" data-for="stringbyte-s--i--j-">string.Byte (s [, i [, j ]])</a></li><li class="depth-1"><a href="#string-char-" data-for="string-char-">string. Char (…)</a></li><li class="depth-1"><a href="#stringupper-s" data-for="stringupper-s">string.Upper (s)</a></li><li class="depth-1"><a href="#stringlower-s" data-for="stringlower-s">string.Lower (s)</a></li><li class="depth-1"><a href="#stringlen-s" data-for="stringlen-s">string.Len (s)</a></li><li class="depth-1"><a href="#stringfind-s-p--init--plain" data-for="stringfind-s-p--init--plain">string.Find (s, p [, init [, plain]])</a></li><li class="depth-1"><a href="#stringformat-formatstring-" data-for="stringformat-formatstring-">string.Format (formatstring, …)</a></li><li class="depth-1"><a href="#stringmatch-s-p--init" data-for="stringmatch-s-p--init">string.Match (s, p [, init])</a></li><li class="depth-1"><a href="#stringgmatch-s-p" data-for="stringgmatch-s-p">string.Gmatch (s, p)</a></li><li class="depth-1"><a href="#stringrep-s-n" data-for="stringrep-s-n">string.Rep (s, n)</a></li><li class="depth-1"><a href="#stringsub-s-i--j" data-for="stringsub-s-i--j">string.Sub (s, i [, j])</a></li><li class="depth-1"><a href="#stringgsub-s-p-r--n" data-for="stringgsub-s-p-r--n">string.Gsub (s, p, r [, n])</a></li><li class="depth-1"><a href="#string-reverse-s" data-for="string-reverse-s">string. Reverse (s)</a></li><li class="depth-0"><a href="#table" data-for="table">Table</a></li><li class="depth-1"><a href="#下标从-1-开始" data-for="下标从-1-开始">下标从 1 开始</a></li><li class="depth-1"><a href="#table-getn-获取长度" data-for="table-getn-获取长度">table. Getn 获取长度</a></li><li class="depth-1"><a href="#table-concat-table--sep--i--j---" data-for="table-concat-table--sep--i--j---">table. Concat (table [, sep [, i [, j ] ] ])</a></li><li class="depth-1"><a href="#table-insert-table-pos--value" data-for="table-insert-table-pos--value">table. Insert (table, [pos ,] value)</a></li><li class="depth-1"><a href="#table-maxn-table" data-for="table-maxn-table">table. Maxn (table)</a></li><li class="depth-1"><a href="#table-remove-table--pos" data-for="table-remove-table--pos">table. Remove (table [, pos])</a></li><li class="depth-1"><a href="#table-sort-table--comp" data-for="table-sort-table--comp">table. Sort (table [, comp])</a></li><li class="depth-1"><a href="#其他" data-for="其他">其他</a></li><li class="depth-0"><a href="#日期时间" data-for="日期时间">日期时间</a></li><li class="depth-1"><a href="#os-time-table" data-for="os-time-table">os. Time ([table])</a></li><li class="depth-1"><a href="#os-difftime-t-2-t-1" data-for="os-difftime-t-2-t-1">os. Difftime (t 2, t 1)</a></li><li class="depth-1"><a href="#os-date-format--time" data-for="os-date-format--time">os. Date ([format [, time]])</a></li><li class="depth-0"><a href="#数学库" data-for="数学库">数学库</a></li><li class="depth-0"><a href="#文件" data-for="文件">文件</a></li><li class="depth-1"><a href="#隐式文件描述" data-for="隐式文件描述">隐式文件描述</a></li><li class="depth-1"><a href="#显式文件描述" data-for="显式文件描述">显式文件描述</a></li><li class="depth-1"><a href="#文件操作函数" data-for="文件操作函数">文件操作函数</a></li><li class="depth-0"><a href="#元表" data-for="元表">元表</a></li><li class="depth-1"><a href="#修改表的操作符行为" data-for="修改表的操作符行为">修改表的操作符行为</a></li><li class="depth-1"><a href="#__index-元方法" data-for="__index-元方法">__index 元方法</a></li><li class="depth-1"><a href="#__tostring-元方法" data-for="__tostring-元方法">__tostring 元方法</a></li><li class="depth-1"><a href="#__call-元方法" data-for="__call-元方法">__call 元方法</a></li><li class="depth-1"><a href="#__metatable-元方法" data-for="__metatable-元方法">__metatable 元方法</a></li><li class="depth-0"><a href="#面向对象" data-for="面向对象">面向对象</a></li><li class="depth-1"><a href="#类" data-for="类">类</a></li><li class="depth-1"><a href="#继承" data-for="继承">继承</a></li><li class="depth-1"><a href="#成员私有性" data-for="成员私有性">成员私有性</a></li><li class="depth-0"><a href="#局部变量" data-for="局部变量">局部变量</a></li><li class="depth-1"><a href="#定义-1" data-for="定义-1">定义</a></li><li class="depth-1"><a href="#作用域" data-for="作用域">作用域</a></li><li class="depth-1"><a href="#使用局部变量的好处" data-for="使用局部变量的好处">使用局部变量的好处</a></li><li class="depth-1"><a href="#检测模块的函数使用局部变量" data-for="检测模块的函数使用局部变量">检测模块的函数使用局部变量</a></li><li class="depth-0"><a href="#判断数组的大小" data-for="判断数组的大小">判断数组的大小</a></li><li class="depth-0"><a href="#非空判断" data-for="非空判断">非空判断</a></li><li class="depth-0"><a href="#正则表达式" data-for="正则表达式">正则表达式</a></li><li class="depth-0"><a href="#虚变量" data-for="虚变量">虚变量</a></li><li class="depth-1"><a href="#返回值" data-for="返回值">返回值</a></li><li class="depth-1"><a href="#迭代" data-for="迭代">迭代</a></li><li class="depth-0"><a href="#抵制使用-module--定义模块" data-for="抵制使用-module--定义模块">抵制使用 module () 定义模块</a></li><li class="depth-1"><a href="#调用函数前先定义函数" data-for="调用函数前先定义函数">调用函数前先定义函数</a></li><li class="depth-0"><a href="#点号操作符和冒号操作符的区别" data-for="点号操作符和冒号操作符的区别">点号操作符和冒号操作符的区别</a></li><li class="depth-0"><a href="#module-的缺点" data-for="module-的缺点">Module 的缺点</a></li><li class="depth-0"><a href="#ffi" data-for="ffi">FFI</a></li><li class="depth-1"><a href="#ffi-库词汇" data-for="ffi-库词汇">ffi 库词汇</a></li><li class="depth-1"><a href="#ffi-api" data-for="ffi-api">ffi. API*</a></li><li class="depth-0"><a href="#jit" data-for="jit">JIT</a></li><li class="depth-1"><a href="#可以被-jit-编译的元操作" data-for="可以被-jit-编译的元操作">可以被 JIT 编译的元操作</a></li><li class="depth-2"><a href="#基础库的支持情况" data-for="基础库的支持情况">基础库的支持情况</a></li><li class="depth-2"><a href="#字符串库" data-for="字符串库">字符串库</a></li><li class="depth-2"><a href="#表" data-for="表">表</a></li><li class="depth-2"><a href="#math-库" data-for="math-库">math 库</a></li></ul></div></div><div class="backlinks"><h3>反向链接</h3><ul class="overflow"><li><a href="../" class="internal">index</a></li></ul></div><div class="graph"><h3>关系图谱</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:false}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xml:space="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:true}"></div></div></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.2.3</a> © 2024</p><ul><li><a href="https://github.com/googoo-s">GitHub</a></li></ul></footer></div></body><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js" type="application/javascript"></script><script type="application/javascript">function c(){let t=this.parentElement;t.classList.toggle("is-collapsed");let l=t.classList.contains("is-collapsed")?this.scrollHeight:t.scrollHeight;t.style.maxHeight=l+"px";let o=t,e=t.parentElement;for(;e;){if(!e.classList.contains("callout"))return;let n=e.classList.contains("is-collapsed")?e.scrollHeight:e.scrollHeight+o.scrollHeight;e.style.maxHeight=n+"px",o=e,e=e.parentElement}}function i(){let t=document.getElementsByClassName("callout is-collapsible");for(let s of t){let l=s.firstElementChild;if(l){l.addEventListener("click",c),window.addCleanup(()=>l.removeEventListener("click",c));let e=s.classList.contains("is-collapsed")?l.scrollHeight:s.scrollHeight;s.style.maxHeight=e+"px"}}}document.addEventListener("nav",i);window.addEventListener("resize",i);
</script><script type="module">
          let mermaidImport = undefined
          document.addEventListener('nav', async () => {
            if (document.querySelector("code.mermaid")) {
              mermaidImport ||= await import('https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.7.0/mermaid.esm.min.mjs')
              const mermaid = mermaidImport.default
              const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
              mermaid.initialize({
                startOnLoad: false,
                securityLevel: 'loose',
                theme: darkMode ? 'dark' : 'default'
              })

              await mermaid.run({
                querySelector: '.mermaid'
              })
            }
          });
          </script><script src="../postscript.js" type="module"></script></html>