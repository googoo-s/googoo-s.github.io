<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Luas on</title><link>https://googoo-s.github.io/lua/</link><description>Recent content in Luas on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 31 Jul 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://googoo-s.github.io/lua/index.xml" rel="self" type="application/rss+xml"/><item><title>lua基础</title><link>https://googoo-s.github.io/lua/lua%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/lua/lua%E5%9F%BA%E7%A1%80/</guid><description>Lua 简介 Lua 是一个小巧的脚本语言。是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组并于 1993 年开发。其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。Lua 由标准 C 编写而成，几乎在所有操作系统和平台上都可以编译、运行。Lua 并没有提供强大的库，这是由它的定位决定的。所以 Lua 不适合作为开发独立应用程序的语言。Lua 有一个同时进行的 JIT 项目，提供在特定平台上的即时编译功能。</description></item><item><title>Lua高级</title><link>https://googoo-s.github.io/lua/Lua%E9%AB%98%E7%BA%A7/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/lua/Lua%E9%AB%98%E7%BA%A7/</guid><description>元表 元表 (metatable) 的表现行为类似于 C++ 语言中的操作符重载，例如我们可以重载 &amp;ldquo;__add&amp;rdquo; 元方法 (metamethod)，来计算两个 Lua 数组的并集；或者重载 &amp;ldquo;__index&amp;rdquo; 方法，来定义我们自己的 Hash 函数。Lua 提供了两个十分重要的用来处理元表的方法
setmetatable(table, metatable)：此方法用于为一个表设置元表。</description></item><item><title/><link>https://googoo-s.github.io/lua/%E7%94%A8Go%E5%AE%9E%E7%8E%B0Lua/1.%E4%BA%8C%E8%BF%9B%E5%88%B6Chunk/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/lua/%E7%94%A8Go%E5%AE%9E%E7%8E%B0Lua/1.%E4%BA%8C%E8%BF%9B%E5%88%B6Chunk/</guid><description>什么是二进制 chunk Lua 脚本并.不是直接被 Lua 解释器解释执行，而是类似 Java 语言那样，先由 Lua 编译器编译为字节码，然后再交给 Lua 虚拟机去执行
Lua 字节码需要一个载体，这个载体就是二进制 chunk，对 Java 虚拟机比较熟悉的读者可以把二进制 chunk 看作 Lua 版的 class 文件</description></item><item><title/><link>https://googoo-s.github.io/lua/%E7%94%A8Go%E5%AE%9E%E7%8E%B0Lua/2.%E6%8C%87%E4%BB%A4%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/lua/%E7%94%A8Go%E5%AE%9E%E7%8E%B0Lua/2.%E6%8C%87%E4%BB%A4%E9%9B%86/</guid><description>指令集介绍 按照实现方式，虚拟机大致可以分为两类：
基于栈（Stack Based）。 Java 虚拟机、. NET CLR、Python 虚拟机，以及在第 2 章中提到过的 Ruby YARV 虚拟机都是基于栈的虚拟机； 基于寄存器（Register Based）。 以及本书讨论的 Lua 虚拟机则是基于寄存器的虚拟机 如同真实机器有一套指令集（Instruction Set）一样，虚拟机也有自己的指令集：</description></item><item><title/><link>https://googoo-s.github.io/lua/%E7%94%A8Go%E5%AE%9E%E7%8E%B0Lua/3.lua-API/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/lua/%E7%94%A8Go%E5%AE%9E%E7%8E%B0Lua/3.lua-API/</guid><description>Lua 核心是以库（Library）的形式被实现的，其他应用程序只需要链接 Lua 库就可以使用 Lua 提供的 API 轻松获得脚本执行能力
Lua 发布版包含的两个命令行程序，也就是我们已经很熟悉的 lua 和 luac，实际上就是 Lua 库的两个特殊的宿主程序。
Lua API 介绍 官方 Lua 使用 Clean C（其语法是 C 和 C++语言的子集）编写，Lua API 主要是指一系列以“lua_”开头的 C 语言函数（也可能是宏定义，后文统称为函数）。</description></item><item><title/><link>https://googoo-s.github.io/lua/%E7%94%A8Go%E5%AE%9E%E7%8E%B0Lua/%E5%89%8D%E8%A8%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://googoo-s.github.io/lua/%E7%94%A8Go%E5%AE%9E%E7%8E%B0Lua/%E5%89%8D%E8%A8%80/</guid><description>参考资料 * 自己动手实现Lua:虚拟机、编译器和标准库 《Programming in Lua, Fourth Edition》 《Lua 5.3 Reference Manual》 《The Evolution of Lua》 《The Implementation of Lua 5.</description></item></channel></rss>