<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kubernetes on</title><link>https://quartz.jzhao.xyz/kubernetes/</link><description>Recent content in Kubernetes on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://quartz.jzhao.xyz/kubernetes/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://quartz.jzhao.xyz/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-DaemonSet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-DaemonSet/</guid><description>另外一类代表在线业务 API 对象：DaemonSet，它会在 Kubernetes 集群的每个节点上都运行一个 Pod，就好像是 Linux 系统里的“守护进程”（Daemon）。
为什么要有 DaemonSet Deployment 并不关心这些 Pod 会在集群的哪些节点上运行，在它看来，Pod 的运行环境与功能是无关的，只要 Pod 的数量足够，应用程序应该会正常工作。
有一些业务比较特殊**，它们不是完全独立于系统运行的，而是与主机存在“绑定”关系，必须要依附于节点才能产生价值**，比如说：
网络应用（如 kube-proxy），必须每个节点都运行一个 Pod，否则节点就无法加入 Kubernetes 网络</description></item><item><title/><link>https://quartz.jzhao.xyz/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-Deployment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-Deployment/</guid><description>Deployment”，顾名思义，它是专门用来部署应用程序的，能够让应用永不宕机，多用来发布无状态的应用，是 Kubernetes 里最常用也是最有用的一个对象
为什么要有Delplyment 除了“离线业务”，另一大类业务——也就是“在线业务”，在 Kubernetes 里应该如何处理呢？
我们先看看用 Pod 是否就足够了。因为它在 YAML 里使用“containers”就可以任意编排容器，而且还有一个**“restartPolicy”字段，默认值就是 Always**，可以监控 Pod 里容器的状态，一旦发生异常，就会自动重启容器。
“restartPolicy”只能保证容器正常工作。不知你有没有想到，如果容器之外的 Pod 出错了该怎么办呢？比如说，有人不小心用 kubectl delete 误删了 Pod，或者 Pod 运行的节点发生了断电故障，那么 Pod 就会在集群里彻底消失，对容器的控制也就无从谈起了</description></item><item><title/><link>https://quartz.jzhao.xyz/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-Job-%E4%B8%8E-CronJob/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-Job-%E4%B8%8E-CronJob/</guid><description>Pod 已经是一个相对完善的对象，专门负责管理容器，那么我们就不应该再“画蛇添足”地盲目为它扩充功能，而是要保持它的独立性，**容器之外的功能就需要定义其他的对象，把 Pod 作为它的一个成员“组合”**进去。
为什么要有 Job/CronJob Nginx 和 busybox，它们分别代表了 Kubernetes 里的两大类业务。一类是像 Nginx 这样长时间运行的**“在线业务”，另一类是像 busybox 这样短时间运行的“离线业务**”
在线业务”类型的应用有很多，比如 Nginx、Node.js、MySQL、Redis 等等，一旦运行起来基本上不会停，也就是永远在线。</description></item><item><title/><link>https://quartz.jzhao.xyz/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-Pod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-Pod/</guid><description>为什么要有 Pod Namespace 做隔离，Cgroups 做限制，rootfs 做文件系统”这样的“三句箴言”可以朗朗上口了，为什么 Kubernetes 项目又突然搞出一个 Pod 来呢？
为了解决这样多应用联合运行的问题，同时还要不破坏容器的隔离，就需要在容器外面再建立一个“收纳舱”，让多个容器既保持相对独立，又能够小范围共享网络、存储等资源，而且永远是“绑在一起”的状态。
Kubernetes 项目所做的，其实就是将“进程组”的概念映射到了容器技术中，这就是Pod
为什么Pod 是Kubernetes 的核心对象 Kubernetes 让 Pod 去编排处理容器，然后把 Pod 作为应用调度部署的最小单位，</description></item><item><title/><link>https://quartz.jzhao.xyz/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-StatefulSet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-StatefulSet/</guid><description>eployment 和 DaemonSet 两种 API 对象，它们是在 Kubernetes 集群里部署应用的重要工具，不过它们也有一个缺点，只能管理“无状态应用”（Stateless Application），不能管理“有状态应用”（Stateful Application）。
有状态应用”的处理比较复杂，要考虑的事情很多，但是这些问题我们其实可以通过组合Deployment、Service、PersistentVolume 等对象来解决。
什么是有状态的应用 状态”，应用保存的数据，实际上就是它某个时刻的“运行状态”。
只是有的应用的状态信息不是很重要，即使不恢复状态也能够正常运行，这就是我们常说的“无状态应用”。
还有一些应用，运行状态信息就很重要了，如果因为重启而丢失了状态是绝对无法接受的，这样的应用就是“有状态应用”。</description></item><item><title/><link>https://quartz.jzhao.xyz/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-YAML/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Kubernetes/%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86-YAML/</guid><description>声明式与命令式是怎么回事 “声明式”，在 Kubernetes 出现之前比较少见，它与“命令式”完全相反，不关心具体的过程，更注重结果。我们不需要“教”计算机该怎么做，只要告诉它一个目标状态，它自己就会想办法去完成任务，相比起来自动化、智能化程度更高。
什么是 YAML YAML 的官网（https://yaml.org/）有对语言规范的完整介绍，所以我就不在这里列举语言的细节了，只讲一些与 Kubernetes 相关的要点，帮助你快速掌握。
YAML 是 JSON 的超集，支持整数、浮点数、布尔、字符串、数组和对象等数据类型
但和 JSON 比起来，YAML 的语法更简单，形式也更清晰紧凑，比如：
使用空白与缩进表示层次（有点类似 Python），可以不使用花括号和方括号。</description></item><item><title/><link>https://quartz.jzhao.xyz/Kubernetes/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Kubernetes/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</guid><description>为啥要有命名空间 Kubernetes 的名字空间并不是一个实体对象，只是一个逻辑上的概念。
它可以把集群切分成一个个彼此独立的区域，然后我们把对象放到这些区域里，就实现了类似容器技术里 namespace 的隔离效果，应用只能在自己的名字空间里分配资源和运行，不会干扰到其他名字空间里的应用。
Kubernetes面对大规模集群、海量节点时的一种现实考虑。）
可能会有大量的 Pod，这就使得资源争抢和命名冲突的概率大大增加了。
多团队、多项目共用 Kubernetes 的时候，我们就需要把集群给适当地“局部化”，为每一类用户创建出只属于它自己的“工作空间”
区分测试，生产环境
如何使用名字空间 创建</description></item><item><title/><link>https://quartz.jzhao.xyz/Kubernetes/%E5%AD%98%E5%82%A8-PersistentVolume/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Kubernetes/%E5%AD%98%E5%82%A8-PersistentVolume/</guid><description>一起来了解 Volume 的高级用法，看看 Kubernetes 管理存储资源的 API 对象 PersistentVolume、PersistentVolumeClaim、StorageClass，然后使用本地磁盘来创建实际可用的存储卷。
什么是 PersistentVolume PersistentVolume专门用来表示持久存储设备，但隐藏了存储的底层实现，我们只需要知道它能安全可靠地保管数据就可以了（由于 PersistentVolume 这个词很长，一般都把它简称为 PV）。
作为存储的抽象，PV 实际上就是一些存储设备、文件系统，比如 Ceph、GlusterFS、NFS，甚至是本地磁盘，管理它们已经超出了 Kubernetes 的能力范围，所以，一般会由系统管理员单独维护，然后再在 Kubernetes 里创建对应的 PV</description></item><item><title/><link>https://quartz.jzhao.xyz/Kubernetes/%E5%AE%B9%E5%99%A8-docker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Kubernetes/%E5%AE%B9%E5%99%A8-docker/</guid><description>Docker 相关内容 [[如何容器化应用]]
[[dockerfile]]
[[与外界资源的共享]]
什么是 CRI NCF 已经成立一年了，而 Kubernetes 也已经发布了 1.0 版，可以正式用于生产环境，这些都标志着 Kubernetes 已经成长起来了，不再需要“看脸色吃饭”。于是它就宣布加入了 CNCF，成为了第一个 CNCF 托管项目，想要借助基金会的力量联合其他厂商，一起来“扳倒”Docker。
Kubernetes 引入了一个新的接口标准：CRI ，Container Runtime Interface。</description></item><item><title/><link>https://quartz.jzhao.xyz/Kubernetes/%E5%AE%B9%E5%99%A8-%E5%AE%B9%E5%99%A8%E7%9A%84%E6%9C%AC%E8%B4%A8%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%9B%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Kubernetes/%E5%AE%B9%E5%99%A8-%E5%AE%B9%E5%99%A8%E7%9A%84%E6%9C%AC%E8%B4%A8%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%9B%E7%A8%8B/</guid><description>容器就是操作系统里一个特殊的“沙盒”环境，里面运行的进程只能看到受限的信息，与外部系统实现了隔离。
容器隔离的目的是为了系统安全，限制了进程能够访问的各种资源。
相比虚拟机技术，容器更加轻巧、更加高效，消耗的系统资源非常少，在云计算时代极具优势。
容器的基本实现技术是 Linux 系统里的 namespace、cgroup、chroot。
广义上来说，容器技术是动态的容器、静态的镜像和远端的仓库这三者的组合。</description></item><item><title/><link>https://quartz.jzhao.xyz/Kubernetes/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E4%B8%8EKubernetes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Kubernetes/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E4%B8%8EKubernetes/</guid><description>容器技术的核心概念是容器、镜像、仓库，使用这三大基本要素我们就可以轻松地完成应用的打包、分发工作，实现“一次开发，到处运行”的梦想。
现实生产环境的复杂程度实在是太高了，除了最基本的安装，还会有各式各样的需求，
服务发现
负载均衡
状态监控
健康检查
扩容缩容
应用迁移</description></item><item><title/><link>https://quartz.jzhao.xyz/Kubernetes/%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Kubernetes/%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0/</guid><description>在 Kubernetes 里，使用命令 kubectl scale，我们就可以轻松调整 Deployment,StatefulSet 下属的 Pod 数量。
除了“应用伸缩”，其他的运维操作比如应用更新、版本回退等工作
滚动更新，使用 kubectl rollout 实现用户无感知的应用升级和降级
Kubernetes 如何定义应用版本 在 Kubernetes 里，版本更新使用的不是 API 对象，而是两个命令：kubectl apply 和 kubectl rollout，当然它们也要搭配部署应用所需要的 Deployment、DaemonSet 等 YAML 文件。</description></item><item><title/><link>https://quartz.jzhao.xyz/Kubernetes/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7Metrics-Server%E5%92%8CPrometheus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Kubernetes/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7Metrics-Server%E5%92%8CPrometheus/</guid><description>观测集群是不能用“探针”这种简单的方式的，所以今天我就带你一起来看看 Kubernetes 为集群提供的两种系统级别的监控项目：**Metrics Server 和 Prometheus，**以及基于它们的水平自动伸缩对象 HorizontalPodAutoscaler。
Metrics Server https://github.com/kubernetes-sigs/metrics-server
top 能够实时显示当前系统的 CPU 和内存利用率，它是性能分析和调优的基本工具，非常有用。Kubernetes 也提供了类似的命令，就是 kubectl top，不过默认情况下这个命令不会生效，必须要安装一个插件 Metrics Server 才可以</description></item><item><title/><link>https://quartz.jzhao.xyz/Kubernetes/%E7%BD%91%E7%BB%9C-CNI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Kubernetes/%E7%BD%91%E7%BB%9C-CNI/</guid><description>讲讲 Kubernetes 的网络接口标准 CNI，以及 Calico、Cilium 等性能更好的网络插件。
Kubernetes 的网络模型 Docker 的 null、host 和 bridge 三种网络模式还有印象吗？这里我重新画了一张图，描述了 Docker 里最常用的 bridge 网络模式：
Docker 会创建一个名字叫“docker0”的网桥，默认是私有网段“172.</description></item><item><title/><link>https://quartz.jzhao.xyz/Kubernetes/%E7%BD%91%E7%BB%9C-Ingress/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Kubernetes/%E7%BD%91%E7%BB%9C-Ingress/</guid><description>集群进出流量的总管
对网络流量的管理方案还是太简单，离复杂的现代应用架构需求还有很大的差距，所以 Kubernetes 就在 Service 之上又提出了一个新的概念：Ingress。
为什么要有 Ingress Service 的功能和运行机制，它本质上就是一个由 kube-proxy 控制的四层负载均衡，在 TCP/IP 协议栈上转发流量
但在四层上的负载均衡功能还是太有限了，只能够依据 IP 地址和端口号做一些简单的判断和组合，而我们现在的绝大多数应用都是跑在七层的 HTTP/HTTPS 协议上的，有更多的高级路由条件，比如主机名、URI、请求头、证书等等，而这些在 TCP/IP 网络栈里是根本看不见的。</description></item><item><title/><link>https://quartz.jzhao.xyz/Kubernetes/%E7%BD%91%E7%BB%9C-Service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Kubernetes/%E7%BD%91%E7%BB%9C-Service/</guid><description>而在云原生时代，微服务无疑是应用的主流形态。为了更好地支持微服务以及服务网格这样的应用架构，Kubernetes 又专门定义了一个新的对象：Service，它是集群内部的负载均衡机制，用来解决服务发现的关键问题
为什么要有 Service 解决服务发现的问题，实现负载均衡，它们在前端与后端之间加入了一个“中间层”，屏蔽后端的变化，为前端提供一个稳定的服务。
LVS、Nginx 毕竟不是云原生技术，所以 Kubernetes 就按照这个思路，定义了新的 API 对象**：Service。**
Service 的工作原理和 LVS、Nginx 差不多，Kubernetes 会给Service 分配一个静态 IP 地址，然后它再去自动管理、维护后面动态变化的 Pod 集合，当客户端访问 Service，它就根据某种策略，把流量转发给后面的某个 Pod。</description></item><item><title/><link>https://quartz.jzhao.xyz/Kubernetes/%E8%B5%84%E6%BA%90%E5%92%8C%E6%8E%A2%E9%92%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Kubernetes/%E8%B5%84%E6%BA%90%E5%92%8C%E6%8E%A2%E9%92%88/</guid><description>容器资源配额 cgroup、chroot。其中的 namespace 实现了独立的进程空间，chroot 实现了独立的文件系统，但唯独没有看到 cgroup 的具体应用。cgroup 的作用是管控 CPU、内存，保证容器不会无节制地占用基础资源，进而影响到系统里的其他应用。
CPU、内存直接“内置”在系统里的，不像硬盘那样需要“外挂”，所以申请和管理的过程也就会简单很多。具体的申请方法很简单，只要在 Pod 容器的描述部分添加一个新字段 resources 就可以了，
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 apiVersion: v1 kind: Pod metadata: name: ngx-pod-resources spec: containers: - image: nginx:alpine name: ngx resources: requests: cpu: 10m memory: 100Mi limits: cpu: 20m memory: 200Mi containers.</description></item><item><title/><link>https://quartz.jzhao.xyz/Kubernetes/%E9%85%8D%E7%BD%AE-ConfigMap-Secret/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://quartz.jzhao.xyz/Kubernetes/%E9%85%8D%E7%BD%AE-ConfigMap-Secret/</guid><description>配置方式
第一种是编写 Dockerfile，用 COPY 指令把配置文件打包到镜像里；
第二种是在运行时使用 docker cp 或者 docker run -v，把本机的文件拷贝进容器。
。第一种方法相当于是在镜像里固定了配置文件，不好修改，不灵活，第二种方法则显得有点“笨拙”，不适合在集群中自动化运维管理。
ConfigMap/Secret 首先你要知道，应用程序有很多类别的配置信息，但从数据安全的角度来看可以分成两类：</description></item></channel></rss>